/**
 * D·List v0.9.11
 * Copyright (C) 2014-2023 Dataludi Inc.
 * All Rights Reserved.
 */

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.DList = factory());
})(this, (function () { 'use strict';

    ////////////////////////////////////////////////////////////////////////////////
    // DObject.ts
    // 2021. 11. 30. created by dataludi
    // -----------------------------------------------------------------------------
    // Copyright (c) 2021 Dataludi Inc.
    // All rights reserved.
    ////////////////////////////////////////////////////////////////////////////////
    let $$_hash = 0;
    /**
     * D·List 라이브러리 클래스 모델의 최상위 base 클래스.
     * <br>
     *
     * @see concepts.dev_guide 개발 가이드
     * @see concepts.about D·List 개요
     */
    class DObject {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(noHash) {
            this.$_destroyed = false;
            this.$_destroying = false;
            if (!noHash) {
                this.$_hash = String($$_hash++);
            }
        }
        //-------------------------------------------------------------------------
        // static members
        //-------------------------------------------------------------------------
        static destroy(obj) {
            return obj && obj.destroy();
        }
        /**
         * 객체가 소유한 참조 등을 해제하고 null을 리턴한다.
         *
         * ```
         * list = lis.destroy();
         * ```
         *
         * @returns null
         */
        destroy() {
            if (!this.$_destroyed && !this.$_destroying) {
                this.$_destroyed = true;
                this.$_destroying = true;
                this._doDestory();
            }
            return null;
        }
        _doDestory() { }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        get destroying() {
            return this.$_destroying;
        }
        get hash() {
            return this.$_hash;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        isMe(hash) {
            return hash === this.$_hash;
        }
        /**
         * @internal
         *
         * true를 리턴하면 assignProps()이 진행되지 않는다.
         */
        _doAssignProps(source) {
            return false;
        }
        /**
         * @internal
         *
         * 객체의 여러 속성들을 한꺼번에 설정한다.
         *
         * @param source 속성 원본 object
         * //@param valueCallback
         * @returns 객체 자신
         */
        // assignProps(source: any, valueCallback?: (v: any) => any): DObject {
        assignProps(source) {
            if (this._doAssignProps(source) === true) {
                return this;
            }
            if (source) {
                const proto = Object.getPrototypeOf(this);
                // const proto = Reflect.getPrototypeOf(this); 
                for (let k in source) {
                    // const v = valueCallback ? valueCallback(source[k]) : source[k];
                    const v = source[k];
                    let p = Object.getOwnPropertyDescriptor(proto, k);
                    if (p) {
                        if (p.set) {
                            p.set.call(this, v);
                        }
                        else if (p.get) {
                            const obj = p.get.call(this);
                            if (obj instanceof DObject) {
                                obj.assignProps(v);
                            }
                        }
                    }
                    else {
                        let proto2 = Object.getPrototypeOf(proto);
                        while (proto2) {
                            let p = Object.getOwnPropertyDescriptor(proto2, k);
                            if (p) {
                                if (p.set) {
                                    p.set.call(this, v);
                                }
                                else if (p.get) {
                                    const obj = p.get.call(this);
                                    if (obj instanceof DObject) {
                                        obj.assignProps(v);
                                    }
                                }
                                break;
                            }
                            else {
                                proto2 = Object.getPrototypeOf(proto2);
                            }
                        }
                    }
                }
            }
            return this;
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        toString() {
            return this.constructor.name;
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        /**
         * @internal
         *
         * template param으로부터 생성되는 값은 문자열일 수 있다.
         */
        toBool(v) {
            return typeof v === 'string' ? v === 'true' : v;
        }
        toNum(v, def = NaN) {
            v = parseFloat(v);
            return isNaN(v) ? def : v;
        }
    }
    class DWrappableObject extends DObject {
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        wrapper() {
            return this._wrapper;
        }
        wrapperOrThis() {
            return this._wrapper || this;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        createWrapper(clazz) {
            const w = this._wrapper = new clazz();
            w['$_c'] = this;
            return w;
        }
        setWrapper(wrapper) {
            this._wrapper = wrapper;
            wrapper['$_c'] = this;
            return wrapper;
        }
        isWrapper(w) {
            return w === this._wrapper;
        }
    }
    class DWrapper extends DObject {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        _doDestory() {
            this.$_c = null;
        }
    }
    class DEventProvider extends DObject {
        constructor() {
            super(...arguments);
            //-------------------------------------------------------------------------
            // fields
            //-------------------------------------------------------------------------
            this._listeners = [];
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        addListener(listener) {
            if (listener && this._listeners.indexOf(listener) < 0) {
                this._listeners.push(listener);
            }
        }
        removeListener(listener) {
            const i = this._listeners.indexOf(listener);
            if (i >= 0) {
                this._listeners.splice(i, 1);
            }
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        /**
         * event로 지정한 함수가 정의된 모든 리스너에 대해 실행한다.
         * 리스너 scope으로 실행하고, 첫번째 매개변수로 이 객체가 전달된다.
         * 다만, 리스너들 중 하나라도 undefined가 아닌 값을 리턴하면,
         * 그 값을 리턴하면서 멈춘다.
         */
        _fireEvent(event, ...args) {
            const arr = Array.prototype.slice.call(arguments, 0);
            arr[0] = this;
            for (const listener of this._listeners) {
                const func = listener[event];
                if (func) {
                    const rslt = func.apply(listener, arr);
                    if (rslt !== void 0) {
                        return rslt;
                    }
                }
            }
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    // Utils.ts
    // 2021. 11. 26. created by dataludi
    // -----------------------------------------------------------------------------
    // Copyright (c) 2021 DataLudi Inc.
    // All rights reserved.
    ////////////////////////////////////////////////////////////////////////////////
    const __epoch = new Date().getTime();
    if (!Element.prototype.animate) {
        Element.prototype.animate = function (_) { };
    }
    const _isOpera = !!window["opera"] || navigator.userAgent.indexOf(' OPR/') >= 0;
    const _isChrome = !!window["chrome"] && !_isOpera; // Chrome 1+
    const _isSafari = Object.prototype.toString.call(HTMLElement).indexOf('Constructor') > 0 || (!_isChrome && !_isOpera && navigator.userAgent.indexOf("Safari") >= 0);
    const LINE_SEP = /\r\n|\n/g;
    const CSV_SPLIT = /,(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)(?=(?:[^\']*\'[^\']*\')*[^\']*$)/;
    const TAB_SPLIT = /\t/g;
    const MULTI_TAB_SPLIT = /\t+/g;
    const DBL_QUOTE_REP = /"([^"]*(?="))"/;
    const QUOTE_REP = /'([^']*(?='))'/;
    const DBL_QUOTE = '"'.charCodeAt(0);
    const QUOTE = "'".charCodeAt(0);
    /**
     * @internal
     *
     */
    class Utils {
        static now() {
            return +new Date();
        }
        static stopEvent(e, immediate = false) {
            if (e.preventDefault) {
                e.preventDefault();
                e.stopPropagation();
            }
            else {
                e.returnValue = false;
            }
            immediate && e.stopImmediatePropagation();
        }
        static getErrorStack(error) {
            const stack = error.stack;
            if (stack) {
                return stack.split('\n').map((line) => line + '<br/>');
            }
            return '';
        }
        static getBaseClassName(obj) {
            return Object.getPrototypeOf(obj.constructor).name;
        }
        static isObject(v) {
            return v && typeof v === 'object' && !Array.isArray(v);
        }
        static assign(target, source) {
            this.isObject(source) && Object.assign(target, source);
        }
        static isValidObject(v) {
            if (this.isObject(v)) {
                for (let p in v) {
                    if (v.hasOwnProperty(p))
                        return true;
                }
            }
        }
        static copyObject(v) {
            if (v && typeof v === 'object' && !Array.isArray(v)) {
                return Object.assign({}, v);
            }
        }
        static checkArray(v) {
            return Array.isArray(v) ? v : void 0;
        }
        static makeArray(v, force = false) {
            if (v != null) {
                return Array.isArray(v) ? v : [v];
            }
            else if (force) {
                return [];
            }
        }
        static makeNumArray(v) {
            if (Array.isArray(v)) {
                return v.map(n => +n);
            }
            else {
                return v != null ? [+v] : [];
            }
        }
        static getIntArray(count, start = 0) {
            const arr = [];
            for (let i = start, end = start + count; i < end; i++) {
                arr.push(i);
            }
            return arr;
        }
        static isValueArray(arr) {
            if (Array.isArray(arr)) {
                for (let i = arr.length - 1; i >= 0; i--) {
                    if (arr[i] != null && typeof arr[i] === 'object')
                        return false;
                }
                return true;
            }
            return false;
        }
        static toArray(v) {
            if (Array.isArray(v))
                return v;
            if (v !== undefined && v !== null)
                return [v];
            return null;
        }
        static copyArray(v) {
            if (Array.isArray(v))
                return v.slice(0);
            if (v !== undefined && v !== null)
                return [v];
            return undefined;
        }
        static push(arr, items) {
            if (items && items.length > 0) {
                for (let i = 0, n = items.length; i < n; i++) {
                    arr.push(items[i]);
                }
            }
        }
        static isDefined(v) {
            // return v !== (void 0) && v !== null;
            return v != null;
        }
        static isNotDefined(v) {
            // return v === (void 0) || v === null;
            return v == null;
        }
        static isNumber(value) {
            return typeof value === "number";
        }
        static isValidNumber(value) {
            return typeof value === 'number' && !isNaN(value) && isFinite(value);
        }
        static toNumber(value, def = 0) {
            return (isNaN(value) || value === null || value === '') ? def : +value;
        }
        static getEnumValues(type) {
            return Object.keys(type).map(key => type[key]);
        }
        static compareText(s1, s2, ignoreCase = false) {
            s1 = s1 || '';
            s2 = s2 || '';
            if (ignoreCase) {
                s1 = s1.toLocaleLowerCase();
                s2 = s2.toLocaleLowerCase();
            }
            return s1 > s2 ? 1 : (s1 < s2) ? -1 : 0;
        }
        static getTimeF() {
            return new Date().getTime() / 1000;
        }
        static getTimer() {
            return new Date().getTime() - __epoch;
        }
        static isWhiteSpace(s) {
            return !s || !s.trim();
        }
        static pad(value, len, c) {
            len = Math.max(len || 2, 1);
            c = c || '0';
            return new Array(len - String(value).length + 1).join(c) + value;
        }
        static pad16(value, len, c) {
            len = Math.max(len || 2, 1);
            c = c || '0';
            return new Array(len - value.toString(16).length + 1).join(c) + value.toString(16);
        }
        static pick(...args) {
            const len = args.length;
            let v;
            for (let i = 0; i < len; i++) {
                v = args[i];
                if (v !== undefined && v !== null) {
                    return v;
                }
            }
            return undefined;
        }
        static pickNum(...args) {
            const len = args.length;
            for (let i = 0; i < len; i++) {
                if (!isNaN(args[i]) && args[i] !== null)
                    return args[i];
            }
            return NaN;
        }
        static included(value, ...args) {
            const len = args.length;
            for (let i = 0; i < len; i++) {
                if (args[i] == value) {
                    return true;
                }
            }
            return false;
        }
        static compareTextValue(v1, v2, caseSensitive, partialMatch) {
            if (v1 === v2) {
                return true;
            }
            let s1 = String(v1);
            let s2 = v2 == null ? undefined : String(v2);
            if (!s1 && !s2) {
                return true;
            }
            if (!s1 || !s2) {
                return false;
            }
            if (!caseSensitive) {
                s1 = s1.toLowerCase();
                s2 = s2.toLowerCase();
            }
            if (partialMatch) {
                return s2.indexOf(s1) >= 0;
            }
            else {
                return s1 == s2;
            }
        }
        static cast(obj, clazz) {
            return obj instanceof clazz ? obj : null;
        }
        static irandom(min, max) {
            if (max !== undefined) {
                const v1 = min >> 0;
                const v2 = max >> 0;
                return (Math.random() * (v2 - v1) + v1) >>> 0;
            }
            else {
                const v = min >> 0;
                return (Math.random() * v) >> 0;
            }
        }
        static irandomExcept(except, min, max) {
            if (except === 0 && min === 1 && isNaN(max)) {
                throw new Error(`Invalid irandom2`);
            }
            while (true) {
                const i = this.irandom(min, max);
                if (i !== except) {
                    return i;
                }
            }
        }
        static brandom() {
            return Math.random() > 0.5 ? true : false;
        }
        static srandom(min, max) {
            let s = '';
            const len = this.irandom(min, max);
            for (let i = 0; i < len; i++) {
                s += String.fromCharCode(this.irandom(97, 123));
            }
            return s;
        }
        static erandom(clazz) {
            const vals = Object.values(clazz);
            return vals[this.irandom(vals.length)];
        }
        static arandom(arr) {
            return arr[(Math.random() * arr.length) >> 0];
        }
        static iarandom(min, max, count) {
            const list = new Array();
            for (let i = min; i < max; i++) {
                list.push(i);
            }
            while (list.length > count) {
                list.splice(Utils.irandom(list.length), 1);
            }
            return list;
        }
        static alert(message) {
            window.alert(message);
        }
        static toInt(v, radix) {
            const n = parseInt(v, radix || 10);
            return isNaN(n) ? 0 : n;
        }
        static toFloat(v) {
            const n = parseFloat(v);
            return isNaN(n) ? 0 : n;
        }
        static toEven(v) {
            return (v & 1) ? v + 1 : v;
        }
        static hex(value, len = 2, c = "0") {
            len = Math.max(len || 2, 1);
            const s = value.toString(16);
            c = c || "0";
            return new Array(len - s.length + 1).join(c) + s;
        }
        static toStr(value) {
            if (Number.isNaN(value)) {
                return '';
            }
            else {
                return value == null ? '' : String(value);
            }
        }
        static extend(target, source) {
            target = target || {};
            for (let p in source) {
                target[p] = source[p];
            }
            return target;
        }
        static equalNumbers(a, b) {
            return isNaN(a) == isNaN(b) && !isNaN(a) && a == b;
        }
        static equalArrays(a, b) {
            if (a === b)
                return true;
            if (a == null || b == null)
                return false;
            const len = a.length;
            if (len != b.length)
                return false;
            for (let i = 0; i < len; ++i) {
                if (a[i] !== b[i])
                    return false;
            }
            return true;
        }
        // 1 level comparison
        static equalObjects(obj1, obj2) {
            if (obj1 === obj2)
                return true;
            if (!obj1 && !obj2)
                return true;
            if (!obj1 || !obj2)
                return false;
            for (var p in obj1) {
                if (obj1.hasOwnProperty(p)) {
                    if (obj1[p] !== obj2[p]) {
                        return false;
                    }
                }
            }
            for (var p in obj2) {
                if (obj2.hasOwnProperty(p)) {
                    if (obj1[p] !== obj2[p]) {
                        return false;
                    }
                }
            }
            return true;
        }
        static parseDate(date, defaultDate) {
            const d = new Date(date);
            return isNaN(d.getTime()) ? (defaultDate || new Date()) : d;
        }
        static isLeapYear(year) {
            return ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);
        }
        static incMonth(d, delta) {
            const day = d.getDate();
            d.setDate(1);
            d.setMonth(d.getMonth() + delta);
            d.setDate(Math.min(day, Utils.month_days[Utils.isLeapYear(d.getFullYear()) ? 1 : 0][d.getMonth()]));
            return d;
        }
        static minDate(d1, d2) {
            if (d1 !== null)
                return d1;
            if (d2 !== null)
                return d2;
            return d1.getTime() < d2.getTime() ? d1 : d2;
        }
        static maxDate(d1, d2) {
            if (d1 !== null)
                return d2;
            if (d2 !== null)
                return d1;
            return d1.getTime() > d2.getTime() ? d1 : d2;
        }
        // 문자열이 한글이면 2, 영/숫자/기호 이면 1.
        static getTextLength2(s) {
            let b = 0, i = 0, c = 0;
            for (; c = s.charCodeAt(i++); b += c >> 7 ? 2 : 1)
                ;
            return b;
        }
        static getClassName(model) {
            function getFuncName(clazz) {
                let ret = clazz.toString();
                ret = ret.substring('function '.length);
                ret = ret.substring(0, ret.indexOf('('));
                return ret;
            }
            if (model && model.constructor) {
                return model.constructor.name || getFuncName(model.constructor);
            }
        }
        static isInteger(value) {
            if (Number.isInteger)
                return Number.isInteger(value);
            return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
        }
        static isEmpty(obj) {
            if (obj) {
                for (let p in obj) {
                    return false;
                }
            }
            return true;
        }
        static isNotEmpty(obj) {
            if (obj) {
                for (let p in obj) {
                    return true;
                }
            }
            return false;
        }
        static capitalize(s) {
            if (typeof s !== 'string')
                return '';
            const c = s.charAt(0);
            if (c >= 'A' && c <= 'Z')
                return s;
            return c.toUpperCase() + s.slice(1);
        }
        static uncapitalize(s) {
            if (typeof s !== 'string')
                return '';
            const c = s.charAt(0);
            if (c >= 'a' && c <= 'z')
                return s;
            return c.toLowerCase() + s.slice(1);
        }
        static labelize(s) {
            if (typeof s !== 'string')
                return '';
            const c = s.charAt(0);
            s = (c >= 'A' && c <= 'Z') ? s : (c.toUpperCase() + s.slice(1));
            let s2 = s.charAt(0);
            for (let i = 1; i < s.length; i++) {
                const c = s.charAt(i);
                if (c >= 'A' && c <= 'Z') {
                    s2 += ' ';
                }
                s2 += c;
            }
            return s2;
        }
        static deepClone(obj) {
            if (obj === null || typeof obj !== 'object') {
                return obj;
            }
            const result = Array.isArray(obj) ? [] : {};
            for (let key of Object.keys(obj)) {
                result[key] = Utils.deepClone(obj[key]);
            }
            return result;
        }
        static getArray(length, value) {
            const arr = [];
            for (let i = 0; i < length; i++)
                arr.push(value);
            return arr;
        }
        static getNumArray(length, value = 0) {
            const arr = [];
            for (let i = 0; i < length; i++)
                arr.push(value);
            return arr;
        }
        static hasSetter(obj, prop) {
            while (obj) {
                const pd = Reflect.getOwnPropertyDescriptor(obj, prop);
                if (pd)
                    return pd.writable || !!pd.set;
                obj = Object.getPrototypeOf(obj);
            }
            return false;
        }
        static dataUriToBinary(dataUri) {
            const BASE64_MARKER = ';base64,';
            const base64Index = dataUri.indexOf(BASE64_MARKER) + BASE64_MARKER.length;
            const base64 = dataUri.substring(base64Index);
            const raw = window.atob(base64);
            const rawLength = raw.length;
            const array = new Uint8Array(new ArrayBuffer(rawLength));
            for (let i = 0; i < rawLength; i++) {
                array[i] = raw.charCodeAt(i);
            }
            return array;
        }
        static assignProps(target, source) {
            let changed = false;
            if (source) {
                for (let p in source) {
                    // if (target.hasOwnProperty(p)) {
                    if (source[p] !== target[p]) {
                        target[p] = source[p];
                        changed = true;
                    }
                    //}
                }
            }
            return changed;
        }
        static assignStyleAndProps(target, source) {
            let changed = false;
            if (source) {
                for (let p in source) {
                    if (p === 'style') {
                        target[p] = source[p];
                        changed = true;
                    }
                    else if (target.hasOwnProperty(p)) {
                        //if (source[p] !== target[p]) {
                        target[p] = source[p];
                        changed = true;
                        //}
                    }
                }
            }
            return changed;
        }
        static dedupe(list, comparer) {
            list = list.sort(comparer || ((n1, n2) => n1 > n2 ? 1 : n1 < n2 ? -1 : 0));
            for (let i = list.length - 1; i > 0; i--) {
                if (list[i] === list[i - 1]) {
                    list.splice(i, 1);
                }
            }
            return list;
        }
        static isUnique(list, comparer) {
            list = list.sort(comparer || ((n1, n2) => n1 > n2 ? 1 : n1 < n2 ? -1 : 0));
            for (let i = list.length - 1; i > 0; i--) {
                if (list[i] === list[i - 1]) {
                    return false;
                }
            }
            return true;
        }
        static sortNum(list) {
            return list.sort((n1, n2) => n1 - n2);
        }
        static logElapsed(message, runner) {
            const t = +new Date();
            runner();
            console.log(message, (+new Date() - t) + 'ms');
        }
        static clamp(v, min, max) {
            if (!isNaN(max))
                v = Math.min(v, max);
            if (!isNaN(min))
                v = Math.max(v, min);
            return v;
        }
        static splice(array, start, deleteCount, items) {
            const args = [start, deleteCount].concat(items);
            Array.prototype.splice.apply(array, args);
        }
        static makeIntArray(from, to) {
            const arr = new Array(Math.max(0, to - from));
            for (let i = from; i < to; i++) {
                arr[i - from] = i;
            }
            return arr;
        }
        static setInterval(handler, interval) {
            return setInterval(handler, interval);
        }
        static clearInterval(handle) {
            clearInterval(handle);
        }
        static isStringArray(value) {
            return Array.isArray(value) && value.every(v => typeof v === 'string');
        }
        static isNumberArray(value) {
            return Array.isArray(value) && value.every(v => typeof v === 'number');
        }
        static makeLineSeparator(pattern) {
            if (Array.isArray(pattern)) {
                if (pattern.length > 0) {
                    let s = pattern[0];
                    for (let i = 1, n = pattern.length; i < n; i++) {
                        s += '|' + pattern[i];
                    }
                    return new RegExp(s, 'g');
                }
            }
            else if (pattern) {
                return new RegExp(pattern, 'g');
            }
        }
        static stripQuotes(s) {
            const c = s.charCodeAt(0);
            if (c === DBL_QUOTE) {
                s = s.replace(DBL_QUOTE_REP, "$1");
            }
            else if (c === QUOTE) {
                s = s.replace(QUOTE_REP, "$1");
            }
            return s;
        }
        static isDate(v) {
            // return v instanceof Date;
            return Object.prototype.toString.call(v) === '[object Date]';
        }
        static isValidDate(d) {
            return d.getTime() === d.getTime();
        }
        static asFunction(fn) {
            return typeof fn === 'function' ? fn : void 0;
        }
        static getFieldProp(field) {
            const p = field.indexOf('.');
            if (p >= 0) {
                return { field: field.substring(0, p), props: field.substring(p + 1).split('.') };
            }
        }
        static watch() {
            return new Stopwatch();
        }
    }
    Utils.week_days = [
        '일', '월', '화', '수', '목', '금', '토'
    ];
    Utils.month_days = [
        [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
        [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    ];
    class Stopwatch {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor() {
            this._started = +new Date();
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        elapsed(reset = false) {
            const e = +new Date() - this._started;
            reset && (this._started = +new Date());
            return e;
        }
        elapsedText(reset = false, suffix = 'ms.') {
            return this.elapsed(reset) + suffix;
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    const Locales = {};
    Locales['ko'] = {
        // formats
        dateFormat: 'yyyy.MM.dd',
        am: '오전',
        pm: '오후',
        // data messages
        notExistsDataField: '존재하지 않는 필드입니다: %1',
        notSpecifiedDataField: '하나 이상의 데이터필드가 설정돼야 합니다.',
        invalidFieldName: '잘못된 데이터필드 이름입니다: %1',
        invalidFieldIndex: '잘못된 데이터필드 index입니다: %1',
        invalidRowIndex: '잘못된 데이터행 index입니다: %1',
        canNotModifyData: '읽기 전용 데이터를 변경할 수 없습니다.',
        canNotModifyDeleted: '삭제 상태 행을 변경할 수 없습니다: %1',
        requiredField: '반드시 값을 지정해야 하는 필드입니다: %1',
        invalidValueInDomain: '값이 필드 값 도메인에 포함되지 않습니다: %1',
        invalidValueInRange: '값이 필드 값 범위에 포함되지 않습니다: %1',
        invalidToIndex: "잘못된 'to' index입니다.: %1",
        requireSourceData: '원본 data가 반드시 지정돼야 합니다.',
        requireFilterName: '필터 이름이 반드시 지정돼야 합니다.',
        // other messages
        invalidDateFormat: '잘못된 시간 날짜 형식입니다: %1',
        invalidSizeValue: '잘못된 Size 값입니다: %1',
        invalidOuterDiv: '잘못된 외부 div 입니다: %1',
        canNotHorzGrouping: '수평 모드일 때 그룹핑할 수 없습니다.',
        dataMustSet: '데이터가 먼저 설정돼야 합니다.',
        requireGroupingInfos: '하나 이상의 행 그룹핑 정보가 설정돼야 합니다.',
        canNotRowGrouping: '데이터링크 view에 대해 행그룹핑 할 수 없습니다. dataGroupBy()를 사용하세요.',
        canNotDataGrouping: '데이터링크 view가 아니면 데이터그룹핑할 수 없습니다. rowGroupBy()를 사용하세요.',
        canNotHorzInGrouping: '그룹핑 상태일 때 수평모드로 변경할 수 없습니다.',
        unknownLayoutType: '잘못된 layout 종류입니다: %1',
        layoutMustSet: '레이아웃 모델이 반드시 설정돼야 합니다.',
        unknownItemViewType: '잘못된 item view 종류입니다: %1',
        requireCommandName: 'Command 이름이 지정돼야 합니다.',
        commandNameDuplicated: '이미 존재하는 command 이름입니다: %1',
        requireDataOrGroup: '데이터소스나 그룹 모델이 반드시 지정돼야 합니다.',
    };
    Locales['en'] = {
        // formats
        dateFormat: 'M/d/yyyy',
        am: 'AM',
        pm: 'PM',
        // data messages
        notExistsDataField: 'A data field is not exists: %1',
        notSpecifiedDataField: 'At least one datafield must be set.',
        invalidFieldName: 'Invalid field name: %1',
        invalidFieldIndex: 'Invalid field index: %1',
        invalidRowIndex: 'Invalid row index: %1',
        canNotModifyData: 'Can not modify a readonly data.',
        canNotModifyDeleted: 'Can not modify a deleted row: %1',
        requiredField: 'Required field: %1',
        invalidValueInDomain: 'The value is not int the domain: %1',
        invalidValueInRange: 'The value is not int the range: %1',
        invalidToIndex: "Invalid 'to' index: %1",
        requireSourceData: 'A source data must be set.',
        requireFilterName: 'A filter name must be set.',
        // other messages
        invalidDateFormat: 'Invalid datetime format: %1',
        invalidSizeValue: 'Invalid size value: %1',
        invalidOuterDiv: 'Invalid outer div element: %1',
        canNotHorzGrouping: 'Can not row grouping in horz mode.',
        dataMustSet: 'A data must be set first.',
        requireGroupingInfos: 'At least one grouping info must be set.',
        canNotRowGrouping: 'Can not row grouping by data link view. use dataGroupBy().',
        canNotDataGrouping: 'Can not data grouping without data link view. rowGroupBy()를 사용하세요.',
        canNotHorzInGrouping: 'Can not change to horz mode while grouping',
        unknownLayoutType: 'Invalid layout: %1',
        layoutMustSet: 'A layout model must be set.',
        unknownItemViewType: 'Unknow item view type: %1',
        requireCommandName: 'Command name must be supplied.',
        commandNameDuplicated: 'Command name is already exists: %1',
        requireDataOrGroup: 'A data or group view must be set.',
    };
    let _currLang = 'ko';
    let locale = Locales[_currLang];
    const $_setLocale = (lang) => {
        locale = Locales[_currLang = lang];
        if (!locale)
            locale = Locales[_currLang = 'ko'];
        return locale;
    };
    const $_registerLocale = (lang, data) => {
        if (lang && Utils.isObject(data)) {
            locale = Locales[lang] = data;
            // 빈 항목은 'en'으로 대체 시킨다.
            if (lang !== 'en') {
                const en = Locales['en'];
                for (const p in en) {
                    locale[p] = locale[p] || en[p];
                }
            }
        }
    };
    const formatMessage = (str, value) => {
        return str.replace('%1', value);
    };
    const formatMessage2 = (str, value1, value2) => {
        return str.replace('%1', value1).replace('%2', value2);
    };

    ////////////////////////////////////////////////////////////////////////////////
    class DLog {
        static setLogging(enabled = true) {
            this._logging = enabled;
        }
        static log(...messages) {
            this._logging && console.log.apply(console, messages);
        }
    }
    //-------------------------------------------------------------------------
    // static members
    //-------------------------------------------------------------------------
    DLog._logging = false;
    const NOT_IMPLEMENT = new Error("Not Implemented.");
    const PERCENT = '%'.charCodeAt(0);
    function parsePercentSize(sv, enableNull) {
        let fixed;
        let size;
        if (sv != null && !Number.isNaN(sv)) {
            if (!(fixed = !isNaN(size = +sv))) {
                const s = sv.trim();
                const c = s.charCodeAt(s.length - 1);
                if (c === PERCENT) {
                    size = s.length === 1 ? NaN : parseFloat(s);
                }
                if (isNaN(size)) {
                    if (enableNull) {
                        return null;
                    }
                    throwFormat(locale.invalidSizeValue, sv);
                }
            }
        }
        else if (enableNull) {
            return null;
        }
        else {
            size = 0;
            fixed = true;
        }
        return { size, fixed };
    }
    function getPercent(size) {
        return size && !size.fixed ? size.size : NaN;
    }
    function calcPercent(size, domain) {
        return size ? (size.fixed ? size.size : size.size * domain / 100) : NaN;
    }
    function isValidSizeValue(v) {
        if (!isNaN(v))
            return true;
        if (typeof v === 'string' && v.trimRight().endsWith('*') && !isNaN(parseFloat(v)))
            return true;
        return false;
    }
    function getRelativeSize(dim) {
        if (dim) {
            if (dim.rated) {
                return { size: dim.size, rated: true };
            }
            else if (!dim.fixed) {
                return { size: dim.size, rated: false };
            }
        }
        return null;
    }
    class AssertionError extends Error {
    }
    const assert = function (predict, message) {
        if (!predict) {
            throw new AssertionError(message);
        }
    };
    const checkNull = function (obj, message) {
        if (!obj) {
            throw new Error(message || (obj + ' is null.'));
        }
    };
    const createRect = function (x, y, width, height) {
        return { x, y, width, height };
    };
    class Registy extends DObject {
        constructor() {
            super(...arguments);
            //-------------------------------------------------------------------------
            // fields
            //-------------------------------------------------------------------------
            this._items = {};
        }
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        _doDestory() {
            this.clear();
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        get(name) {
            return this._items[name];
        }
        clear() {
            for (let t in this._items) {
                this._items[t].destroy();
            }
            this._items = {};
        }
        add(name, template) {
            if (name && template) {
                this._items[name] = template;
            }
        }
        remove(name) {
            delete this._items[name];
        }
        removeAll(names) {
            if (Array.isArray(names)) {
                const items = this._items;
                names.forEach(name => {
                    const item = items[name];
                    if (item) {
                        item.destroy();
                        delete items[name];
                    }
                });
            }
        }
    }
    var Direction;
    (function (Direction) {
        Direction["UP"] = "up";
        Direction["DOWN"] = "down";
        Direction["LEFT"] = "left";
        Direction["RIGHT"] = "right";
    })(Direction || (Direction = {}));
    const throwError = (message) => {
        throw new Error(message);
    };
    const throwFormat = (format, value) => {
        throw new Error(formatMessage(format, value));
    };

    ////////////////////////////////////////////////////////////////////////////////
    // BooleanFormatter.ts
    // 2021. 12. 07. created by dataludi
    // -----------------------------------------------------------------------------
    // Copyright (c) 2021 Dataludi Inc.
    // All rights reserved.
    ////////////////////////////////////////////////////////////////////////////////
    const SPLITTER = /[;\:]/;
    /**
     * @internal
     *
     * 'falseText;trueText'
     */
    class BooleanFormatter {
        //-------------------------------------------------------------------------
        // constructors
        //-------------------------------------------------------------------------
        constructor(format) {
            this.$_parse(this._format = format);
        }
        static getFormatter(format) {
            let f = BooleanFormatter.Formatters[format];
            if (!f) {
                BooleanFormatter.Formatters[format] = f = new BooleanFormatter(format);
            }
            return f;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        get format() {
            return this._format;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        toStr(v) {
            return v === true ? this._trueText : this._falseText;
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        $_parse(format) {
            this._falseText = this._trueText = null;
            if (format) {
                const arr = format.split(SPLITTER);
                this._falseText = arr[0];
                if (arr.length > 0) {
                    this._trueText = arr[1];
                }
            }
        }
    }
    //-------------------------------------------------------------------------
    // static members
    //-------------------------------------------------------------------------
    BooleanFormatter.Formatters = {};

    ////////////////////////////////////////////////////////////////////////////////
    const $$_DT_DATE_TOKENS = [
        "yy", "yyyy",
        "M", "MM",
        "d", "dd",
        "a",
        "H", "HH", "h", "hh",
        "m", "mm",
        "s", "ss",
        "S", "SS", "SSS"
    ];
    const $$_DT_DATE_SEPARATORS = [
        ".", "/", "-", ":"
    ];
    const U_Z = "Z".charCodeAt(0);
    const L_Z = "z".charCodeAt(0);
    const U_A = "A".charCodeAt(0);
    const L_A = "a".charCodeAt(0);
    const L_Y = "y".charCodeAt(0);
    const U_M = "M".charCodeAt(0);
    const L_M = "m".charCodeAt(0);
    const L_D = "d".charCodeAt(0);
    const U_H = "H".charCodeAt(0);
    const L_H = "h".charCodeAt(0);
    const U_S = "S".charCodeAt(0);
    const L_S = "s".charCodeAt(0);
    const pad = function (v) {
        return (v < 10) ? "0" + v : String(v);
    };
    const pad3 = function (v) {
        return (v < 10) ? "00" + v : (v < 100) ? "0" : String(v);
    };
    /**
     * @internal
     *
     */
    class DatetimeFormatter {
        //-------------------------------------------------------------------------
        // constructors
        //-------------------------------------------------------------------------
        constructor(format) {
            this._baseYear = 2000;
            this._preserveTime = false;
            this._hasAmPm = false;
            this._formatString = "";
            this.formatString = format;
        }
        static getFormatter(format) {
            let f = DatetimeFormatter.Formatters[format];
            if (!f) {
                DatetimeFormatter.Formatters[format] = f = new DatetimeFormatter(format);
            }
            return f;
        }
        static get Default() {
            return DatetimeFormatter.getFormatter(locale.dateFormat);
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /** format */
        get format() {
            return this._format;
        }
        /** formatString */
        get formatString() {
            return this._formatString;
        }
        set formatString(value) {
            value = value || locale.dateFormat;
            if (value != this._formatString) {
                this._tokens = [];
                this.parse(value);
                this._formatString = value;
            }
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        toStr(date) {
            if (!this._tokens) {
                return "";
            }
            const tokens = this._tokens;
            let s = "";
            for (var i = 0, cnt = tokens.length; i < cnt; i++) {
                var t = tokens[i];
                var len = t.length;
                switch (t.charCodeAt(0)) {
                    case L_Y:
                        s += len > 2 ? date.getFullYear() : pad(date.getFullYear() % 100);
                        break;
                    case U_M:
                        s += len > 1 ? pad(date.getMonth() + 1) : (date.getMonth() + 1);
                        break;
                    case L_D:
                        s += len > 1 ? pad(date.getDate()) : date.getDate();
                        break;
                    case U_H:
                        s += len > 1 ? pad(date.getHours()) : date.getHours();
                        break;
                    case L_H:
                        if (this._hasAmPm) {
                            let h = date.getHours();
                            if (h == 0) {
                                h = 12;
                            }
                            else if (h > 12) {
                                h = h - 12;
                            }
                            s += len > 1 ? pad(h) : h;
                        }
                        else {
                            s += len > 1 ? pad(date.getHours()) : date.getHours();
                        }
                        break;
                    case L_M:
                        s += len > 1 ? pad(date.getMinutes()) : date.getMinutes();
                        break;
                    case L_S:
                        s += len > 1 ? pad(date.getSeconds()) : date.getSeconds();
                        break;
                    case L_A:
                    case U_A:
                        if (date.getHours() < 12) {
                            s += locale.am;
                        }
                        else {
                            s += locale.pm;
                        }
                        break;
                    case U_S:
                        let v = date.getMilliseconds();
                        if (len == 3)
                            s += pad3(v);
                        else if (len == 2)
                            s += pad(v);
                        else
                            s += v.toString().substr(0, len);
                        break;
                    /*
                     case U_Y:
                     break;
                     case U_D:
                     s += day of year
                     break;
                     */
                    default:
                        s += t;
                }
            }
            return s;
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        parseDateFormatTokens(format) {
            var tokens = [];
            if (format) {
                const str = format.trim();
                const len = str.length;
                let i = 0;
                while (i < len) {
                    let tok = str.charAt(i);
                    if ($$_DT_DATE_SEPARATORS.indexOf(tok) >= 0) {
                        tokens.push(tok);
                        i++;
                    }
                    else {
                        let p = i++;
                        while (i < len && str.charAt(i) == tok) {
                            i++;
                        }
                        tok = str.substring(p, i);
                        if ($$_DT_DATE_TOKENS.indexOf(tok) < 0) {
                            let c = tok.charCodeAt(0);
                            if (c >= U_A && c <= U_Z || c >= L_A && c <= L_Z) {
                                throwFormat(locale.invalidDateFormat, format);
                            }
                        }
                        tokens.push(tok);
                    }
                    if (i < len && Utils.isWhiteSpace(tok = str.charAt(i))) {
                        tokens.push(tok);
                        while (i < len && Utils.isWhiteSpace(str.charAt(i))) {
                            i++;
                        }
                    }
                }
            }
            return tokens;
        }
        ;
        parse(fmt) {
            if (fmt) {
                this._format = fmt || locale.dateFormat;
                this._tokens = this.parseDateFormatTokens(this._format);
                this._hasAmPm = this._tokens.indexOf("a") >= 0 || this._tokens.indexOf("A") >= 0;
            }
        }
        ;
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    //-------------------------------------------------------------------------
    // static members
    //-------------------------------------------------------------------------
    DatetimeFormatter.Formatters = {};

    ////////////////////////////////////////////////////////////////////////////////
    // NumberFormatter.ts
    // 2022. 03. 06. created by dataludi
    // -----------------------------------------------------------------------------
    // Copyright (c) 2021-2022 Dataludi Inc.
    // All rights reserved.
    ////////////////////////////////////////////////////////////////////////////////
    const ZERO = '0'.charCodeAt(0);
    const SHARP = '#'.charCodeAt(0);
    const COMMA = ','.charCodeAt(0);
    const SIGN = 's'.charCodeAt(0);
    const ABS = 'a'.charCodeAt(0);
    /**
     * @internal
     *
     * 'as,0.0#'
     * NOTE: 'a'는 bigint에 사용할 수 없다.
     */
    class NumberFormatter {
        //-------------------------------------------------------------------------
        // constructors
        //-------------------------------------------------------------------------
        constructor(format) {
            format = format.trim();
            this._options = format ? this.$_parse(this._format = format) : { useGrouping: false };
        }
        static getFormatter(format) {
            let f = NumberFormatter.Formatters[format];
            if (!f) {
                NumberFormatter.Formatters[format] = f = new NumberFormatter(format);
            }
            return f;
        }
        static get Default() {
            return NumberFormatter.getFormatter(NumberFormatter.DEFAULT_FORMAT);
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        toStr(value) {
            return value.toLocaleString(undefined, this._options);
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        $_parse(s) {
            const len = s.length;
            if (len > 0) {
                const options = {
                    useGrouping: false,
                    minimumIntegerDigits: 0,
                    minimumFractionDigits: 0,
                    maximumFractionDigits: 0,
                };
                let p = s.indexOf('.');
                if (p >= 0) {
                    let i = p + 1;
                    while (i < len) {
                        if (s.charCodeAt(i) === ZERO) {
                            options.minimumFractionDigits++;
                            i++;
                        }
                        else {
                            break;
                        }
                    }
                    options.maximumFractionDigits = options.minimumFractionDigits;
                    while (i < len) {
                        if (s.charCodeAt(i) === SHARP) {
                            options.maximumFractionDigits++;
                            i++;
                        }
                        else {
                            break;
                        }
                    }
                    p = p - 1;
                }
                else {
                    p = len - 1;
                }
                let i = p;
                while (i >= 0) {
                    if (s.charCodeAt(i) === ZERO) {
                        options.minimumIntegerDigits++;
                        i--;
                    }
                    else {
                        break;
                    }
                }
                while (i >= 0) {
                    const c = s.charCodeAt(i--);
                    if (c === COMMA) {
                        options.useGrouping = true;
                        break;
                    }
                }
                i = p;
                while (i >= 0) {
                    const c = s.charCodeAt(i--);
                    if (c === SIGN) {
                        options.signDisplay = 'always';
                        break;
                    }
                }
                if (!options.signDisplay) {
                    i = p;
                    while (i >= 0) {
                        const c = s.charCodeAt(i--);
                        if (c === ABS) {
                            options.signDisplay = 'never';
                            break;
                        }
                    }
                }
                options.minimumIntegerDigits = Math.max(1, options.minimumIntegerDigits);
                return options;
            }
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    NumberFormatter.DEFAULT_FORMAT = "";
    //-------------------------------------------------------------------------
    // static members
    //-------------------------------------------------------------------------
    NumberFormatter.Formatters = {};

    ////////////////////////////////////////////////////////////////////////////////
    // TextFormatter.ts
    // 2021. 12. 07. created by dataludi
    // -----------------------------------------------------------------------------
    // Copyright (c) 2021 Dataludi Inc.
    // All rights reserved.
    ////////////////////////////////////////////////////////////////////////////////
    const DUMMY_PATTERN = /(.*)/;
    const DUMMY_REPLACE = "$1";
    const spliter = new RegExp(';(?=(?:[^"]*"[^"]*")*(?![^"]*"))');
    /**
     * @internal
     *
     * 값이 문자형일 때 텍스트 변경 형식.
     * 세미콜론(;)으로 구분되는 형식. 두개의 문자열은 각각 String.prototype.replace의 매개변수가 된다.
     * 예) 사업자번호: '(\\d{3})(\\d{2})(\\d{5});$1-$2-$3'
     */
    class TextFormatter {
        //-------------------------------------------------------------------------
        // constructors
        //-------------------------------------------------------------------------
        constructor(format) {
            this._pattern = DUMMY_PATTERN;
            this._replace = DUMMY_REPLACE;
            this.$_parse(this._format = format);
        }
        static getFormatter(format) {
            let f = TextFormatter.Formatters[format];
            if (!f) {
                TextFormatter.Formatters[format] = f = new TextFormatter(format);
            }
            return f;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        get format() {
            return this._format;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        toStr(text) {
            return text && text.replace(this._pattern, this._replace);
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        $_parse(fmt) {
            if (fmt) {
                const arr = fmt.trim().split(spliter);
                if (arr.length > 1) {
                    let p = arr[0].trim();
                    let f = arr[1].trim();
                    if (p && f) {
                        if (p.charAt(0) == '"') {
                            p = p.substr(1, p.length - 2);
                        }
                        if (p) {
                            if (f.charAt(0) == '"') {
                                f = p.substr(1, f.length - 2);
                            }
                            if (f) {
                                this._pattern = new RegExp(p, arr[2] || '');
                                this._replace = f;
                            }
                        }
                    }
                }
            }
        }
    }
    //-------------------------------------------------------------------------
    // static members
    //-------------------------------------------------------------------------
    TextFormatter.Formatters = {};

    ////////////////////////////////////////////////////////////////////////////////
    const T_RENDERER = '_rnd_';
    const T_FIELD = '_fld_';
    const T_ROW = '_row_';
    const T_IDX = '_idx_';
    const T_URL = '_url_';
    const T_WIDTH = '_width_';
    const T_HEIGHT = '_height_';
    const T_NAME = '_name_';
    const T_STYLES = '_sts_';
    const T_CLASS = '_sts_';
    const SPAN = '_span';
    const IMG = '_img';
    const BUTTON$1 = '_btn';
    const BOX = '_box';
    const GROUP = '_group';
    const BAR = '_bar';
    const SHAPE = '_shape';
    const SVG = '_svg';
    const CLICKABLE = '_clkable';
    // 사용가능 문자들 : A-Za-z0-9_-,#@
    //               기본값, 형식에는 space를 포함할 수 있다.
    // ${이름;기본값;형식} 혹은 ${이름|기본값|형식} - 기본값, 형식은 지정하지 않을 수 있다.
    // %{이름;기본값;형식} 혹은 %{이름|기본값|형식}
    // const PARAM_EXP = /\$\{[^\$\{\}\;\|]+[\;\|]*[\w\s\-#@,\.\:\p{L}]*[\;\|]*[\w\s\-#@,\.\:\p{L}]*\}/gu;
    // const PARAM_EXP = /\$\{[^\$\{\}\;\|]+[\;\|]*[\w\s\-#@,\.\:]*[\;\|]*[\w\s\-#@,\.\:]*\}/g;
    // const PARAM_EXP = /\$\{[^\$\{\}\;\|]+[\;\|]*[\w\s\-#@,\.\:\u3131-\u318E\uAC00-\uD7A3]*[\;\|]*[\w\s\-#@,\.\:\u3131-\u318E\uAC00-\uD7A3]*\}/g;
    const PARAM_EXP = /(\$|%)\{[^(\$|%)\{\}\;\|]+[\;\|]*[\w\s\-#@,\.\:가-힇ㄱ-ㅎㅏ-ㅣぁ-ゔァ-ヴー々〆〤一-龥]*[\;\|]*[\w\s\-#@,\.\:가-힇ㄱ-ㅎㅏ-ㅣぁ-ゔァ-ヴー々〆〤一-龥]*\}/g;
    const AT = '@'.charCodeAt(0);
    /**
     * @internal
     *
     * Template 등에서 '${name;default;format}' 형식으로 설정되는 매개변수화된 값.
     * NOTE: ';'나 '|'로 분리한다. ':'가 아니다. ':'는 시간 형식 문자에 사용될 수 있다.
     */
    class DParam {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(source, name, defaultValue, format) {
            this.source = source;
            this.stock = name.charCodeAt(0) === AT;
            this.name = this.stock ? name.substring(1) : name;
            this.default = defaultValue;
            this.format = format;
        }
        //-------------------------------------------------------------------------
        // static methods
        //-------------------------------------------------------------------------
        static create(name, defaultValue, format) {
            return new DParam(void 0, name, defaultValue, format);
        }
    }
    /**
     * @internal
     *
     * 하나 이상의 DParam과 단순 문자열이 섞여 있는 문자열.
     */
    class DParamString {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(s, matches) {
            //-------------------------------------------------------------------------
            // fields
            //-------------------------------------------------------------------------
            this._params = [];
            this._args = {
                context: void 0,
                // target: void 0,
                field: void 0
            };
            function indexOfSep(m, from) {
                let i = m.indexOf('|', from);
                let j = m.indexOf(';', from);
                if (i >= 0 && j >= 0) {
                    return Math.min(i, j);
                }
                else if (i >= 0) {
                    return i;
                }
                return j;
            }
            const params = this._params;
            let p = 0;
            for (let match of matches) {
                const q = s.indexOf(match, p);
                const m = match.substring(2, match.length - 1);
                const i = indexOfSep(m);
                let param;
                if (q > p) {
                    params.push(s.substring(p, q));
                    p = q;
                }
                if (i >= 0) {
                    const name = m.substring(0, i);
                    const j = indexOfSep(m, i + 1);
                    let def;
                    let fmt;
                    if (j >= 0) {
                        def = m.substring(i + 1, j);
                        fmt = m.substring(j + 1);
                    }
                    else {
                        def = m.substring(i + 1);
                    }
                    param = new DParam(match, name, def, fmt);
                }
                else {
                    param = new DParam(match, m, void 0, void 0);
                }
                params.push(param);
                p += match.length;
            }
            if (p < s.length) {
                params.push(s.substring(p));
            }
        }
        //-------------------------------------------------------------------------
        // static members
        //-------------------------------------------------------------------------
        static parse(s) {
            if (typeof s === 'string') {
                const matches = s.match(PARAM_EXP);
                if (matches) {
                    return new DParamString(s, matches);
                }
            }
            return s;
        }
        static load(source) {
            const props = {};
            for (const p in source) {
                const v = source[p];
                if (typeof v === 'string') {
                    props[p] = DParamString.parse(v);
                }
                else {
                    props[p] = v;
                }
            }
            return props;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        get count() {
            return this._params.length;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        get(index) {
            return this._params[index];
        }
        inflate(context, target, field, inflater) {
            const args = this._args;
            const params = this._params;
            let s = '';
            args.context = context;
            // args.target = target;
            args.field = field;
            for (let i = 0, n = params.length; i < n; i++) {
                const param = params[i];
                if (param instanceof DParam) {
                    let v;
                    if (inflater.inflateParam) {
                        if (param.stock) {
                            v = inflater.inflateStock(target, field, param);
                            if (param.format) {
                                const t = typeof v;
                                if ((t === 'number' || t === 'bigint') && !Number.isNaN(v)) {
                                    const fmt = NumberFormatter.getFormatter(param.format);
                                    if (fmt) {
                                        v = fmt.toStr(v);
                                    }
                                }
                            }
                        }
                        else {
                            v = inflater.inflateParam(target, field, param);
                        }
                    }
                    else {
                        v = inflater[param.name];
                    }
                    if (typeof v === 'function') {
                        v = v(args);
                    }
                    // param 하나로만 구성된 경우 값을 그대로 리턴한다.
                    if (n === 1) {
                        return v != null ? v : param.default;
                    }
                    s += v != null ? v : (param.default || '');
                }
                else {
                    s += param;
                }
            }
            return s;
        }
    }
    /**
     * 데이터행 배치 방향.
     * <br>
     * {@link DListOptions.orientation} 속성에서 사용된다.
     *
     * ```
     *  list.setConfig({
     *      options: {
     *          orientation: DList.DListOrientation.HORIZONTAL
     *      }
     *  });
     * ```
     *
     * @see concepts.list_mode 리스트 모드
     * @see concepts.options 컨트롤 Options
     */
    var DListOrientation;
    (function (DListOrientation) {
        /**
         * 데이터행들을 왼쪽에 오른쪽 순서로 배치한다.
         * <br>
         * <img data-all="1" src="../images/horizontal-01.png" style="width: 450px;"/>
         * <br>
         */
        DListOrientation["HORIZONTAL"] = "horizontal";
        /**
         * 데이터행들을 위에서 아래쪽 순서로 배치한다.
         */
        DListOrientation["VERTICAL"] = "vertical";
    })(DListOrientation || (DListOrientation = {}));
    var DScreenOrientation;
    (function (DScreenOrientation) {
        DScreenOrientation["PORTRAIT"] = "portrait";
        DScreenOrientation["LANDSCAPE"] = "landscape";
    })(DScreenOrientation || (DScreenOrientation = {}));
    /**
     * 자식 항목들의 배치 방식.
     * <br>
     *
     * @see {@link DListButtonPanel.align}
     */
    var DListItemsAlign;
    (function (DListItemsAlign) {
        /**
         * 자식 항목이 포함된 컨테이너 시작 쪽에 배치한다.
         */
        DListItemsAlign["START"] = "start";
        /**
         * 자식 항목이 포함된 컨테이너 중앙에 배치한다.
         */
        DListItemsAlign["CENTER"] = "center";
        /**
         * 자식 항목이 포함된 컨테이너 끝 쪽에 배치한다.
         */
        DListItemsAlign["END"] = "end";
    })(DListItemsAlign || (DListItemsAlign = {}));
    /**
     * 수평 정렬.
     * <br>
     *
     * @see ISimpleLayoutChild.align
     * @see IVLinearLayout.itemsAlign
     */
    var DListHorizontalAlign;
    (function (DListHorizontalAlign) {
        /**
         * 왼쪽 정렬.
         */
        DListHorizontalAlign["LEFT"] = "left";
        /**
         * 중앙 정렬.
         */
        DListHorizontalAlign["CENTER"] = "center";
        /**
         * 오른쪽 정렬.
         */
        DListHorizontalAlign["RIGHT"] = "right";
    })(DListHorizontalAlign || (DListHorizontalAlign = {}));
    /**
     * 수직 정렬 방식.
     * <br>
     *
     * @see ISimpleLayoutChild.valign
     * @see IHLinearLayout.itemsAlign
     */
    var DListVerticalAlign;
    (function (DListVerticalAlign) {
        /**
         * 위쪽으로 정렬.
         */
        DListVerticalAlign["TOP"] = "top";
        /**
         * 중앙에 정렬.
         */
        DListVerticalAlign["MIDDLE"] = "middle";
        /**
         * 아래쪽에 정렬.
         */
        DListVerticalAlign["BOTTOM"] = "bottom";
    })(DListVerticalAlign || (DListVerticalAlign = {}));
    var DScrollUnit;
    (function (DScrollUnit) {
        DScrollUnit["DEFAULT"] = "default";
        DScrollUnit["ROW"] = "row";
        DScrollUnit["PIXEL"] = "pixel";
    })(DScrollUnit || (DScrollUnit = {}));
    /**
     * {@link IListLinearLayout}에서 자식들의 크기 합이 고정된 레이아웃 크기보다 작을 때,
     * 자식들을 배치하는 방식.
     * <br>
     * {@link IListLinearLayout.itemsArrange} 속성으로 설정한다.
     *
     * @see IListLinearLayout
     */
    var DListItemsArrange;
    (function (DListItemsArrange) {
        /**
         * 레이아웃 시작 위치에서 부터 자식들을 배치한다.
         */
        DListItemsArrange["START"] = "start";
        /**
         * 레이아웃 끝 위치에서 부터 자식들을 배치한다.
         */
        DListItemsArrange["END"] = "end";
        /**
         * 레이아웃 중앙에 자식들을 배치한다.
         */
        DListItemsArrange["CENTER"] = "center";
        /**
         * 자식들을 배치한 후 남은 공간을 자식들 사이에 분배한다.
         */
        DListItemsArrange["SPACE_BETWEEN"] = "spaceBetween";
        /**
         * 자식들을 배치한 후 남은 공간을 자식들 사이와 양 끝에 골고루 분배한다.
         */
        DListItemsArrange["SPACE_AROUND"] = "spaceAround";
    })(DListItemsArrange || (DListItemsArrange = {}));
    /**
     * @internal
     *
     * 각각 다른 이름으로 미리 등록된 동일한 크기의 이미지 집합.
     * 버튼 및 렌더러(?) 등에 사용된다.
     */
    class DIconSet extends DObject {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(config) {
            super();
            this._icons = {};
            if (Utils.isObject(config)) {
                this._width = +config.width;
                this._height = +config.height;
                this._root = config.root;
                Object.assign(this._icons, config.icons);
            }
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        get width() {
            return this._width;
        }
        get height() {
            return this._height;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        getUrl(name) {
            let url = this._icons[name];
            if (url) {
                if (this._root) {
                    url = this._root + url;
                }
                return url;
            }
        }
        get(name) {
            return this._icons[name];
        }
        set(name, url) {
            this._icons[name] = url;
        }
    }
    /**
     * 정렬 방향.
     * <br>
     *
     * @see DListDataView.addSort
     * @see IListSelectRenderer.sortDirection
     */
    var DListSortDirection;
    (function (DListSortDirection) {
        /**
         * 내림 차순으로 정렬한다.
         */
        DListSortDirection["ASCENDING"] = "ascending";
        /**
         * 올림 차순으로 정렬한다.
         */
        DListSortDirection["DESCENDING"] = "descending";
    })(DListSortDirection || (DListSortDirection = {}));
    const isObject = function (v) {
        return v && typeof v === 'object' && !Array.isArray(v);
    };
    const pickProp = function (v1, v2) {
        return v1 === void 0 ? v2 : v1;
    };
    const pickProp3 = function (v1, v2, v3) {
        return v1 === void 0 ? (v2 === void 0 ? v3 : v2) : v1;
    };
    const toNumProp = function (v1, v2) {
        v1 = parseFloat(v1);
        return !isNaN(v1) ? v1 : v2;
    };
    const pickNum = function (v1, v2) {
        v1 = parseFloat(v1);
        return !isNaN(v1) ? v1 : parseFloat(v2);
    };
    const pickNum3 = function (v1, v2, v3) {
        return !isNaN(v1) ? v1 : !isNaN(v2) ? v2 : v3;
    };
    const pixel = function (v) {
        return v + 'px';
    };
    const ZERO_PX = '0px';
    const KR_LETTERS = '가나다라마바사아자차카타파하힣';
    class DListRowStyles {
    }
    const copyRowStyles = function (source) {
        const st = Utils.copyObject(source);
        let impl;
        if (st) {
            impl = new DListRowStyles();
            if (st.alternate) {
                impl.alternate = Object.assign({}, st.alternate);
                delete st.alternate;
            }
            if (st.updated) {
                impl.updated = Object.assign({}, st.updated);
                delete st.updated;
            }
            if (st.deleted) {
                impl.deleted = Object.assign({}, st.deleted);
                delete st.deleted;
            }
            if (st.selected) {
                impl.selected = Object.assign({}, st.selected);
                delete st.selected;
            }
            if (st.checked) {
                impl.checked = Object.assign({}, st.checked);
                delete st.checked;
            }
            if (st.searched) {
                impl.searched = Object.assign({}, st.searched);
                delete st.searched;
            }
            const def = st.default;
            def && delete st.default;
            impl.default = st;
            def && Object.assign(impl.default, def);
        }
        return impl;
    };
    /**
     * 데이터행들을 배치하는 방식.
     * <br>
     */
    var DListMode;
    (function (DListMode) {
        /**
         * 한 줄에 한 행을 표시하는 기본 표시 모드.
         * <br>
         */
        DListMode["DEFAULT"] = "default";
        /**
         * 한 줄에 여러 행을 분할해서 표시.
         */
        DListMode["CARD"] = "card";
    })(DListMode || (DListMode = {}));
    /**
     * {@link DListContorl 컨트롤}의 데이터행 뷰(html element)들을 생성하는 방식.
     * <br>
     * render mode는 {@link DListControl 리스트 컨트롤} 생성시 결정되고,
     * {@link DListControl.renderMode} 속성으로 현재 상태를 알 수 있다.
     *
     * ```
     * const list = DList.createList(document, 'dlist', DList.DListRenderMode.PRE);
     * ```
     *
     * @see concepts.render_mode 리스트 Render 모드
     */
    var DListRenderMode;
    (function (DListRenderMode) {
        /**
         * 기본 render 모드.
         * <br>
         * 설정된 리스크 컨트롤 크기에 맞춰 필요한 데이터행만 표시하고,
         * 스크롤될 때마다 데이터행들의 view를 갱신한다.
         * 즉, 당장 표시될 행들의 html element 만을 생성한다.
         */
        DListRenderMode["DEFAULT"] = "default";
        /**
         * 모든 데이터행에 대한 view를 미리 준비한다.
         * <br>
         * 즉, 모든 데이터행의 html element를 미리 생성한다.
         * [접근성]을 제공해야 하고, 행 수가 100 건 이하일 때 사용한다.
         */
        DListRenderMode["PRE"] = "pre";
        /**
         * 전체 데이터행 및 헤더 푸터 등 관련 내용들을 한꺼번에 모두 표시한다.
         * <br>
         * 브라우저 스크롤링으로 넘치는 데이터를 확인한다.
         * UI 필요성 혹은 [접근성]을 제공해야 하고, 행 수가 100 건 이하일 때 사용한다.
         */
        DListRenderMode["FULL"] = "full";
    })(DListRenderMode || (DListRenderMode = {}));
    const text_formatters = {};
    const bool_formatters = {};
    const number_formatters = {};
    const date_formatters = {};
    const getTextFormatter = function (fmt) {
        let ft = text_formatters[fmt];
        if (ft) {
            return ft;
        }
        else if (fmt) {
            const f = TextFormatter.getFormatter(fmt);
            text_formatters[fmt] = ft = (value) => f.toStr(value);
            return ft;
        }
        else {
            return null;
        }
    };
    const getBoolFormatter = function (fmt) {
        let ft = bool_formatters[fmt];
        if (ft) {
            return ft;
        }
        else if (fmt) {
            const f = BooleanFormatter.getFormatter(fmt);
            bool_formatters[fmt] = ft = (value) => f.toStr(value);
            return ft;
        }
        else {
            return null;
        }
    };
    const getNumberFormatter = function (fmt) {
        let ft = number_formatters[fmt];
        if (ft) {
            return ft;
        }
        else if (fmt) {
            const f = NumberFormatter.getFormatter(fmt);
            number_formatters[fmt] = ft = (value) => f.toStr(value);
            return ft;
        }
        else {
            return null;
        }
    };
    const getDateFormatter = function (fmt) {
        let ft = number_formatters[fmt];
        if (ft) {
            return ft;
        }
        else if (fmt) {
            const f = DatetimeFormatter.getFormatter(fmt);
            date_formatters[fmt] = ft = (value) => f.toStr(value);
            return ft;
        }
        else {
            return null;
        }
    };
    /**
     * 사용자가 데이터행을 탭했을 때 실행될 일.
     * <br>
     * {@link DListRow.clickAction} 속성으로 사용된다. 또, {@link DListRow}는 {@link DListOptions.row} 속성으로 설정한다.
     *
     * @see concepts.data_row 데이터행 개요
     */
    var DListRowClickAction;
    (function (DListRowClickAction) {
        /**
         * 별다른 action 없이 컨트롤의{@link DListControl.onRowClick onRowClick} 이벤트만 발생한다.
         */
        DListRowClickAction["NONE"] = "none";
        // /**
        //  * @deprecated
        //  * {@link DListControl.rowFocusable}이 true이면 무조건 focusing한다 !
        //  *
        //  * {@link DListControl.rowFocusable}이 true이면 클릭한 행을 포커스행으로 지정한다.
        //  */
        // FOUCS = 'focus',
        // /**
        //  * @next 1.1
        //  * 기존 선택을 지우고 클릭된 행을 선택한다.
        //  */
        // SELECT = 'select',
        /**
         * 데이터행의 {@link DListControl.isRowChecked checked} 상태를 뒤바꾼다.
         * {@link DListControl.checkRow} 호출로 직접 상태를 변경할 수도 있다.
         */
        DListRowClickAction["CHECK"] = "check";
        /**
         * 데이터행 {@link concepts.command_box 커맨드 상자}를 표시한다.
         */
        DListRowClickAction["COMMAND"] = "command";
        /**
         * {@link DListDataLinkView}로 {@link DListControl.data}가 설정된 컨트롤에서
         * master 행인 경우 접힌 상태면 펼치고, 펼쳐진 상태면 접는다.
         *
         * @see concepts.data_grouping 데이터 그룹핑
         */
        DListRowClickAction["EXPAND"] = "expand";
        /**
         * 데이터행 템플릿에 '**detailed**'가 포함된 경우 기존 데이터행 대신 detailed 템플릿으로 구성된 내용이 표시된다.
         * <br>
         * '**detailed**'가 설정되지 않고 '**extra**'가 포함되면 기존 데이터행 아래 '**extra**' 내용이 추가된다.
         *
         * @see concepts.layouts 레이아웃 개요
         * @see concepts.templates 템플릿 개요
         */
        DListRowClickAction["DETAIL"] = "detail";
        /**
         * {@link DETAIL}과 동일하다.
         * <br>
         * 다만, 데이터행 하나만 '**detailed**'로 표시될 수 있다.
         * 즉, 새 행이 클릭되면 기존 detailed 행은 기본 행으로 복귀된다.
         */
        DListRowClickAction["DETAILEX"] = "detailex";
        /**
         * {@link concepts.info_page Info 페이지}를 표시한다.
         * <br>
         * {@link DListControl.showInfoPage} 호출로 직접 표시할 수도 있다.
         */
        DListRowClickAction["INFO"] = "info";
        /**
         * {@link concepts.edit_page Edit 페이지}를 표시한다.
         * <br>
         * {@link DListControl.showEditPage} 호출로 직접 표시할 수도 있다.
         */
        DListRowClickAction["EDIT"] = "edit";
        /**
         * {@link DListRow.link} 설정 정보에 따라 다른 페이지로 이동한다.
         */
        DListRowClickAction["LINK"] = "link";
        /**
         * 데이터행을 이동 시킨다. longPress일 때만 가능.
         */
        DListRowClickAction["MOVE"] = "move";
    })(DListRowClickAction || (DListRowClickAction = {}));
    var DListOverScrollEffect;
    (function (DListOverScrollEffect) {
        DListOverScrollEffect["NONE"] = "none";
        DListOverScrollEffect["BALLOON"] = "balloon";
        DListOverScrollEffect["BOUNCE"] = "bounce"; // 튕겨나옴
    })(DListOverScrollEffect || (DListOverScrollEffect = {}));
    /**
     * 데이터행을 swipe 제스처로 드래그했을 때 실행되는 action.
     * <br>
     * {@link DListRow.swipteAction} 속성으로 지정한다.
     *
     * @see concepts.data_row 데이터행 개요
     */
    var DListRowSwipeAction;
    (function (DListRowSwipeAction) {
        /**
         * 아무것도 하지 않는다.
         */
        DListRowSwipeAction["NONE"] = "none";
        /**
         * 등록된 데이터행 관련 command 목록이 표시된 {@link concepts.command_box command 상자}를 표시한다.
         */
        DListRowSwipeAction["COMMAND"] = "command";
        /**
         * {@link concepts.paging 페이징} 상태일 경우 페이지를 이동한다.
         */
        DListRowSwipeAction["PAGE"] = "page";
        /**
         * Tap한 것과 동일하게 처리한다.
         */
        DListRowSwipeAction["TAP"] = "tap";
        /**
         * {@link concepts.info_page Info Page}를 표시한다.
         */
        DListRowSwipeAction["INFO"] = "info";
        /**
         * 수정 가능한 경우 {@link concepts.edit_page Edit Page}를 표시한다.
         */
        DListRowSwipeAction["EDIT"] = "edit";
        /**
         * {@link concepts.row_bar Row Bar}가 감춰진 상태면 표시하고, 표시된 상태면 감춘다.
         */
        DListRowSwipeAction["ROW_BAR"] = "rowBar";
        /**
         * {@link concepts.edit_bar Edit Bar}가 감춰진 상태면 표시하고, 표시된 상태면 감춘다.
         */
        DListRowSwipeAction["EDIT_BAR"] = "editBar";
    })(DListRowSwipeAction || (DListRowSwipeAction = {}));
    var DRowChangeDirection;
    (function (DRowChangeDirection) {
        DRowChangeDirection["DEFAULT"] = "default";
        DRowChangeDirection["HORIZONTAL"] = "horizontal";
        DRowChangeDirection["VERTICAL"] = "vertical";
        DRowChangeDirection["BOTH"] = "both";
    })(DRowChangeDirection || (DRowChangeDirection = {}));
    var DListPanelType;
    (function (DListPanelType) {
        DListPanelType["FORM"] = "form";
        DListPanelType["BUTTON"] = "button";
        DListPanelType["SEARCH"] = "search";
    })(DListPanelType || (DListPanelType = {}));
    /**
     * {@link ILstButtonModel 버튼 view}나 {@link IListButtonRenderer 버튼 렌더러}에 버튼과 같이 표시되는 label의 표시 위치.
     * <br>
     *
     * ```
     *  list.setConfig({
     *      options: {
     *          header: {
     *              buttons: [{
     *                  label: 'HOME',
     *                  labelPosition: 'bottom',
     *                  onClick: args => {
     *                      location.href = './index.tml';
     *                  }
     *              }]
     *          }
     *      }
     *  });
     * ```
     *
     * @see IListButtonModel.labelPosition
     * @see IListButtonRenderer.labelPosition
     */
    var DListButtonLabelPosition;
    (function (DListButtonLabelPosition) {
        /**
         * label을 표시하지 않는다.
         * <br>
         */
        DListButtonLabelPosition["NONE"] = "none";
        /**
         * 버튼 왼쪽에 표시한다.
         * <br>
         */
        DListButtonLabelPosition["LEFT"] = "left";
        /**
         * 버튼 오른쪽에 표시한다.
         * <br>
         */
        DListButtonLabelPosition["RIGHT"] = "right";
        /**
         * 버튼 위쪽에 표시한다.
         * <br>
         */
        DListButtonLabelPosition["TOP"] = "top";
        /**
         * 버튼 아래쪽에 표시한다.
         * <br>
         */
        DListButtonLabelPosition["BOTTOM"] = "bottom";
    })(DListButtonLabelPosition || (DListButtonLabelPosition = {}));
    var DListBarPosition;
    (function (DListBarPosition) {
        /**
         * List header 다음에 표시.
         */
        DListBarPosition["AFTER"] = "after";
        /**
         * List header 이 전에 표시.
         */
        DListBarPosition["BEFORE"] = "before";
    })(DListBarPosition || (DListBarPosition = {}));
    class DWrappableOptions extends DWrappableObject {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(owner, defaults) {
            super();
            this._owner = owner;
            this._defs = defaults || void 0; // null로 설정하면 안된다. pickNum3() 등에서 void 0으로 간주한다.
            !defaults && this._doInitDefaults();
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        owner() {
            return this._owner;
        }
        _changed() {
            this._owner && this._owner.optionItemChanged(this);
        }
    }
    /**
     * Swipe 등의 액션이나 api 호출로 view의 위치를 변경시킬 때,
     * view의 이동 방향.
     * <br>
     *
     * @see concepts.single_row Single Row
     */
    var DListSlideDirection;
    (function (DListSlideDirection) {
        /**
         * View 상태에 따라 결정되는 기본 방향 값.
         */
        DListSlideDirection["DEFAULT"] = "default";
        /**
         * 실행 시점에 임의 방향으로 진행.
         */
        DListSlideDirection["RANDOM"] = "random";
        /**
         * 오른쪽에서 왼쪽으로 진행.
         */
        DListSlideDirection["LEFT"] = "left";
        /**
         * 왼쪽에서 오른쪽으로 진행.
         */
        DListSlideDirection["RIGHT"] = "right";
        /**
         * 아래에서 위로 진행.
         */
        DListSlideDirection["UP"] = "up";
        /**
         * 위에서 아래로 진행.
         */
        DListSlideDirection["DOWN"] = "down";
    })(DListSlideDirection || (DListSlideDirection = {}));
    var DControlRole;
    (function (DControlRole) {
        DControlRole["GRID"] = "grid";
        DControlRole["LIST"] = "list";
        DControlRole["MENU"] = "menu";
    })(DControlRole || (DControlRole = {}));
    var GroupIndentMode;
    (function (GroupIndentMode) {
        /**
         * 데이터행이나 그룹 헤더의 컨텐트를 들여쓰기한다.
         */
        GroupIndentMode["ROW"] = "row";
        /**
         * 데이터행인 그룹 헤더 자체를 밀어서 들어쓰기한다.
         */
        GroupIndentMode["BODY"] = "body";
    })(GroupIndentMode || (GroupIndentMode = {}));
    var DListRowIndents;
    (function (DListRowIndents) {
        /**
         * 들여쓰기 하지 않는다.
         * Grouping 되지 않을 때와 동일히게 표시한다.
         */
        DListRowIndents["NONE"] = "none";
        /**
         * 부모 행(그룹 헤더 혹은 Master 행)의 들여쓰기와 맞춘다.
         */
        DListRowIndents["PARENT"] = "parent";
        /**
         * 그룹 헤더보다 더 들여쓴다.
         */
        DListRowIndents["INNER"] = "inner";
    })(DListRowIndents || (DListRowIndents = {}));

    ////////////////////////////////////////////////////////////////////////////////
    // Dom.ts
    // 2022. 01. 27. created by dataludi
    // -----------------------------------------------------------------------------
    // Copyright (c) 2021-2022 DataLudi Inc.
    // All rights reserved.
    ////////////////////////////////////////////////////////////////////////////////
    let _dom_id_ = 651212;
    const BORDER_SIDES = {
        't': 'borderTop',
        'b': 'borderBottom',
        'l': 'borderLeft',
        'r': 'borderRight'
    };
    /**
     * @internal
     *
     * Utilities for HTML element.
     */
    class Dom {
        static getWin(doc) {
            return doc.defaultView || doc['parentWindow'];
        }
        static isVisible(elt) {
            return elt && elt.style.display !== 'none';
        }
        static setVisible(elt, visible, visibleStyle = '') {
            elt.style.display = visible ? (visibleStyle || '') : 'none';
            return visible;
        }
        static hide(elt) {
            elt.style.display = 'none';
        }
        static show(elt, visibleStyle = '') {
            elt.style.display = visibleStyle;
        }
        static addClass(elt, className) {
            className && elt.classList.add(className);
        }
        static getImageUrl(css) {
            const url = css.backgroundImage;
            if (url && url.startsWith('url("')) {
                return url.substring(5, url.length - 2);
            }
        }
        static getFocused() {
            const sel = document.getSelection();
            let node = sel.focusNode;
            while (node) {
                if (node instanceof HTMLElement)
                    return node;
                node = node.parentElement;
            }
        }
        static isAncestorOf(elt, child) {
            let p = child;
            while (p) {
                if (p == elt) {
                    return true;
                }
                p = p.parentElement;
            }
            return false;
        }
        static getOffset(elt) {
            const doc = elt.ownerDocument;
            const win = doc.defaultView;
            const box = elt.getBoundingClientRect();
            const body = doc.body;
            const docElem = doc.documentElement;
            const scrollTop = win.pageYOffset || docElem.scrollTop || body.scrollTop;
            const scrollLeft = win.pageXOffset || docElem.scrollLeft || body.scrollLeft;
            const clientTop = docElem.clientTop || body.clientTop || 0;
            const clientLeft = docElem.clientLeft || body.clientLeft || 0;
            const x = box.left + scrollLeft - clientLeft;
            const y = box.top + scrollTop - clientTop;
            return { x: Math.round(x), y: Math.round(y) };
        }
        static getSize(elt) {
            const r = elt.getBoundingClientRect();
            return { width: r.width, height: r.height };
        }
        static moveX(elt, x) {
            elt.style.left = x + 'px';
        }
        static moveY(elt, y) {
            elt.style.top = y + 'px';
        }
        static move(elt, x, y) {
            elt.style.left = x + 'px';
            elt.style.top = y + 'px';
        }
        static moveI(elt, x, y) {
            elt.style.left = (x >>> 0) + 'px';
            elt.style.top = (y >>> 0) + 'px';
        }
        static resize(elt, width, height) {
            elt.style.width = width + 'px';
            elt.style.height = height + 'px';
        }
        static resizeSVG(elt, width, height) {
            elt.setAttribute('viewBox', `0 0 ${width} ${height}`);
        }
        static setWidth(elt, width) {
            elt.style.width = width + 'px';
        }
        static setHeight(elt, height) {
            elt.style.height = height + 'px';
        }
        static getBrowserSize(elt) {
            const doc = elt ? elt.ownerDocument : document;
            const win = doc.defaultView;
            return {
                // width: _win.innerWidth || _doc.documentElement.clientWidth || _doc.body.clientWidth,
                // height: _win.innerHeight || _doc.documentElement.clientHeight || _doc.body.clientHeight
                width: win.innerWidth || doc.documentElement.clientWidth || doc.body.clientWidth,
                height: win.innerHeight || doc.documentElement.clientHeight || doc.body.clientHeight
            };
        }
        static setRect(elt, r) {
            const style = elt.style;
            style.left = r.x + 'px';
            style.top = r.y + 'px';
            style.width = r.width + 'px';
            style.height = r.height + 'px';
        }
        static setBounds(elt, x, y, w, h) {
            const style = elt.style;
            style.left = x + 'px';
            style.top = y + 'px';
            style.width = w + 'px';
            style.height = h + 'px';
        }
        static setBoundsEx(elt, x, y, w, h) {
            const style = elt.style;
            !isNaN(x) && (style.left = x + 'px');
            !isNaN(y) && (style.top = y + 'px');
            !isNaN(x) && (style.width = w + 'px');
            !isNaN(x) && (style.height = h + 'px');
        }
        static getClientRect(elt) {
            const r = elt.getBoundingClientRect();
            r["cx"] = elt.offsetLeft;
            r["cy"] = elt.offsetTop;
            return r;
        }
        static getChildIndex(elt) {
            if (elt) {
                const parent = elt.parentNode;
                if (parent) {
                    const childs = parent.children;
                    for (let i = childs.length; i--;) {
                        if (childs[i] === elt) {
                            return i;
                        }
                    }
                }
            }
            return -1;
        }
        static clearChildren(parent) {
            let elt;
            while (elt = parent.lastChild) {
                parent.removeChild(elt);
            }
        }
        static clearElements(parent) {
            let elt;
            while (elt = parent.lastChild) {
                Dom.clearElements(elt);
                parent.removeChild(elt);
            }
        }
        static append(elt, child) {
            child.parentNode !== elt && elt.appendChild(child);
        }
        static addChild(elt, child) {
            if (elt && child && child.parentNode !== elt) {
                elt.appendChild(child);
                return true;
            }
            return false;
        }
        static removeChild(elt, child) {
            if (elt && child && child.parentNode === elt) {
                elt.removeChild(child);
                return true;
            }
            return false;
        }
        static removeChildren(elt, children) {
            children.forEach(child => {
                if (child instanceof Element) {
                    if (child.parentNode === elt) {
                        elt.removeChild(child);
                    }
                }
                else if (child && child.dom().parentNode == elt) {
                    elt.removeChild(child.dom());
                }
            });
        }
        static remove(elt) {
            const p = elt && elt.parentElement;
            p && p.removeChild(elt);
            return null;
        }
        static clearStyle(elt) {
            elt.style.cssText = '';
        }
        static setStyle(elt, style) {
            style && Object.assign(elt.style, style);
        }
        static resetClassList(svg, className) {
            const list = svg.classList;
            while (list.length > 0) {
                list.remove(list.item(0));
            }
            className && list.add(className);
        }
        static createElement(doc, tagName, style) {
            const elt = doc.createElement(tagName);
            style && Object.assign(elt.style, style);
            return elt;
        }
        static htmlEncode(text) {
            return document.createElement('a').appendChild(document.createTextNode(text)).parentNode["innerHTML"];
        }
        static setData(elt, name, value) {
            if (value == null || value === '') {
                delete elt.dataset[name];
            }
            else {
                elt.dataset[name] = value;
            }
        }
        static getData(elt, name) {
            return elt.dataset[name];
        }
        static hasData(elt, name) {
            return elt.dataset[name] !== void 0;
        }
        static animate(elt, prop, from, to, duration = 150, fill = 'none') {
            const frame1 = {};
            const frame2 = {};
            frame1[prop] = from;
            frame2[prop] = to;
            return elt.animate([
                frame1, frame2
            ], {
                duration: duration,
                fill: fill
            });
        }
        // static setAnimating(elt: HTMLElement, set: boolean) {
        //     elt.dataset.animating = set ? '1' : '0';
        // }
        // static isAnimating(elt: HTMLElement) {
        //     return elt.dataset.animating === '1';
        // }
        static setAttr(elt, attr, value) {
            if (value != null && value !== '') {
                elt.setAttribute(attr, value);
            }
            else {
                elt.removeAttribute(attr);
            }
        }
        static setAttrs(elt, attrs) {
            for (const attr in attrs) {
                elt.setAttribute(attr, attrs[attr]);
            }
        }
        static getDomId() {
            return '-dlist-' + _dom_id_++;
        }
        static createBR(doc, className) {
            const br = doc.createElement('br');
            br.className = className;
            return br;
        }
        static createSpan(doc, style) {
            const span = doc.createElement('span');
            style && Object.assign(span.style, style);
            return span;
        }
        static createCheckBox(doc, style) {
            const chk = doc.createElement('input');
            chk.type = 'checkbox';
            style && Object.assign(chk.style, style);
            return chk;
        }
        static createRadio(doc, style) {
            const chk = doc.createElement('input');
            chk.type = 'radio';
            style && Object.assign(chk.style, style);
            return chk;
        }
        static getPadding(dom) {
            const cs = getComputedStyle(dom);
            return {
                left: parseFloat(cs.paddingLeft) || 0,
                right: parseFloat(cs.paddingRight) || 0,
                top: parseFloat(cs.paddingTop) || 0,
                bottom: parseFloat(cs.paddingBottom) || 0
            };
        }
        static getPadding2(dom) {
            const cs = getComputedStyle(dom);
            return {
                left: parseFloat(cs.paddingLeft) || 0,
                right: parseFloat(cs.paddingRight) || 0,
                top: parseFloat(cs.paddingTop) || 0,
                bottom: parseFloat(cs.paddingBottom) || 0,
                borderLeft: parseFloat(cs.borderLeftWidth) || 0,
                borderRight: parseFloat(cs.borderRightWidth) || 0,
                borderTop: parseFloat(cs.borderTopWidth) || 0,
                borderBottom: parseFloat(cs.borderBottomWidth) || 0
            };
        }
        static stopAnimation(ani) {
            if (ani) {
                try {
                    ani.finish(); // cancel()?
                }
                catch (e) {
                    debugger;
                    console.error(e);
                }
            }
            return null;
        }
        static childByPath(dom, path) {
            let node = dom;
            if (path) {
                let i = 0;
                while (i < path.length) {
                    node = node.childNodes[path[i++]];
                }
            }
            return node;
        }
        static childByClass(parent, className) {
            return parent.getElementsByClassName(className)[0];
        }
        static setDisabled(dom, value) {
            this.setAttr(dom, 'disabled', value ? true : void 0);
        }
        static setImportantStyle(css, property, value) {
            css.setProperty(property, value, 'important');
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     *
     * Control base.
     */
    class DControl extends DWrappableObject {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(doc, container, className) {
            super();
            this._syncOrientation = true;
            this._syncScreenOrientation = false;
            this.longPressDelay = 1000;
            this._inited = false;
            this._testing = false;
            this._dirty = true;
            this._invalidElements = [];
            this._toAnimation = 0;
            this._invalidateLock = false;
            this._lockDirty = false;
            this._cssVars = {};
            this._screenOrientationChangeHandler = (event) => {
                this._screenOrientation = this.$_getScreenOrientation();
                this.$_checkOrientation();
            };
            this._windowResizeHandler = (event) => {
                this.$_checkOrientation();
                this._windowResized();
                this.doc().getElementById(DControl.currentInput);
                //elt && elt.focus();
                DControl.currentInput = null;
            };
            this._clickHandler = (event) => {
                // DElement['TESTING'] && console.log('> CLICK', event);
                this._doClick(event);
                this._tool.click(event);
            };
            this._touchStartHandler = (ev) => {
                // DLog.log('> TOUCHE START', ev);
                if (this._doTouchStart(ev) || this._tool.touchStart(ev)) {
                    ev.preventDefault();
                    // ev.stopImmediatePropagation();
                }
            };
            this.m = 0;
            this._touchMoveHandler = (ev) => {
                // DLog.log('> TOUCHE MOVE', this.m++);// ev);
                this._doTouchMove(ev);
                this._tool.touchMove(ev);
            };
            this._touchEndHandler = (ev) => {
                // DLog.log('> TOUCHE END', ev);
                this._doTouchEnd(ev);
                this._tool.touchEnd(ev);
            };
            this._touchCancelHandler = (ev) => {
                // DLog.log('> TOUCHE CANCEL', ev);
                this._doTouchCancel(ev);
                this._tool.touchCancel(ev);
            };
            this._touchLeaveHandler = (ev) => {
                // DLog.log('> TOUCHE LEAVE', ev);
                this._doTouchLeave(ev);
                this._tool.touchLeave(ev);
            };
            this._keyPressHandler = (ev) => {
                this._doKeyPress(ev);
                this._tool.keyPress(ev);
            };
            if (!doc && container instanceof HTMLDivElement) {
                doc = container.ownerDocument;
            }
            this.$_initControl(doc || document, container, className);
            this._resigterEventHandlers(this._dom);
            this._inited = true;
            this.invalidate(true);
        }
        _doDestory() {
            this._unresigterEventHandlers(this._dom);
            Dom.remove(this._dom);
            this._dom = null;
            this._container = null;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        isInited() {
            return this._inited;
        }
        isTesting() {
            return this._testing;
        }
        doc() {
            return this._dom.ownerDocument;
        }
        dom() {
            return this._dom;
        }
        width() {
            return this._container.offsetWidth;
        }
        height() {
            return this._container.offsetHeight;
        }
        activeTool() {
            return this._activeTool || this._tool;
        }
        setSctiveTool(value) {
            if (value !== this._activeTool) {
                this._activeTool = value;
                this._tool = value || this._defaultTool;
            }
        }
        /**
         * Control orientation
         * 이 속성을 통해 명시적으로 변경하거나, window 이벤트 핸들러를 캐치할 수 있는 경우 자동 설정된다.
         */
        orientation() {
            return this._orientation;
        }
        setOrientation(value) {
            if (value !== this._orientation) {
                this._orientation = value;
                this.$_orientationChanged(value);
            }
        }
        isPortrait() {
            return this._orientation !== DScreenOrientation.LANDSCAPE;
        }
        isLandscape() {
            return this._orientation === DScreenOrientation.LANDSCAPE;
        }
        /**
         * 컨트롤 크기가 변경될 때 orientation 속성을 자동 설정.
         */
        syncOrientation() {
            return this._syncOrientation;
        }
        setSyncOrientation(value) {
            this._syncOrientation = value;
        }
        /**
         * 장치 스크린 방향.
         */
        screenOrientation() {
            return this._screenOrientation;
        }
        /**
         * syncOrientation이 true일 때,
         * 컨트롤 크기와 상관 없이 단말기 방향에 맞춰 orientation 속성을 자동 설정.
         */
        syncScreenOrientation() {
            return this._syncScreenOrientation;
        }
        setScreenSyncOrientation(value) {
            this._syncScreenOrientation = value;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        addElement(elt) {
            elt && this._root.addChild(elt);
        }
        removeElement(elt) {
            this._root.removeChild(elt);
        }
        invalidate(force = false) {
            if (force || !this._invalidateLock && !this._dirty && this._inited) {
                this._dirty = true;
                if (!this._requestTimer && !this._testing) {
                    this.$_requestRender();
                }
            }
            else if (this._invalidateLock /* && !_lockDirty */) {
                this._lockDirty = true;
            }
        }
        invalidateLayout(force = false) {
            this.invalidate(force);
        }
        setLock() {
            this._invalidateLock = true;
        }
        releaseLock(validate = true) {
            if (this._invalidateLock) {
                this._invalidateLock = false;
            }
            // lock 중에 invalidate()가 호출됐었다면
            if (this._lockDirty && validate) {
                this.invalidate();
            }
            this._lockDirty = false;
        }
        lock(func) {
            this.setLock();
            try {
                func(this);
            }
            finally {
                this.releaseLock();
            }
        }
        elementOfDom(dom) {
            return this._root.childOfDom(dom);
        }
        getBounds() {
            return this._dom.getBoundingClientRect();
        }
        toElement(elt, x, y) {
            const r1 = this.getBounds();
            const r2 = elt.getClientRect();
            x -= r2.left - r1.left;
            y -= r2.top - r1.top;
            return { x, y };
        }
        setAnimation(to) {
            this._toAnimation = to || 0;
        }
        fling(distance, duration) {
        }
        getCssVar(name) {
            let v = this._cssVars[name];
            if (name in this._cssVars) {
                return this._cssVars[name];
            }
            else {
                v = getComputedStyle(this._root.dom).getPropertyValue(name);
                this._cssVars[name] = v;
            }
            return v;
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        _setTesting() {
            this._testing = true;
            DElement.TESTING = true;
        }
        _setSize(w, h) {
            if (!isNaN(w)) {
                this._container.style.width = w + 'px';
                // this._dom.style.width = isNaN(w) ? '100%' : w + 'px';
            }
            if (!isNaN(h)) {
                this._container.style.height = h + 'px';
                // this._dom.style.height = isNaN(h) ? '100%' : h + 'px';  // 왜 이렇게 했지?
            }
        }
        $_getScreenOrientation() {
            if (window.screen.orientation) {
                return window.screen.orientation.type.startsWith('landscape') ? DScreenOrientation.LANDSCAPE : DScreenOrientation.PORTRAIT;
            }
            else if ('orientation' in window) {
                return Math.abs(+window.orientation) === 90 ? DScreenOrientation.LANDSCAPE : DScreenOrientation.PORTRAIT;
            }
            else {
                return window.innerWidth > window.innerHeight ? DScreenOrientation.LANDSCAPE : DScreenOrientation.PORTRAIT;
            }
        }
        $_getOrientation() {
            return this._dom.clientWidth > this._dom.clientHeight ? DScreenOrientation.LANDSCAPE : DScreenOrientation.PORTRAIT;
        }
        $_checkOrientation() {
            if (this._syncOrientation) {
                if (this._syncScreenOrientation) {
                    this.setOrientation(this._screenOrientation);
                }
                else {
                    this.setOrientation(this.$_getOrientation());
                }
            }
        }
        $_addListener(node, event, handler) {
            node.addEventListener(event, handler);
        }
        _resigterEventHandlers(dom) {
            if (window.screen && window.screen.orientation) {
                window.screen.orientation.addEventListener('change', this._screenOrientationChangeHandler);
            }
            window.addEventListener('resize', this._windowResizeHandler);
            this.$_addListener(dom, "click", this._clickHandler);
            this.$_addListener(dom, "touchstart", this._touchStartHandler);
            this.$_addListener(dom, "touchmove", this._touchMoveHandler);
            this.$_addListener(dom, "touchend", this._touchEndHandler);
            this.$_addListener(dom, "touchcancel", this._touchCancelHandler);
            this.$_addListener(dom, "touchleave", this._touchLeaveHandler);
            this.$_addListener(dom, "keypress", this._keyPressHandler);
        }
        _unresigterEventHandlers(dom) {
            if (window.screen && window.screen.orientation) {
                window.screen.orientation.removeEventListener('change', this._screenOrientationChangeHandler);
            }
            window.removeEventListener('resize', this._windowResizeHandler);
            dom.removeEventListener('click', this._clickHandler);
            dom.removeEventListener('touchstart', this._touchStartHandler);
            dom.removeEventListener('touchmove', this._touchMoveHandler);
            dom.removeEventListener('touchend', this._touchEndHandler);
            dom.removeEventListener('touchcancel', this._touchCancelHandler);
            dom.removeEventListener('touchleave', this._touchLeaveHandler);
            dom.removeEventListener('keypress', this._keyPressHandler);
        }
        $_orientationChanged(orientation) {
            this._doOrientationChanged(orientation);
            const cb = this.onOrientationChanged;
            cb && cb(orientation);
        }
        _doOrientationChanged(orientation) { }
        // container div의 'dlist-renderers' 자식들을 사용할 수 있도록 한다.
        _prepareRenderers(dom) {
        }
        $_initControl(document, container, className) {
            if (this._inited)
                return;
            if (container instanceof HTMLDivElement) {
                this._container = container;
            }
            else {
                this._container = document.getElementById(container);
            }
            if (!(this._container instanceof HTMLDivElement)) {
                throwFormat(locale.invalidOuterDiv, container);
            }
            // container div의 자식들을 사용할 수 있도록 한다.
            const renderers = this._container.getElementsByClassName('dlist-renderers')[0];
            if (renderers) {
                this._prepareRenderers(renderers);
                renderers.remove();
            }
            const dom = this._dom = document.createElement('div');
            Object.assign(dom.style, {
                position: 'relative',
                width: '100%',
                height: '100%',
                boxSizing: 'border-box',
                overflow: 'hidden',
            });
            dom.className = className;
            this._container.appendChild(dom);
            this._screenOrientation = this.$_getScreenOrientation();
            this._orientation = this.$_getOrientation();
            this._root = new RootElement(document, this);
            dom.appendChild(this._root['_dom']);
            this._defaultTool = this._tool = this._creatDefaultTool();
            this._doInitModel();
            this._doInitView(document);
            if (DElement.ANIMATABLE === void 0) {
                const ani = dom.animate && dom.animate([
                    { left: 0 }, { left: 0 }
                ], {
                    duration: 0,
                    fill: 'none'
                });
                DElement.ANIMATABLE = !!ani;
            }
        }
        _render() {
            this.$_render();
        }
        $_invalidateElement(elt) {
            this._invalidElements.push(elt);
            this.invalidate();
        }
        $_requestRender() {
            if (window.requestAnimationFrame) {
                this._requestTimer = requestAnimationFrame(() => this.$_render());
            }
            else {
                setTimeout(() => {
                    this.$_render();
                }, 0);
            }
        }
        updateNow() {
            this.$_render();
        }
        $_render() {
            const t = +new Date();
            // animation 중이면 종료 후에 다시 그리도록 한다.
            if (t <= this._toAnimation) {
                this.$_requestRender();
                return;
            }
            try {
                this._doBeforeRender();
                const w = this._dom.clientWidth;
                const h = this._dom.clientHeight;
                this._doRender({ x: 0, y: 0, width: w, height: h });
            }
            finally {
                this._dirty = false;
                this._requestTimer = null;
                this._invalidElements.forEach(elt => elt.validate());
                this._invalidElements = [];
                this._doAfterRender();
            }
            DLog.log('render in ' + (+new Date() - t) + 'ms.');
        }
        _doBeforeRender() { }
        _doAfterRender() { }
        _doControlObjectChanged(obj, tag) { }
        //-------------------------------------------------------------------------
        // event handlers
        //-------------------------------------------------------------------------
        _doClick(event) { }
        _doTouchStart(event) {
            return false;
        }
        _doTouchMove(event) { }
        _doTouchEnd(event) { }
        _doTouchCancel(event) { }
        _doTouchLeave(event) { }
        _doKeyPress(event) { }
        _windowResized() {
            this.invalidateLayout();
        }
    }
    /**
     * @internal
     *
     * DContainer 구성 요소.
     */
    class DElement extends DObject {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(doc, contentable, className, tag = 'div') {
            super();
            //-------------------------------------------------------------------------
            // static members
            //-------------------------------------------------------------------------
            //-------------------------------------------------------------------------
            // property fields
            //-------------------------------------------------------------------------
            this._visible = true;
            this._dirty = false;
            const dom = this._dom = doc.createElement(tag);
            if (className) {
                dom.className = className;
            }
            Object.assign(dom.style, {
                display: this._getDisplayStyle(),
                position: this._getPositionStyle(),
                boxSizing: 'border-box',
                overflow: this._getOverflow()
            });
            if (contentable) {
                dom.appendChild(this._content = doc.createElement('div'));
                this._content.className = 'dlist-view-content';
                this._content.style.position = this._getContentPosition();
            }
            this._doInitDom(doc, dom);
            this._content && this._doInitContent(doc, this._content);
        }
        _doDestory() {
            this._dom = null;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        get doc() {
            return this._dom.ownerDocument;
        }
        get win() {
            const doc = this._dom.ownerDocument;
            return doc.defaultView || doc['parentWindow'];
        }
        get dom() {
            return this._dom;
        }
        get content() {
            return this._content;
        }
        get parent() {
            return this._parent;
        }
        get childCount() {
            return this._children ? this._children.length : 0;
        }
        get control() {
            return this._parent && this._parent.control;
        }
        /**
         * move())를 통해 설정된 x 좌표.
         */
        get x() {
            return this._x;
        }
        right() {
            return this._x + this._width;
        }
        /**
         * move())를 통해 설정된 y 좌표.
         */
        get y() {
            return this._y;
        }
        bottom() {
            return this._y + this._height;
        }
        /**
         * resize()를 통해 설정된 너비.
         */
        get width() {
            return this._width;
        }
        /**
         * resize()를 통해 설정된 높이.
         */
        get height() {
            return this._height;
        }
        /**
         * visible
         */
        get visible() {
            return this._visible;
        }
        set visible(value) {
            if (value !== this._visible) {
                this._visible = value;
                if (this._dom) {
                    this._dom.style.display = this._visible ? this._getDisplayStyle() : 'none';
                }
                this._changed();
            }
        }
        setVisible(value) {
            if (value !== this._visible) {
                this._visible = value;
                if (this._dom) {
                    this._dom.style.display = this._visible ? this._getDisplayStyle() : 'none';
                }
                this._changed();
            }
            return this._visible;
        }
        _internalVisible(visible) {
            this._visible = visible;
            this._dom.style.display = this._visible ? this._getDisplayStyle() : 'none';
            return visible;
        }
        canAnimate() {
            return DElement.ANIMATABLE && Element.prototype.animate !== void 0;
        }
        setAnimating(value) {
            this._dom.dataset.animating = value ? '1' : '0';
        }
        animating() {
            return this._dom.dataset.animating === '1';
        }
        /**
         * hidden
         */
        get hidden() {
            return this._dom.style.visibility === 'hidden';
        }
        set hidden(value) {
            this._dom.style.visibility = value ? 'hidden' : 'visible';
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        setStyles(style) {
            Object.assign(this._dom.style, style);
            return this;
        }
        getClientSize() {
            return {
                width: this._dom.clientWidth,
                height: this._dom.clientHeight
            };
        }
        getOffsetSize() {
            return {
                width: this._dom.offsetWidth,
                height: this._dom.offsetHeight
            };
        }
        getOffsetBounds() {
            return {
                x: this._dom.offsetLeft,
                y: this._dom.offsetTop,
                width: this._dom.offsetWidth,
                height: this._dom.offsetHeight
            };
        }
        getClientRect() {
            return this._dom.getBoundingClientRect();
        }
        getBounds() {
            return {
                x: this._x,
                y: this._y,
                width: this._width,
                height: this._height
            };
        }
        validate() {
            this._dirty = false;
        }
        getLabel() {
            return;
        }
        getChildren() {
            return this._children && this._children.slice(0);
        }
        getChild(index) {
            return this._children && this._children[index];
        }
        indexOf(child) {
            return this._children ? this._children.indexOf(child) : -1;
        }
        contains(elt, deep = false) {
            const childs = this._children;
            if (childs) {
                if (childs.indexOf(elt) >= 0) {
                    return true;
                }
                if (deep) {
                    for (const v of childs) {
                        const c = v.contains(elt, true);
                        if (c)
                            return true;
                    }
                }
            }
        }
        insertChild(at, child) {
            if (child && !this.contains(child)) {
                if (child._parent) {
                    child._parent.removeChild(child);
                }
                if (!this._children) {
                    this._children = [];
                }
                const elts = this._children;
                const dom = this._content || this._dom;
                const label = child.getLabel();
                if (at < 0 || at >= elts.length) {
                    label && dom.appendChild(label);
                    dom.appendChild(child._dom);
                    elts.push(child);
                }
                else {
                    dom.insertBefore(child._dom, elts[at]._dom);
                    label && dom.insertBefore(label, child._dom);
                    elts.splice(at, 0, child);
                }
                child._parent = this;
                child.$_attached();
                this._changed();
            }
        }
        insertBefore(child, before) {
            this.insertChild(this.indexOf(before), child);
        }
        /**
         * 자식 목록의 마지막에 추가한다.
         * @param {DElement} child 추가할 자식 {@link DElement}.
         */
        addChild(child) {
            this.insertChild(-1, child);
        }
        remove() {
            this._parent && this._parent.removeChild(this);
        }
        /**
         * 지정한 위치에 존재하는 자식 {@link DElement element}를 제거한다.
         * @param {number} at 제거할 자식의 위치.
         * @returns {DElement} 삭제된 element.
         */
        removeChildAt(at) {
            if (this._children && at >= 0 && at < this._children.length) {
                const child = this._children[at];
                const label = child.getLabel();
                label && (this._content || this._dom).removeChild(label);
                (this._content || this._dom).removeChild(child._dom);
                this._children.splice(at, 1);
                this.$_removeChild(child);
                this._changed();
                return child;
            }
        }
        /**
         * 지정한 자식 {@link DElement element}를 제거한다.
         * @param {DElement} child 제거할 자식 {@link DElement element}
         * @returns {DElement} 삭제된 element.
         */
        removeChild(child) {
            return this.removeChildAt(this.indexOf(child));
        }
        removeLast() {
            const elts = this._children;
            return elts && this.removeChildAt(elts.length - 1);
        }
        clear() {
            const elts = this._children;
            if (elts && elts.length > 0) {
                for (let child of elts) {
                    this.$_removeChild(child);
                }
                this._children = [];
                const dom = this._content || this._dom;
                let node;
                while (node = dom.lastChild) {
                    dom.removeChild(node);
                }
                this._changed();
                return true;
            }
            return false;
        }
        moveIndex(child, newIndex) {
            const elts = this._children;
            const idx = elts.indexOf(child);
            newIndex = Math.max(0, Math.min(elts.length - 1));
            if (idx >= 0 && idx !== newIndex) {
                const dom = elts[idx]._dom;
                elts.splice(idx, 1);
                elts.splice(newIndex, 0, child);
                this._dom.insertBefore(dom, child._dom);
                this._changed();
                return true;
            }
        }
        isDom(dom) {
            return this._dom === dom || (this._content && this._content === dom);
        }
        containsDom(dom) {
            return (this._content || this._dom).contains(dom);
        }
        isView(dom) {
            return this.isDom(dom) || this.containsDom(dom);
        }
        containsClass(className) {
            return (this._content || this._dom).classList.contains(className);
        }
        domByClass(className, text) {
            const elts = this._dom.getElementsByClassName(className);
            const n = elts ? elts.length : 0;
            if (n > 0) {
                if (text) {
                    for (let i = 0; i < n; i++) {
                        const elt = elts[i];
                        if (Array.isArray(text)) {
                            if (text.indexOf(elt.textContent) >= 0) {
                                return elt;
                            }
                        }
                        else if (elt.textContent === text) {
                            return elt;
                        }
                    }
                }
                else {
                    return elts[0];
                }
            }
        }
        childOfDom(dom) {
            const elts = this._children;
            if (elts && elts.length > 0) {
                for (const elt of elts) {
                    if (elt.isDom(dom)) {
                        return elt;
                    }
                    const elt2 = elt.childOfDom(dom);
                    if (elt2)
                        return elt2;
                }
            }
            return;
        }
        hasData(name) {
            return !!this._dom.dataset[name];
        }
        setData(name, value) {
            if (value == null || value === '') {
                delete this._dom.dataset[name];
            }
            else {
                this._dom.dataset[name] = value;
            }
        }
        setBounds(x, y, width, height) {
            return this.move(x, y).resize(width, height);
        }
        setRect(r) {
            return this.move(r.x, r.y).resize(r.width, r.height);
        }
        moveX(x) {
            if (isNaN(x)) {
                this._x = x;
                this._dom.style.left = '';
            }
            else if (x != this._x) {
                this._x = x;
                this._dom.style.left = x + 'px';
            }
            return this;
        }
        moveY(y) {
            if (isNaN(y)) {
                this._y = y;
                this._dom.style.top = '';
            }
            else if (y !== this._y) {
                this._y = y;
                this._dom.style.top = y + 'px';
            }
            return this;
        }
        move(x, y) {
            return this.moveX(x).moveY(y);
        }
        center(width, height) {
            return this.moveX((width - this.width) / 2).moveY((height - this.height) / 2);
        }
        moveI(x, y) {
            // return this.moveX(x >>> 0).moveY(y >>> 0); >>> 연산자가 ios 옛 버전에서 문제?
            return this.moveX(x >> 0).moveY(y >> 0);
        }
        resetPosition() {
            if (isNaN(this._x)) {
                this._dom.style.left = this._x + 'px';
            }
            if (isNaN(this._y)) {
                this._dom.style.top = this._y + 'px';
            }
        }
        setWidth(width, unit = 'px') {
            if (width !== this._width) {
                this._width = width;
                this._dom.style.width = isNaN(width) ? '' : width + unit;
            }
            return this;
        }
        setHeight(height, unit = 'px') {
            if (height !== this._height) {
                this._height = height;
                this._dom.style.height = isNaN(height) ? '' : height + unit;
            }
            return this;
        }
        clearSize() {
            this._width = this._height = NaN;
            this._dom.style.width = '';
            this._dom.style.height = '';
        }
        resize(width, height, unit = 'px') {
            return this.setWidth(width, unit).setHeight(height, unit);
        }
        internalClearSize() {
            this._dom.style.width = '';
            this._dom.style.height = '';
        }
        internalResize(width, height) {
            this._dom.style.width = width + 'px';
            this._dom.style.height = height + 'px';
            return this;
        }
        syncSize() {
            this.resize(Math.ceil(this._dom.offsetWidth), Math.ceil(this._dom.offsetHeight));
        }
        resizeContent(width, height, unit = 'px') {
            this._content.style.width = isNaN(width) ? '' : width + unit;
            this._content.style.height = isNaN(height) ? '' : height + unit;
            return;
        }
        setContentBounds(x, y, w, h) {
            const css = this._content.style;
            css.left = x + 'px';
            css.top = y + 'px';
            css.width = w + 'px';
            css.height = h + 'px';
        }
        /**
         * 계산된 dom 크기를 참조할 수 있도록 필드에 저장한다.
         */
        saveSize() {
            this._width = this._dom.offsetWidth;
            this._height = this._dom.offsetHeight;
            return this;
        }
        forEach(callback) {
            const elts = this._children;
            if (elts) {
                for (let i = 0, n = elts.length; i < n; i++) {
                    callback(elts[i], i, n);
                }
            }
        }
        some(callback) {
            const elts = this._children;
            if (elts) {
                for (let i = 0, n = elts.length; i < n; i++) {
                    if (callback(elts[i], i, n) === true) {
                        break;
                    }
                }
            }
        }
        findChild(selector) {
            const elts = this._children;
            if (elts) {
                for (let i = 0, n = elts.length; i < n; i++) {
                    if (selector(elts[i], i, n) == true) {
                        return elts[i];
                    }
                }
            }
        }
        findDescendant(selector) {
            const elts = this._children;
            if (elts) {
                for (let i = 0, n = elts.length; i < n; i++) {
                    if (selector(elts[i]) == true) {
                        return elts[i];
                    }
                    const elt = elts[i].findDescendant(selector);
                    if (elt)
                        return elt;
                }
            }
        }
        findDescendants(selector, elements) {
            const childs = this._children;
            if (childs) {
                for (const elt of childs) {
                    if (selector(elt) == true) {
                        elements.push(elt);
                    }
                    elt.findDescendants(selector, elements);
                }
            }
        }
        applyStyle(style) {
            style && Object.assign(this._dom.style, style);
        }
        setImportantStyle(css, property, value) {
            css.setProperty(property, value, 'important');
            return this;
        }
        getComputedStyle() {
            return getComputedStyle(this._dom);
        }
        getPadding() {
            return Dom.getPadding(this._dom);
        }
        getPadding2() {
            return Dom.getPadding2(this._dom);
        }
        setPressed(value) {
            if (value) {
                this._dom.dataset.pressed = '1';
            }
            else {
                delete this._dom.dataset.pressed;
            }
        }
        appendSpan(doc, className) {
            const span = (doc || this.doc).createElement('span');
            this._dom.appendChild(span);
            className && (span.className = className);
            return span;
        }
        appendDom(dom) {
            this._dom.appendChild(dom);
            return dom;
        }
        removeDom(dom) {
            this._dom.removeChild(dom);
        }
        detachDom() {
            this._dom.remove();
        }
        createElement(tag) {
            return this._dom.ownerDocument.createElement(tag);
        }
        setClassName(clazz) {
            this._dom.className = clazz;
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        _testing() {
            return DElement.TESTING;
        }
        _doInitDom(doc, dom) { }
        _doInitContent(doc, div) { }
        _getPositionStyle() {
            return 'absolute';
        }
        _getDisplayStyle() {
            return 'block';
        }
        _getContentPosition() {
            return 'relative';
        }
        _getOverflow() {
            return '';
        }
        $_attached() {
            this._doAttached();
        }
        _doAttached() { }
        $_detached(oldParent) {
            this._doDetached(oldParent);
        }
        _doDetached(oldParent) { }
        $_removeChild(child) {
            child.validate();
            child._parent = null;
            child.$_detached(this);
        }
        _changed() {
            var _a;
            if (!this._dirty) {
                this._dirty = true;
                (_a = this.control) === null || _a === void 0 ? void 0 : _a['$_invalidateElement'](this);
            }
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    DElement.TESTING = false;
    DElement.BOUNDING = false;
    DElement.BOUNDING_BORDER = '1px solid #ff000080';
    DElement.BOUNDING_BORDER_2 = '1px solid #0000ff40';
    class LayerElement extends DElement {
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doInitDom(doc, dom) {
            dom.style.pointerEvents = 'none';
        }
    }
    class RootElement extends DElement {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(doc, control) {
            super(doc, false, 'dlist-root');
            this._control = control;
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        get control() {
            return this._control;
        }
    }
    class DControlObject extends DWrappableObject {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(control) {
            super();
            this._control = control;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        control() {
            return this._control;
        }
        //-------------------------------------------------------------------------
        // internal mehtods
        //-------------------------------------------------------------------------
        _changed(tag) {
            var _a;
            (_a = this._control) === null || _a === void 0 ? void 0 : _a['_doControlObjectChanged'](this, tag);
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * {@link DListGroupHeader 행 그룹 헤더}를 클릭했을 때 실행되는 action.
     *
     * @see DListGroupHeader.clickAction
     */
    var DListGroupClickAction;
    (function (DListGroupClickAction) {
        /**
         * 아무것도 하지 않는다.
         */
        DListGroupClickAction["NONE"] = "none";
        /**
         * 그룹을 펼치거나 접는다.
         */
        DListGroupClickAction["EXPAND"] = "expand";
        /**
         * TODO: 지정된 action을 실행한다.
         */
        DListGroupClickAction["COMMAND"] = "command";
    })(DListGroupClickAction || (DListGroupClickAction = {}));
    class Group extends DObject {
    }
    /**
     * @internal
     *
     * ListControl이 그룹된 상태일 때 하나의 그룹 헤더나 푸터 혹은 데이터행에 대한 모델.
     */
    class GroupItem {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(group) {
            this.index = -1;
            this.vindex = -1;
            this.group = group;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        row() {
            return -1;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        getParamValue(param) {
            return this.group.getParamValue(param);
        }
    }
    class GroupRow extends GroupItem {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(group, row) {
            super(group);
            this._row = row;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        isLeaf() {
            return true;
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        row() {
            return this._row;
        }
    }
    class GroupDecoItem extends GroupItem {
    }
    /** @internal */
    class GroupHeader extends GroupDecoItem {
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        getStyle() {
            var _a, _b;
            return {
                itemDef: this.group.model().header().style,
                levelDef: (_b = (_a = this.group.info) === null || _a === void 0 ? void 0 : _a.header) === null || _b === void 0 ? void 0 : _b.style
            };
        }
    }
    /** @internal */
    class GroupFooter extends GroupDecoItem {
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        getStyle() {
            var _a, _b;
            return {
                itemDef: this.group.model().footer().style,
                levelDef: (_b = (_a = this.group.info) === null || _a === void 0 ? void 0 : _a.footer) === null || _b === void 0 ? void 0 : _b.style
            };
        }
    }
    class GroupModel extends DEventProvider {
    }

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     *
     * DListOptions에서 사용.
     */
    class RowGroupHeader extends DWrappableObject {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(owner, defaults) {
            super();
            this._owner = owner;
            this._defs = defaults;
            if (!defaults) {
                this._visible = true;
                this._collapsedVisible = false;
                this._template = this._defTemplate();
                this._clickAction = DListGroupClickAction.EXPAND;
            }
        }
        _doDestory() {
            this._owner = this._defs = null;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * visible.
         */
        get visible() {
            return pickProp(this._visible, this._defs && this._defs._visible);
        }
        setVisible(value) {
            if (value !== this._visible) {
                this._visible = value;
                this._changed();
            }
        }
        /**
         * visible when collapsed.
         */
        get collapsedVisible() {
            return pickProp(this._collapsedVisible, this._defs && this._defs._collapsedVisible);
        }
        setCollapsedVisible(value) {
            if (value !== this._collapsedVisible) {
                this._collapsedVisible = value;
                this._changed();
            }
        }
        /**
         * template
         */
        get template() {
            return pickProp(this._template, this._defs && this._defs._template);
        }
        setTemplate(value) {
            if (value !== this._template) {
                this._template = value;
                this._changed();
            }
        }
        /**
         * click action
         */
        clickAction() {
            return pickProp(this._clickAction, this._defs && this._defs._clickAction);
        }
        setClickAction(value) {
            if (value !== this._clickAction) {
                this._clickAction = value;
                this._changed();
            }
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        _defTemplate() {
            return '@it_group_header';
        }
        _changed() {
            var _a;
            (_a = this._owner) === null || _a === void 0 ? void 0 : _a.groupSectionChanged(this);
        }
    }
    class RowGroupFooter extends RowGroupHeader {
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _defTemplate() {
            return '@it_group_footer';
        }
    }
    /**
     * @internal
     *
     * 그룹핑 정보 모델.<br>
     * 부모 그룹의 자식이면, 또한 자식 그룹들을 가질 수 있다.
     * 자식이 없는 leaf 그룹이면, 그 그룹 아래 {@link GroupItemType 그룹 아이템}들이 포함된다.
     * 리스트 컨트롤에 실제 표시되는 것은 {@link GroupHeader 헤더}, {@link GroupFooter 푸터},
     * {@link LGroupRow 데이터행} 등의 그룹 아이템들이다.
     */
    class RowGroup extends Group {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(parent, info, value, start, end) {
            super();
            //-------------------------------------------------------------------------
            // property fields
            //-------------------------------------------------------------------------
            this._expanded = true;
            this._checked = false;
            this._summary = {};
            this._parent = parent;
            this.info = info;
            this._value = value;
            // TODO: data 행/추가 시, 재사용할 경우 변경해줘야 한다.
            this._startRow = start;
            this._endRow = end;
        }
        _doDestory() {
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        level() {
            return this._parent.level() + 1;
        }
        parent() {
            return this._parent;
        }
        model() {
            return this._parent.model();
        }
        field() {
            return this.info.field;
        }
        headerInfo() {
            return this.info.header;
        }
        footerInfo() {
            return this.info.footer;
        }
        value() {
            return this._value;
        }
        startRow() {
            return this._startRow;
        }
        endRow() {
            return this._endRow;
        }
        rowCount() {
            return this._endRow - this._startRow + 1;
        }
        children() {
            var _a;
            return (_a = this._children) === null || _a === void 0 ? void 0 : _a.slice();
        }
        count() {
            return this._children ? this._children.length : 0;
        }
        isLeaf() {
            return !this._children || this._children.length === 0;
        }
        header() {
            return this._header;
        }
        footer() {
            return this._footer;
        }
        /**
         * expanded
         */
        expanded() {
            return this._expanded;
        }
        visible() {
            return this._parent._expanded && this._parent.visible();
        }
        /**
         * checked
         */
        checked() {
            return this._checked;
        }
        setChecked(value) {
            var _a;
            value = !!value;
            if (value != this._checked) {
                this._checked = value;
                (_a = this.model()) === null || _a === void 0 ? void 0 : _a.$_checkedChanged(this);
            }
        }
        firstVis() {
            return this._firstVis;
        }
        lastVis() {
            return this._lastVis;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        get(index) {
            return this._children[index];
        }
        getItems(recursive = false) {
            const model = this.model();
            if (model) {
                if (recursive) {
                    return model['_items'].slice(this._header.index, this._footer.index + 1);
                }
                else {
                    return model.getItemsOf(this);
                }
            }
        }
        getVisItems(recursive = false) {
            const model = this.model();
            if (model) {
                if (recursive) {
                    return model['_visItems'].slice(this._firstVis.vindex, this._lastVis.vindex + 1);
                }
                else {
                    return model.getVisItemsOf(this);
                }
            }
        }
        isLast(row) {
            return row === this._endRow;
        }
        clear() {
            this._children = null;
            this.$_clearSummary();
        }
        /**
         * callback에서 true를 리턴하면 중도 리턴.
         */
        visit(callback, recursive) {
            if (callback && this._children) {
                for (let child of this._children) {
                    if (callback(child) === true) {
                        return true;
                    }
                    if (recursive) {
                        const rslt = child.visit(callback, true);
                        if (rslt === true) {
                            return true;
                        }
                    }
                }
            }
        }
        /**
         * 모든 아이템들을 방문한다.
         * callback에서 명시적인 false를 리턴하면 loop가 중단된다.
         */
        visitItems(recursive, callback) {
            var _a;
            if (recursive) {
                (_a = this.model()) === null || _a === void 0 ? void 0 : _a.forEachVisItem(this._firstVis.index, this._lastVis.index, callback);
            }
        }
        /**
         * 펼쳐진 아이템들을 방문한다.
         * callback에서 명시적인 false를 리턴하면 loop가 중단된다.
         */
        visitVisItems(recursive, callback) {
            var _a;
            if (recursive) {
                (_a = this.model()) === null || _a === void 0 ? void 0 : _a.forEachVisItem(this._firstVis.vindex, this._lastVis.vindex, callback);
            }
        }
        getSummary(field) {
            let s = this._summary[field];
            if (!s) {
                this._summary[field] = s = this.model().data().getSummary(field, this._startRow, this._endRow);
            }
            return s;
        }
        getParamValue(param) {
            switch (param) {
                case 'group_field':
                    return this.field();
                case 'group_value':
                    return this.value();
                case 'group_level':
                    return this.level();
                case 'row_count':
                    return this.rowCount();
                case 'group_sum':
                    return this.value();
            }
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        $_add(g) {
            if (!this._children) {
                this._children = [];
            }
            this._children.push(g);
        }
        $_setExpanded(v) {
            if (v != this._expanded) {
                this._expanded = v;
                return true;
            }
        }
        $_clearSummary() {
            this._summary = {};
        }
    }
    /**
     * @internal
     *
     * 항상 expanded 상태이다.
     */
    class RootGroup$1 extends RowGroup {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(model) {
            super(null, null, null, 0, 0);
            this._model = model;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        level() { return -1; }
        model() { return this._model; }
        headerInfo() { return RootGroup$1.INFO; }
        footerInfo() { return RootGroup$1.INFO; }
        isLeaf() { return false; }
        expanded() { return true; }
        visible() { return true; }
        firstVis() { return this._model.firstVisItem(); }
        lastVis() { return this._model.lastVisItem(); }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    RootGroup$1.INFO = {
        visible: false,
        collapsedVisible: false
    };
    /**
     * @internal
     *
     * DList 컨트롤 그룹핑 모델.
     * 하나 이상의 계층을 가진다.
     * 계층 단위로 expand/collapse할 수 있다.
     */
    class RowGroupModel extends GroupModel {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor() {
            super();
            /**
             * 기본 그룹 header 설정. 각 group이나 컨트롤에 설정이 없으면 이 설정을 따른다.
             */
            this._header = {
                visible: true,
                collapsedVisible: true,
                template: RowGroupModel.HEADER_TEMPLATE,
                style: null
            };
            /**
             * 기본 그룹 footer 설정. 각 group이나 컨트롤에 설정이 없으면 이 설정을 따른다.
             */
            this._footer = {
                visible: true,
                collapsedVisible: false,
                template: RowGroupModel.FOOTER_TEMPLATE,
                style: null
            };
            this._levels = 0;
            this._descendants = 0;
            this._items = [];
            this._vitems = [];
            this._root = new RootGroup$1(this);
        }
        _doDestory() {
        }
        //-------------------------------------------------------------------------
        // IParamInflater
        //-------------------------------------------------------------------------
        inflateParam(target, field, param) {
            param.name;
            let v;
            return v;
        }
        inflateStock(target, field, param) {
            const item = target;
            const p = param.name;
            let v;
            v = item.getParamValue(p);
            // TODO:
            // DListControl.templateParams로 지정한 값.
            // Group header/footer 값.
            // field 이름이면 field값.
            return v;
        }
        //-------------------------------------------------------------------------
        // IListDataListener
        //-------------------------------------------------------------------------
        onDataReset(data) {
            this.$_refresh();
        }
        onDataValueUpdated(data, row, field, value, oldValue) {
            // TODO: 필요한 경우에만
            this.$_refresh();
        }
        onDataRowUpdated(data, row, oldValues) {
            // TODO: 필요한 경우에만
            this.$_refresh();
        }
        onDataRowsUpdated(data, rows) {
            // TODO: 필요한 경우에만
            this.$_refresh();
        }
        onDataRangeUpdated(data, row, count) {
            // TODO: 필요한 경우에만
            this.$_refresh();
        }
        onDataRowAdded(data, row) {
            // TODO: 필요한 경우에만
            this.$_refresh();
        }
        onDataRowsAdded(data, row, count) {
            // TODO: 필요한 경우에만
            this.$_refresh();
        }
        onDataCleared(data, oldCount) {
            // TODO: 필요한 경우에만
            this.$_refresh();
        }
        onDataRowDeleted(data, row) {
            // TODO: 필요한 경우에만
            this.$_refresh();
        }
        onDataRowsDeleted(data, rows) {
            // TODO: 필요한 경우에만
            this.$_refresh();
        }
        onDataRangeDeleted(data, row, count) {
            // TODO: 필요한 경우에만
            this.$_refresh();
        }
        // onDataCountChanged(data: IListDataView, newCount: number, oldCount: number): void {
        // }
        // onDataChanged(data: IListDataView): void {
        // }
        //-------------------------------------------------------------------------
        // IListDataViewListener
        //-------------------------------------------------------------------------
        onDataViewFilterChanged(dv) {
            this.$_refresh();
        }
        onDataViewSortChanged(dv) {
            this.$_refresh();
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * @internal
         */
        data() {
            return this._data;
        }
        root() {
            return this._root;
        }
        /**
         * header info.
         */
        header() {
            return Object.assign({}, this._header);
        }
        setHeader(value) {
            if (Utils.isObject(value)) {
                const header = this._header;
                if (Utils.assignProps(header, value)) {
                    this.$_resetVisibles();
                }
            }
        }
        /**
         * footer info.
         */
        footer() {
            return Object.assign({}, this._footer);
        }
        setFooter(value) {
            if (Utils.isObject(value)) {
                this._footer;
                if (Utils.assignProps(this._footer, value)) {
                    this.$_resetVisibles();
                }
            }
        }
        levels() {
            return this._levels;
        }
        groupCount() {
            return this._root.count();
        }
        descendants() {
            return this._descendants;
        }
        leafRowCount() {
            return;
        }
        itemCount() {
            return this._items.length;
        }
        visItemCount() {
            return this._vitems.length;
        }
        firstVisItem() {
            return this._vitems[0];
        }
        lastVisItem() {
            return this._vitems[this._vitems.length - 1];
        }
        firstVisRow() {
            for (let item of this._vitems) {
                if (item instanceof GroupRow) {
                    return item;
                }
            }
        }
        lastVisRow() {
            for (let i = this._vitems.length - 1; i >= 0; i--) {
                if (this._vitems[i] instanceof GroupRow) {
                    return this._vitems[i];
                }
            }
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        getGroup(index) {
            return this._root.get(index);
        }
        /**
         * @param level 최상위 그룹이 0.
         * @returns 그룹아이템 개수.
         */
        getLevelGroupCount(level) {
            let cnt = 0;
            if (level === 0) {
                cnt = this._root.count();
            }
            else if (level > 0 && level < this._levels) {
                this._root.visit(g => {
                    if (g.level() === level) {
                        cnt++;
                    }
                    return false;
                }, true);
            }
            return cnt;
        }
        getLevelGroups(level) {
            if (level === 0) {
                return this._root.children();
            }
            else if (level > 0 && level < this._levels) {
                const groups = [];
                this._root.visit(g => {
                    if (g.level() === level) {
                        groups.push(g);
                    }
                    return false;
                }, true);
                return groups;
            }
            else {
                return [];
            }
        }
        getLevelGroup(level, index) {
            let group;
            if (level === 0) {
                return this._root.get(index);
            }
            else if (level >= 0 && level < this._levels && index >= 0) {
                this._root.visit(g => {
                    if (g.level() === level) {
                        if (index === 0) {
                            group = g;
                            return true;
                        }
                        index--;
                    }
                }, true);
            }
            return group;
        }
        getGroupRows(group) {
            return Utils.getIntArray(group.endRow() - group.startRow() + 1, group.startRow());
        }
        indexOfRow(row) {
            const item = this.itemOfRow(row, false);
            return item ? item.index : -1;
        }
        visIndexOfRow(row) {
            const item = this.itemOfRow(row, true);
            return item ? item.index : -1;
        }
        itemOfRow(row, visibleOnly) {
            if (row >= 0 && row < this._data.rowCount()) {
                const items = visibleOnly ? this._vitems : this._items;
                const count = items.length;
                let i = row;
                while (i < count) {
                    const item = items[i++];
                    if (item instanceof GroupRow && item.row() === row) {
                        return item;
                    }
                }
            }
        }
        groupOfRow(row) {
            const item = this.itemOfRow(row, false);
            return item && item.group;
        }
        getItem(index) {
            return this._items[index];
        }
        getVisItem(index) {
            return this._vitems[index];
        }
        getItems(from, to) {
            return this._items.slice(from, to);
        }
        getVisItems(from, to) {
            return this._vitems.slice(from, to);
        }
        getItemsOf(g) {
            const items = [];
            const start = g ? g.header().index : 0;
            const end = g ? g.footer().index : this._items.length - 1;
            for (let i = start; i <= end; i++) {
                const item = this._items[i];
                if (item.group === g) {
                    items.push(item);
                }
            }
            return items;
        }
        getVisItemsOf(g) {
            const items = [];
            const start = g ? g._firstVis.vindex : 0;
            const end = g ? g._lastVis.vindex : this._vitems.length - 1;
            for (let i = start; i <= end; i++) {
                const item = this._vitems[i];
                if (item.group === g) {
                    items.push(item);
                }
            }
            return items;
        }
        forEachItem(from, to, callback) {
            if (callback && to > from) {
                const items = this._items;
                for (let i = from; i < to; i++) {
                    if (callback(items[i]) === false) {
                        break;
                    }
                }
            }
        }
        forEachVisItem(from, to, callback) {
            if (callback && to > from) {
                const items = this._vitems;
                for (let i = from; i < to; i++) {
                    if (callback(items[i]) === false) {
                        break;
                    }
                }
            }
        }
        clear() {
            this._root.clear();
            this._items = [];
            this._vitems = [];
        }
        /**
         * items와 visItems를 새로 구축한다.
         * {@link DListControl.groupBy}에서 호출한다.
         */
        build(data, options, infos) {
            function clone(info) {
                return {
                    field: info.field,
                    ranges: info.ranges && info.ranges.length > 0 ? info.ranges.slice(0) : null,
                    comparer: info.comparer,
                    header: Object.assign({}, info.header),
                    footer: Object.assign({}, info.footer)
                };
            }
            if (infos.length < 1) {
                throwError(locale.requireGroupingInfos);
            }
            this._infos = infos.map(i => clone(i));
            this._data = data;
            this._options = options;
            this.$_refresh();
            return this;
        }
        /**
         * 기존 아이템들을 모두 제거하고, 지정된 data view의 행들을 기준으로 그룹 아이템들을 새로 구축한다.
         * Data 변경이 있을 때 호출한다.
         */
        refresh(data) {
            this._data = data;
            this.$_refresh();
            DLog.log("Group items refreshed.");
        }
        /**
         * 지정한 그룹들의 data row 들을 감춘다.
         * 단, 지정한 그룹이 root일 때는 root 바로 아래 자식 그룹이나 data row들을 표시하고,
         * 자식 그룹들은 collapse한다. 즉, 최상위 group들을 모두 collapse한 것과 동일하다.
         */
        collapse(g, recursive) {
            g = g || this._root;
            if (this.$_collapse(g, recursive)) {
                if (g === this._root) {
                    // 최상위 level 그룹들만 표시한다.
                    for (let i = this._root.count() - 1; i >= 0; i--) {
                        this._root.get(i).$_setExpanded(false);
                    }
                    this.$_expand(this._root, false, true);
                }
                this.$_resetVisIndices();
                this.$_expandedChanged(g);
            }
        }
        collapseAll() {
            this.collapse(this._root, true);
        }
        expand(g, recursive) {
            g = g || this._root;
            if (this.$_expand(g, recursive, false)) {
                this.$_resetVisIndices();
                this.$_expandedChanged(g);
            }
        }
        expandAll() {
            this.expand(this._root, true);
        }
        toggle(g, recursive) {
            g.expanded() ? this.collapse(g, recursive) : this.expand(g, recursive);
        }
        visit(g, visitor) {
            return (g || this._root).visit(visitor, true);
        }
        getHeaderTemplate(item) {
            return this._header.template || RowGroupModel.HEADER_TEMPLATE;
        }
        getFooterTemplate(item) {
            return this._footer.template || RowGroupModel.FOOTER_TEMPLATE;
        }
        isLastDataRow(item) {
            return item === this._lastRow;
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        $_refresh() {
            const data = this._data;
            this.clear();
            if (this._data) {
                const nRow = data.rowCount();
                if (nRow > 0) {
                    const infos = this._infos;
                    if (infos) {
                        this._descendants = this.$_buildGroups(this._root, infos, data, 0, nRow - 1);
                        this._levels = infos.length + 1;
                        this.$_buildItems(this._root, this._items = []);
                        this.$_resetIndices();
                    }
                }
                this._root._endRow = nRow - 1;
            }
            else {
                this._root._endRow = -1;
            }
            this.$_resetVisibles();
        }
        $_buildGroups(parent, infos, data, start, end) {
            function addGroup(m, info, start, end, v) {
                const g = new RowGroup(parent, info, v, start, end);
                parent.$_add(g);
                if (infos.length > g.level() + 1) {
                    n += m.$_buildGroups(g, infos, data, g._startRow, g._endRow);
                }
                n++;
            }
            const info = infos[parent.level() + 1];
            const field = info.field;
            const ranges = info.ranges;
            let n = 0;
            if (ranges) {
                const reversed = ranges.length > 1 && ranges[0] > ranges[1];
                let r = start;
                let v = data.getValue(r, field, true);
                let prev = v;
                let i = 0;
                let range = ranges[i++];
                let needData = false;
                while (r <= end) {
                    if (needData) {
                        v = data.getValue(r, field, true);
                        needData = false;
                    }
                    if (reversed && v < range || !reversed && v >= range) {
                        if (r > start) {
                            addGroup(this, info, start, r - 1, prev);
                            start = r;
                            if (i === ranges.length)
                                break;
                        }
                        else {
                            r++;
                            needData = true;
                        }
                        prev = range;
                        range = ranges[i++];
                    }
                    else {
                        r++;
                        needData = true;
                    }
                }
                if (start <= end) {
                    addGroup(this, info, start, end, range);
                }
            }
            else {
                const comparer = info.comparer;
                const rowCount = data.rowCount();
                let prev = data.getValue(start, field, true);
                for (let r = start + 1; r <= end; r++) {
                    const v = data.getValue(r, field, true);
                    const eq = comparer ? comparer(v, prev, r, rowCount) : v === prev;
                    if (!eq) {
                        addGroup(this, info, start, r - 1, prev);
                        prev = v;
                        start = r;
                    }
                }
                addGroup(this, info, start, end, prev);
            }
            return n;
        }
        getHeaderVisible(g, expanded) {
            var _a, _b;
            if (expanded) {
                return Utils.pick((_a = g.headerInfo()) === null || _a === void 0 ? void 0 : _a.visible, this._header.visible, true);
            }
            else {
                return Utils.pick((_b = g.headerInfo()) === null || _b === void 0 ? void 0 : _b.collapsedVisible, this._header.collapsedVisible, true);
            }
        }
        getFooterVisible(g, expanded) {
            var _a, _b;
            if (expanded) {
                return Utils.pick((_a = g.footerInfo()) === null || _a === void 0 ? void 0 : _a.visible, this._footer.visible, true);
            }
            else {
                return Utils.pick((_b = g.footerInfo()) === null || _b === void 0 ? void 0 : _b.collapsedVisible, this._footer.collapsedVisible, false);
            }
        }
        $_buildItems(group, items) {
            const cnt = group.count();
            if (cnt > 0) {
                for (let i = 0; i < cnt; i++) {
                    const child = group.get(i);
                    items.push(child['_header'] = new GroupHeader(child));
                    this.$_buildItems(child, items);
                    items.push(child['_footer'] = new GroupFooter(child));
                }
            }
            // leaf
            else {
                items.length;
                for (let r = group.startRow(); r <= group.endRow(); r++) {
                    items.push(new GroupRow(group, r));
                }
            }
        }
        $_collectVisibles(group, vitems) {
            const bRoot = group === this._root;
            const items = this._items;
            const expanded = group.expanded();
            const bHeader = this.getHeaderVisible(group, expanded);
            const bFooter = this.getFooterVisible(group, expanded);
            let n = vitems.length;
            const cnt = group.count();
            if (!bRoot) {
                const h = group.header();
                // header나 footer 중 하나는 반드시 표시
                if (bHeader || !bFooter) {
                    vitems.push(h);
                    group._firstVis = h;
                }
                else {
                    group._firstVis = null;
                }
            }
            if (expanded) {
                if (cnt > 0) {
                    for (let i = 0; i < cnt; i++) {
                        const child = group.get(i);
                        this.$_collectVisibles(child, vitems);
                    }
                }
                // leaf
                else if (items.length > 0) {
                    let no = 0;
                    for (let r = group.header().index + 1; r < group.footer().index; r++) {
                        items[r].no = no++;
                        vitems.push(items[r]);
                    }
                }
                if (!group._firstVis) {
                    group._firstVis = vitems[n];
                }
            }
            const f = group.footer();
            if (bFooter) {
                vitems.push(f);
            }
            group._lastVis = vitems[vitems.length - 1];
            if (!bRoot && !group._firstVis) {
                group._firstVis = group._lastVis;
            }
        }
        $_expand(group, recursive, force) {
            let changed = false;
            if (recursive) {
                group.visit(child => {
                    if (child.$_setExpanded(true)) {
                        changed = true;
                    }
                    return false;
                }, true);
            }
            if (force || changed || !group.expanded()) {
                const vitems = this._vitems;
                const bRoot = group === this._root;
                const first = bRoot ? 0 : group._firstVis.vindex;
                const last = bRoot ? vitems.length - 1 : group._lastVis.vindex;
                const items = [];
                const visible = group.visible();
                if (visible) {
                    if (!bRoot && (last < 0 || first < 0)) {
                        debugger;
                    }
                    if (bRoot) {
                        vitems.length = 0;
                        // assert(visItems.length === 0, 'Visible items must be empty.')
                    }
                    else {
                        vitems.splice(first, last - first + 1);
                    }
                }
                changed = group.$_setExpanded(true) || changed;
                this.$_collectVisibles(group, items);
                visible && Utils.splice(vitems, first, 0, items);
            }
            return changed;
        }
        $_collapse(group, recursive) {
            const bRoot = group === this._root;
            const oldItems = this._vitems.slice(0);
            const oldCount = this._vitems.length;
            let changed = false;
            if (recursive || bRoot) {
                group.visit(child => {
                    if (child.$_setExpanded(false)) {
                        changed = true;
                    }
                    return false;
                }, recursive);
            }
            if (changed || group.expanded()) {
                const vItems = this._vitems;
                let first = bRoot ? 0 : group._firstVis.vindex;
                const last = bRoot ? vItems.length - 1 : group._lastVis.vindex;
                const items = [];
                const visible = group.visible();
                if (visible && !bRoot && last < 0) {
                    debugger;
                }
                changed = group.$_setExpanded(false) || changed;
                visible && vItems.splice(first, last - first + 1);
                this.$_collectVisibles(group, items);
                if (!bRoot && visible && (group.lastVis().vindex < 0 || group.firstVis().vindex < 0)) {
                    debugger;
                }
                visible && Utils.splice(vItems, first, 0, items);
                if (vItems.length > oldCount) {
                    console.log(oldItems);
                    debugger;
                }
                if (!bRoot && visible && (group.lastVis().vindex < 0 || group.firstVis().vindex < 0)) {
                    debugger;
                }
            }
            return changed;
        }
        $_resetVisibles() {
            const vitems = this._vitems = [];
            const root = this._root;
            this._lastRow = null;
            if (root.count() > 0) {
                this.$_collectVisibles(root, vitems);
                this.$_resetVisIndices();
                for (let i = vitems.length - 1; i >= 0; i--) {
                    if (vitems[i] instanceof GroupRow) {
                        this._lastRow = vitems[i];
                        break;
                    }
                }
            }
        }
        $_resetIndices() {
            const items = this._items;
            for (let i = 0, n = items.length; i < n; i++) {
                items[i].index = i;
            }
        }
        $_resetVisIndices() {
            let items = this._items;
            for (let i = items.length - 1; i >= 0; i--) {
                items[i].vindex = -1;
            }
            items = this._vitems;
            for (let i = 0, n = items.length; i < n; i++) {
                items[i].vindex = i;
            }
        }
        $_expandedChanged(group) {
            this._fireEvent('onGroupExpanded', group, group.expanded());
        }
        $_checkedChanged(group) {
            this._fireEvent('onGroupChecked', group, group.checked());
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    RowGroupModel.HEADER_TEMPLATE = '@it_group_header';
    RowGroupModel.FOOTER_TEMPLATE = '@it_group_footer';

    ////////////////////////////////////////////////////////////////////////////////
    class TemplateVars {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(vars) {
            const v = this._vars = {};
            for (let p in vars) {
                v['--' + p] = vars[p];
            }
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        out(value) {
            if (value in this._vars) {
                return this._vars[value];
            }
            return value;
        }
        assign(source) {
            const vars = this._vars;
            const obj = {};
            for (let p in source) {
                const v = source[p];
                if (v in vars) {
                    obj[p] = vars[v];
                }
                else {
                    obj[p] = v;
                }
            }
            return obj;
        }
    }
    let _tid_ = 1;
    /**
     * @internal
     *
     * 템플릿 구성 항목은 값을 표시하는 field 아이템과, field및 자식 layout을 포함하는 layout 아이템으로 구성된다.
     * 1. 'layout' 속성을 지정하면 layout 아이템이 된다.
     * 2. 'field' 속성을 지정하면 지정한 field의 값을 표시하는 field 아이템이 된다.
     * 3. 'value' 속성을 지정하면 지정한 값을 표시하는 field 아이템이 된다. field 값보다 우선한다.
     *
     * 항목의 속성이나 상위 layout에서 지정하는 자식 속성들은 'props'에 지정한다.
     */
    class DTemplateChild {
        // // 기본 공통 속성들은 props 밖에 설정할 수 있도록 한다.
        // width: number | DParamString;
        // height: number | DParamString;
        // visible: boolean | DParamString;
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(parent, source, vars) {
            this.tid = _tid_++;
            this._parent = parent;
            if (source) {
                this.tag = source.tag != null ? String(source.tag) : void 0;
                this._doLoad(source, vars);
                // if ('width' in source) {
                //     const v = vars ? vars.out(source.width) : source.width;
                //     this.width = (typeof v === 'number') ? v as any : DParamString.parse(v);
                // }
                // if ('height' in source) {
                //     const v = vars ? vars.out(source.height) : source.height;
                //     this.height = (typeof v === 'number') ? v as any : DParamString.parse(v);
                // }
                // if ('visible' in source) {
                //     const v = vars ? vars.out(source.visible) : source.visible;
                //     this.visible = (typeof v === 'boolean') ? v as any : DParamString.parse(v);
                // }
            }
        }
        _loadProps(source, vars) {
            return DParamString.load(vars ? vars.assign(source) : source);
        }
        _loadStyle(source, vars) {
            if (Utils.isObject(source)) {
                return DParamString.load(vars ? vars.assign(source) : source);
            }
            else if (source) {
                if (vars)
                    source = vars.out(source);
                return DParamString.parse(source);
            }
        }
        /**
         * renderer type은 변경할 수 없다.
         * type 속성을 param으로 지정할 수 있지만 비추천.
         * renderer가 사용하는 dom의 style을 layout field 수준에서 설정하므로...
         * 상태에 따라 renderer를 바꾸려면 row template을 동적으로 설정해야 한다.
         */
        _loadRenderer(source, styles, vars) {
            if (Utils.isObject(source)) {
                const r = DParamString.load(vars ? vars.assign(source) : source);
                // renderer가 'Style'로 끝나는 여러 속성을 가질 수 있다.
                for (let p in r) {
                    const v = r[p];
                    if (p.endsWith('Style')) {
                        styles[p] = r[p] = this._loadStyle(v, vars);
                    }
                }
                // renderer의 기본 스타일
                if (source.style) {
                    // styles.style = r.style = this._loadStyle(source.style, vars);
                    styles.style = this._loadStyle(source.style, vars);
                }
                r.type = source.type; // NOTE: 위에서 이미 설정한 것이다. param을 무시하기 위해...
                return r;
            }
            else if (typeof source === 'string') {
                return source;
            }
        }
    }
    /**
     * @internal
     *
     * { type: 'field', field: 'fieldName', props: {}, renderer: 'label' }
     */
    class DTemplateField extends DTemplateChild {
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        // // NOTE: DListControl.registerTemplates(...)에서 성능 비교...
        // protected _doLoad2(source: any, vars: TemplateVars): void {
        //     if (typeof source === 'string') {
        //         this.field = DParamString.parse(source);
        //     } else {
        //         const props = {};
        //         // SIMPLE_LAYOUT_PROPS.forEach(p => source.hasOwnProperty(p) && (props[p] = source[p]));
        //         // CHILD_PROPS[this._parent.layout].forEach(p => source.hasOwnProperty(p) && (props[p] = source[p]));
        //         // for (const p in source) {
        //         //     if (!(p in FIELD_KEYS)) {
        //         //         props[p] = source[p];
        //         //     }
        //         // }
        //         this.id = source.id;
        //         if (Array.isArray(source.fields)) {
        //             this.fields = DParamString.parse(source.fields);
        //         }
        //         if (source.field) {
        //             this.field = DParamString.parse(source.field);
        //         } 
        //         if (source.value) {
        //             this.value = DParamString.parse(source.value);
        //         }
        //         this.renderer = this._loadRenderer(source.renderer, this.rendererStyles = {}, vars);
        //         // this.props = this._loadProps(source.props, vars);
        //         this.props = this._loadProps(props, vars);
        //         this.style = this._loadStyle(source.style, vars);
        //     }
        // }
        _doLoad(source, vars) {
            if (typeof source === 'string') {
                this.field = DParamString.parse(source);
            }
            else {
                const props = Object.assign({}, source);
                this.id = source.id;
                delete props.id;
                if (Array.isArray(source.fields)) {
                    this.fields = DParamString.parse(source.fields);
                    delete props.fields;
                }
                if (source.field) {
                    this.field = DParamString.parse(source.field);
                    delete props.field;
                }
                if (source.value) {
                    this.value = DParamString.parse(source.value);
                    delete props.value;
                }
                this.renderer = this._loadRenderer(source.renderer, this.rendererStyles = {}, vars);
                delete props.renderer;
                if (source.style) {
                    this.style = this._loadStyle(source.style, vars);
                    delete props.style;
                }
                if (source.classCallback) {
                    this.classCallback = source.classCallback;
                    delete props.classCallback;
                }
                if (source.styleCallback) {
                    this.styleCallback = source.styleCallback;
                    delete props.styleCallback;
                }
                this.props = this._loadProps(props, vars);
            }
        }
    }
    /**
     * @internal
     *
     * { type: 'layout', layout: 'vlinear', childnre: [], props: {}, style: {}}
     */
    class DTemplateLayout extends DTemplateChild {
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        count() {
            return this.children.length;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        get(index) {
            return this.children[index];
        }
        tagBy(tag) {
            return this.children.find(child => child.tag === tag);
        }
        fieldBy(tag) {
            return this.children.find(child => child.tag === tag && child instanceof DTemplateField);
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        // protected _doLoad2(source: any, vars: TemplateVars): void {
        //     const props = {};
        //     this.layout = source.layout;
        //     this.id = source.id;
        //     // DEF_LAYOUT_PROPS.forEach(p => source.hasOwnProperty(p) && (props[p] = source[p]));
        //     // LAYOUT_PROPS[this.layout].forEach(p => source.hasOwnProperty(p) && (props[p] = source[p]));
        //     // this._parent && CHILD_PROPS[this._parent.layout].forEach(p => source.hasOwnProperty(p) && (props[p] = source[p]));
        //     // for (const p in source) {
        //     //     if (!(p in LAYOUT_KEYS)) {
        //     //         props[p] = source[p];
        //     //     }
        //     // }
        //     // this.props = this._loadProps(source.props, vars);
        //     this.props = this._loadProps(props, vars);
        //     this.style = this._loadStyle(source.style, vars);
        //     if (Array.isArray(source.children)) {
        //         const childs = this.children = [];
        //         for (let src of source.children) {
        //             let t: DTemplateChild;
        //             if (src != null) { // check undefined or null
        //                 if (src.type === 'layout' || src.layout) {
        //                     t = new DTemplateLayout(this, src, vars);
        //                 } else if (src.space !== void 0) {
        //                     // space: '*' 로 지정할 수 있도록 renderer 속성 대신 layout 크기를 지정하는 용도로 사용할 수 있게 한다.
        //                     // t = new DTemplateField({renderer: {type: 'spacer', props: {space: src.space}}}, vars);
        //                     // t = new DTemplateField({props: {width: src.space, height: src.space}, renderer: {type: 'spacer', space: 0}}, vars);
        //                     t = new DTemplateField(this, {width: src.space, height: src.space, renderer: {type: 'spacer', space: 0}}, vars);
        //                 } else {
        //                     t = new DTemplateField(this, src, vars);
        //                 }
        //             }
        //             if (t) {
        //                 t.tag = src.tag;
        //                 childs.push(t);
        //             }
        //         }
        //     }
        // }
        _doLoad(source, vars) {
            const props = Object.assign({}, source);
            this.layout = props.layout;
            delete props.layout;
            this.id = props.id;
            delete props.id;
            if (props.style) {
                this.style = this._loadStyle(props.style, vars);
                delete props.style;
            }
            if (Array.isArray(source.children)) {
                const childs = this.children = [];
                for (let src of source.children) {
                    let t;
                    if (src != null) { // check undefined or null
                        if (src.type === 'layout' || src.layout) {
                            t = new DTemplateLayout(this, src, vars);
                        }
                        else if (src.space !== void 0) {
                            // space: '*' 로 지정할 수 있도록 renderer 속성 대신 layout 크기를 지정하는 용도로 사용할 수 있게 한다.
                            // t = new DTemplateField({renderer: {type: 'spacer', props: {space: src.space}}}, vars);
                            // t = new DTemplateField({props: {width: src.space, height: src.space}, renderer: {type: 'spacer', space: 0}}, vars);
                            if (src.space === '*') {
                                t = new DTemplateField(this, Object.assign({ width: 0, height: 0, grow: 1, renderer: { type: 'spacer', space: 0 } }, src), vars);
                            }
                            else {
                                t = new DTemplateField(this, Object.assign({ width: src.space, height: src.space, renderer: { type: 'spacer', space: 0 } }, src), vars);
                            }
                        }
                        else {
                            t = new DTemplateField(this, src, vars);
                        }
                    }
                    if (t) {
                        t.tag = src.tag;
                        childs.push(t);
                    }
                }
                delete props.children;
            }
            else {
                this.children = [];
            }
            this.props = this._loadProps(props, vars);
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        _getFields(fields) {
            this.children.forEach(child => {
                if (child instanceof DTemplateLayout) {
                    child._getFields(fields);
                }
                else if (typeof (child.field) === 'string') {
                    fields.push(child.field);
                }
            });
        }
    }
    /**
     * @internal
     *
     * { type: 'html', domid: ''} or { html: '<div>...</div>' }
     */
    class DTemplateHtmlLayout extends DTemplateChild {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(dom, vars) {
            super(null, null, null);
            this.tokens = [];
            this.$_parseParams(this.dom = dom, []);
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doLoad(source, vars) { }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        $_parseParams(dom, index) {
            // attrs
            let param;
            const attrs = dom.getAttributeNames();
            if (attrs) {
                attrs.forEach(attr => {
                    param = DParamString.parse(dom.getAttribute(attr));
                    if (param instanceof DParamString) {
                        this.tokens.push({ node: index, attr: attr, param: param });
                    }
                });
            }
            // 자식들
            const childs = dom.childNodes;
            for (let i = 0; i < childs.length; i++) {
                const node = childs[i];
                const index2 = index.concat(i);
                if (node.nodeType === Node.TEXT_NODE) {
                    const s = node.nodeValue;
                    param = DParamString.parse(s);
                    if (param instanceof DParamString) {
                        this.tokens.push({ node: index2, param: param });
                    }
                }
                if (node instanceof HTMLElement) {
                    this.$_parseParams(node, index2);
                }
            }
        }
    }
    let $_template_id = 1000000;
    /**
     * @internal
     *
     * 설정을 통해 {@link DListLayout 레이아웃} 계층을 구성하고,
     * 각 layout에 {@link DListField 리스트 필드}들을 배치하는 layout 설정 모델.
     * Template으로 부터 rendering 시간에 item view 표시를 위한 layout이 생성된다.
     */
    class DListTemplate extends DObject {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(htmlProvider, source) {
            super();
            //-------------------------------------------------------------------------
            // static members
            //-------------------------------------------------------------------------
            //-------------------------------------------------------------------------
            // fields
            //-------------------------------------------------------------------------
            this.id = $_template_id++;
            this.detailId = $_template_id++;
            this.collapsedId = $_template_id++;
            if (source) {
                if (source.template) {
                    const vars = Utils.isValidObject(source.vars) ? new TemplateVars(source.vars) : null;
                    this.description = source.description;
                    this.rowProps = Utils.copyObject(source.rowProps);
                    this.rowStyle = copyRowStyles(source.rowStyle);
                    this.layout = this.$_createLayout(htmlProvider, source.template, vars);
                    this.detailed = source.detailed && this.$_createLayout(htmlProvider, source.detailed, vars);
                    this.extra = source.extra && this.$_createLayout(htmlProvider, source.extra, vars);
                    this.collapsed = source.collapsed && this.$_createLayout(htmlProvider, source.collapsed, vars);
                    this.brief = source.brief && this.$_createLayout(htmlProvider, source.brief, vars);
                    this.params = Utils.copyObject(source.params);
                }
                else if (source.layout) {
                    this.layout = this.$_createLayout(htmlProvider, source, null);
                }
            }
        }
        _doDestory() {
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        getFields() {
            const flds = [];
            this.layout._getFields(flds);
            return flds;
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        $_createLayout(htmlProvider, source, vars) {
            if (source.type === 'html' || typeof (source.html) === 'string') {
                let dom;
                if (typeof (source.html) === 'string') {
                    dom = htmlProvider.doc().createElement('div');
                    dom.innerHTML = source.html;
                    dom = dom.firstElementChild;
                }
                else if (source.domid) {
                    dom = htmlProvider.getTemplateHtml(source.domid);
                }
                if (!dom) {
                    dom = htmlProvider.doc().createElement('div');
                }
                return new DTemplateHtmlLayout(dom, vars);
            }
            else {
                return new DTemplateLayout(null, source, vars);
            }
        }
    }
    const DummyTemplate = new DListTemplate(null, {
        template: {
            layout: 'frame',
            children: [{
                    value: "[ Dummy Template ]",
                    style: {
                        color: '#aaa',
                        fontWeight: 'bold'
                    }
                }]
        }
    });
    const DummyTemplateLayout = new DTemplateLayout(null, {
        layout: 'frame',
        children: [{
                width: '35%',
                height: 25,
                left: 0,
            }, {
                width: '10%',
                height: 18,
                right: '50%',
            }, {
                width: '15%',
                height: 18,
                right: '30%',
            }, {
                width: '25%',
                height: 21,
                right: '0',
            }]
    }, null);

    ////////////////////////////////////////////////////////////////////////////////
    class DataGroupRow extends GroupRow {
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(group, row) {
            super(group, row);
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        dataLevel() {
            return this.group.dataLevel();
        }
        isLeaf() {
            return this.group instanceof DetailGroup;
        }
    }
    /**
     * @internal
     *
     * IDataGroupInfo implementation.
     */
    class DataGroup extends Group {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(parent) {
            super();
            //-------------------------------------------------------------------------
            // property fields
            //-------------------------------------------------------------------------
            this._expanded = true;
            this.parent = parent;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        count() {
            return this._children ? this._children.length : 0;
        }
        level() {
            return this.parent.level() + 1;
        }
        model() {
            return this.parent.model();
        }
        expanded() {
            return this._expanded;
        }
        visible() {
            return this.parent._expanded && this.parent.visible();
        }
        // NOTE: 자식이 없으면 leaf. 그룹 모델 계층 상 바닥 group인 지는 model.isLeaf()로 check.
        isLeaf() {
            return !this._children;
        }
        rowCount() {
            if (this._children) {
                let n = 0;
                this._children.forEach(g => n += g.rowCount());
                return n;
            }
            return 0;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        get(index) {
            return this._children[index];
        }
        isLast(row) {
            return row === this.end;
        }
        contains(g) {
            let p = g;
            while (p) {
                if (p === this)
                    return true;
                p = p.parent;
            }
            return false;
        }
        visit(callback, recursive) {
            if (callback && this._children) {
                for (let child of this._children) {
                    if (callback(child) === true) {
                        return true;
                    }
                    if (recursive) {
                        const rslt = child.visit(callback, true);
                        if (rslt === true) {
                            return true;
                        }
                    }
                }
            }
        }
        clear() {
            // this.$_clearSummary();
            this._children = [];
        }
        getParamValue(param) {
            switch (param) {
                // case 'group_field':
                //     return this._group.field;
                // case 'group_value':
                //     return this._group.value;
                // case 'group_level':
                //     return this._group.level;
                case 'row_count':
                    return this.rowCount();
                // case 'group_sum':
                //     return this._group.value;
            }
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        $_add(g) {
            if (!this._children) {
                this._children = [];
            }
            this._children.push(g);
        }
        $_setExpanded(v) {
            if (v != this._expanded) {
                this._expanded = v;
                return true;
            }
        }
    }
    class MasterGroup extends DataGroup {
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        dataLevel() {
            return this.parent.dataLevel();
        }
        rowCount() {
            return this.isLeaf() ? 1 : super.rowCount();
        }
    }
    class DetailGroup extends DataGroup {
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        dataLevel() {
            return this.parent.dataLevel() + 1;
        }
        rowCount() {
            return this.isLeaf() ? this.rows.length : super.rowCount();
        }
    }
    class RootGroup extends DetailGroup {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(model) {
            super(null);
            this._model = model;
            this.start = 0;
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        level() { return -1; }
        dataLevel() { return 0; }
        model() { return this._model; }
        expanded() { return true; }
        visible() { return true; }
        isLeaf() { return false; }
    }
    /**
     * @internal
     *
     * Master/detail data를 data 계층 기준으로 grouping 한다.
     *
     * 1. 마스터행 당 하나의 master그룹이 생성된다.
     *    - 기본적으로 마스터행이 그룹의 헤더 역할을 하지만, master header가 추가될 수 있다.
     *    - master footer가 추가될 수 있다.
     *    - 디테일이 하나도 없는 마스터행은 설정(hideEmptyMaster)에 따라 표시되지 않을 수 있다.
     * 2. 디테일 묶음 당 하나의 detail그룹이 생성된다.
     *    - 디테일 header/footer를 추가할 수 있다.
     */
    class DataGroupModel extends GroupModel {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor() {
            super();
            /**
             * 기본 그룹 header 설정. 각 group이나 컨트롤에 설정이 없으면 이 설정을 따른다.
             */
            this._header = {
                visible: true,
                collapsedVisible: true,
                template: DataGroupModel.HEADER_TEMPLATE,
                style: null
            };
            /**
             * 기본 그룹 footer 설정. 각 group이나 컨트롤에 설정이 없으면 이 설정을 따른다.
             */
            this._footer = {
                visible: true,
                collapsedVisible: false,
                template: DataGroupModel.FOOTER_TEMPLATE,
                style: null
            };
            this._levels = 0;
            this._rowLevels = 0;
            this._descendants = 0;
            this._items = [];
            this._vitems = [];
            this._leafCount = 0;
            this._root = new RootGroup(this);
        }
        _doDestory() {
        }
        //-------------------------------------------------------------------------
        // IParamInflater
        //-------------------------------------------------------------------------
        inflateParam(target, field, param) {
            param.name;
            let v;
            return v;
        }
        inflateStock(target, field, param) {
            const item = target;
            const p = param.name;
            let v;
            v = item.getParamValue(p);
            // TODO:
            // DListControl.templateParams로 지정한 값.
            // Group header/footer 값.
            // field 이름이면 field값.
            return v;
        }
        //-------------------------------------------------------------------------
        // IListDataListener
        //-------------------------------------------------------------------------
        onDataValueUpdated(data, row, field, value, oldValue) {
            this.$_refresh();
        }
        onDataRowUpdated(data, row, oldValues) {
            this.$_refresh();
        }
        onDataRowsUpdated(data, rows) {
            this.$_refresh();
        }
        onDataRangeUpdated(data, row, count) {
            this.$_refresh();
        }
        onDataRowAdded(data, row) {
            this.$_refresh();
        }
        onDataRowsAdded(data, row, count) {
            this.$_refresh();
        }
        onDataCleared(data, oldCount) {
            this.$_refresh();
        }
        onDataRowDeleted(data, row) {
            this.$_refresh();
        }
        onDataRowsDeleted(data, rows) {
            this.$_refresh();
        }
        onDataRangeDeleted(data, row, count) {
            this.$_refresh();
        }
        // onDataCountChanged(data: IListDataView, newCount: number, oldCount: number): void {
        // }
        // onDataChanged(data: IListDataView): void {
        // }
        //-------------------------------------------------------------------------
        // IListDataViewListener
        //-------------------------------------------------------------------------
        onDataViewFilterChanged(dv) {
            this.$_refresh();
        }
        onDataViewSortChanged(dv) {
            this.$_refresh();
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        data() {
            return this._data;
        }
        header() {
            return this._header;
        }
        footer() {
            return this._footer;
        }
        root() {
            return this._root;
        }
        levels() {
            return this._levels;
        }
        /**
         * 데이터행을 기준으로 한 단계 수. levels와 같거나 작다.
         */
        rowLevels() {
            return this._data.levels();
            // return this._rowLevels;
        }
        groupCount() {
            return this._root.count();
        }
        descendants() {
            return this._descendants;
        }
        leafRowCount() {
            return this._leafCount;
        }
        itemCount() {
            return this._items.length;
        }
        visItemCount() {
            return this._vitems.length;
        }
        firstVisItem() {
            return this._vitems[0];
        }
        lastVisItem() {
            return this._vitems[this._vitems.length - 1];
        }
        firstVisRow() {
            for (let item of this._vitems) {
                if (item instanceof DataGroupRow) {
                    return item;
                }
            }
        }
        lastVisRow() {
            for (let i = this._vitems.length - 1; i >= 0; i--) {
                if (this._vitems[i] instanceof DataGroupRow) {
                    return this._vitems[i];
                }
            }
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        clear() {
            this._root.clear();
            this._items = [];
            this._vitems = [];
        }
        build(data, options, infos) {
            function clone(info) {
                if (info) {
                    const obj = Object.assign({}, info);
                    obj.header = Object.assign({}, info.header);
                    obj.footer = Object.assign({}, info.footer);
                    return obj;
                }
            }
            const map = this._infoMap = {};
            for (const d in infos) {
                map[d] = clone(infos[d]);
            }
            this._options = options;
            this._data = data;
            this.$_refresh();
            return this;
        }
        refresh(data) {
            this._data = data;
            this.$_refresh();
        }
        containsData(name) {
            return name in this._infoMap;
        }
        itemOfRow(row, visibleOnly) {
            const items = visibleOnly ? this._vitems : this._items;
            for (const item of items) {
                if (item instanceof DataGroupRow && item.row() === row) {
                    return item;
                }
            }
        }
        indexOfRow(row) {
            const item = this.itemOfRow(row, false);
            return item ? item.index : -1;
        }
        visIndexOfRow(row) {
            const item = this.itemOfRow(row, true);
            return item ? item.index : -1;
        }
        getItem(index) {
            return this._items[index];
        }
        getVisItem(index) {
            return this._vitems[index];
        }
        expand(g, recursive) {
            g = g || this._root;
            if (this.$_expand(g, recursive, false)) {
                this.$_resetVisIndices(0);
                this.$_expandedChanged(g);
            }
        }
        expandAll() {
            this.expand(this._root, true);
        }
        collapse(g, recursive) {
            g = g || this._root;
            if (this.$_collapse(g, recursive)) {
                if (g === this._root) {
                    // 최상위 level 그룹들만 표시한다.
                    for (let i = this._root.count() - 1; i >= 0; i--) {
                        this._root.get(i).$_setExpanded(false);
                    }
                    this.$_expand(this._root, false, true);
                }
                this.$_resetVisIndices(0);
                this.$_expandedChanged(g);
            }
        }
        collapseAll() {
            this.collapse(this._root, true);
        }
        toggle(g, recursive) {
            g.expanded() ? this.collapse(g, recursive) : this.expand(g, recursive);
        }
        isLastDataRow(item) {
            return item === this._lastRow;
        }
        visit(g, visitor) {
            return (g || this._root).visit(visitor, true);
        }
        getHeaderTemplate(item) {
            //return this._header.template || DataGroupModel.HEADER_TEMPLATE;
            return DataGroupModel.HEADER_TEMPLATE;
        }
        getFooterTemplate(item) {
            //return this._footer.template || DataGroupModel.FOOTER_TEMPLATE;
            return DataGroupModel.FOOTER_TEMPLATE;
        }
        getLevelGroupCount(level) {
            let cnt = 0;
            if (level === 0) {
                cnt = this._root.count();
            }
            else if (level > 0 && level < this._levels) {
                this._root.visit(g => {
                    if (g.level() === level) {
                        cnt++;
                    }
                    return false;
                }, true);
            }
            return cnt;
        }
        getPageGroupCount(level) {
            let cnt = 0;
            if (level >= 0 && level < this._rowLevels - 1) {
                this._root.visit(g => {
                    if (g instanceof MasterGroup && g.dataLevel() === level) {
                        cnt++;
                    }
                    return false;
                }, true);
            }
            return cnt;
        }
        getPageGroup(level, index) {
            let group;
            let i = 0;
            this._root.visit(g => {
                if (g instanceof MasterGroup && g.dataLevel() === level) {
                    if (i === index) {
                        group = g;
                        return true;
                    }
                    i++;
                }
                return false;
            }, true);
            return group;
        }
        getPageRows(group) {
            group.level();
            const items = this._items;
            const len = items.length;
            const rows = [];
            let i = group.row.index;
            while (i < len) {
                const item = items[i++];
                if (item instanceof DataGroupRow && group.contains(item.group)) {
                    rows.push(item);
                }
                else {
                    break;
                }
            }
            return rows;
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        $_refresh() {
            const t = +new Date();
            this.clear();
            const rowCount = this._data ? this._data.rowCount() : 0;
            if (rowCount > 0) {
                // this._levels = this._rowLevels = 0;
                this._levels = 0;
                this._rowLevels = this._data.levels();
                this._descendants = this.$_buildGroups(this._root, 0, rowCount);
                this._root.end = rowCount - 1;
                this.$_buildItems(this._root, this._items = []);
                this.$_resetIndices();
                this.$_resetVisibles();
            }
            console.log('DATA GROUP BUILD: ' + (+new Date() - t) + 'ms.');
        }
        $_buildGroups(root, start, end) {
            function addMaster(parent, start, end) {
                const g = new MasterGroup(parent);
                g.row = new DataGroupRow(g, start);
                g.start = start;
                g.end = end;
                parent.$_add(g);
                n++;
                self._levels = Math.max(self._levels, g.level() + 1);
                if (end > start) {
                    addDetails(g);
                }
            }
            function addMasters(parent, start, end) {
                const dv = data.getSource(start);
                for (let r = start + 1; r <= end; r++) {
                    if (data.getSource(r) === dv) {
                        addMaster(parent, start, r - 1);
                        start = r;
                    }
                }
                addMaster(parent, start, end);
            }
            function addDetail(master, start, end) {
                const g = new DetailGroup(master);
                g.start = start;
                g.end = end;
                master.$_add(g);
                n++;
                self._levels = Math.max(self._levels, g.level() + 1);
                if (data.getLevel(g.start) < levels - 1) { // leaf가 아니면 다시 master
                    addMasters(g, start, end);
                }
                else {
                    g.rows = [];
                    for (let i = g.start; i <= g.end; i++) {
                        g.rows.push(new DataGroupRow(g, i));
                    }
                }
            }
            function addDetails(master) {
                let r = master.start + 1;
                let prev = r;
                let dv = data.getSource(r);
                let lev = data.getLevel(r);
                while (r < master.end) {
                    if (data.getSource(r) !== dv && data.getLevel(r) === lev) {
                        addDetail(master, prev, r - 1);
                        prev = r;
                    }
                    r++;
                }
                addDetail(master, prev, r);
            }
            const self = this;
            const data = this._data;
            const levels = data.levels();
            let n = 0;
            if (start < end) {
                addMasters(root, start, end - 1);
            }
            return n;
        }
        $_buildItems(g, items) {
            const options = this._options;
            const childs = g._children;
            const nChild = childs ? childs.length : 0;
            if (g instanceof MasterGroup) {
                // master header
                if (options.addMasterHeader()) {
                    if (nChild > 0 || options.addEmptyMasterHeader()) {
                        items.push(g.header = new GroupHeader(g));
                    }
                }
                // master row
                items.push(g.row);
                // details
                if (nChild > 0) {
                    for (let i = 0; i < nChild; i++) {
                        const d = childs[i];
                        if (options.addDetailHeader()) {
                            if (nChild > 1 || options.addSingleDetailHeader()) ;
                        }
                        if (d.rows) {
                            d.rows.forEach((r, i) => {
                                r.no = i;
                                items.push(r);
                            });
                        }
                        else {
                            this.$_buildItems(childs[i], items);
                        }
                        if (options.addDetailFooter()) {
                            if (nChild > 1 || options.addSingleDetailFooter()) ;
                        }
                    }
                }
                // master footer
                if (options.addMasterFooter()) {
                    if (nChild > 0 || options.addEmptyMasterFooter()) {
                        items.push(g.footer = new GroupFooter(g));
                    }
                }
            }
            else { // detail group
                for (let i = 0; i < nChild; i++) {
                    this.$_buildItems(childs[i], items);
                }
            }
        }
        $_collectVisibles(group, vitems) {
            const bRoot = group === this._root;
            const items = this._items;
            const expanded = group.expanded();
            let n = vitems.length;
            const cnt = group.count();
            if (!bRoot) {
                if (group instanceof DetailGroup) {
                    const h = group.header;
                    if (h) {
                        if (h.index >= 0) { // header가 items에 포함되지 않을 수 있다.
                            vitems.push(h);
                            group._firstVis = h;
                        }
                        else {
                            group._firstVis = null;
                        }
                    }
                }
                else {
                    vitems.push(group.row);
                }
            }
            if (expanded) {
                if (cnt > 0) {
                    for (let i = 0; i < cnt; i++) {
                        const child = group.get(i);
                        this.$_collectVisibles(child, vitems);
                    }
                }
                // leaf - DetailGroup
                else if (items.length > 0) {
                    if (group instanceof DetailGroup) {
                        const rows = group.rows;
                        for (let r = rows[0].index; r <= rows[rows.length - 1].index; r++) {
                            vitems.push(items[r]);
                        }
                    }
                    else {
                        if (!(group instanceof MasterGroup))
                            debugger;
                    }
                }
                if (!group._firstVis) {
                    group._firstVis = vitems[n];
                }
            }
            if (!bRoot) {
                const f = group.footer;
                if (f) {
                    if (f.index >= 0) {
                        vitems.push(f);
                    }
                }
                group._lastVis = vitems[vitems.length - 1];
                if (!group._firstVis) {
                    group._firstVis = group._lastVis;
                }
            }
        }
        $_resetVisibles() {
            const vitems = this._vitems = [];
            const root = this._root;
            this._lastRow = null;
            if (root.count() > 0) {
                this.$_collectVisibles(root, vitems);
                this.$_resetVisIndices(0);
                for (let i = vitems.length - 1; i >= 0; i--) {
                    if (vitems[i] instanceof DataGroupRow) {
                        this._lastRow = vitems[i];
                        break;
                    }
                }
            }
        }
        $_resetIndices() {
            const items = this._items;
            for (let i = 0, n = items.length; i < n; i++) {
                items[i].index = i;
            }
        }
        $_resetVisIndices(from) {
            let items = this._items;
            for (let i = 0, n = items.length; i < n; i++) {
                items[i].vindex = -1;
            }
            items = this._vitems;
            for (let i = items.length - 1; i >= from; i--) {
                items[i].vindex = i;
            }
        }
        $_expand(group, recursive, force) {
            let changed = false;
            if (recursive) {
                group.visit(child => {
                    if (child.$_setExpanded(true)) {
                        changed = true;
                    }
                    return false;
                }, true);
            }
            if (force || changed || !group.expanded()) {
                const vitems = this._vitems;
                const bRoot = group === this._root;
                const first = bRoot ? 0 : group._firstVis.vindex;
                const last = bRoot ? vitems.length - 1 : group._lastVis.vindex;
                const items = [];
                const visible = group.visible();
                if (visible) {
                    if (!bRoot && (last < 0 || first < 0)) {
                        debugger;
                    }
                    if (bRoot) {
                        vitems.length = 0;
                        // assert(visItems.length === 0, 'Visible items must be empty.')
                    }
                    else {
                        vitems.splice(first, last - first + 1);
                    }
                }
                changed = group.$_setExpanded(true) || changed;
                this.$_collectVisibles(group, items);
                visible && Utils.splice(vitems, first, 0, items);
            }
            return changed;
        }
        $_collapse(group, recursive) {
            const bRoot = group === this._root;
            const oldItems = this._vitems.slice(0);
            const oldCount = this._vitems.length;
            let changed = false;
            if (recursive || bRoot) {
                group.visit(child => {
                    if (child.$_setExpanded(false)) {
                        changed = true;
                    }
                    return false;
                }, recursive);
            }
            if (changed || group.expanded()) {
                const vItems = this._vitems;
                let first = bRoot ? 0 : group._firstVis.vindex;
                const last = bRoot ? vItems.length - 1 : group._lastVis.vindex;
                const items = [];
                const visible = group.visible();
                if (visible && !bRoot && last < 0) {
                    debugger;
                }
                changed = group.$_setExpanded(false) || changed;
                visible && vItems.splice(first, last - first + 1);
                this.$_collectVisibles(group, items);
                if (!bRoot && visible && (group._lastVis.vindex < 0 || group._firstVis.vindex < 0)) {
                    debugger;
                }
                visible && Utils.splice(vItems, first, 0, items);
                if (vItems.length > oldCount) {
                    console.log(oldItems);
                    debugger;
                }
                if (!bRoot && visible && (group._lastVis.vindex < 0 || group._firstVis.vindex < 0)) {
                    debugger;
                }
            }
            return changed;
        }
        $_expandedChanged(group) {
            this._fireEvent('onGroupExpanded', group, group.expanded());
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    DataGroupModel.HEADER_TEMPLATE = '@it_datagroup_header';
    DataGroupModel.FOOTER_TEMPLATE = '@it_datagroup_footer';

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     *
     * {@link DListControl} 페이징 모델.<br>
     * 그룹핑과 배타적이다. 즉, 둘 중 하나만 적용될 수 있다.
     *
     * 연결된 data 행 수가 변경되면 바로 반영된다.
     * 즉, 동적으로 페이징을 구현할 수 있다.
     */
    class ListPageModel extends DEventProvider {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(source, options) {
            super();
            //-------------------------------------------------------------------------
            // property fields
            //-------------------------------------------------------------------------
            this._page = 0;
            this._level = 0;
            this._size = 1;
            this._headerLevel = 0;
            this._footerLevel = 0;
            if (!source) {
                throwError(locale.requireDataOrGroup);
            }
            let group;
            if (source instanceof GroupModel) {
                this._data = source.data();
                group = this._group = source;
            }
            else {
                this._data = source;
            }
            if (options) {
                this._size = pickNum(+options.size, this._size);
                this._level = pickNum(+options.level, this._level);
                this._headerLevel = pickNum(+options.headerLevel, this._headerLevel);
                this._footerLevel = pickNum(+options.footerLevel, this._footerLevel);
            }
            if (group instanceof RowGroupModel) {
                this._groupLevel = Math.max(0, group.levels() - 2 + pickNum(this._level, 0));
                this._getRows = this.$_getRowGroupPageRows.bind(this);
            }
            else if (group instanceof DataGroupModel) {
                this._groupLevel = Math.max(0, group.rowLevels() - 2 + pickNum(this._level, 0));
                this._getRows = this.$_getDataGroupPageRows.bind(this);
            }
            else {
                this._getRows = this.$_getPageRows.bind(this);
            }
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        isGrouped() {
            return !!this._group;
        }
        /**
         * 한 페이지에 표시되는 데이터행 개수.
         *
         * @default 1
         */
        size() {
            return this._size;
        }
        /**
         * 컨트롤이 그룹핑 상태일 때 페이징 기준이되는 그룹 level,
         * 혹은, Master/Detail일 때 Master 데이터의 level.
         * 0이면 마지막 그룹이거나 마지막 Master 데이터이다.
         * -1이면 바로 상위의 그룹이나 마스터 데이터,
         * -2면 그 위...
         */
        level() {
            return this._level;
        }
        /**
         * 현재 페이지.
         *
         * @default 0
         */
        page() {
            return this._page;
        }
        setPage(value) {
            value = Math.floor(Utils.toNumber(value));
            if (value !== this._page) {
                const old = this._page;
                this._page = value;
                this.$_reset();
                this._fireEvent('onPageChanged', value, old);
            }
        }
        /**
         * 페이지 개수.
         */
        pageCount() {
            if (isNaN(this._pageCount)) {
                let n = 0;
                if (this._data) {
                    if (this._group instanceof RowGroupModel) {
                        n = this._group.getLevelGroupCount(this._groupLevel);
                    }
                    else if (this._group instanceof DataGroupModel) {
                        // _groupLevel은 MasterGroup의 level. 실제 표시되는 data 행들은 MasterGroup 아래 DetailGroup에 포함된 것들.
                        n = this._group.getLevelGroupCount(this._groupLevel);
                    }
                    else {
                        n = ((this._data.rowCount() + this._size - 1) / this.size()) >>> 0;
                    }
                }
                this._pageCount = n;
            }
            return this._pageCount;
        }
        /**
         * 현재 페이지의 데이터행 목록.
         */
        rows() {
            if (!this._rows && this._data) {
                this._rows = this._getRows(this._page);
            }
            this._rows = this._rows || [];
            return this._rows;
        }
        rowCount() {
            return this.rows().length;
        }
        startRow() {
            return this.rows()[0];
        }
        endRow() {
            const rows = this.rows();
            return rows[rows.length - 1];
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        getRow(index) {
            return this.rows()[index];
        }
        getPageRows(page) {
            return this._getRows(page);
        }
        incPage(delta) {
            this.setPage(this._page + delta);
        }
        getGroupItems() {
            if (this._group instanceof RowGroupModel) {
                return this.$_getRowGroupItems(this._group);
            }
            else {
                return this.$_getDataGroupItems(this._group);
            }
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        $_reset() {
            this._pageCount = NaN;
            this._page = Math.max(0, Math.min(this.pageCount() - 1, this._page));
            this._rows = null;
        }
        $_getPageRows(page) {
            const rowCount = this._data.rowCount();
            const start = this._size * page;
            const rows = [];
            for (let r = start, i = 0; r < rowCount && i < this._size; r++, i++) {
                rows.push(r);
            }
            return rows;
        }
        $_getRowGroupPageRows(page) {
            const group = this._group;
            // _groupLevel은 MasterGroup 기준. 그 MasterGroup 아래 detailGroup의 행들을 리턴한다.
            const g = group.getLevelGroup(this._groupLevel, page);
            const rows = group.getGroupRows(g);
            return rows;
        }
        $_getDataGroupPageRows(page) {
            const group = this._group;
            const g = group.getPageGroup(this._groupLevel, page);
            const rows = group.getPageRows(g);
            return rows.map(row => row.row());
        }
        $_getRowGroupItems(gm) {
            if (gm) {
                const g = gm.getLevelGroup(this._groupLevel, this._page);
                const lev = g.level();
                const hLevel = lev + this._headerLevel;
                const fLevel = lev + this._footerLevel;
                const items = [];
                let start = g.header().index;
                let end = g.footer().index;
                // 중간에 있는 그룹때문에 start/end 위치 조정만으로는 안된다.
                // 조상들의 header/footer를 가져와 붙여야 한다.
                if (this._headerLevel < 0) {
                    let i = -this._headerLevel;
                    let p = g.parent();
                    while (i > 0 && p !== gm.root()) {
                        items.push(p.header());
                        p = p.parent();
                        i--;
                    }
                }
                else if (this._headerLevel > 0) {
                    let i = 0;
                    while (i < this._headerLevel) {
                        if (gm.getItem(start + 1) instanceof GroupHeader) {
                            start++;
                            i++;
                        }
                        else {
                            break;
                        }
                    }
                }
                if (this._footerLevel > 0) {
                    let i = 0;
                    while (i < this._footerLevel) {
                        if (gm.getItem(end - 1) instanceof GroupFooter) {
                            end--;
                            i++;
                        }
                        else {
                            break;
                        }
                    }
                }
                for (let i = start; i <= end; i++) {
                    let item = gm.getItem(i);
                    if (item.vindex >= 0) {
                        if (item instanceof GroupHeader && item.group.level() < hLevel) {
                            item = null;
                        }
                        else if (item instanceof GroupFooter && item.group.level() < fLevel) {
                            item = null;
                        }
                        item && items.push(item);
                    }
                }
                if (this._footerLevel < 0) {
                    let i = -this._footerLevel;
                    let p = g.parent();
                    while (i > 0 && p !== gm.root()) {
                        items.push(p.footer());
                        p = p.parent();
                        i--;
                    }
                }
                return items;
            }
            return [];
        }
        $_getDataGroupItems(gm) {
            if (gm) {
                const g = gm.getPageGroup(this._groupLevel, this._page);
                const rows = g._children[0].rows;
                const lev = g.level();
                const hLevel = lev + this._headerLevel;
                const fLevel = lev + this._footerLevel;
                let start = rows[0].index;
                let end = rows[rows.length - 1].index;
                let items = [];
                if (hLevel < 0) ;
                else if (hLevel > 0) ;
                else {
                    items.push(g.row);
                    let i = g.row.index + 1;
                    while (i < start) {
                        const item = gm.getItem(i++);
                        if (item.vindex >= 0) {
                            items.push(item);
                        }
                    }
                }
                for (let i = start; i <= end; i++) {
                    const item = gm.getItem(i);
                    if (item.vindex >= 0) {
                        item && items.push(item);
                    }
                }
                if (fLevel > 0) ;
                else if (fLevel < 0) ;
                else if (g.footer) {
                    const f = g.footer.index;
                    let i = items[items.length - 1].index + 1;
                    while (i <= f) {
                        const item = gm.getItem(i++);
                        if (item.vindex >= 0) {
                            items.push(item);
                        }
                    }
                }
                return items;
            }
            return [];
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    let renderer_id = 0;
    /**
     * @internal
     */
    class DListRenderer extends DObject {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor() {
            super();
            this._clickable = false;
            this._id = this.type() + renderer_id++; // template에서 id를 설정하면 overwrite된다.
        }
        get id() {
            return this._id;
        }
        set id(value) {
            this._id = value;
        }
        get hint() {
            return this._hint;
        }
        set hint(value) {
            this._hint = value;
        }
        // /**
        //  * class name.
        //  */
        // get class(): string {
        //     return this._class;
        // }
        // set class(value: string) {
        //     this._class = value;
        // }
        // /**
        //  * class callback
        //  */
        // get classCallback(): DListRendererClassCallback {
        //     return this._classCallback;
        // }
        // set classCallback(value: DListRendererClassCallback) {
        //     this._classCallback = value;
        // }
        get style() {
            return this._style;
        }
        set style(value) {
            // 템플릿으로 부터 생성 시 원본을 inflate하므로 복사할 필요가 없다.
            this._style = value;
        }
        get styleCallback() {
            return this._styleCallback;
        }
        set styleCallback(value) {
            this._styleCallback = value;
        }
        get clickable() {
            return this._clickable;
        }
        set clickable(value) {
            this._clickable = value;
        }
        get onClick() {
            return this._onClick;
        }
        set onClick(value) {
            this._onClick = value;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        /**
         * @internal
         *
         * 이벤트 핸들러 매개변수로 사용된다.
         */
        getProxy() {
            return {
                type: this.type(),
                id: this._id
            };
        }
        clicked(control, row, field) {
            return this._doClicked(control, row, field);
        }
        longPressed(control, row, field) {
            return this._doLongPressed(control, row, field);
        }
        // getClassName(args: IListStyleCallbackArgs): string {
        //     const cb = this._classCallback;
        //     if (cb) {
        //         const cls = cb(args);
        //         if (cls !== void 0) return cls;
        //     }
        //     return this._class;
        // }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        _doClicked(control, row, field) {
            if (this.clickable && this._onClick) {
                if (!this._clickArgs) {
                    this._clickArgs = {
                        control: control.wrapperOrThis(),
                        renderer: this.getProxy()
                    };
                }
                this._clickArgs.row = row;
                this._clickArgs.field = field;
                return this._onClick(this._clickArgs);
            }
        }
        _doLongPressed(control, row, field) {
            return false;
        }
    }
    /**
     * @internal
     */
    class ValueRenderer extends DListRenderer {
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        get value() {
            return this._value;
        }
        set value(value) {
            this._value = value;
        }
    }
    /**
     * @internal
     */
    class BoundableRenderer extends ValueRenderer {
        constructor() {
            super(...arguments);
            //-------------------------------------------------------------------------
            // property fields
            //-------------------------------------------------------------------------
            this._fitWidth = 1;
            this._fitHeight = 1;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        get fitWidth() {
            return this._fitWidth;
        }
        set fitWidth(value) {
            this._fitWidth = value;
        }
        get fitHeight() {
            return this._fitHeight;
        }
        set fitHeight(value) {
            this._fitHeight = value;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        getFitWidth() {
            return isNaN(this._fitWidth) ? 1 : this._fitWidth;
        }
        getFitHeight() {
            return isNaN(this._fitHeight) ? 1 : this._fitHeight;
        }
    }
    /**
     * @internal
     */
    class BoolRenderer extends ValueRenderer {
        constructor() {
            super(...arguments);
            //-------------------------------------------------------------------------
            // consts
            //-------------------------------------------------------------------------
            //-------------------------------------------------------------------------
            // property fields
            //-------------------------------------------------------------------------
            this._disabled = false;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        get disabled() {
            return this._disabled;
        }
        set disabled(value) {
            this._disabled = value;
        }
        get trueValues() {
            return this._trueValues && this._trueValues.slice(0);
        }
        set trueValues(value) {
            this._trueValues = value && value.slice(0);
        }
        get trueValue() {
            return this._trueValue;
        }
        set trueValue(value) {
            this._trueValue = value;
        }
        get falseValue() {
            return this._falseValue;
        }
        set falseValue(value) {
            this._falseValue = value;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        isTrue(value) {
            if (value === true) {
                return true;
            }
            if (this._trueValues) {
                return this._trueValues.indexOf(value) >= 0;
            }
            return false;
        }
        getValueOf(checked) {
            if (checked) {
                return pickProp(this._trueValue, (this._trueValues && this._trueValues.length > 0) ? this._trueValues[0] : true);
            }
            else {
                return pickProp(this._falseValue, false);
            }
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     */
    class ButtonRenderer extends DListRenderer {
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor() {
            super();
            //-------------------------------------------------------------------------
            // static members
            //-------------------------------------------------------------------------
            //-------------------------------------------------------------------------
            // property fields
            //-------------------------------------------------------------------------
            this._disabled = false;
            this._borderless = false;
            this._labelPosition = DListButtonLabelPosition.BOTTOM;
            this.clickable = true;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        get disabled() {
            return this._disabled;
        }
        set disabled(value) {
            this._disabled = value;
        }
        get buttonWidth() {
            return this._buttonWidth;
        }
        set buttonWidth(value) {
            this._buttonWidth = +value;
        }
        get buttonHeight() {
            return this._buttonHeight;
        }
        set buttonHeight(value) {
            this._buttonHeight = +value;
        }
        get borderless() {
            return this._borderless;
        }
        set borderless(value) {
            this._borderless = true;
        }
        get label() {
            return this._label;
        }
        set label(value) {
            this._label = value;
        }
        get labelPosition() {
            return this._labelPosition;
        }
        set labelPosition(value) {
            this._labelPosition = value;
        }
        get imageUrl() {
            return this._imageUrl;
        }
        set imageUrl(value) {
            this._imageUrl = value;
        }
        get imageWidth() {
            return this._imageWidth;
        }
        set imageWidth(value) {
            this._imageWidth = +value;
        }
        get imageHeight() {
            return this._imageHeight;
        }
        set imageHeight(value) {
            this._imageHeight = +value;
        }
        get shape() {
            return this._shape;
        }
        set shape(value) {
            this._shape = value;
        }
        get shapeWidth() {
            return this._shapeWidth;
        }
        set shapeWidth(value) {
            this._shapeWidth = value;
        }
        get shapeHeight() {
            return this._shapeHeight;
        }
        set shapeHeight(value) {
            this._shapeHeight = value;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        getShapeSize() {
            let h = Math.max(0, this._shapeHeight);
            const w = Math.max(0, this._shapeWidth) || h || ButtonRenderer.SHAPE_SIZE;
            h = h || w;
            return { width: w, height: h };
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        type() {
            return ButtonRenderer.TYPE;
        }
        getProxy() {
            const r = super.getProxy();
            r.label = this._label;
            return r;
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    ButtonRenderer.TYPE = 'button';
    ButtonRenderer.SHAPE_SIZE = 20;

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     */
    class CheckRenderer extends BoolRenderer {
        constructor() {
            super(...arguments);
            this._labelWrap = true;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        get boxSize() {
            return this._boxSize;
        }
        set boxSize(value) {
            this._boxSize = +value;
        }
        get boxWidth() {
            return this._boxWidth;
        }
        set boxWidth(value) {
            this._boxWidth = +value;
        }
        get boxHeight() {
            return this._boxHeight;
        }
        set boxHeight(value) {
            this._boxHeight = +value;
        }
        get label() {
            return this._label;
        }
        set label(value) {
            this._label = value;
        }
        get checkedLabel() {
            return this._checkedLabel;
        }
        set checkedLabel(value) {
            this._checkedLabel = value;
        }
        get uncheckedLabel() {
            return this._uncheckedLabel;
        }
        set uncheckedLabel(value) {
            this._uncheckedLabel = value;
        }
        get labelWrap() {
            return this._labelWrap;
        }
        set labelWrap(value) {
            this._labelWrap = value;
        }
        get checkedStyle() {
            return this._checkedStyle;
        }
        set checkedStyle(value) {
            this._checkedStyle = value;
        }
        get uncheckedStyle() {
            return this._uncheckedStyle;
        }
        set uncheckedStyle(value) {
            this._uncheckedStyle = value;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        getBoxWidth() {
            return pickNum(this._boxWidth, this._boxSize);
        }
        getBoxHeight() {
            return pickNum(this._boxHeight, this._boxSize);
        }
        getLabel(checked) {
            return checked ? (this._checkedLabel || this._label) : (this._uncheckedLabel || this._label);
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        type() {
            return CheckRenderer.TYPE;
        }
        _doClicked(control, row, field) {
            if (!super._doClicked(control, row, field) && field) {
                const dv = control.data();
                if (!dv.readOnly()) {
                    let v = dv.getValue(row, field, true);
                    if (this.isTrue(v)) {
                        v = this.getValueOf(false);
                    }
                    else {
                        v = this.getValueOf(true);
                    }
                    dv.updateValue(row, field, v);
                    return true;
                }
            }
            else {
                return true;
            }
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    CheckRenderer.TYPE = 'check';

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     */
    class GaugeRendererBase extends ValueRenderer {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        get gaugeSize() {
            return this._gaugeSize;
        }
        set gaugeSize(value) {
            this._gaugeSize = +value;
        }
        get gaugeWidth() {
            return this._gaugeWidth;
        }
        set gaugeWidth(value) {
            this._gaugeWidth = +value;
        }
        get gaugeHeight() {
            return this._gaugeHeight;
        }
        set gaugeHeight(value) {
            this._gaugeHeight = +value;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        getGaugeWidth() {
            return pickNum3(this._gaugeWidth, this._gaugeSize, GaugeRendererBase.SIZE);
        }
        getGaugeHeight() {
            return pickNum3(this._gaugeHeight, this._gaugeSize, GaugeRendererBase.SIZE);
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    GaugeRendererBase.SIZE = 200;

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     */
    class GaugeRenderer extends GaugeRendererBase {
        constructor() {
            super(...arguments);
            this._startAngle = 0;
            this._endAngle = 360;
            this._clockwise = true;
            this._minValue = 0;
            this._maxValue = 100;
        }
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        // protected _initProps(): void {
        //     this.size = GuageRenderer.SIZE;
        // }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        get centerX() {
            return this._centerX;
        }
        set centerX(value) {
            this._centerX = Utils.toNumber(value);
        }
        get centerY() {
            return this._centerY;
        }
        set centerY(value) {
            this._centerY = Utils.toNumber(value);
        }
        get radiusX() {
            return this._radiusX;
        }
        set radiusX(value) {
            this._radiusX = Utils.toNumber(value);
        }
        get radiusY() {
            return this._radiusY;
        }
        set radiusY(value) {
            this._radiusY = Utils.toNumber(value);
        }
        get startAngle() {
            return this._startAngle;
        }
        set startAngle(value) {
            this._startAngle = Utils.toNumber(value);
        }
        get endAngle() {
            return this._endAngle;
        }
        set endAngle(value) {
            this._endAngle = Utils.toNumber(value);
        }
        get clockwise() {
            return this._clockwise !== false;
        }
        set clockwise(value) {
            this._clockwise = value;
        }
        get minValue() {
            return this._minValue;
        }
        set minValue(value) {
            this._minValue = value;
        }
        get maxValue() {
            return this._maxValue;
        }
        set maxValue(value) {
            this._maxValue = this.toNum(value);
        }
        get valueStyle() {
            return this._valueStyle;
        }
        set valueStyle(value) {
            this._valueStyle = value;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        getExtents(w, h) {
            const cx = pickNum(this._centerX, w / 2);
            const cy = pickNum(this._centerY, h / 2);
            const rx = pickNum(this._radiusX, cx);
            const ry = pickNum(this._radiusY, cy);
            return { cx, cy, rx, ry };
        }
        getStyle() {
            if (!this._gaugeStyle) {
                this._gaugeStyle = Object.assign(Object.assign({}, GaugeRenderer.STYLE), this.style);
                this._gaugeStyle.fill = 'none';
            }
            return this._gaugeStyle;
        }
        getValueStyle() {
            if (!this._activeStyle) {
                this._activeStyle = Object.assign(Object.assign({}, GaugeRenderer.VALUE_STYLE), this.valueStyle);
                this._activeStyle.fill = 'none';
            }
            return this._activeStyle;
        }
        getValueRate(value) {
            return (value - this._minValue) / (this._maxValue - this._minValue);
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        type() {
            return GaugeRenderer.TYPE;
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    GaugeRenderer.TYPE = 'gauge';
    GaugeRenderer.STYLE = {
        stroke: '#eee',
        strokeWidth: '10px'
    };
    GaugeRenderer.VALUE_STYLE = {
        stroke: '#00c',
        strokeWidth: '10px'
    };

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     */
    class IconRenderer extends DListRenderer {
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        get iconSet() {
            return this._iconSet;
        }
        set iconSet(value) {
            this._iconSet = value;
        }
        get iconName() {
            return this._iconName;
        }
        set iconName(value) {
            this._iconName = value;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        type() {
            return IconRenderer.TYPE;
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    IconRenderer.TYPE = 'icon';

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     */
    class ImageRenderer extends ValueRenderer {
        constructor() {
            super(...arguments);
            this._decorative = false;
            this._nullWidth = 100;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        get imageWidth() {
            return this._imageWidth;
        }
        set imageWidth(value) {
            this._imageWidth = +value;
        }
        get imageHeight() {
            return this._imageHeight;
        }
        set imageHeight(value) {
            this._imageHeight = +value;
        }
        get root() {
            return this._root;
        }
        set root(value) {
            this._root = value || '';
        }
        get url() {
            return this._url;
        }
        set url(value) {
            this._url = value;
        }
        get urlCallback() {
            return this._urlCallback;
        }
        set urlCallback(value) {
            this._urlCallback = value;
        }
        get alt() {
            return this._alt;
        }
        set alt(value) {
            this._alt = value;
        }
        get decorative() {
            return this._decorative;
        }
        set decorative(value) {
            this._decorative = value;
        }
        get nullUrl() {
            return this._nullUrl;
        }
        set nullUrl(value) {
            this._nullUrl = value;
        }
        get nullWidth() {
            return this._nullWidth;
        }
        set nullWidth(value) {
            this._nullWidth = value;
        }
        get nullHeight() {
            return this._nullHeight;
        }
        set nullHeight(value) {
            this._nullHeight = value;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        getUrl(value) {
            const root = this._root || '';
            const cb = this._urlCallback;
            let isNull = false;
            let url;
            if (cb) {
                const s = cb({ value: value });
                if (s !== void 0) {
                    url = s;
                }
            }
            if (!url) {
                url = this._url || value;
            }
            if (!url) {
                url = this._nullUrl || '';
                isNull = true;
            }
            if (url) {
                url = root + url;
            }
            return { url, isNull };
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        type() {
            return ImageRenderer.TYPE;
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        $_inflateUrl(value) {
            return;
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    ImageRenderer.TYPE = 'image';

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     */
    class InputRendererBase extends BoundableRenderer {
        constructor() {
            super(...arguments);
            // private _label: string; // => aria-label
            this._autoHide = false;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        get boxWidth() {
            return this._boxWidth;
        }
        set boxWidth(value) {
            this._boxWidth = +value;
        }
        get boxHeight() {
            return this._boxHeight;
        }
        set boxHeight(value) {
            this._boxHeight = +value;
        }
        get autoHide() {
            return this._autoHide;
        }
        set autoHide(value) {
            this._autoHide = value;
        }
    }
    /**
     * @internal
     */
    class InputRenderer extends InputRendererBase {
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        get placeholder() {
            return this._placeholder;
        }
        set placeholder(value) {
            this._placeholder = value;
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        type() {
            return InputRenderer.TYPE;
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    InputRenderer.TYPE = 'input';
    /**
     * @internal
     *
     */
    class NumberRenderer extends InputRendererBase {
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        type() {
            return NumberRenderer.TYPE;
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    NumberRenderer.TYPE = 'number';

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     */
    class FormattableRenderer extends ValueRenderer {
        constructor() {
            super(...arguments);
            this._hiddenChar = '*';
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        get textFormatter() {
            return this._textFormatter;
        }
        set textFormatter(value) {
            this._textFormatter = value;
        }
        get boolFormatter() {
            return this._boolFormatter;
        }
        set boolFormatter(value) {
            this._boolFormatter = value;
        }
        get numberFormatter() {
            return this._numberFormatter;
        }
        set numberFormatter(value) {
            this._numberFormatter = value;
        }
        get dateFormatter() {
            return this._dateFormatter;
        }
        set dateFormatter(value) {
            this._dateFormatter = value;
        }
        get textFormat() {
            return this._textFormat;
        }
        set textFormat(value) {
            this._textFormat = value;
        }
        get boolFormat() {
            return this._boolFormat;
        }
        set boolFormat(value) {
            this._boolFormat = value;
        }
        get numberFormat() {
            return this._numberFormat;
        }
        set numberFormat(value) {
            this._numberFormat = value;
        }
        get dateFormat() {
            return this._dateFormat;
        }
        set dateFormat(value) {
            this._dateFormat = value;
        }
        get prefix() {
            return this._prefix;
        }
        set prefix(value) {
            this._prefix = value;
        }
        get suffix() {
            return this._suffix;
        }
        set suffix(value) {
            this._suffix = value;
        }
        get maxLength() {
            return this._maxLength;
        }
        set maxLength(value) {
            value = +value;
            this._maxLength = value;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        getText(ctx, value, sepReg) {
            const val = this._text !== void 0 ? this._text : value;
            if (val == null) {
                return this._getAltText(ctx) || '';
            }
            const t = typeof val;
            let s;
            if (t === 'string') {
                if (val) {
                    const f = this._textFormatter || getTextFormatter(this._textFormat) || ctx.textFormatter();
                    if (f) {
                        s = f(val);
                    }
                }
            }
            else if (t === 'number' || t === 'bigint') {
                if (!Number.isNaN(val)) {
                    const f = this._numberFormatter || getNumberFormatter(this._numberFormat) || ctx.numberFormatter();
                    if (f) {
                        s = f(val);
                    }
                }
                else if (typeof this._nanText == 'string') {
                    s = this._nanText;
                }
            }
            else if (val instanceof Date) {
                const f = this._dateFormatter || getDateFormatter(this._dateFormat) || ctx.dateFormatter();
                if (f) {
                    s = f(val);
                }
                else {
                    s = val.toLocaleDateString();
                }
            }
            else if (t === 'boolean') {
                const f = this._boolFormatter || getBoolFormatter(this._boolFormat) || ctx.boolFormatter();
                if (f) {
                    s = f(val);
                }
            }
            else ;
            if (s === void 0) {
                s = String(val) || '';
            }
            if (s) {
                if (this._hiddenRange && this._hiddenChar) {
                    const f = this._hiddenRange[0];
                    if (f >= 0) {
                        const len = s.length;
                        let t = pickNum(this._hiddenRange[1], len);
                        if (t < 0) {
                            t = s.length + t;
                        }
                        if (t > f) {
                            t = Math.min(t, len);
                            s = s.substring(0, f) + this._hiddenChar.repeat(t - f) + s.substring(t);
                        }
                    }
                }
                const sep = this._sepReg || sepReg;
                if (sep) {
                    s = s.replace(sep, '\n');
                }
                if (this._maxLength >= 0) {
                    s = s.substring(0, this._maxLength);
                }
            }
            if (this._prefix) {
                s = this._prefix + s;
            }
            if (this._suffix) {
                s += this._suffix;
            }
            return s;
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        /**
         * renderer에 text나 value도 설정되지 않고,
         * layout에 field도 설정되지 않은 경우 대체 택스트.
         */
        _getAltText(ctx) {
            return '';
        }
    }
    /**
     * @internal
     */
    class TextRenderer extends FormattableRenderer {
        constructor() {
            super(...arguments);
            //-------------------------------------------------------------------------
            // property fields
            //-------------------------------------------------------------------------
            this._wrap = false;
            this._singleLine = false;
        }
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        get wrap() {
            return this._wrap;
        }
        set wrap(value) {
            value = this.toBool(value);
            this._wrap = value;
        }
        get lineSeparator() {
            return Array.isArray(this._lineSeparator) ? this._lineSeparator.slice(0) : this._lineSeparator;
        }
        set lineSeparator(value) {
            if (value !== this._lineSeparator) {
                this._lineSeparator = Array.isArray(value) ? value.slice(0) : value;
                this._sepReg = Utils.makeLineSeparator(this._lineSeparator);
            }
        }
        get singleLine() {
            return this._singleLine;
        }
        set singleLine(value) {
            this._singleLine = value;
        }
        get text() {
            return this._text;
        }
        set text(value) {
            this._text = value;
        }
        get hiddenChar() {
            return this._hiddenChar;
        }
        set hiddenChar(value) {
            this._hiddenChar = value;
        }
        get hiddenRange() {
            return this._hiddenRange ? this._hiddenRange.slice(0) : void 0;
        }
        set hiddenRange(value) {
            this._hiddenRange = value ? value.slice(0) : void 0;
        }
        get nanText() {
            return this._nanText;
        }
        set nanText(value) {
            this._nanText = value;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        type() {
            return TextRenderer.TYPE;
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    TextRenderer.TYPE = 'text';

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     *
     */
    class LinkRenderer extends TextRenderer {
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        get root() {
            return this._root;
        }
        set root(value) {
            this._root = value || '';
        }
        get linkField() {
            return this._linkField;
        }
        set linkField(value) {
            this._linkField = value;
        }
        get link() {
            return this._link;
        }
        set link(value) {
            this._link = value;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        getLink(ctx) {
            let s = this._link;
            if (!s && this._linkField) {
                s = ctx.getValue(this._linkField);
            }
            if (this._root) {
                s = this._root + s;
            }
            return s || '';
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        type() {
            return LinkRenderer.TYPE;
        }
        _getAltText(ctx) {
            return this.getLink(ctx);
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    LinkRenderer.TYPE = 'link';

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     */
    class ProgressRenderer extends BoundableRenderer {
        constructor() {
            super(...arguments);
            this._minValue = 0;
            this._maxValue = 100;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /** barWidth */
        get barWidth() {
            return this._barWidth;
        }
        set barWidth(value) {
            this._barWidth = this.toNum(value);
        }
        /** barHeight */
        get barHeight() {
            return this._barHeight;
        }
        set barHeight(value) {
            this._barHeight = this.toNum(value);
        }
        /** minValue */
        get minValue() {
            return this._minValue;
        }
        set minValue(value) {
            this._minValue = +value;
        }
        /** maxValue */
        get maxValue() {
            return this._maxValue;
        }
        set maxValue(value) {
            this._maxValue = +value;
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        type() {
            return ProgressRenderer.TYPE;
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    ProgressRenderer.TYPE = 'progress';

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     */
    class MeterRenderer extends ProgressRenderer {
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /** lowValue */
        get lowValue() {
            return this._lowValue;
        }
        set lowValue(value) {
            this._lowValue = +value;
        }
        /** highValue */
        get highValue() {
            return this._highValue;
        }
        set highValue(value) {
            this._highValue = +value;
        }
        /** optimumValue */
        get optimumValue() {
            return this._optimumValue;
        }
        set optimumValue(value) {
            this._optimumValue = +value;
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        type() {
            return MeterRenderer.TYPE;
        }
        _checkMax(value) {
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    MeterRenderer.TYPE = 'meter';

    ////////////////////////////////////////////////////////////////////////////////
    var QrcodeOutputType;
    (function (QrcodeOutputType) {
        QrcodeOutputType["CANVAS"] = "canvas";
        QrcodeOutputType["SVG"] = "svg";
    })(QrcodeOutputType || (QrcodeOutputType = {}));
    var QrcodeErrorCorrectionLevel;
    (function (QrcodeErrorCorrectionLevel) {
        QrcodeErrorCorrectionLevel["L"] = "L";
        QrcodeErrorCorrectionLevel["M"] = "M";
        QrcodeErrorCorrectionLevel["Q"] = "Q";
        QrcodeErrorCorrectionLevel["H"] = "H";
    })(QrcodeErrorCorrectionLevel || (QrcodeErrorCorrectionLevel = {}));
    /**
     * @internal
     */
    class QrcodeRenderer extends ValueRenderer {
        constructor() {
            super(...arguments);
            this._qrcodeSize = QrcodeRenderer.DEF_SIZE;
            this._correctionLevel = QrcodeErrorCorrectionLevel.Q;
            //-------------------------------------------------------------------------
            // internal members
            //-------------------------------------------------------------------------
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        get output() {
            return this._output;
        }
        set output(value) {
            this._output = value;
        }
        get qrcodeWidth() {
            return this._qrcodeWidth;
        }
        set qrcodeWidth(value) {
            this._qrcodeWidth = Math.max(+value, QrcodeRenderer.MIN_SIZE);
        }
        get qrcodeHeight() {
            return this._qrcodeHeight;
        }
        set qrcodeHeight(value) {
            this._qrcodeHeight = Math.max(+value, QrcodeRenderer.MIN_SIZE);
        }
        get qrcodeSize() {
            return this._qrcodeSize;
        }
        set qrcodeSize(value) {
            this._qrcodeSize = Math.max(+value, QrcodeRenderer.MIN_SIZE);
        }
        get correctionLevel() {
            return this._correctionLevel;
        }
        set correctionLevel(value) {
            this._correctionLevel = value;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        getQrcodeSize() {
            return {
                w: pickNum3(this._qrcodeWidth, this._qrcodeSize, QrcodeRenderer.DEF_SIZE),
                h: pickNum3(this._qrcodeHeight, this._qrcodeSize, QrcodeRenderer.DEF_SIZE),
            };
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        type() {
            return QrcodeRenderer.TYPE;
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    QrcodeRenderer.TYPE = 'qrcode';
    // default props
    QrcodeRenderer.DEF_SIZE = 100;
    QrcodeRenderer.MIN_SIZE = 76;

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     */
    class RadioGroupRenderer extends DListRenderer {
        constructor() {
            super(...arguments);
            // private _orientation = DOrientation.HORIZONTAL;
            this._boxGap = 5;
            this._itemGap = 10;
            this._labelWrap = true;
            //-------------------------------------------------------------------------
            // internal members
            //-------------------------------------------------------------------------
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        get labels() {
            return this._labels && this._labels.slice(0);
        }
        set labels(value) {
            if (!Utils.equalArrays(value, this._labels)) {
                this._labels = value && value.slice(0);
            }
        }
        get values() {
            return this._values && this._values.slice(0);
        }
        set values(value) {
            if (!Utils.equalArrays(value, this._values)) {
                this._values = value && value.slice(0);
            }
        }
        get valueCount() {
            return this._values ? this._values.length : 0;
        }
        get boxSize() {
            return this._boxSize;
        }
        set boxSize(value) {
            this._boxSize = +value;
        }
        get boxWidth() {
            return this._boxWidth;
        }
        set boxWidth(value) {
            this._boxWidth = +value;
        }
        get boxHeight() {
            return this._boxHeight;
        }
        set boxHeight(value) {
            this._boxHeight = +value;
        }
        get boxGap() {
            return this._boxGap;
        }
        set boxGap(value) {
            this._boxGap = this.toNum(value, 0);
        }
        get itemGap() {
            return this._itemGap;
        }
        set itemGap(value) {
            this._itemGap = this.toNum(value, 0);
        }
        get labelWrap() {
            return this._labelWrap;
        }
        set labelWrap(value) {
            this._labelWrap = value;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        type() {
            return RadioGroupRenderer.TYPE;
        }
        _doClicked(control, row, field) {
            return super._doClicked(control, row, field);
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    RadioGroupRenderer.TYPE = 'radiogroup';

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     *
     */
    class RadioRenderer extends CheckRenderer {
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        get group() {
            return this._group;
        }
        set group(value) {
            this._group = value;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        type() {
            return RadioRenderer.TYPE;
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    RadioRenderer.TYPE = 'radio';

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     */
    class ShapeRenderer extends DListRenderer {
        constructor() {
            super(...arguments);
            //-------------------------------------------------------------------------
            // property fields
            //-------------------------------------------------------------------------
            this._shape = ShapeRenderer.DEF_SHAPE;
            this._shapeSize = ShapeRenderer.DEF_SIZE;
            this._decorative = false;
            //-------------------------------------------------------------------------
            // internal members
            //-------------------------------------------------------------------------
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        get shape() {
            return this._shape;
        }
        set shape(value) {
            this._shape = value;
        }
        get shapeWidth() {
            return this._shapeWidth;
        }
        set shapeWidth(value) {
            this._shapeWidth = +value;
        }
        get shapeHeight() {
            return this._shapeHeight;
        }
        set shapeHeight(value) {
            this._shapeHeight = +value;
        }
        get shapeSize() {
            return this._shapeSize;
        }
        set shapeSize(value) {
            this._shapeSize = +value;
        }
        get decorative() {
            return this._decorative;
        }
        set decorative(value) {
            this._decorative = value;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        getShapeName() {
            return this._shape || ShapeRenderer.DEF_SHAPE;
        }
        getShapeWidth() {
            return pickNum3(this._shapeWidth, this._shapeSize, this._shapeHeight);
        }
        getShapeHeight() {
            return pickNum3(this._shapeHeight, this._shapeSize, this._shapeWidth);
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        type() {
            return ShapeRenderer.TYPE;
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    ShapeRenderer.TYPE = 'shape';
    ShapeRenderer.DEF_SHAPE = '@star';
    ShapeRenderer.DEF_SIZE = 20;

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     */
    class RatingRenderer extends ShapeRenderer {
        constructor() {
            super(...arguments);
            //-------------------------------------------------------------------------
            // static members
            //-------------------------------------------------------------------------
            //-------------------------------------------------------------------------
            // property fields
            //-------------------------------------------------------------------------
            this._shapeCount = RatingRenderer.SHAPE_COUNT;
            this._minValue = 0;
            this._maxValue = RatingRenderer.SHAPE_COUNT;
            this._integral = true;
            this._editable = false;
            //-------------------------------------------------------------------------
            // internal members
            //-------------------------------------------------------------------------
        }
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        get shapeCount() {
            return this._shapeCount;
        }
        set shapeCount(value) {
            this._shapeCount = Math.max(this.toNum(+value, 0));
        }
        get minValue() {
            return this._minValue;
        }
        set minValue(value) {
            this._minValue = this.toNum(+value, 0);
        }
        get maxValue() {
            return this._maxValue;
        }
        set maxValue(value) {
            this._maxValue = this.toNum(+value, 0);
        }
        get integral() {
            return this._integral;
        }
        set integral(value) {
            this._integral = value;
        }
        get editable() {
            return this._editable;
        }
        set editable(value) {
            this._editable = value;
        }
        get valueStyle() {
            return this._valueStyle;
        }
        set valueStyle(value) {
            this._valueStyle = value;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        getStyle() {
            if (!this._shapeStyle) {
                this._shapeStyle = Object.assign(Object.assign({}, RatingRenderer.STYLE), this.style);
            }
            return this._shapeStyle;
        }
        getValueStyle() {
            if (!this._activeStyle) {
                this._activeStyle = Object.assign(Object.assign({}, RatingRenderer.VALUE_STYLE), this.valueStyle);
            }
            return this._activeStyle;
        }
        getValueRate(value) {
            return (value - this._minValue) / (this._maxValue - this._minValue);
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        type() {
            return RatingRenderer.TYPE;
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    RatingRenderer.TYPE = 'rating';
    // def props
    RatingRenderer.SHAPE_COUNT = 3;
    RatingRenderer.STYLE = {
        stroke: '#0088ff',
        strokeWidth: '2px'
    };
    RatingRenderer.VALUE_STYLE = {
        fill: '#0088ff',
        strokeWidth: '0px'
    };

    ////////////////////////////////////////////////////////////////////////////////
    var DListSelectSortMode;
    (function (DListSelectSortMode) {
        DListSelectSortMode["NONE"] = "none";
        DListSelectSortMode["GROUP"] = "group";
        DListSelectSortMode["LABEL"] = "label";
        DListSelectSortMode["ALL"] = "all";
    })(DListSelectSortMode || (DListSelectSortMode = {}));
    /**
     * @internal
     */
    class SelectRenderer extends BoundableRenderer {
        constructor() {
            super(...arguments);
            this._sortMode = DListSelectSortMode.NONE;
            this._sortDirection = DListSortDirection.ASCENDING;
            //-------------------------------------------------------------------------
            // fields
            //-------------------------------------------------------------------------
            this._itemsChanged = true;
            //-------------------------------------------------------------------------
            // internal members
            //-------------------------------------------------------------------------
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        get boxWidth() {
            return this._boxWidth;
        }
        set boxWidth(value) {
            this._boxWidth = +value;
        }
        get labels() {
            return this._labels ? this._labels.slice(0) : null;
        }
        set labels(value) {
            if (!Utils.equalArrays(value, this._labels)) {
                this._labels = value ? value.slice(0) : null;
                this._itemsChanged = true;
            }
        }
        get values() {
            return this._values ? this._values.slice(0) : null;
        }
        set values(value) {
            if (!Utils.equalArrays(value, this._values)) {
                this._values = value ? value.slice(0) : null;
                this._itemsChanged = true;
            }
        }
        get groups() {
            return this._groups ? this._groups.slice(0) : null;
        }
        set groups(value) {
            if (!Utils.equalArrays(value, this._groups)) {
                this._groups = value ? value.slice(0) : null;
                this._groupValues = [];
                this._groupLabels = [];
                if (value) {
                    for (let g of value) {
                        const values = g.values;
                        const labels = g.labels;
                        if (values) {
                            for (let i = 0; i < values.length; i++) {
                                this._groupValues.push(values[i]);
                                this._groupLabels.push(labels[i]);
                            }
                        }
                    }
                }
                this._itemsChanged = true;
            }
        }
        get isGrouped() {
            return this._groups && this._groups.length > 0;
        }
        get itemsChanged() {
            return this._itemsChanged;
        }
        get sortMode() {
            return this._sortMode;
        }
        set sortMode(value) {
            this._sortMode = value;
        }
        get sortDirection() {
            return this._sortDirection;
        }
        set sortDirection(value) {
            if (value !== this._sortDirection) {
                this._sortDirection = value;
                this._itemsChanged = true;
            }
        }
        // /**
        //  * select element의 size 속성.
        //  * 리스트 박스에 한 번에 표시하는 옵션 항목의 개수.
        //  */
        // get dropDownCount(): number {
        //     return this._dropdownCount;
        // }
        // set dropDownCount(value: number) {
        //     this._dropdownCount = value;
        // }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        type() {
            return SelectRenderer.TYPE;
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    SelectRenderer.TYPE = 'select';

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     */
    class SpacerRenderer extends DListRenderer {
        constructor() {
            super(...arguments);
            //-------------------------------------------------------------------------
            // static members
            //-------------------------------------------------------------------------
            //-------------------------------------------------------------------------
            // property fields
            //-------------------------------------------------------------------------
            this._space = SpacerRenderer.SPACE;
            //-------------------------------------------------------------------------
            // internal members
            //-------------------------------------------------------------------------
        }
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        get space() {
            return this._space;
        }
        set space(value) {
            this._space = +value || 0;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        type() {
            return SpacerRenderer.TYPE;
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    SpacerRenderer.TYPE = 'spacer';
    // default props
    SpacerRenderer.SPACE = 10;

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     */
    class SparkRenderer extends ValueRenderer {
        constructor() {
            super(...arguments);
            this._pointWidth = 10;
            this._minPadding = 0.1;
            //-------------------------------------------------------------------------
            // methods
            //-------------------------------------------------------------------------
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        get chartWidth() {
            return this._chartWidth;
        }
        set chartWidth(value) {
            this._chartWidth = value;
        }
        get chartHeight() {
            return this._chartHeight;
        }
        set chartHeight(value) {
            this._chartHeight = value;
        }
        get pointWidth() {
            return this._pointWidth;
        }
        set pointWidth(value) {
            this._pointWidth = Math.max(1, +value, 0);
        }
        get baseValue() {
            return this._baseValue;
        }
        set baseValue(value) {
            this._baseValue = this.toNum(value);
        }
        get minValue() {
            return this._minValue;
        }
        set minValue(value) {
            this._minValue = +value;
        }
        get maxValue() {
            return this._maxValue;
        }
        set maxValue(value) {
            this._maxValue = +value;
        }
        get minPadding() {
            return this._minPadding;
        }
        set minPadding(value) {
            this._minPadding = this.toNum(value);
        }
        get firstStyle() {
            return this._firstStyle;
        }
        set firstStyle(value) {
            this._firstStyle = value;
        }
        get lastStyle() {
            return this._lastStyle;
        }
        set lastStyle(value) {
            this._lastStyle = value;
        }
        get minStyle() {
            return this._minStyle;
        }
        set minStyle(value) {
            this._minStyle = value;
        }
        get maxStyle() {
            return this._maxStyle;
        }
        set maxStyle(value) {
            this._maxStyle = value;
        }
        get pointStyle() {
            return this._pointStyle;
        }
        set pointStyle(value) {
            this._pointStyle = value;
        }
    }
    /**
     * @internal
     *
     */
    class SparkLineRenderer extends SparkRenderer {
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        type() {
            return SparkLineRenderer.TYPE;
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    SparkLineRenderer.TYPE = 'sparkline';
    /**
     * @internal
     */
    class SparkBarRenderer extends SparkRenderer {
        constructor() {
            super(...arguments);
            //-------------------------------------------------------------------------
            // property fields
            //-------------------------------------------------------------------------
            this._pointSize = 0.7;
            this._belowSize = 0.4;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        get pointSize() {
            return this._pointSize;
        }
        set pointSize(value) {
            this._pointSize = +value || 0.1;
        }
        get belowSize() {
            return this._belowSize;
        }
        set belowSize(value) {
            this._belowSize = this.toNum(value);
        }
        /**
         * {@link baseValue} 아래쪽 point들의 기본 스타일.
         */
        get belowStyle() {
            return this._belowStyle;
        }
        set belowStyle(value) {
            this._belowStyle = value;
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        type() {
            return SparkBarRenderer.TYPE;
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    SparkBarRenderer.TYPE = 'sparkbar';

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     */
    class SvgRenderer extends ValueRenderer {
        constructor() {
            super(...arguments);
            this._svgWidth = SvgRenderer.DEF_SIZE;
            this._svgHeight = SvgRenderer.DEF_SIZE;
            this._vboxWidth = NaN;
            this._vboxHeight = NaN;
            this._decorative = false;
            //-------------------------------------------------------------------------
            // internal members
            //-------------------------------------------------------------------------
        }
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        get shapes() {
            return Array.isArray(this._shapes) ? this._shapes.slice(0) : this._shapes;
        }
        set shapes(value) {
            this._shapes = value;
        }
        get svgWidth() {
            return this._svgWidth;
        }
        set svgWidth(value) {
            this._svgWidth = value;
        }
        get svgHeight() {
            return this._svgHeight;
        }
        set svgHeight(value) {
            this._svgHeight = value;
        }
        get vboxWidth() {
            return this._vboxWidth;
        }
        set vboxWidth(value) {
            this._vboxWidth = value;
        }
        get vboxHeight() {
            return this._vboxHeight;
        }
        set vboxHeight(value) {
            this._vboxHeight = value;
        }
        get decorative() {
            return this._decorative;
        }
        set decorative(value) {
            this._decorative = value;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        getVboxWidth() {
            return pickNum(this._vboxWidth, this._vboxHeight);
        }
        getVboxHeight() {
            return pickNum(this._vboxHeight, this._vboxWidth);
        }
        getSvgWidth() {
            return pickNum(this._svgWidth, this._svgHeight);
        }
        getSvgHeight() {
            return pickNum(this._svgHeight, this._svgWidth);
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        type() {
            return SvgRenderer.TYPE;
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    SvgRenderer.TYPE = 'svg';
    SvgRenderer.DEF_SIZE = 24;

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     */
    class SwitchRenderer extends BoolRenderer {
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        get boxSize() {
            return this._boxSize;
        }
        set boxSize(value) {
            this._boxSize = +value;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        type() {
            return SwitchRenderer.TYPE;
        }
        _doClicked(control, row, field) {
            return super._doClicked(control, row, field);
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    SwitchRenderer.TYPE = 'switch';

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     */
    class LabelRenderer extends TextRenderer {
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /** target */
        get target() {
            return this._target;
        }
        set target(value) {
            this._target = value;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        type() {
            return LabelRenderer.TYPE;
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    LabelRenderer.TYPE = 'label';

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     */
    class LetterRenderer extends DListRenderer {
        constructor() {
            super(...arguments);
            //-------------------------------------------------------------------------
            // property fields
            //-------------------------------------------------------------------------
            this._letter = LetterRenderer.DEF_LETTER;
            this._offsetX = 0;
            this._offsetY = 0.1;
            this._decorative = false;
            //-------------------------------------------------------------------------
            // internal members
            //-------------------------------------------------------------------------
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        get letter() {
            return this._letter;
        }
        set letter(value) {
            this._letter = value ? value.charAt(0) : '';
        }
        get offsetX() {
            return this._offsetX;
        }
        set offsetX(value) {
            this._offsetX = this.toNum(value, 0);
        }
        get offsetY() {
            return this._offsetY;
        }
        set offsetY(value) {
            this._offsetY = this.toNum(value, 0);
        }
        get decorative() {
            return this._decorative;
        }
        set decorative(value) {
            this._decorative = value;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        getChar() {
            return this._letter || LetterRenderer.DEF_LETTER;
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        type() {
            return LetterRenderer.TYPE;
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    LetterRenderer.TYPE = 'letter';
    // static readonly DEF_LETTER = '😀';
    LetterRenderer.DEF_LETTER = '♥';

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     */
    class LineRenderer extends DListRenderer {
        constructor() {
            super(...arguments);
            this._thickness = 1;
            //-------------------------------------------------------------------------
            // internal members
            //-------------------------------------------------------------------------
        }
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        get dir() {
            return this._dir;
        }
        set dir(value) {
            this._dir = value;
        }
        get thickness() {
            return this._thickness;
        }
        set thickness(value) {
            this._thickness = this.toNum(value, 0);
        }
        get lineColor() {
            return this._lineColor;
        }
        set lineColor(value) {
            this._lineColor = value;
        }
        get lineStyle() {
            return this._lineStyle;
        }
        set lineStyle(value) {
            this._lineStyle = value;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        type() {
            return LineRenderer.TYPE;
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    LineRenderer.TYPE = 'line';

    ////////////////////////////////////////////////////////////////////////////////
    const SVGNS = "http://www.w3.org/2000/svg";
    class DSvg extends DObject {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(svg, className) {
            super();
            if (svg instanceof Document) {
                this.svg = svg.createElementNS(SVGNS, 'svg');
            }
            else {
                this.svg = svg;
            }
            className && this.svg.classList.add(className);
        }
        //-------------------------------------------------------------------------
        // static members
        //-------------------------------------------------------------------------
        static create(doc) {
            return doc.createElementNS(SVGNS, 'svg');
        }
        _doDestory() {
            this.svg = null;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        attach(parent) {
            parent.appendChild(this.svg);
            return this;
        }
        detach() {
            this.svg.parentElement && this.svg.remove();
        }
        setClass(className) {
            this.svg.setAttribute('class', '');
            className && this.svg.classList.add(className);
        }
        addClass(className) {
            className && this.svg.classList.add(className);
        }
        setStyle(style) {
            style && Object.assign(this.svg.style, style);
        }
        setViewSize(w, h) {
            if (!isNaN(w)) {
                h = h || w;
                Dom.resizeSVG(this.svg, w, h);
            }
        }
        clearViewSize() {
            this.svg.removeAttribute('viewBox');
        }
        setSize(w, h) {
            this.svg.style.width = !isNaN(w) ? w + 'px' : '';
            this.svg.style.height = !isNaN(h) ? h + 'px' : '';
        }
        fillSize() {
            this.svg.style.width = '100%';
            this.svg.style.height = '100%';
        }
        makeBackground(width, height) {
            this.svg.style.pointerEvents = 'none';
            this.svg.style.verticalAlign = 'middle';
            !isNaN(width) && Dom.resize(this.svg, width, height || width);
            return this;
        }
        clear() {
            Dom.clearChildren(this.svg);
        }
        rect(x, y, w, h, style) {
            const r = this.svg.ownerDocument.createElementNS(SVGNS, 'rect');
            r.x.baseVal.value = x;
            r.y.baseVal.value = y;
            r.width.baseVal.value = w;
            r.height.baseVal.value = h;
            style && Object.assign(r.style, style);
            this.svg.appendChild(r);
            return r;
        }
        circle(cx, cy, radius, style) {
            const svg = this.svg;
            const doc = svg.ownerDocument;
            const circle = doc.createElementNS(SVGNS, 'circle');
            circle.cx.baseVal.value = cx;
            circle.cy.baseVal.value = cy;
            circle.r.baseVal.value = radius;
            style && Object.assign(circle.style, style);
            svg.appendChild(circle);
            return circle;
        }
        line(x1, y1, x2, y2, style) {
            let d = `M ${x1} ${y1} L ${x2} ${y2}`;
            const path = this._createPath(d);
            style && Object.assign(path.style, style);
            return path;
        }
        polyline(pts, style) {
            let d = `M ${pts[0]} ${pts[1]} L`;
            for (let i = 1, n = (pts.length / 2) >> 0; i < n; i++) {
                d += ` ${pts[i * 2]} ${pts[i * 2 + 1]}`;
            }
            const path = this._createPath(d);
            style && Object.assign(path.style, style);
            path.style.fill = 'none';
            return path;
        }
        polylgon(pts, style) {
            let d = `M ${pts[0]} ${pts[1]} L`;
            for (let i = 1, n = (pts.length / 2) >> 0; i < n; i++) {
                d += ` ${pts[i * 2]} ${pts[i * 2 + 1]}`;
            }
            d += 'z';
            const path = this._createPath(d);
            style && Object.assign(path.style, style);
            return path;
        }
        quadratic(x1, y1, x2, y2, x3, y3, style) {
            const d = `M ${x1} ${y1} Q ${x2} ${y2} ${x3} ${y3} z`;
            const path = this._createPath(d);
            style && Object.assign(path.style, style);
            return path;
        }
        arc(cx, cy, rx, ry, startAngle, angle, clockwise, style) {
            angle = Math.min(359.99999, angle);
            const endAngle = clockwise ? startAngle + angle : startAngle - angle;
            const start = this.$_angleToPos(cx, cy, rx, ry, startAngle, clockwise);
            const end = this.$_angleToPos(cx, cy, rx, ry, endAngle, clockwise);
            const largeArcFlag = clockwise ? (endAngle - startAngle >= 180 ? 1 : 0) : (endAngle - startAngle <= 180 ? 1 : 0);
            const sweepFlag = clockwise ? 1 : 0;
            const d = `M${start.x},${start.y} A${rx},${ry},0,${largeArcFlag},${sweepFlag},${end.x},${end.y}`;
            const path = this._createPath(d);
            style && Object.assign(path.style, style);
            return path;
        }
        path(d) {
            return this._createPath(d);
        }
        setShape(shape, clear = false) {
            clear && this.clear();
            this.setViewSize(shape.width, shape.height);
            this._createPath(shape.path);
            return this;
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        _createPath(d) {
            const p = this.svg.ownerDocument.createElementNS(SVGNS, 'path');
            p.setAttribute('d', d);
            this.svg.appendChild(p);
            return p;
        }
        $_angleToPos(cx, cy, rx, ry, angle, clockwise) {
            //angle = (angle - 90) * Math.PI / 180.0;
            angle = angle * Math.PI / 180.0;
            return {
                x: cx + (rx * Math.cos(angle)),
                y: cy + (ry * Math.sin(angle))
            };
        }
        _animateRevert(path, from, to, duration) {
            const ani = this.svg.ownerDocument.createElementNS(SVGNS, 'animate');
            ani.setAttribute('attributeName', 'd');
            ani.setAttribute('dur', duration + 'ms');
            // ani.setAttribute('fill', 'freeze');
            // ani.setAttribute('calcMode', 'spline');
            // ani.setAttribute('keySplines', '0 0.75 0.25 1');
            // from && ani.setAttribute('from', from);
            // to && ani.setAttribute('to', to);
            ani.setAttribute('values', from + ';' + to + ';' + from);
            path.appendChild(ani);
        }
    }
    /*
    let _clip_id = 0;

    export class SvgRenderer extends DObject  {

        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        private _element: SVGElement;
        private _defs: SVGDefsElement;
        private _transforms: any[] = [];
        private _trans: any;

        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(defs?: SVGDefsElement, element?: SVGElement) {
            super();

            this._defs = defs;
            this._element = element;
        }

        protected _doDestory(): void {
            this.clear();
        }

        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        private get doc(): Document {
            return (this._element && this._element.ownerDocument) || document;
        }

        get element(): SVGElement {
            return this._element;
        }

        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        init(defs: SVGDefsElement, element: SVGElement): SvgRenderer {
            this._defs = defs;
            this._element = element;
            return this;
        }

        clear(): void {
            this._defs = null;
            this._element = null;
            this._transforms = null;
        }

        setSvg(svg: string): void {
            this._element.innerHTML = svg;
        }

        save(): void {
            this._transforms.push(this._trans);
            this._trans = "";
        }

        restore(): void {
            this._trans = this._transforms.pop();
        }

        translate(x: number, y: number): void {
            this._trans += `translate(${x},${y})`;
        }

        rotate(angle: number): void {
            this._trans += `rotate(${angle * 180 / Math.PI})`;
        }

        rotateAt(angle: number, x: number, y: number): void {
            this._trans += `rotate(${angle * 180 / Math.PI},${x},${y})`;
        }

        scale(x: number, y: number): void {
            this._trans += `scale(${x},${y})`;
        }

        clipRect(r: IRect): void {
            this.clip(r.x, r.y, r.width, r.height);
        }

        clip(x: number, y: number, w: number, h: number): void {
            const doc = this.doc;
            const id = _clip_id++;
            const clip = doc.createElementNS(SVGNS, "clipPath");

            clip.setAttributeNS(null, "id", "clip" + id);

            const rect = doc.createElementNS(SVGNS, "rect");

            rect.x.baseVal.value = x;
            rect.y.baseVal.value = y;
            rect.width.baseVal.value = w;
            rect.height.baseVal.value = h;
            
            clip.appendChild(rect);
            this._defs.appendChild(clip);
        }

        line(style: any, x1: number, y1: number, x2: number, y2: number): SVGElement {
            const elt = this.doc.createElementNS(SVGNS, "line");

            elt.x1.baseVal.value = x1;
            elt.y1.baseVal.value = y1;
            elt.x2.baseVal.value = x2;
            elt.y2.baseVal.value = y2;

            this.$_setStyle(elt, style);
            this._element.appendChild(elt);
            return elt;
        }

        sline(style: any, x1: string, y1: string, x2: string, y2: string): SVGElement {
            const elt = this.doc.createElementNS(SVGNS, "line");

            elt.x1.baseVal.valueAsString = x1;
            elt.y1.baseVal.valueAsString = y1;
            elt.x2.baseVal.valueAsString = x2;
            elt.y2.baseVal.valueAsString = y2;

            this.$_setStyle(elt, style);
            this._element.appendChild(elt);
            return elt;
        }

        lines(style: any, ...pts: string[]): void {
            if (!pts || pts.length < 4) return;

            const elt = this.doc.createElementNS(SVGNS, "polyline");
            const points = [];

            points.push(pts[0] + "," + pts[1]);
            for (let i = 2; i < pts.length; i += 2) {
                points.push(pts[i] + "," + pts[i + 1]);
            }

            elt.setAttributeNS(null, 'points', points.join(" "));
            this.$_setStyle(elt, style);
            this._element.appendChild(elt);
        }

        polygon(style: any, pts: number[]): SVGElement {
            if (!pts || pts.length < 4) return;

            const elt = this.doc.createElementNS(SVGNS, "polygon");
            const points = [];

            points.push(pts[0] + "," + pts[1]);
            for (let i = 2; i < pts.length; i += 2) {
                points.push(pts[i] + "," + pts[i + 1]);
            }

            this._trans && elt.setAttributeNS(null, 'transform', this._trans);
            elt.setAttributeNS(null, 'points', points.join(" "));
            this.$_setStyle(elt, style);

            this._element.appendChild(elt);
            return elt;
        }

        quadratic(style: any, x1: number, y1: number, x2: number, y2: number, x3: number, y3: number): void {
            const elt: SVGPathElement = this.doc.createElementNS(SVGNS, "path");

            elt.setAttributeNS(null, 'd', ['M', x1, y1, 'Q', x2, y2, x3, y3].join(' '));
            this.$_setStyle(elt, style);

            this._element.appendChild(elt);
        }

        squadratic(style: any, x1: number, y1: number, x2: number, y2: number, x3: number, y3: number): void {
            const elt: SVGPathElement = this.doc.createElementNS(SVGNS, "path");
            
            elt.setAttributeNS(null, 'd', ['M', x1 + "%", y1 + "%", 'Q', x2 + "%", y2 + "%", x3 + "%", y3 + "%"].join(' '));
            this.$_setStyle(elt, style);
            
            this._element.appendChild(elt);
        }

        curve(style: any, ...pts: number[]): void {
            const cmds = this.$_getCurvedLinePath(pts, 0, pts.length - 1);

            if (cmds) {
                const elt = this.doc.createElementNS(SVGNS, "path");
                
                elt.setAttributeNS(null, 'd', cmds.join(' '));
                this.$_setStyle(elt, style);

                this._element.appendChild(elt);
            }
        }

        scurve(style: any, ...pts: number[]): void {
            const cmds = this.$_getCurvedLinePath(pts, 0, pts.length - 1);

            if (cmds) {
                const elt = this.doc.createElementNS(SVGNS, "path");
                
                for (let i = 0; i < cmds.length; i++) {
                    if (typeof cmds[i] === "number") {
                        cmds[i] = cmds[i] + "%";
                    }
                }
                elt.setAttributeNS(null, 'd', cmds.join(' '));
                this.$_setStyle(elt, style);

                this._element.appendChild(elt);
            }
        }

        curveRange(fill: string, stroke: string, width: number, pts1: number[], pts2: number[]): void {
            if (pts1 && pts1.length > 1 && pts2 && pts2.length > 1 && (fill || stroke)) {
                let cmds1 = this.$_getCurvedLinePath(pts1, 0, pts1.length / 2 - 1, true);

                if (cmds1) {
                    cmds1.push("L", pts2[pts2.length  - 2], [pts2.length  - 1]);

                    const cmds2 = this.$_getCurvedLinePath(pts2, pts2.length / 2 - 1, 0, false);

                    if (cmds2) {
                        cmds1 = cmds1.concat(cmds2);
                    }
                    cmds1.push("L", pts1[0], pts1[1]);

                    const elt = this.doc.createElementNS(SVGNS, "path");

                    elt.setAttributeNS(null, 'd', cmds1.join(' '));
                    this.$_fillOrStroke(elt, fill, stroke, width);

                    this._element.appendChild(elt);
                }
            }
        }

        rect(style: any, r: IRect): void {
            const elt = this.doc.createElementNS(SVGNS, "rect");

            elt.x.baseVal.value = r.x;
            elt.y.baseVal.value = r.y;
            elt.width.baseVal.value = r.width;
            elt.height.baseVal.value = r.height;

            this.$_setStyle(elt, style);
            this._element.appendChild(elt);
        }

        srect(style: any, r: IRect): void {
            const elt = this.doc.createElementNS(SVGNS, "rect");

            elt.x.baseVal.valueAsString = r.x + "%";
            elt.y.baseVal.valueAsString = r.y + "%";
            elt.width.baseVal.valueAsString = r.width + "%";
            elt.height.baseVal.valueAsString = r.height + "%";

            this.$_setStyle(elt, style);
            this._element.appendChild(elt);
        }

        bounds(style: any, x: number, y: number, w: number, h: number): void {
            const elt = this.doc.createElementNS(SVGNS, "rect");

            elt.x.baseVal.value = x;
            elt.y.baseVal.value = h < 0 ? y + h : y;
            elt.width.baseVal.value = w;
            elt.height.baseVal.value = Math.abs(h);

            this.$_setStyle(elt, style);
            this._element.appendChild(elt);
        }

        pbounds(style: any, x: number, y: number, w: number, h: number): void {
            const elt = this.doc.createElementNS(SVGNS, "rect");

            elt.x.baseVal.valueAsString = x + "%";
            elt.y.baseVal.valueAsString = (h < 0 ? y + h : y) + "%";
            elt.width.baseVal.valueAsString = w + "%";
            elt.height.baseVal.valueAsString = Math.abs(h) + "%";

            this.$_setStyle(elt, style);
            this._element.appendChild(elt);
        }

        sbounds(style: any, x: string, y: string, w: string, h: string): void {
            const elt = this.doc.createElementNS(SVGNS, "rect");

            elt.x.baseVal.valueAsString = x;
            elt.y.baseVal.valueAsString = y;
            elt.width.baseVal.valueAsString = w;
            elt.height.baseVal.valueAsString = h;

            this.$_setStyle(elt, style);
            this._element.appendChild(elt);
        }

        circle(style: any, cx: number, cy: number, rd: number): void {
            const elt = this.doc.createElementNS(SVGNS, "circle");

            elt.cx.baseVal.value = cx;
            elt.cy.baseVal.value = cy;
            elt.r.baseVal.value = rd;
        
            this.$_setStyle(elt, style);
            this._element.appendChild(elt);
        }

        scircle(style: any, cx: string, cy: string, rd: string): void {
            const elt = this.doc.createElementNS(SVGNS, "circle");

            elt.cx.baseVal.valueAsString = cx;
            elt.cy.baseVal.valueAsString = cy;
            elt.r.baseVal.valueAsString = rd;
        
            this.$_setStyle(elt, style);
            this._element.appendChild(elt);
        }

        circleRect(style: any, width: number, x: number, y: number, w: number, h: number): void {
            const elt = this.doc.createElementNS(SVGNS, "circle");
            const cx = x + w / 2;
            const cy = y + h / 2;
            const rd = Math.min(w, h) / 2;

            elt.cx.baseVal.value = cx;
            elt.cy.baseVal.value = cy;
            elt.r.baseVal.value = rd;
        
            this.$_setStyle(elt, style);
            this._element.appendChild(elt);
        }

        scircleRect(style: any, x: number, y: number, w: number, h: number): void {
            const elt = this.doc.createElementNS(SVGNS, "circle");
            const cx = x + w / 2;
            const cy = y + h / 2;
            const rd = Math.min(w, h) / 2;

            elt.cx.baseVal.valueAsString = cx + "%";
            elt.cy.baseVal.valueAsString = cy + "%";
            elt.r.baseVal.valueAsString = rd + "%";
        
            this.$_setStyle(elt, style);
            this._element.appendChild(elt);
        }

        ellipse(style: any, cx: number, cy: number, rx: number, ry: number): SVGElement {
            const elt = this.doc.createElementNS(SVGNS, "ellipse");

            elt.cx.baseVal.value = cx;
            elt.cy.baseVal.value = cy;
            elt.rx.baseVal.value = rx;
            elt.ry.baseVal.value = ry;
            
            this.$_setStyle(elt, style);
            this._element.appendChild(elt);
            return elt;
        }

        sellipse(style: any, cx: number, cy: number, rx: number, ry: number): void {
            const elt = this.doc.createElementNS(SVGNS, "ellipse");

            elt.cx.baseVal.valueAsString = cx + "%";
            elt.cy.baseVal.valueAsString = cy + "%";
            elt.rx.baseVal.valueAsString = rx + "%";
            elt.ry.baseVal.valueAsString = ry + "%";
            
            this.$_setStyle(elt, style);
            this._element.appendChild(elt);
        }

        ellipseRect(style: any, x: number, y: number, w: number, h: number): SVGElement {
            const elt = this.doc.createElementNS(SVGNS, "ellipse");
            const rx = w / 2;
            const ry = h / 2;

            elt.cx.baseVal.value = x + rx;
            elt.cy.baseVal.value = y + ry;
            elt.rx.baseVal.value = rx;
            elt.ry.baseVal.value = ry;
            
            this.$_setStyle(elt, style);
            this._element.appendChild(elt);
            return elt;
        }

        sellipseRect(style: any, x: number, y: number, w: number, h: number): void {
            const elt = this.doc.createElementNS(SVGNS, "ellipse");
            const rx = w / 2;
            const ry = h / 2;

            elt.cx.baseVal.valueAsString = (x + rx) + "%";
            elt.cy.baseVal.valueAsString = (y + ry) + "%";
            elt.rx.baseVal.valueAsString = rx + "%";
            elt.ry.baseVal.valueAsString = ry + "%";
            
            this.$_setStyle(elt, style);
            this._element.appendChild(elt);
        }

        text(style: any, font: string, fontSize: number, color: string, deco: string, text: string, x: number, y: number, align: string) {
            const elt = this.doc.createElementNS(SVGNS, "text");

            font = font || "Verdana";

            elt.setAttributeNS(null, "y", y + "");
            elt.setAttributeNS(null, "dy", "top"); // top : 1em, middle: .5em, bottom : "".
            elt.setAttributeNS(null, "x", x + "");
            elt.setAttributeNS(null, "text-anchor", align);
            elt.setAttributeNS(null, "font-family", font);
            elt.setAttributeNS(null, "font-size", fontSize + "");
            deco && elt.setAttributeNS(null, "text-decoration", deco);

            elt.textContent = text;
            this.$_setStyle(elt, style);
            this._element.appendChild(elt);
        }

        stext(style: any, text: string, x: number, y: number, align: string) {
            const elt = this.doc.createElementNS(SVGNS, "text");

            elt.setAttributeNS(null, "y", y + "%");
            elt.setAttributeNS(null, "dy", "top"); // top : 1em, middle: .5em, bottom : "".
            elt.setAttributeNS(null, "x", x + "%");

            elt.textContent = text;
            this.$_setStyle(elt, style);
            this._element.appendChild(elt);
        }

        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        private $_setStyle(elt: SVGElement, style: any): void {
            if (typeof style === 'string') {
                elt.setAttribute("class", style);
            } else if (style) {
                Object.assign(elt.style, style);
            }
        }

        private $_stroke(elt: SVGGraphicsElement, color: string, width: number): void {
            elt.style.fill = "none";
            elt.style.stroke = color;
            if (!isNaN(width)) {
                elt.style.strokeWidth = width + "";
            }
        }

        private $_fill(elt: SVGGraphicsElement, color: string): void {
            elt.style.fill = color;
        }

        private $_fillOrStroke(elt: SVGGraphicsElement, fill: string, stroke: string, width: number): void {
            if (stroke) {
                elt.style.stroke = stroke;
                if (!isNaN(width)) {
                    elt.style.strokeWidth = width + "";
                }
            }
            if (fill) {
                elt.style.fill = fill;
            } else {
                elt.style.fill = "none";
            }
        }

        private $_getCurvedLinePath(pts: number[], start: number, end: number, moving = true): any[] {
            if (pts && end != start && pts.length / 2 > end) {
                const points: any[] = [];
                const reverse = start > end;
                const delta = reverse ? -1 : 1;
                let p = start;

                if (moving) {
                    points.push("M", pts[p * 2], pts[p * 2 + 1]);
                }
                if (Math.abs(end - start) == 2) {
                    points.push("L", pts[(p + delta) * 2], pts[(p + delta) * 2 + 1]);
                    return points;
                }

                const tension = 0.25;
                const tanLeft = { x: 0, y: 0 };
                const tanRight = { x: 0, y: 0 };

                const v1 = { x: 0, y: 0 };
                const v2 = { x: pts[(p + delta) * 2] - pts[p * 2], y: pts[(p + delta) * 2 + 1] - pts[p * 2 + 1] };
                let tan = { x: 0, y: 0 };
                const p1 = { x: 0, y: 0 };
                const p2 = { x: 0, y: 0 };
                const mp = { x: 0, y: 0 };

                let len = Math.sqrt(v2.x * v2.x + v2.y * v2.y);
                v2.x /= len;
                v2.y /= len;

                let tanLenFactor = pts[(p + delta) * 2] - pts[p * 2];
                let prevX = pts[p * 2];
                let prevY = pts[p * 2 + 1];

                for (p += delta; p != end; p += delta) {
                    v1.x = -v2.x;
                    v1.y = -v2.y;

                    v2.x = pts[(p + delta) * 2] - pts[p * 2];
                    v2.y = pts[(p + delta) * 2] - pts[p * 2 + 1];

                    len = Math.sqrt(v2.x * v2.x + v2.y * v2.y);
                    v2.x /= len;
                    v2.y /= len;

                    if (v2.x < v1.x) {
                        tan.x = v1.x - v2.x;
                        tan.y = v1.y - v2.y;
                    } else {
                        tan.x = v2.x - v1.x;
                        tan.y = v2.y - v1.y;
                    }

                    const tanlen = Math.sqrt(tan.x * tan.x + tan.y * tan.y);

                    tan.x /= tanlen;
                    tan.y /= tanlen;

                    if (v1.y * v2.y >= 0) {
                        tan = { x: 1, y: 0 };
                    }

                    tanLeft.x = -tan.x * tanLenFactor * tension;
                    tanLeft.y = -tan.y * tanLenFactor * tension;

                    if (p == (delta + start)) {
                        points.push("Q", pts[p * 2] + tanLeft.x, pts[p * 2 + 1] + tanLeft.y, pts[p * 2], pts[p * 2 + 1]);
                    } else {
                        p1.x = prevX + tanRight.x;
                        p1.y = prevY + tanRight.y;

                        p2.x = pts[p * 2] + tanLeft.x;
                        p2.y = pts[p * 2 + 1] + tanLeft.y;

                        mp.x = (p1.x + p2.x) / 2;
                        mp.y = (p1.y + p2.y) / 2;

                        points.push("Q", p1.x, p1.y, mp.x, mp.y);
                        points.push("Q", p2.x, p2.y, pts[p * 2], pts[p * 2 + 1]);
                    }

                    tanLenFactor = pts[(p + delta) * 2] - pts[p * 2];
                    tanRight.x = tan.x * tanLenFactor * tension;
                    tanRight.y = tan.y * tanLenFactor * tension;
                    prevX = pts[p * 2];
                    prevY = pts[p * 2 + 1];
                }

                points.push("Q", prevX + tanRight.x, prevY + tanRight.y, pts[p * 2], pts[p * 2 + 1]);
                return points;
            }
        }
    }
    */

    ////////////////////////////////////////////////////////////////////////////////
    var DListSpinnerType;
    (function (DListSpinnerType) {
        /**
         * 작은 원들이 표시된다.
         * <br>
         */
        DListSpinnerType["DEFAULT"] = "default";
        /**
         * 바퀴 살들이 표시된다.
         * <br>
         */
        DListSpinnerType["SPOKES"] = "spokes";
        // CIRCLES = 'circle',
        // DOTS = 'dots',
        // ARC = 'arc'
    })(DListSpinnerType || (DListSpinnerType = {}));
    /**
     * @internal
     *
     * Svg spinner.
     */
    class DSpinner {
        //-------------------------------------------------------------------------
        // static members
        //-------------------------------------------------------------------------
        static render(doc, svg, spinner) {
            switch (spinner.type) {
                case DListSpinnerType.SPOKES:
                    DSpinner.spoke(doc, svg, spinner);
                    break;
                // case DListSpinnerType.ARC:
                // case DListSpinnerType.CIRCLES:
                // case DListSpinnerType.DOTS:
                case DListSpinnerType.DEFAULT:
                default:
                    DSpinner.default(doc, svg, spinner);
                    break;
            }
        }
        /**
         * 지정된 수만큼 작은 원들을 표시하고 회전 효과를 준다.
         */
        static default(doc, svg, spinner) {
            const cs = getComputedStyle(svg);
            const cx = spinner.width / 2;
            const cy = spinner.height / 2;
            const r = Math.min(cx, cy) * 2 / 3;
            const small = spinner.width <= 30;
            const rd = small ? 2 : 5;
            const c1 = '#f0f0f0';
            const c2 = cs.fill || '#404040';
            const cols = [c1, c1, c2, c1, c1].join(';');
            const n = pickNum(spinner.itemCount, 12);
            const dur = pickNum(spinner.duration, 1000) + 'ms';
            for (let i = 0; i < n; i++) {
                const circle = doc.createElementNS(SVGNS, 'circle');
                const deg = i / n * Math.PI * 2;
                circle.cx.baseVal.value = cx + r * Math.cos(deg);
                circle.cy.baseVal.value = cy + r * Math.sin(deg);
                circle.r.baseVal.value = rd;
                // https://loading.io/
                let ani = doc.createElementNS(SVGNS, 'animate');
                Dom.setAttrs(ani, Object.assign({}, small ? this.DEFAULT_SMALL : this.DEFAULT_ANI, {
                    'dur': dur,
                    'begin': -((n - 1 - i) / n) + 's'
                }));
                circle.appendChild(ani);
                ani = doc.createElementNS(SVGNS, 'animate');
                Dom.setAttrs(ani, Object.assign({}, this.DEFAULT_FILL, {
                    'values': cols,
                    'dur': dur,
                    'begin': -((n - 1 - i) / n) + 's'
                }));
                circle.appendChild(ani);
                svg.appendChild(circle);
            }
        }
        static spoke(doc, svg, spinner) {
            const cs = getComputedStyle(svg);
            const cx = spinner.width / 2;
            const cy = spinner.height / 2;
            const r1 = Math.min(cx, cy) * 2 / 5;
            const r2 = Math.min(cx, cy) * 2 / 3;
            const c1 = '#f0f0f0';
            const c2 = cs.stroke || '#404040';
            const cols = [c1, c1, c2, c1, c1].join(';');
            const n = pickNum(spinner.itemCount, 10);
            const dur = pickNum(spinner.duration, 1000) + 'ms';
            for (let i = 0; i < n; i++) {
                const deg = i / n * Math.PI * 2;
                const x1 = cx + r1 * Math.cos(deg);
                const y1 = cx + r1 * Math.sin(deg);
                const x2 = cx + r2 * Math.cos(deg);
                const y2 = cx + r2 * Math.sin(deg);
                const line = doc.createElementNS(SVGNS, 'path');
                const ani = doc.createElementNS(SVGNS, 'animate');
                line.setAttribute('d', `M ${x1} ${y1} L ${x2} ${y2}`);
                line.style.stroke = c1;
                Dom.setAttrs(ani, Object.assign({}, this.SPOKE_ANI, {
                    'values': cols,
                    'begin': -((n - 1 - i) / n) + 's',
                    'dur': dur
                }));
                line.appendChild(ani);
                svg.appendChild(line);
            }
        }
        static arc(doc, svg, spinner) {
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    DSpinner.DEFAULT_ANI = {
        'attributeName': 'r',
        'times': '0;0.1;0.2;0.3;1',
        'repeatCount': 'indefinite',
        'values': '2;3;5;3;2',
    };
    DSpinner.DEFAULT_SMALL = {
        'attributeName': 'r',
        'times': '0;0.1;0.2;0.3;1',
        'repeatCount': 'indefinite',
        'values': '0.5;1;2;1;0.5'
    };
    DSpinner.DEFAULT_FILL = {
        'attributeName': 'fill',
        'times': '0;0.1;0.2;0.3;1',
        'repeatCount': 'indefinite',
    };
    DSpinner.SPOKE_ANI = {
        'attributeName': 'stroke',
        'times': '0;0.1;0.2;0.3;1',
        'repeatCount': 'indefinite',
    };

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     */
    class SpinnerRenderer extends DListRenderer {
        constructor() {
            super(...arguments);
            //-------------------------------------------------------------------------
            // property fields
            //-------------------------------------------------------------------------
            this._spinnerType = DListSpinnerType.DEFAULT;
            this._spinnerSize = SpinnerRenderer.SPINNER_SIZE;
            // private _clockwise = true;
            this._duration = 1000;
            //-------------------------------------------------------------------------
            // internal members
            //-------------------------------------------------------------------------
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /** spinnerType */
        get spinnerType() {
            return this._spinnerType;
        }
        set spinnerType(value) {
            this._spinnerType = value;
        }
        /** spinnerWidth */
        get spinnerWidth() {
            return this._spinnerWidth;
        }
        set spinnerWidth(value) {
            this._spinnerWidth = +value;
        }
        /** spinnerHeight */
        get spinnerHeight() {
            return this._spinnerHeight;
        }
        set spinnerHeight(value) {
            this._spinnerHeight = +value;
        }
        /** spinnerSize */
        get spinnerSize() {
            return this._spinnerSize;
        }
        set spinnerSize(value) {
            this._spinnerSize = +value;
        }
        /** itemCount */
        get itemCount() {
            return this._wheelCount;
        }
        set itemCount(value) {
            this._wheelCount = value;
        }
        /** duration */
        get duration() {
            return this._duration;
        }
        set duration(value) {
            this._duration = value;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        getSpinnerWidth() {
            return pickNum(this._spinnerWidth, this._spinnerSize);
        }
        getSpinnerHeight() {
            return pickNum(this._spinnerHeight, this._spinnerSize);
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        type() {
            return SpinnerRenderer.TYPE;
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    SpinnerRenderer.TYPE = 'spinner';
    SpinnerRenderer.SPINNER_SIZE = 120;

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * {@link concepts.sorting Field 헤더}의 필드 뷰에 정렬 순서를 표시하는 방식.
     * <br>
     * {@link IListFieldRenderer 필드 렌더러}의 {@link IListFieldRenderer.orderVisibility orderVisibility} 속성으로 사용된다.
     *
     * @see concepts.renderers 렌더러 개요
     */
    var DListFieldOrderVisibility;
    (function (DListFieldOrderVisibility) {
        /**
         * 필드 view가 표시되는 영역의 기본 설정을 따른다.
         */
        DListFieldOrderVisibility["DEFAULT"] = "default";
        /**
         * 정렬 상태면 무조건 순서를 표시한다.
         */
        DListFieldOrderVisibility["VISIBLE"] = "visible";
        /**
         * 정렬 상태와 상관없이 표시하지 않는다.
         */
        DListFieldOrderVisibility["HIDDEN"] = "hidden";
    })(DListFieldOrderVisibility || (DListFieldOrderVisibility = {}));
    /**
     * @internal
     */
    class FieldRenderer extends ValueRenderer {
        constructor() {
            super(...arguments);
            this._orderVisibility = DListFieldOrderVisibility.DEFAULT;
            //-------------------------------------------------------------------------
            // internal members
            //-------------------------------------------------------------------------
        }
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        get field() {
            return this._field;
        }
        set field(value) {
            this._field = value;
        }
        get label() {
            return this._label;
        }
        set label(value) {
            this._label = value;
        }
        get orderVisibility() {
            return this._orderVisibility;
        }
        set orderVisibility(value) {
            this._orderVisibility = value;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        type() {
            return FieldRenderer.TYPE;
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    FieldRenderer.TYPE = 'field';

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     */
    class DummyRenderer extends DListRenderer {
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        get placeholders() {
            return this._placeholders && this._placeholders.slice(0);
        }
        set placeholders(value) {
            this._placeholders = value && value.slice(0);
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        type() {
            return DummyRenderer.TYPE;
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    DummyRenderer.TYPE = 'dummy';

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     */
    class HtmlRenderer extends FormattableRenderer {
        constructor() {
            super(...arguments);
            this._useInner = false;
            //-------------------------------------------------------------------------
            // internal members
            //-------------------------------------------------------------------------
        }
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        get domid() {
            return this._domid;
        }
        set domid(value) {
            this._domid = value;
        }
        get useInner() {
            return this._useInner;
        }
        set useInner(value) {
            this._useInner = value;
        }
        get html() {
            return this._html;
        }
        set html(value) {
            this._html = value;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        type() {
            return HtmlRenderer.TYPE;
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    HtmlRenderer.TYPE = 'html';

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     */
    class DateRenderer extends InputRendererBase {
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        type() {
            return DateRenderer.TYPE;
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    DateRenderer.TYPE = 'date';
    /**
     * @internal
     */
    class TimeRenderer extends InputRendererBase {
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        type() {
            return TimeRenderer.TYPE;
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    TimeRenderer.TYPE = 'time';
    /**
     * @internal
     */
    class DatetimeRenderer extends InputRendererBase {
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        type() {
            return DatetimeRenderer.TYPE;
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    DatetimeRenderer.TYPE = 'datetime';

    ////////////////////////////////////////////////////////////////////////////////
    const renderers = {
        'button': ButtonRenderer,
        'check': CheckRenderer,
        'date': DateRenderer,
        'datetime': DatetimeRenderer,
        'dummy': DummyRenderer,
        'field': FieldRenderer,
        'gauge': GaugeRenderer,
        'html': HtmlRenderer,
        'icon': IconRenderer,
        'image': ImageRenderer,
        'input': InputRenderer,
        'label': LabelRenderer,
        'letter': LetterRenderer,
        'line': LineRenderer,
        'link': LinkRenderer,
        'meter': MeterRenderer,
        'number': NumberRenderer,
        'progress': ProgressRenderer,
        'qrcode': QrcodeRenderer,
        'radio': RadioRenderer,
        'radiogroup': RadioGroupRenderer,
        'rating': RatingRenderer,
        'select': SelectRenderer,
        'shape': ShapeRenderer,
        'spacer': SpacerRenderer,
        'sparkbar': SparkBarRenderer,
        'sparkline': SparkLineRenderer,
        'spinner': SpinnerRenderer,
        'svg': SvgRenderer,
        'switch': SwitchRenderer,
        'text': TextRenderer,
        'time': TimeRenderer,
    };
    class Renderers {
        //-------------------------------------------------------------------------
        // static members
        //-------------------------------------------------------------------------
        static getRenderer(config, def) {
            if (Utils.isObject(config)) {
                let t = (typeof config.type === 'string' ? config.type : null) || def;
                if (t in renderers) {
                    return new renderers[t]().assignProps(config);
                }
            }
            else if (typeof config === 'string') {
                config = config.toLowerCase();
                if (config in renderers) {
                    return new renderers[config]();
                }
            }
            else {
                const r = renderers[def];
                return r ? new r() : void 0;
            }
            // 모두 실패하면 RendererImplPool에서 기본 text renderer를 재사용한다.
        }
        static createRenderer(type) {
            return new renderers[type]();
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @layout IListLayout
     *
     * undefined라도 반드시 속성의 기본값을 지정할 것!
     */
    class LayoutChildProps {
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(props) {
            Utils.isObject(props) && Object.assign(this, props);
        }
    }
    /**
     * @internal
     */
    class DLayoutChild extends DObject {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(id, childProps) {
            super();
            //-------------------------------------------------------------------------
            // property fields
            //-------------------------------------------------------------------------
            this._visible = true;
            this._id = id;
            this._childProps = childProps || {};
        }
        /**
         * @internal
         *
         * 속성 필드 초기화가 template loading 이전에 실행되도록 ctor와 분리해서 별도 호출하게 한다.
         * 또, 각 layout에서 해당 클래스를 리턴하도록 무조건 계승한다.
         */
        loadProps(props) {
            if (Utils.isObject(props)) {
                this._doLoadProps(props);
            }
            return this;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        /**
         * {@link concepts.templates Template}에서 지정된 상위 layout 내에서 유일한 값.
         * <br>
         *
         * @returns id
         */
        id() {
            return this._id;
        }
        getChildProp(prop) {
            return this._childProps[prop];
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        get visible() {
            return this._visible;
        }
        set visible(value) {
            value = this.toBool(value); // template에서 load되는 경우 대비.
            if (value !== this._visible) {
                this._visible = value;
                this._changed();
            }
        }
        get width() {
            return this._width;
        }
        set width(value) {
            if (value === '*') {
                this.width = 0;
                this._childProps['grow'] = 1;
            }
            else if (value != this._width) {
                this._width = value;
                this._widthDim = parsePercentSize(value, true);
                this._changed();
            }
        }
        get height() {
            return this._height;
        }
        set height(value) {
            if (value === '*') {
                this.height = 0;
                this._childProps['grow'] = 1;
            }
            else if (value != this._height) {
                this._height = value;
                this._heightDim = parsePercentSize(value, true);
                this._changed();
            }
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        getLeft() {
            return this._leftDim && this._leftDim.fixed ? this._leftDim.size : NaN;
        }
        getRight() {
            return this._rightDim && this._rightDim.fixed ? this._rightDim.size : NaN;
        }
        getTop() {
            return this._topDim && this._topDim.fixed ? this._topDim.size : NaN;
        }
        getBottom() {
            return this._bottomDim && this._bottomDim.fixed ? this._bottomDim.size : NaN;
        }
        getRelativeLeft() {
            return this._leftDim && !this._leftDim.fixed ? this._leftDim.size : NaN;
        }
        getRelativeRight() {
            return this._rightDim && !this._rightDim.fixed ? this._rightDim.size : NaN;
        }
        getRelativeTop() {
            return this._topDim && !this._topDim.fixed ? this._topDim.size : NaN;
        }
        getRelativeBottom() {
            return this._bottomDim && !this._bottomDim.fixed ? this._bottomDim.size : NaN;
        }
        getLeftIn(domain) {
            return calcPercent(this._leftDim, domain);
        }
        getRightIn(domain) {
            return calcPercent(this._rightDim, domain);
        }
        getTopIn(domain) {
            return calcPercent(this._topDim, domain);
        }
        getBottomIn(domain) {
            return calcPercent(this._bottomDim, domain);
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        _changed() {
        }
        _doLoadProps(props) {
            // 이 객체 속성 
            this.assignProps(props);
            // child props
            const cprops = this._childProps;
            for (let p in this._childProps) {
                if (props.hasOwnProperty(p) && props[p] !== void 0) {
                    cprops[p] = props[p];
                }
            }
            this._leftDim = parsePercentSize(cprops['left'], true);
            this._rightDim = parsePercentSize(cprops['right'], true);
            this._topDim = parsePercentSize(cprops['top'], true);
            this._bottomDim = parsePercentSize(cprops['bottom'], true);
        }
    }
    /**
     * @internal
     */
    class DSimpleLayoutChild extends DLayoutChild {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(id, value, style, renderer, childProps) {
            super(id, childProps);
            this._valign = DListVerticalAlign.MIDDLE;
            this._style = style;
            this.renderer = renderer;
            // renderer에 id가 자동 생성되서 설정되어 있다.
            if (id && renderer) {
                renderer.id = id;
            }
            this.value = value;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        get align() {
            return this._align;
        }
        set align(value) {
            if (value === DListHorizontalAlign.RIGHT || DListHorizontalAlign.CENTER) {
                this._align = value;
            }
            else {
                value = DListHorizontalAlign.LEFT;
            }
        }
        get valign() {
            return this._valign;
        }
        set valign(value) {
            if (value === DListVerticalAlign.TOP || value === DListVerticalAlign.BOTTOM) {
                this._valign = value;
            }
            else {
                this._valign = DListVerticalAlign.MIDDLE;
            }
        }
        /**
         * @readonly
         *
         * css 클래스명.
         */
        get class() {
            return this._class;
        }
        set class(value) {
            this._class = value;
        }
        /**
         * @readonly
         *
         * 스타일셋.
         */
        get style() {
            return this._style;
        }
        get styleObj() {
            return typeof this._style !== 'string' && this._style;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        setRow(dv, row, gindex) {
            this.dv = dv;
            this.row = row;
            this.gindex = gindex;
        }
        getField() {
            return;
        }
        getValue() {
            return this.value;
        }
    }
    /**
     * @internal
     */
    class DLayoutField extends DSimpleLayoutChild {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(id, field, fields, value, style, renderer, childProps) {
            super(id, value, style, renderer, childProps);
            if (field) {
                const p = Utils.getFieldProp(field);
                if (p) {
                    this.field = p.field;
                    this.fprop = p.props;
                }
                else {
                    this.field = field;
                }
            }
            this.fields = fields;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        getField() {
            return this.field;
        }
        getValue() {
            // 행 추가 view에서 사용될 때 row가 -1일 수 있다.
            if (this.value === void 0 && this.row >= 0) {
                if (this.fprop) {
                    return this.dv.getProp(this.row, this.field, this.fprop, true);
                }
                else {
                    return this.dv.getValue(this.row, this.field, true);
                }
            }
        }
    }
    /**
     * @internal
     */
    class DLayoutLiteral extends DSimpleLayoutChild {
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(id, value, style, renderer, childProps) {
            super(id, value, style, renderer, childProps);
        }
    }
    var DListLayoutOverflow;
    (function (DListLayoutOverflow) {
        DListLayoutOverflow["SHRINK"] = "shrink";
        DListLayoutOverflow["WRAP"] = "wrap";
        DListLayoutOverflow["OVERFLOW"] = "overflow";
    })(DListLayoutOverflow || (DListLayoutOverflow = {}));
    /**
     * @internal
     *
     */
    class DListLayout extends DLayoutChild {
        //-------------------------------------------------------------------------
        // properti fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(id, children, style, childProps) {
            super(id, childProps);
            this._noShrink = false;
            this._style = style; // || new DListRowStyles();
            this._children = children;
            children && children.forEach(c => c._parent = this);
        }
        get style() {
            return this._style;
        }
        childCount() {
            return this._children ? this._children.length : 0;
        }
        children() {
            return this._children ? this._children.slice(0) : [];
        }
        // /**
        //  * 최소 너비.
        //  */
        // get minWidth(): number {
        //     return this._minWidth;
        // }
        // set minWidth(value: number) {
        //     value = Utils.toNumber(value);
        //     if (value !== this._minWidth) {
        //         this._minWidth = value;
        //         this._changed();
        //     }
        // }
        // /**
        //  * 최대 너비.
        //  */
        // get maxWidth(): number {
        //     return this._maxWidth;
        // }
        // set maxWidth(value: number) {
        //     value = Utils.toNumber(value);
        //     if (value !== this._maxWidth) {
        //         this._maxWidth = value;
        //         this._changed();
        //     }
        // }
        // /**
        //  * 최소 높이.
        //  */
        // get minHeight(): number {
        //     return this._minHeight;
        // }
        // set minHeight(value: number) {
        //     value = Utils.toNumber(value);
        //     if (value !== this._minHeight) {
        //         this._minHeight = value;
        //         this._changed();
        //     }
        // }
        // /**
        //  * 최대 높이.
        //  */
        // get maxHeight(): number {
        //     return this._maxHeight;
        // }
        // set maxHeight(value: number) {
        //     value = Utils.toNumber(value);
        //     if (value !== this._maxHeight) {
        //         this._maxHeight = value;
        //         this._changed();
        //     }
        // }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        getChild(index) {
            return this._children[index];
        }
        tagBy(tag) {
            function find(layout) {
                for (const child of layout._children) {
                    if (child.tag === tag) {
                        return child;
                    }
                    if (child instanceof DListLayout) {
                        const f = find(child);
                        if (f)
                            return f;
                    }
                }
            }
            return find(this);
        }
        literalBy(tag) {
            const layout = this.tagBy(tag);
            return layout instanceof DLayoutLiteral && layout;
        }
        fieldBy(field) {
            function find(layout) {
                for (const child of layout._children) {
                    if (child instanceof DLayoutField && child.field === field) {
                        return child;
                    }
                    if (child instanceof DListLayout) {
                        const f = find(child);
                        if (f)
                            return f;
                    }
                }
            }
            return find(this);
        }
        setNoShrink(value) {
            this._noShrink = value;
        }
        canShrink() {
            return !this._noShrink;
        }
        canGrow() {
            return true;
        }
        canContainHspace() {
            return false;
        }
        canContainVspace() {
            return false;
        }
        setRow(dv, row, gindex) {
            this.row = row;
            this._children.forEach(child => child.setRow(dv, row, gindex));
        }
        getOrderedChildren() {
            return this._children;
        }
        getSimples() {
            let childs = [];
            this.getOrderedChildren().forEach(child => {
                if (child instanceof DSimpleLayoutChild) {
                    childs.push(child);
                }
                else if (child instanceof DListLayout) {
                    childs = childs.concat(child.getSimples());
                }
            });
            return childs;
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    DListLayout.CHILD_PROPS = LayoutChildProps;
    /**
     * @internal
     */
    class DHtmlLayout extends DObject {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(template) {
            super();
            this._dom = template.dom;
            this._tokens = template.tokens;
            this.tid = template.tid;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        clone() {
            return this._dom.cloneNode(true);
        }
        setRow(dv, row, gindex) {
            // this._layout.setRow(dv, row, gindex);
        }
        inflate(inflater) {
            this._tokens.forEach(token => {
                token.value = token.param.inflate(null, null, null, inflater);
            });
        }
        apply(target) {
            this._tokens.forEach(token => {
                const node = Dom.childByPath(target, token.node);
                if (token.attr) {
                    node.setAttribute(token.attr, token.value);
                }
                else {
                    node.nodeValue = token.value;
                }
            });
        }
    }
    /**
     * @layout IListPositionableLayout
     *
     * Child properties for PositionableLayout.
     */
    class PositionableLayoutProps extends LayoutChildProps {
        constructor() {
            super(...arguments);
            //-------------------------------------------------------------------------
            // properties
            //-------------------------------------------------------------------------
            /**
             * left 위치를 (픽셀 단위의)숫자나 '%' 문자열로 지정한다..
             * <br>
             */
            this.left = undefined;
            /**
             * right 위치를 (픽셀 단위의)숫자나 '%' 문자열로 지정한다..
             * <br>
             * {@link left}를 지정하면 이 속성은 무시된다.
             */
            this.right = undefined;
            /**
             * top 위치를 (픽셀 단위의)숫자나 '%' 문자열로 지정한다..
             * <br>
             */
            this.top = undefined;
            /**
             * bottom 위치를 (픽셀 단위의)숫자나 '%' 문자열로 지정한다..
             * <br>
             * {@link bottom}을 지정하면 이 속성은 무시된다.
             */
            this.bottom = undefined;
        }
    }
    /**
     * @internal
     */
    class PositionableLayout extends DListLayout {
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    PositionableLayout.CHILD_PROPS = PositionableLayoutProps;

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @layout IListFrameLayout
     *
     * Child properties for FrameLayout.
     */
    class FrameLayoutProps extends PositionableLayoutProps {
    }
    /**
     * @internal
     */
    class FrameLayout extends PositionableLayout {
        //-------------------------------------------------------------------------
        // property fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        get type() {
            return FrameLayout.TYPE;
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    FrameLayout.TYPE = 'frame';
    FrameLayout.CHILD_PROPS = FrameLayoutProps;

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @layout IListLinearLayout
     *
     * Child properties for LinearLayout.
     */
    class LinearLayoutProps extends LayoutChildProps {
        constructor() {
            super(...arguments);
            /**
             * 자식들의 크기 합이 layout 크기보다 클 때, 이 값의 비율대로 줄인다.
             * <br>
             * 전체 감소 크기 중 자식의 원래 상대 크기(전체 자식의 크기에 대한)에
             * 이 값의 상대값(전체 자식의 shrink르 더한 값에 대한)을 곱한 값을 줄인다.
             *
             * @default 1
             */
            this.shrink = 1;
            /**
             * 자식들의 크기 합이 layout 크기보다 작을 때, 이 값의 비율대로 줄인다.
             * <br>
             * 전체 자식들의 grow 합이 1보다 작으면 layout 크기에 여분이 생긴다.
             *
             * @default 0;
             */
            this.grow = 0;
        }
    }
    /**
     * @internal
     */
    class LinearLayout extends DListLayout {
        constructor() {
            super(...arguments);
            //-------------------------------------------------------------------------
            // static members
            //-------------------------------------------------------------------------
            //-------------------------------------------------------------------------
            // property fields
            //-------------------------------------------------------------------------
            this._itemsArrange = DListItemsArrange.START;
            this._itemGap = LinearLayout.DEF_ITEM_GAP;
            this._reversed = false;
            //-------------------------------------------------------------------------
            // methods
            //-------------------------------------------------------------------------
            //-------------------------------------------------------------------------
            // overriden members
            //-------------------------------------------------------------------------
            //-------------------------------------------------------------------------
            // internal members
            //-------------------------------------------------------------------------
        }
        // private _wrap = false;   // TODO: v1.1 ! overflow보다는 wrap으로 가는 게 맞을 듯.
        // overflow 시켜서 어떻게 할 것인가? 
        // single row 처럼 scroll 가능하게 할 수 있나?
        // DListLayoutOverflow.OVERFLOW가 아니라 DListLayoutOverflow.SCROLL 이어야 의미가 있다.
        // private _overflow = DListLayoutOverflow.SHRINK; // TODO: v1.1
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        get itemsArrange() {
            return this._itemsArrange;
        }
        set itemsArrange(value) {
            if (value !== this._itemsArrange) {
                this._itemsArrange = value;
                this._changed();
            }
        }
        get itemGap() {
            return this._itemGap;
        }
        set itemGap(value) {
            if (!isNaN(value) && value !== this._itemGap) {
                this._itemGap = value;
                this._changed();
            }
        }
        get reversed() {
            return this._reversed;
        }
        set reversed(value) {
            if (value !== this._reversed) {
                this._reversed = value;
                this._changed();
            }
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    LinearLayout.DEF_ITEM_GAP = 4;
    /**
     * @layout IListVLinearLayout
     *
     * Child properties for VLinearLayout.
     */
    class VLinearLayoutProps extends LinearLayoutProps {
        constructor() {
            super(...arguments);
            //-------------------------------------------------------------------------
            // properties
            //-------------------------------------------------------------------------
            /**
             * left 위치를 (픽셀 단위의)숫자나 '%' 문자열로 지정한다..
             * <br>
             *
             * @default undefined
             */
            this.left = void 0;
            /**
             * right 위치를 (픽셀 단위의)숫자나 '%' 문자열로 지정한다..
             * <br>
             * {@link left}를 지정하면 이 속성은 무시된다.
             *
             * @default undefined
             */
            this.right = void 0;
        }
    }
    /**
     * @internal
     */
    class VLinearLayout extends LinearLayout {
        constructor() {
            super(...arguments);
            //-------------------------------------------------------------------------
            // property fields
            //-------------------------------------------------------------------------
            this._itemsAlign = DListHorizontalAlign.CENTER;
        }
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        get itemsAlign() {
            return this._itemsAlign;
        }
        set itemsAlign(value) {
            if (value !== this._itemsAlign) {
                this._itemsAlign = value;
                this._changed();
            }
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        get type() {
            return VLinearLayout.TYPE;
        }
        canContainVspace() {
            return true;
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    VLinearLayout.TYPE = 'vlinear';
    VLinearLayout.CHILD_PROPS = VLinearLayoutProps;
    /**
     * @layout IListHLinearLayout
     *
     * Child properties for HLinearLayout.
     */
    class HLinearLayoutProps extends LinearLayoutProps {
        constructor() {
            super(...arguments);
            //-------------------------------------------------------------------------
            // properties
            //-------------------------------------------------------------------------
            /**
             * top 위치를 (픽셀 단위의)숫자나 '%' 문자열로 지정한다..
             * <br>
             *
             * @default undefined
             */
            this.top = void 0;
            /**
             * bottom 위치를 (픽셀 단위의)숫자나 '%' 문자열로 지정한다..
             * <br>
             * {@link top}을 지정하면 이 속성은 무시된다.
             *
             * @default undefined
             */
            this.bottom = void 0;
        }
    }
    /**
     * @internal
     *
     */
    class HLinearLayout extends LinearLayout {
        constructor() {
            super(...arguments);
            //-------------------------------------------------------------------------
            // property fields
            //-------------------------------------------------------------------------
            this._itemsAlign = DListVerticalAlign.MIDDLE;
        }
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        get itemsAlign() {
            return this._itemsAlign;
        }
        set itemsAlign(value) {
            if (value !== this._itemsAlign) {
                this._itemsAlign = value;
                this._changed();
            }
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        get type() {
            return HLinearLayout.TYPE;
        }
        canContainHspace() {
            return true;
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    HLinearLayout.TYPE = 'hlinear';
    HLinearLayout.CHILD_PROPS = HLinearLayoutProps;

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @layout IListStackLayout
     *
     * Child properties for StackLayout.
     */
    class StackLayoutProps extends PositionableLayoutProps {
    }
    /**
     * @internal
     */
    class StackLayout extends PositionableLayout {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        get activeChild() {
            return this._activeChild;
        }
        set activeChild(value) {
            this._activeChild = value;
        }
        get activeField() {
            return this._activeField;
        }
        set activeField(value) {
            this._activeField = value;
        }
        get activeCallback() {
            return this._activeCallback;
        }
        set activeCallback(value) {
            this._activeCallback = value;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        getActiveChild(ctx, row) {
            return pickProp3(this._activeCallback && this._activeCallback({ ctx, row }), this._activeChild, this._idValue);
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        get type() {
            return StackLayout.TYPE;
        }
        setRow(dv, row, gindex) {
            super.setRow(dv, row, gindex);
            if (this._activeField) {
                this._idValue = dv.getValue(row, this._activeField, true);
            }
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    StackLayout.TYPE = 'stack';
    StackLayout.CHILD_PROPS = StackLayoutProps;

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * {@link IListFormLayout 폼 레이아웃}에서 각 line에 표시될 label의 위치를 지정한다.
     * <br>
     * {@link IListFormLayout.labelPosition} 속성으로 사용된다.
     *
     * @see concepts.layouts 레이아웃 개요
     */
    var DListFormLabelPostion;
    (function (DListFormLabelPostion) {
        /**
         * label을 표시하지 않는다.
         */
        DListFormLabelPostion["NONE"] = "none";
        /**
         * 왼쪽에 표시하고, 모든 행 label의 너비를 동일하게 한다.
         */
        DListFormLabelPostion["HEAD"] = "head";
        /**
         * 왼쪽에 표시하고, 오른쪽에 값을 표시한다.
         */
        DListFormLabelPostion["LEFT"] = "left";
        /**
         * 위쪽에 표시하고, 아래 쪽에 값을 표시한다.
         */
        DListFormLabelPostion["TOP"] = "top";
    })(DListFormLabelPostion || (DListFormLabelPostion = {}));
    /**
     * @layout IListFormLayout
     *
     * Child properties for FormLayout.
     */
    class FormLayoutProps extends LayoutChildProps {
        constructor() {
            super(...arguments);
            //-------------------------------------------------------------------------
            // properties
            //-------------------------------------------------------------------------
            /**
             * 필드 label.
             * <br>
             */
            this.label = void 0;
            /**
             * label 너비.
             * <br>
             */
            this.labelWidth = void 0;
            /**
             * 이미지 경로.
             * <br>
             */
            this.imageUrl = void 0;
            /**
             * 이미지 너비
             * <br>
             */
            this.imageWidth = void 0;
            /**
             * 이미지 높이
             * <br>
             */
            this.imageHeight = void 0;
        }
    }
    /**
     * @internal
     */
    class FormLayout extends DListLayout {
        constructor() {
            super(...arguments);
            //-------------------------------------------------------------------------
            // property fields
            //-------------------------------------------------------------------------
            this._labelPosition = DListFormLabelPostion.LEFT;
            this._syncLabelWidth = true;
            this._labelGap = 10;
            this._itemGap = 12;
        }
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        get labelPosition() {
            return this._labelPosition;
        }
        set labelPosition(value) {
            if (value !== this._labelPosition) {
                this._labelPosition = value;
                this._changed();
            }
        }
        get labelWidth() {
            return this._labelWidth;
        }
        set labelWidth(value) {
            if (value !== this._labelWidth) {
                this._labelWidth = value;
                this._labelWidthDim = parsePercentSize(value, true);
                this._changed();
            }
        }
        get minLabelWidth() {
            return this._minLabelWidth;
        }
        set minLabelWidth(value) {
            if (value !== this._minLabelWidth) {
                this._minLabelWidth = value;
                this._minLabelWidthDim = parsePercentSize(value, true);
                this._changed();
            }
        }
        get maxLabelWidth() {
            return this._maxLabelWidth;
        }
        set maxLabelWidth(value) {
            if (value !== this._maxLabelWidth) {
                this._maxLabelWidth = value;
                this._maxLabelWidthDim = parsePercentSize(value, true);
                this._changed();
            }
        }
        get syncLabelWidth() {
            return this._syncLabelWidth;
        }
        set syncLabelWidth(value) {
            if (value !== this._syncLabelWidth) {
                this._syncLabelWidth = value;
                this._changed();
            }
        }
        get labelGap() {
            return this._labelGap;
        }
        set labelGap(value) {
            value = pickNum(value, 0);
            if (value !== this._labelGap) {
                this._labelGap = value;
                this._changed();
            }
        }
        get labelStyle() {
            return this._labelStyle;
        }
        set labelStyle(value) {
            if (value !== this._labelStyle) {
                this._labelStyle = value;
                this._changed();
            }
        }
        get itemGap() {
            return this._itemGap;
        }
        set itemGap(value) {
            value = pickNum(value, 0);
            if (value !== this._itemGap) {
                this._itemGap = value;
                this._changed();
            }
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        getLabelWidth(domain) {
            const szMin = calcPercent(this._minLabelWidthDim, domain);
            const szMax = calcPercent(this._maxLabelWidthDim, domain);
            const szLabel = calcPercent(this._labelWidthDim, domain);
            return { szLabel, szMin, szMax };
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        get type() {
            return FormLayout.TYPE;
        }
        canContainVspace() {
            return true;
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    FormLayout.TYPE = 'form';
    FormLayout.CHILD_PROPS = FormLayoutProps;

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @layout IListGridLayout
     *
     * Child properties for GridLayout.
     */
    class GridLayoutProps extends LayoutChildProps {
        constructor() {
            super(...arguments);
            this.col = 0;
            this.row = 0;
            this.colspan = 1;
            this.rowspan = 1;
        }
    }
    /**
     * @internal
     */
    class GridLayout extends DListLayout {
        constructor() {
            super(...arguments);
            //-------------------------------------------------------------------------
            // static members
            //-------------------------------------------------------------------------
            //-------------------------------------------------------------------------
            // property fields
            //-------------------------------------------------------------------------
            this._cols = 1;
            this._rows = 1;
            //-------------------------------------------------------------------------
            // internal members
            //-------------------------------------------------------------------------
        }
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        get cols() {
            return this._cols;
        }
        set cols(value) {
            value = Utils.toNumber(value, 1) >>> 0;
            if (value > 0 && value !== this._cols) {
                this._cols = value;
                this._changed();
            }
        }
        get rows() {
            return this._rows;
        }
        set rows(value) {
            value = Utils.toNumber(value, 1) >>> 0;
            if (value > 0 && value !== this._rows) {
                this._rows = value;
                this._changed();
            }
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        get type() {
            return GridLayout.TYPE;
        }
        loadProps(props) {
            return super.loadProps(props);
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    GridLayout.TYPE = 'grid';
    GridLayout.CHILD_PROPS = GridLayoutProps;

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @layout IListScrollLayout
     *
     * Child properties for ScrollLayout.
     */
    class ScrollLayoutProps extends LayoutChildProps {
    }
    /**
     * @internal
     */
    class ScrollLayout extends DListLayout {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(id, children, style, childProps) {
            super(id, children, style, childProps);
            if (this._children.length > 1) {
                this._children.length = 1;
            }
        }
        //-------------------------------------------------------------------------
        // property fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        get type() {
            return ScrollLayout.TYPE;
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    ScrollLayout.TYPE = 'scroll';
    ScrollLayout.CHILD_PROPS = ScrollLayoutProps;

    ////////////////////////////////////////////////////////////////////////////////
    const LayoutModels = {
        'vlinear': VLinearLayout,
        'hlinear': HLinearLayout,
        'frame': FrameLayout,
        'stack': StackLayout,
        'scroll': ScrollLayout,
        'form': FormLayout,
        'grid': GridLayout,
    };
    const Skeleton = {
        defRender: 'dummy'
    };
    /**
     * @internal
     *
     * 1. Template으로 부터 layout을 생성한다.
     */
    class LayoutFactory {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor() {
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        /**
         *
         * @param context param inflate 결과가 function일 때 첫째 매개변수로 전달된다.
         * @param target
         * @param brief
         * @param detailed
         * @param template
         * @param inflater
         * @returns
         */
        layoutFromTemplate(context, target, brief, detailed, template, inflater) {
            this._target = target;
            this._inflater = inflater;
            this._inflater.templateParams = template.params;
            template.target = target;
            try {
                let layout;
                let id;
                if (context === Skeleton) {
                    layout = this.$_loadLayout(template.id, context, template.skeleton || DummyTemplateLayout, null, Skeleton.defRender);
                }
                else {
                    const defRenderer = target.defRenderer || 'text';
                    const coll = brief && template.collapsed;
                    const d = template.detailed;
                    const e = template.extra;
                    const t = coll || (detailed ? (d || template.layout) : template.layout);
                    id = coll ? template.collapsedId : (detailed && d) ? template.detailId : template.id;
                    layout = this.$_loadLayout(id, context, t, null, defRenderer);
                    if (detailed) {
                        const extra = !d && e && this.$_loadLayout(e.id, context, e, null, defRenderer);
                        if (extra) {
                            layout._extra = extra;
                        }
                    }
                }
                layout.tid = id;
                return layout;
            }
            finally {
                this._inflater = void 0;
                this._target = void 0;
            }
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        $_inflate(context, field, param) {
            if (param instanceof DParamString) {
                return param.inflate(context, this._target, field, this._inflater);
            }
            return param;
        }
        $_loadLayout(id, context, template, childProps, defRenderer) {
            if (template instanceof DTemplateLayout) {
                const clazz = LayoutModels[template.layout];
                const styles = this.$_loadParams(context, null, template.style);
                let childs;
                if (!clazz) {
                    throwFormat(locale.unknownLayoutType, template.layout);
                }
                if (template.children) {
                    childs = [];
                    for (let templ of template.children) {
                        const props = templ.props;
                        const childProps2 = new clazz.CHILD_PROPS();
                        let layout;
                        if (templ instanceof DTemplateField) {
                            const fields = templ.fields && Utils.checkArray(this.$_inflate(context, null, templ.fields));
                            const field = templ.field ? this.$_inflate(context, null, templ.field) : null;
                            const styles = this.$_loadParams(context, field, templ.style);
                            const renderer = templ.renderer ? Renderers.getRenderer(this.$_loadParams(context, field, templ.renderer), defRenderer) : Renderers.createRenderer(defRenderer);
                            if (renderer) {
                                for (const r in templ.rendererStyles) {
                                    renderer[r] = this.$_loadParams(context, field, templ.rendererStyles[r]);
                                }
                                renderer.tid = templ.tid;
                            }
                            const value = this.$_inflate(context, field, templ.value);
                            if (field || fields) {
                                layout = new DLayoutField(templ.id, field, fields, value, styles, renderer, childProps2);
                            }
                            else {
                                layout = new DLayoutLiteral(templ.id, value, styles, renderer, childProps2);
                            }
                            if (layout) {
                                layout.classCallback = templ.classCallback;
                                layout.styleCallback = templ.styleCallback;
                                props && layout.loadProps(this.$_loadParams(context, field, props));
                            }
                        }
                        else if (templ instanceof DTemplateLayout) {
                            layout = this.$_loadLayout(templ.id, context, templ, childProps2, defRenderer).loadProps(props);
                        }
                        if (layout) {
                            // 동일한 template으로 생성된 layout 객체가 달라서 layout.id 들은 서로 다를 수 있다.(이럴 수 있나? 어느 시점에 id가 변경될 수 있나?)
                            // template.tid로 비교할 수 있도록 한다. template.id는 (그래서는 안되지만)중복해서 설정할 수 있다.
                            layout.tid = templ.tid;
                            layout.tag = templ.tag;
                            childs.push(layout);
                        }
                    }
                }
                const props = this.$_loadParams(context, null, template.props);
                return new clazz(id, childs, styles, childProps).loadProps(props);
            }
            else if (template instanceof DTemplateHtmlLayout) {
                const layout = new DHtmlLayout(template);
                layout.inflate(this._inflater);
                return layout;
            }
        }
        $_loadParams(context, field, source) {
            if (source instanceof DParamString) {
                return source.inflate(context, this._target, field, this._inflater);
                // return this.$_inflate(context, field, source);
            }
            else if (Utils.isObject(source)) {
                const obj = {};
                for (let p in source) {
                    obj[p] = this.$_inflate(context, field, source[p]);
                }
                return obj;
            }
            else {
                return source;
            }
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    //-------------------------------------------------------------------------
    // static members
    //-------------------------------------------------------------------------
    LayoutFactory.Instance = new LayoutFactory();

    const it_detail_value = {
        name: '@it_detail_value',
        description: '왼쪽 끝에 이름과 그 아래 설명, 오른쪽 끝에 값을 표시하는 단순 템플릿',
        props: {},
        template: {
            layout: 'frame',
            props: {},
            children: [{
                    field: '${name_field;name}',
                    width: '${name_width}',
                    height: '${name_height}',
                    left: 0,
                    style: {
                        fontSize: '${name_font_size;medium}'
                    },
                    tag: 'name' // for testing
                }, {
                    field: '${value_field;value}',
                    width: '${value_width}',
                    height: '${value_height}',
                    right: 0,
                    style: {
                        fontSize: '${value_font_size;medium}'
                    },
                    tag: 'value' // for testing
                }]
        }
    };

    const it_name_value = {
        name: '@it_name_value',
        description: '왼쪽 끝에 이름, 오른쪽 끝에 값을 표시하는 단순 템플릿',
        props: {},
        rowStyle: {},
        template: {
            layout: 'frame',
            props: {},
            children: [{
                    field: '${name_field;name}',
                    left: 0,
                    width: '${name_width}',
                    height: '${name_height}',
                    style: {
                        fontSize: '${name_font_size;medium}'
                    },
                    tag: 'name' // for testing
                }, {
                    field: '${value_field;value}',
                    right: 0,
                    width: '${value_width}',
                    height: '${value_height}',
                    style: {
                        fontSize: '${value_font_size;medium}'
                    },
                    tag: 'value' // for testing
                }]
        }
    };

    /**
     * @template
     *
     * 그룹 Header의 기본 템플릿이다.
     * <br>
     *
     * @see it_group_footer @it_group_footer
     */
    const it_group_header = {
        name: '@it_group_header',
        description: "Group header template",
        props: {},
        template: {
            layout: "hlinear",
            children: [{
                    value: "${@group_field;Group value}",
                    tag: "field"
                }, {
                    value: ": ",
                    tag: "colon"
                }, {
                    value: "${@group_value}",
                    style: {
                        fontWeight: 'bold'
                    },
                    tag: "value"
                }]
        },
        collapsed: {
            layout: "hlinear",
            children: [{
                    value: "${@group_field;Group value}",
                    tag: "field"
                }, {
                    value: ": ",
                    tag: "colon"
                }, {
                    value: "${@group_value}",
                    style: {
                        fontWeight: 'bold'
                    },
                    tag: "value"
                }, {
                    space: '*'
                }, {
                    value: "${@row_count}",
                    tag: "count"
                }, {
                    value: " rows.",
                    tag: "rows"
                }]
        }
    };

    /**
     * @template
     *
     * 그룹 Footer의 기본 템플릿이다.
     * <br>
     *
     * @see it_group_header @it_group_header
     */
    const it_group_footer = {
        name: '@it_group_footer',
        description: "Group footer template",
        props: {},
        template: {
            layout: "hlinear",
            children: [{
                    //     value: "Σ",
                    //     style: { fontSize: '15px' },
                    //     tag: "sigma"
                    // }, {
                    space: '*'
                }, {
                    value: "${@row_count}",
                    tag: "count"
                }, {
                    value: " rows.",
                    tag: "rows"
                }]
        }
    };

    /**
     * @template
     *
     * {@link DListHeader 리스트 헤더}의 기본 템플릿이다.
     * <br>
     *
     * @see DListHeader
     * @see it_list_footer @it_list_footer
     */
    const it_list_header = {
        name: '@it_list_header',
        description: "List header template",
        props: {},
        template: {
            layout: "hlinear",
            style: "${@style}",
            children: [{
                    value: "${@caption;Header}",
                    tag: "caption",
                    width: '*',
                    style: {
                        textAlign: "${@caption-align}",
                        fontWeight: 'bold',
                        color: "${@caption-color;#333}"
                    }
                }]
        }
    };

    /**
     * @template
     *
    * {@link DListFooter 리스트 Footer}의 기본 템플릿이다.
     * <br>
     
    * @see DListFooter
     * @see it_list_header @it_list_header
     */
    const it_list_footer = {
        name: '@it_list_footer',
        description: "List footer template",
        props: {},
        template: {
            layout: "hlinear",
            children: [{
                    value: "Σ",
                    style: { fontSize: '19px' },
                    tag: "sigma"
                }, {
                    width: '*',
                    renderer: 'spacer',
                    tag: "spacer"
                }, {
                    value: "${@row_count}",
                    tag: "count"
                }, {
                    value: " rows.",
                    tag: "rows"
                }]
        }
    };

    /**
     * @template
     *
     * 데이터그룹 Header의 기본 템플릿이다.
     * <br>
     *
     * @see it_datagroup_footer @it_datagroup_footer
     */
    const it_datagroup_header = {
        name: '@it_datagroup_header',
        description: "Group header template",
        props: {},
        template: {
            layout: "hlinear",
            children: [{
                    value: "${@group_field;Group value}",
                    tag: "field"
                }, {
                    value: ": ",
                    tag: "colon"
                }, {
                    value: "${@group_value}",
                    style: {
                        fontWeight: 'bold'
                    },
                    tag: "value"
                }]
        }
    };

    /**
     * @template
     *
     * 데이터그룹 Footer의 기본 템플릿이다.
     * <br>
     *
     * @see it_datagroup_header @it_datagroup_header
     */
    const it_datagroup_footer = {
        name: '@it_datagroup_footer',
        description: "Group footer template",
        props: {},
        template: {
            layout: "hlinear",
            style: { fontSize: '14px ' },
            children: [{
                    space: '*',
                }, {
                    value: "${@row_count}",
                    tag: "count"
                }, {
                    value: "${rows_suffix;rows.}",
                    tag: "rows"
                }]
        }
    };

    /**
     * @template
     *
     * {@link concepts.empty_page Empty Page}의 기본 템플릿이다.
    * <br><br>
     * <img data-all="1" src="../images/empty-page-02.png" style="width: 300px"/><br>
     * <br>
     *
     * @see concepts.empty_page Empty Page
     * @see it_loading_page @it_loading_page
     */
    const it_empty_page = {
        name: '@it_empty_page',
        description: "Empty page template",
        template: {
            layout: "vlinear",
            itemsArrange: 'center',
            itemGap: 20,
            children: [{
                    visible: '${@message_visible;true}',
                    value: "${@message;표시할 데이터가 없습니다.}",
                    style: {
                        fontFamily: "Courier New",
                        fontSize: "16px",
                        fontWeight: "bold",
                        color: "#555"
                    }
                }, {
                    visible: '${@load_visible;true}',
                    renderer: {
                        type: 'button',
                        label: '${@load_label;Load Data}',
                        onClick: '${@load_callback}'
                    }
                }],
            style: {
                backgroundColor: "#f8f8f8",
                padding: '10px'
            }
        },
    };

    /**
     * @template
     *
     * {@link concepts.loading_page Loading Page}의 기본 템플릿이다.
     * <br><br>
     * <img data-all="1" src="../images/loading-page-02.png" style="width: 300px"/><br>
     * <br>
     *
     * @see concepts.loading_page Loading Page
     * @see it_empty_page @it_empty_page
     */
    const it_loading_page = {
        name: '@it_loading_page',
        description: "Loading page template",
        template: {
            layout: "vlinear",
            itemsArrange: 'center',
            children: [{
                    value: "${message;Data Loading...}",
                    style: {
                        fontFamily: "Courier New",
                        fontSize: "16px",
                        fontWeight: "bold",
                        color: "#777"
                    }
                }, {
                    space: '30'
                }, {
                    renderer: {
                        type: 'spinner'
                    }
                }],
            style: {
                backgroundColor: "#f8f8f8",
                padding: '10px'
            }
        },
    };

    ////////////////////////////////////////////////////////////////////////////////
    let next_template = 0;
    const StockTemplates = new Registy();
    const UserTemplates = new Registy();
    const registerUserTemplate = function (htmlProvider, registry, name, template) {
        name = name || template.name;
        if (name && template) {
            if (!(template instanceof DListTemplate)) {
                if (Utils.isObject(template.template)) {
                    template = new DListTemplate(htmlProvider, template);
                }
            }
            if (template instanceof DListTemplate) {
                registry.add(name, template);
                return template;
            }
        }
        else if (name) {
            registry.remove(name);
        }
    };
    const getNextTemplateName = function () {
        return 'template_' + next_template++;
    };
    [
        it_list_header,
        it_list_footer,
        it_name_value,
        it_detail_value,
        it_group_header,
        it_group_footer,
        it_datagroup_header,
        it_datagroup_footer,
        it_loading_page,
        it_empty_page
    ]
        .forEach(t => StockTemplates.add(t.name, new DListTemplate(null, t)));

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     *
     * Conrol object for ListControl.
     */
    class ListControlObject extends DControlObject {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(control, defaults) {
            super(control);
            this._defs = defaults || void 0; // null로 설정하면 안된다. pickNum3() 등에서 void 0으로 간주한다.
            !defaults && this._doInitDefaults();
        }
        /**
         * 컨트롤 default option에 포함된 경우 호출된다.
         */
        _doInitDefaults() {
            this._visible = true;
        }
        initLandscape() {
        }
        //-------------------------------------------------------------------------
        // IEditButtonOwner
        //-------------------------------------------------------------------------
        rowCellObjectChanged(obj) {
            this._changed();
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * 표시 여부.
         */
        visible() {
            return pickProp(this._visible, this._defs && this._defs._visible);
        }
        setVisible(value) {
            if (value !== this._visible) {
                this._visible = value;
                this._changed('visible');
            }
        }
        /**
         * 스타일셋 혹은 className
         */
        style() {
            return pickProp(this._style, this._defs && this._defs._style);
        }
        setStyle(value) {
            if (value !== this._style) {
                this._style = value;
                this._changed('style');
            }
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        prepareRender() {
            this._doPrepareRender();
        }
        unprepareRender() {
            this._doUnprepareRender();
        }
        _doUnprepareRender() { }
    }
    /**
     * {@link DListScrollIndicator 스크롤 인디케이터}나 {@link DListPageNavigator 페이지 네비게이터}의 표시 위치.
     * <br>
     *
     * @see concepts.scrolling 스크롤 개요
     * @see concepts.paging 페이징 개요
     */
    var DListControlObjectPosition;
    (function (DListControlObjectPosition) {
        /**
         * 기기 방향이 **portrait**일 때는 footer 아래쪽, **landscape**일 때는 오른쪽에 표시한다.
         */
        DListControlObjectPosition["DEFAULT"] = "default";
        /**
         * 기기 방향이 **portrait**일 때는 header 위쪽, **landscape**일 때는 왼쪽에 표시한다.
         */
        DListControlObjectPosition["NEAR"] = "near";
        /**
         * 기기 방향이 **portrait**일 때는 footer 아래쪽, **landscape**일 때는 오른쪽에 표시한다.
         */
        DListControlObjectPosition["FAR"] = "far";
        /**
         * 기기 방향과 상관없이 header 위쪽에 표시한다.
         */
        DListControlObjectPosition["TOP"] = "top";
        /**
         * 기기 방향과 상관없이 footer 아래쪽에 표시한다.
         */
        DListControlObjectPosition["BOTTOM"] = "bottom";
        /**
         * 기기 방향과 상관없이 왼쪽에 표시한다.
         */
        DListControlObjectPosition["LEFT"] = "left";
        /**
         * 기기 방향과 상관없이 오른쪽에 표시한다.
         */
        DListControlObjectPosition["RIGHT"] = "right";
    })(DListControlObjectPosition || (DListControlObjectPosition = {}));
    const CPOS = DListControlObjectPosition;
    class PositionableControlObject extends ListControlObject {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        _doInitDefaults() {
            super._doInitDefaults();
            this._position = DListControlObjectPosition.NEAR;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * @noimpl
         *
         * 인디케이터 표시 위치.
         */
        position() {
            return pickProp(this._position, this._defs && this._defs._position);
        }
        setPosition(value) {
            if (value !== this._position) {
                this._position = value;
                this._changed();
            }
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        getPosition(landscape) {
            const p = this.position();
            if (p === CPOS.TOP || p === CPOS.BOTTOM ||
                p === CPOS.LEFT || p === CPOS.RIGHT) {
                return p;
            }
            switch (p) {
                case CPOS.NEAR:
                    return landscape ? CPOS.LEFT : CPOS.TOP;
                case CPOS.FAR:
                    return landscape ? CPOS.RIGHT : CPOS.BOTTOM;
                default:
                    return CPOS.BOTTOM;
            }
        }
    }
    /**
     * {@link DListRowBar RowBar}나 {@link DListEditBar EditBar}의 표시 위치.
     * {@link DListControlBar.position} 속성으로 설정된다.
     *
     * @see DListControlBar
     * @see concepts.row_bar RowBar 개요
     * @see concepts.edit_bar EditBar 개요
     */
    var DListControlBarPosition;
    (function (DListControlBarPosition) {
        DListControlBarPosition["NEAR"] = "near";
        DListControlBarPosition["FAR"] = "far";
    })(DListControlBarPosition || (DListControlBarPosition = {}));
    var DListControlBarMode;
    (function (DListControlBarMode) {
        /**
         * Bar의 action이나 button들을 행 별로 표시한다.
         */
        DListControlBarMode["BAR"] = "bar";
        /**
         * BAR와 동일하다. 다만 버튼 등이 표시되면서 기존 행을 밀어낸다.
         */
        DListControlBarMode["BAR_PUSH"] = "barPush";
        /**
         * Bar의 action이나 button들을 모든 행에 표시하거나 감춘다.
         */
        DListControlBarMode["ROW"] = "row";
        /**
         * ROW와 동일하다. 다만 버튼 등이 표시되면서 기존 행을 밀어낸다.
         */
        DListControlBarMode["ROW_PUSH"] = "rowPush";
    })(DListControlBarMode || (DListControlBarMode = {}));
    /**
     * @internal
     *
     * 행별로 혹은 전체 행에 bar 아이템을 표시한다.
     * bar 아이템 별로 표시 크기 등 관련 설정을 할 수 있다.
     */
    class ListControlBar extends ListControlObject {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        _doInitDefaults() {
            super._doInitDefaults();
            this._mode = ListControlBar.MODE;
            this._position = DListControlBarPosition.NEAR;
            this._gapLeft = 4;
            this._gapRight = 8;
            this._gapTop = 0;
            this._gapBottom = 8;
        }
        _doDestory() {
            this._rowInfos = null;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /** mode */
        mode() {
            return pickProp(this._mode, this._defs && this._defs._mode);
        }
        setMode(value) {
            if (value !== this._mode) {
                this._mode = value;
                this._changed();
            }
        }
        /**
         * position.
         */
        position() {
            return pickProp(this._position, this._defs && this._defs._position);
        }
        setPosition(value) {
            if (value !== this._position) {
                this._position = value;
                this._changed();
            }
        }
        /**
         * left gap.
         */
        gapLeft() {
            return pickProp(this._gapLeft, this._defs && this._defs._gapLeft);
        }
        setGapLeft(value) {
            value = toNumProp(value);
            if (value !== this._gapLeft) {
                this._gapLeft = value;
                this._changed();
            }
        }
        /**
         * 이 속성을 NaN이 아닌 타당한 값으로 지정하면 내용과 상관없이 이 속성값의 폭으로 표시된다.
         */
        size() {
            return pickProp(this._size, this._defs && this._defs._size);
        }
        setSize(value) {
            value = toNumProp(value);
            if (value !== this._size) {
                this._size = value;
                this._changed();
            }
        }
        /**
         * right gap.
         */
        gapRight() {
            return pickProp(this._gapRight, this._defs && this._defs._gapRight);
        }
        setGapRight(value) {
            value = toNumProp(value);
            if (value !== this._gapRight) {
                this._gapRight = value;
                this._changed();
            }
        }
        /**
         * top gap.
         */
        gapTop() {
            return pickProp(this._gapTop, this._defs && this._defs._gapTop);
        }
        setGapTop(value) {
            value = toNumProp(value);
            if (value !== this._gapTop) {
                this._gapTop = value;
                this._changed();
            }
        }
        /**
         * bottom gap.
         */
        gapBottom() {
            return pickProp(this._gapBottom, this._defs && this._defs._gapBottom);
        }
        setGapBottom(value) {
            value = toNumProp(value);
            if (value !== this._gapBottom) {
                this._gapBottom = value;
                this._changed();
            }
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        gapHorz() {
            return this._gapHorz;
        }
        gapVert() {
            return this._gapVert;
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        // protected _doPrepareRender(): void {
        //     const owner = this.control() as any as IListRowInfoOwner;
        //     const data = owner.data;
        //     // if (data instanceof ListDataSet) {
        //     //     this._dg = data;
        //     //     this._rowInfos = owner.rowInfos();
        //     // } else {
        //     //     this._dg = this._rowInfos = null;
        //     // }
        // }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        _doPrepareRender() {
            this._gapHorz = this.gapLeft() + this.gapRight();
            this._gapVert = this.gapTop() + this.gapBottom();
        }
        _doUnprepareRender() {
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    // defaults
    ListControlBar.MODE = DListControlBarMode.BAR;

    ////////////////////////////////////////////////////////////////////////////////
    // DListStyles.ts
    // 2022. 04. 30. created by dataludi
    // -----------------------------------------------------------------------------
    // Copyright (c) 2021-2022 DataLudi Inc.
    // All rights reserved.
    ////////////////////////////////////////////////////////////////////////////////
    const BUTTON_STYLE = {
        margin: 0,
        whiteSpace: 'nowrap',
        overflow: 'hidden',
        verticalAlign: 'middle'
    };

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     *
     * viewBox 크기가 설정돼야 한다.
     */
    class DShape extends DObject {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(doc, className, style) {
            super();
            if (doc instanceof Document) {
                const svg = this._svg = new DSvg(doc, className);
                svg.setStyle(style);
                this._doInit(svg);
            }
            else if (doc instanceof DShape) {
                // template shape를 복사해서 사용.
                this._svg = new DSvg(doc._svg.svg.cloneNode(true), className);
                this._doClone(doc);
            }
            else {
                // 기존 svg를 그대로 사용.
                this._svg = new DSvg(doc, className);
            }
            Dom.setAttr(this._svg.svg, 'role', 'image');
        }
        //-------------------------------------------------------------------------
        // static members
        //-------------------------------------------------------------------------
        static clone(shape, clazz) {
            return new clazz(shape);
        }
        _doDestory() {
            Dom.remove(this._svg.svg);
            this._svg = null;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        name() {
            // return Object.getPrototypeOf(this.constructor).NAME;
            return this.constructor.NAME;
        }
        dom() {
            return this._svg.svg;
        }
        attached() {
            return !!this._svg.svg.parentElement;
        }
        isDom(svg) {
            return this._svg.svg === svg;
        }
        containsDom(dom) {
            return this._svg.svg.contains(dom);
        }
        setVisible(value) {
            Dom.setVisible(this._svg.svg, value);
        }
        styleTarget() {
            return this._svg.svg.style;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        resize(width, height = NaN) {
            width = width || height;
            height = height || width;
            if (width !== this._width || height !== this._height) {
                this._width = width;
                this._height = height;
                this._svg.setSize(width, height);
                return true;
            }
        }
        setClass(className) {
            this._svg.setClass(className);
        }
        setStyle(style) {
            this._svg.setStyle(style);
        }
        appendTo(dom) {
            if (dom instanceof DElement)
                dom = dom.dom;
            dom.appendChild(this._svg.svg);
        }
        remove() {
            Dom.remove(this._svg.svg);
        }
        makeBackground(width, height) {
            this._svg.makeBackground(width, height);
            return this;
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        _doClone(shape) {
            this._width = shape._width;
            this._height = shape._height;
        }
        _doInit(svg) {
        }
    }
    class ShapeRegistry extends Registy {
        createShape(doc, shapeName) {
            return this.createStock(doc, shapeName) || this.createCustom(shapeName, void 0, void 0);
        }
    }
    /**
     * @internal
     *
     * viewBox 너비/높이를 명시적으로 지정하고 그 크기를 기준으로 상대 좌표로 path를 지정해야 한다.
     * 너비/높이를 지정하지 않으면 기본 10 * 10 크기로 지정된다.
     * 'd' 하나로 구성되는 단색 shape만 지정할 수 있다.
     */
    class DCustomShape extends DShape {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(doc, className, style) {
            super(doc, className, style);
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        setShape(shape) {
            if (shape) {
                this._svg.setViewSize(shape.w, shape.h);
                if (this._path) {
                    this._path.setAttribute('d', shape.d);
                }
                else {
                    this._path = this._svg._createPath(shape.d);
                }
                // 이전에 assignStyle 호출로 (콜백 등) 다른 스타일 값으로 설정됐을 수 있다.
                this._path.style.cssText = '';
            }
            return this;
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doClone(shape) {
            super._doClone(shape);
            if (shape._path) {
                this._path = this._svg.svg.firstElementChild;
            }
        }
    }
    //-------------------------------------------------------------------------
    // const
    //-------------------------------------------------------------------------
    DCustomShape.NAME = '@custom';
    class CheckMark extends DShape {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(doc, className, style) {
            super(doc, className, style);
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doInit(svg) {
            svg.setViewSize(CheckMark.SIZE);
            svg.polyline([5.9, 12.5, 9.7, 16.3, 18.5, 7.5]);
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    CheckMark.NAME = '@checkmark';
    CheckMark.SIZE = 24;
    class DeleteShape extends DShape {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(doc, className, style) {
            super(doc, className, style);
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doInit(svg) {
            svg.setViewSize(DeleteShape.SIZE);
            // svg.line(0, SHAPE_RADIUS, SHAPE_SIZE, SHAPE_RADIUS, LINE_STYLE);
            // svg.line(SHAPE_RADIUS, 0, SHAPE_RADIUS, SHAPE_SIZE, LINE_STYLE);
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    DeleteShape.NAME = '@delete';
    DeleteShape.SIZE = 26;
    class CircleShape extends DShape {
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doInit(svg) {
            svg.setViewSize(CircleShape.SIZE);
            const cx = CircleShape.SIZE / 2;
            const cy = CircleShape.SIZE / 2;
            const r = Math.min(cx, cy);
            this._svg.circle(cx, cy, r, null);
        }
        resize(width, height) {
            // stoke width 때문에 다시 그려야 한다.
            if (super.resize(width, height)) {
                this._svg.setViewSize(this._width, this._height);
                const circle = this._svg.svg.firstElementChild;
                const cx = this._width / 2;
                const cy = this._height / 2;
                const r = Math.min(cx, cy);
                const cs = getComputedStyle(this._svg.svg);
                let w = (parseFloat(cs.strokeWidth) || 0) / 2;
                circle.setAttribute('cx', cx);
                circle.setAttribute('cy', cy);
                circle.setAttribute('r', (r - w));
                return true;
            }
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    CircleShape.NAME = '@circle';
    CircleShape.SIZE = 20;
    class PolygonShape extends DShape {
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doInit(svg) {
            // stroke width 때문에 어차피 resize()를 통해 반드시 다시 그려야 한다.
            // svg.setViewSize(PolygonShape.SIZE);
            const path = this._svg._createPath('M 0 0'); //this.$_getPath(1, 1));
            path.style.pointerEvents = 'none';
            this._svg.svg.appendChild(path);
        }
        resize(width, height) {
            if (super.resize(width, height)) {
                this._svg.setViewSize(this._width, this._height);
                const p = this.$_getPath(this._width, this._height);
                const path = this._svg.svg.firstElementChild;
                path.setAttribute('d', p);
                return true;
            }
        }
        $_getPath(w, h) {
            const pts = this._getPoints();
            for (let i = 0, n = pts.length / 2 >> 0; i < n; i++) {
                pts[i * 2] *= w;
                pts[i * 2 + 1] *= h;
            }
            let s = `M ${pts[0]} ${pts[1]} L`;
            s += pts.slice(2).join(' ') + ' z';
            return s;
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    PolygonShape.SIZE = 1;
    class StarShape extends PolygonShape {
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _getPoints() {
            return [0.5, 0, 0.6122, 0.3454, 0.9755, 0.3454, 0.6816, 0.5590, 0.7938, 0.9045, 0.5, 0.6910, 0.2061, 0.9045, 0.3183, 0.5590, 0.02447, 0.3454, 0.3877, 0.3454];
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    StarShape.NAME = '@star';
    class PathShape extends DShape {
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(doc, svgWidth, svgHeight, path, className) {
            super(doc, className);
            this._svg.setViewSize(svgWidth, svgHeight);
            !this._svg.svg.firstElementChild && this._svg.path(path);
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     *
     * 크기를 갖는 element base.
     */
    class DListElement extends DElement {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        clickable() {
            return false;
        }
        click(dom, x, y) {
        }
        measure(doc, hint, maxWidth, maxHeight) {
            const css = this.dom.style;
            this.mw = this.mh = NaN;
            this._doPrepareRender(doc, hint);
            this._doApplyStyles(css);
            this._doApplyImportantStyles(css);
            const sz = this._doMeasure(doc, maxWidth, maxHeight);
            this.mw = sz.width;
            this.mh = sz.height;
            return sz;
        }
        render(doc) {
            // 부모 element에서 크기가 지정됐다.
            const { width, height } = this.getOffsetSize();
            this._doRender(doc, width, height);
            this._doAfterRender();
        }
        resizeByMeasure() {
            this.resize(this.mw, this.mh);
            return this;
        }
        applyMeasuredBounds() {
            this.move(this.mx, this.my);
            this.resize(this.mw, this.mh);
            return this;
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        /**
         * 초기화시 생성하지 못했던 자식 element등을 상태에 따라 추가/변경한다.
         */
        _doPrepareRender(doc, hint) { }
        _doApplyStyles(css) { }
        _doApplyImportantStyles(css) { }
        _doAfterRender() { }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    // z-index
    DListElement.PANEL_ORDER = '100';
    class ListControlElement extends DListElement {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(doc, model, contentable, className) {
            super(doc, contentable, className);
            this._model = model;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /** model */
        model() {
            return this._model;
        }
        setModel(value) {
            this._model = value;
        }
        listOwner() {
            return this.control;
        }
    }
    class PositonableControlElement extends ListControlElement {
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        setPosition(landscape) {
            const p = this._model.getPosition(this.landscape = landscape);
            this.position = p || DListControlObjectPosition.BOTTOM;
            this.vertical = this.position === DListControlObjectPosition.LEFT || this.position === DListControlObjectPosition.RIGHT;
        }
    }
    const BUTTON_LABEL_GAP = '4px';
    /**
     * @internal
     *
     * TODO: label 과 (img | svg) 동시 표현.
     * NOTE: 수직정렬 문제
     *       1. safari에서는 flex로 처러한다.
     *       2. 크롤에서 flex로 처리하면 다른 layout과 아주 작은 차이로 어긋난다.
     */
    class ButtonElement extends DElement {
        // constructor
        //-------------------------------------------------------------------------
        constructor(doc, className) {
            super(doc, false, className, 'button');
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /** enabled */
        enabled() {
            return !this.dom.disabled;
        }
        setEnabled(value) {
            Dom.setDisabled(this.dom, !value);
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doInitDom(doc, dom) {
            Object.assign(dom.style, BUTTON_STYLE);
            if (_isSafari) {
                const flex = doc.createElement('div');
                flex.style.display = 'flex';
                flex.style.alignItems = 'center';
                flex.style.justifyContent = 'center';
                flex.style.boxSizing = 'border-box';
                flex.style.pointerEvents = 'none';
                dom.appendChild(flex);
            }
            DElement.BOUNDING && (dom.style.border = DElement.BOUNDING_BORDER);
        }
        _setModel(control, model) {
            const doc = control.doc();
            const dom = this.dom;
            const button = _isSafari ? dom.firstElementChild : dom;
            const cls = model.className;
            const st = model.style;
            // if (!model.borderless) {
            Dom.setData(dom, 'image', 1);
            // }
            if (cls !== this._prevClass) {
                this._prevClass && dom.classList.remove(this._prevClass);
                this._prevClass = cls;
                cls && dom.classList.add(cls);
            }
            if (st != this._prevStyles) {
                const css = dom.style;
                if (this._prevStyles) {
                    for (let p in this._prevStyles) {
                        css[p] = '';
                    }
                }
                if (st) {
                    Object.assign(css, st);
                }
                this._prevStyles = st;
            }
            this.resize(NaN, NaN);
            let deco;
            if (model.imageUrl) {
                if (this._shape) {
                    this._shape = this._shape.destroy();
                }
                deco = this.$_setImage(control, button, model);
            }
            else if (model.shape) {
                this._img = Dom.remove(this._img);
                deco = this.$_setShape(control, button, model);
            }
            if (deco) {
                _isSafari ? this.$_arrangeSafari(doc, button, deco, model) : this.$_arrange(doc, button, deco, model);
            }
            else {
                if (this._shape) {
                    this._shape = this._shape.destroy();
                }
                this._img = Dom.remove(this._img);
                this._br = Dom.remove(this._br);
                let span = this._span;
                if (!span) {
                    span = this._span = this.$_createSpan(doc);
                    button.appendChild(span);
                }
                this._span.textContent = model.label || model.name;
                Dom.setData(button, 'image', void 0);
            }
            this.setEnabled(!model.disabled);
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        $_createSpan(doc) {
            const span = doc.createElement('span');
            span.className = ButtonElement.LABEL_CLASS;
            span.style.pointerEvents = 'none';
            span.style.verticalAlign = 'middle'; // flex에서는 의미가 업다.
            return span;
        }
        // css flex 로 구현한다.
        $_arrangeSafari(doc, button, deco, model) {
            const label = model.label;
            let span = this._span;
            if (label && model.labelPosition !== DListButtonLabelPosition.NONE) {
                if (!span) {
                    span = this._span = this.$_createSpan(doc);
                }
                span.textContent = label;
                switch (model.labelPosition) {
                    case DListButtonLabelPosition.LEFT:
                        button.style.flexDirection = 'row';
                        deco.style.paddingLeft = BUTTON_LABEL_GAP; // iOS에서 gap 스타일이 적용되지 않는다.
                        button.insertBefore(span, deco);
                        break;
                    case DListButtonLabelPosition.RIGHT:
                        button.style.flexDirection = 'row';
                        deco.style.paddingRight = BUTTON_LABEL_GAP;
                        button.appendChild(span);
                        break;
                    case DListButtonLabelPosition.TOP:
                        button.style.flexDirection = 'column';
                        button.insertBefore(span, deco);
                        deco.style.paddingTop = BUTTON_LABEL_GAP;
                        break;
                    default:
                        button.style.flexDirection = 'column';
                        deco.style.paddingBottom = BUTTON_LABEL_GAP;
                        button.appendChild(span);
                        break;
                }
            }
            else {
                this._span = Dom.remove(span);
            }
        }
        $_arrange(doc, button, deco, model) {
            const label = model.label;
            let span = this._span;
            if (label && model.labelPosition !== DListButtonLabelPosition.NONE) {
                if (!span) {
                    span = this._span = this.$_createSpan(doc);
                }
                span.textContent = label;
                switch (model.labelPosition) {
                    case DListButtonLabelPosition.LEFT:
                        this._br = Dom.remove(this._br);
                        deco.style.paddingLeft = BUTTON_LABEL_GAP;
                        button.insertBefore(span, deco);
                        break;
                    case DListButtonLabelPosition.RIGHT:
                        this._br = Dom.remove(this._br);
                        deco.style.paddingRight = BUTTON_LABEL_GAP;
                        button.appendChild(span);
                        break;
                    case DListButtonLabelPosition.TOP:
                        this._br = this._br || Dom.createBR(doc, ButtonElement.BR_CLASS);
                        button.insertBefore(span, deco);
                        button.insertBefore(this._br, deco);
                        deco.style.paddingTop = BUTTON_LABEL_GAP;
                        break;
                    default:
                        this._br = this._br || Dom.createBR(doc, ButtonElement.BR_CLASS);
                        deco.style.paddingBottom = BUTTON_LABEL_GAP;
                        button.appendChild(span);
                        button.insertBefore(this._br, span);
                        break;
                }
            }
            else {
                // NOTE: shape나 image가 혼자 있을 때, 높이가 버튼 기본 높이보다 작은 경우,
                //       verticalAlign을 middle로 설정해도 중앙 정렬되지 않는다.
                //       비어 있는 span을 추가하면 정렬된다.
                // this._span = Dom.remove(span);
                if (!span) {
                    span = this._span = this.$_createSpan(doc);
                }
                button.insertBefore(span, deco);
                span.textContent = '';
            }
        }
        $_setImage(control, dom, model) {
            const doc = control.doc();
            const url = model.imageUrl;
            let img = this._img;
            let wImg = model.imageWidth;
            let hImg = model.imageHeight;
            model.style && Object.assign(dom.style, model.style);
            dom.style.overflow = ''; // 이렇게 하지 않으면 (다른 버튼이 이미지가 아닌 경우) 이미지가 잘린다. 부모가 flex라 그런가? 
            dom.textContent = '';
            dom.dataset.type = 'image';
            if (!img) {
                img = this._img = doc.createElement('img');
                img.className = ButtonElement.IMAGE_CLASS;
                img.style.pointerEvents = 'none';
                img.style.verticalAlign = 'middle';
                Dom.setAttr(img, 'aria-hidden', true);
                dom.appendChild(img);
            }
            else if (!img.parentElement) {
                dom.appendChild(img);
            }
            img.src = url;
            !img.complete && control.useImage(url); // 실제 이미지가 로드됐을 때 다시 그려지도록 한다.
            if (isNaN(wImg) && isNaN(hImg)) {
                const sz = _isSafari && control.getImageSize(url);
                if (sz) {
                    wImg = sz.width;
                    hImg = sz.height;
                }
                else {
                    wImg = img.naturalWidth;
                    hImg = img.naturalHeight;
                }
            }
            if (!isNaN(wImg)) {
                img.width = wImg;
                if (isNaN(hImg))
                    img.height = wImg; // 이렇게 해줘야 모델 크기가 설정된 경우 이미지 없는 초기 높이가 계산된다.
            }
            if (!isNaN(hImg)) {
                img.height = hImg;
                if (isNaN(wImg))
                    img.width = hImg;
            }
            return img;
        }
        $_setShape(control, dom, model) {
            const s = model.shape;
            let shape = this._shape;
            let h = Math.max(0, model.shapeHeight);
            const w = Math.max(0, model.shapeWidth) || h || ButtonElement.SHAPE_SIZE;
            h = h || w;
            if (!shape || s !== shape[T_URL]) {
                shape = this._shape = this.control.shapes().createStock(dom.ownerDocument, s) || this.control.shapes().createCustom(s, null, null);
                shape.setClass(ButtonElement.SHAPE_CLASS);
                shape.dom().style.pointerEvents = 'none';
                shape.dom().style.verticalAlign = 'middle';
                shape.appendTo(dom);
            }
            else {
                if (shape instanceof DCustomShape) {
                    shape.setShape(this.control.shapes().getCustom(s));
                }
                if (!shape.attached()) {
                    shape.appendTo(dom);
                }
            }
            shape.resize(w, h);
            shape[T_URL] = s;
            return shape['_svg']['svg'];
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    ButtonElement.LABEL_CLASS = 'dlist-button-label';
    ButtonElement.BR_CLASS = 'dlist-button-br';
    ButtonElement.IMAGE_CLASS = 'dlist-button-image';
    ButtonElement.SHAPE_CLASS = 'dlist-button-shape';
    ButtonElement.SHAPE_SIZE = 20;
    class SvgButton extends DElement {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(doc, className) {
            super(doc, false, SvgButton.BUTTON_CLASS, 'button');
            this.dom.classList.add(className);
        }
        //-------------------------------------------------------------------------
        // static members
        //-------------------------------------------------------------------------
        static createButton(doc, shape, size, className) {
            const button = doc.createElement('button');
            className && (button.className = className);
            const svg = new DSvg(doc).setShape(shape).makeBackground(size);
            button.appendChild(svg.svg);
            return button;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        size() {
            return this._size;
        }
        enabled() {
            return !this.dom.disabled;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        setSize(size) {
            if (size !== this._size) {
                this._size = size;
                this.resize(size, size);
                // this._svg.setSize(size, size);
            }
        }
        setDisabled(disabled) {
            Dom.setDisabled(this.dom, disabled);
        }
        measure() {
            if (!isNaN(this._size)) {
                this.mw = this._size;
                this.mh = this._size;
            }
            else {
                const p = this.getPadding();
                this.mw = SvgButton.DEF_SVG_SIZE + p.left + p.right;
                this.mh = SvgButton.DEF_SVG_SIZE + p.top + p.bottom;
            }
            return { width: this.mw, height: this.mh };
        }
        click() {
            this._doClick();
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        isDom(dom) {
            return super.isDom(dom) || dom === this._svg.svg;
        }
        _doInitDom(doc, dom) {
            const svg = this._svg = new DSvg(doc);
            Object.assign(dom.style, {
                position: 'absolute',
                border: 'none'
            });
            this._svg.svg.style.pointerEvents = 'none';
            this._svg.fillSize();
            this._doInitSvg(svg);
            dom.appendChild(svg.svg);
        }
    }
    //-------------------------------------------------------------------------
    // const
    //-------------------------------------------------------------------------
    SvgButton.BUTTON_CLASS = 'dlist-svg-button';
    SvgButton.DEF_SVG_SIZE = 16;
    /**
     * @internal
     *
     * 툴팁 View 기반 클래스.
     */
    class TooltipElement extends DElement {
    }

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * {@link concepts.data_model 데이터필드} 자료형.
     * <br>
     *
     * @see concepts.data_model 데이터 모델 개요
     * @see DListData
     */
    var DListDataType;
    (function (DListDataType) {
        /**
         * 문자열
         */
        DListDataType["TEXT"] = "text";
        /**
         * 숫자
         */
        DListDataType["NUMBER"] = "number";
        /**
         * Boolean
         */
        DListDataType["BOOL"] = "bool";
        /**
         * 날짜형. Date 객체가 아닌경우 new Date()의 매개변수로 가능한 숫자나 문자열이어야한다.
         * 데이터로 읽어들일 때 Date 객체로 변환한다.
         */
        DListDataType["DATE"] = "date";
        /**
         * BigInt
         */
        DListDataType["BIGINT"] = "bigint";
        /**
         * 임의의 자료형.
         */
        DListDataType["ANY"] = "any";
    })(DListDataType || (DListDataType = {}));
    const _readers = {
        'text': (v) => (v == null) ? v : String(v),
        'number': (v) => Number(v),
        'bool': (v) => (v == null) ? v : Boolean(v),
        'date': (v) => (v instanceof Date ? v : new Date(v)),
        'bigint': (v) => BigInt(v),
        'any': (v) => v
    };
    const numberComparer = (v1, v2) => {
        if (isNaN(v1)) {
            if (isNaN(v2))
                return 0;
            else
                return -1;
        }
        else if (isNaN(v2)) {
            return 1;
        }
        return v1 > v2 ? 1 : v1 < v2 ? -1 : 0;
    };
    /**
     * @internal
     *
     * Data field model.
     */
    class ListDataField {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(name, type = DListDataType.TEXT) {
            if (!name) {
                DListDataError.throw(null, 'Data field name must be exist.');
            }
            this._name = name;
            this._type = type || DListDataType.TEXT;
            this.readValue = _readers[type] || _readers['any'];
            this.comparer = ListDataField.comparers[type];
        }
        //-------------------------------------------------------------------------
        // consts
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // static members
        //-------------------------------------------------------------------------
        static create(name, type = DListDataType.TEXT) {
            if (typeof name === 'string') {
                return new ListDataField(name, type);
            }
            else if (Utils.isObject(name) && name.name) {
                const fld = new ListDataField(name.name, name.type);
                fld.label = name.label;
                fld.default = name.default;
                fld.sortable = !!name.sortable;
                fld.required = !!name.required;
                fld.minimum = name.minimum;
                fld.maximum = name.maximum;
                fld.domain = Array.isArray(name.domain) ? name.domain.slice(0) : void 0;
                return fld;
            }
        }
        static createFields(fields) {
            return fields.map(f => this.create(f));
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        get name() {
            return this._name;
        }
        get type() {
            return this._type;
        }
        /**
         * 필드 label.
         * 컨트롤 헤더 등에 표시될 때 사용되는 text.
         * 지정하지 않으면 {@link name}이 대신 사용된다.
         */
        get label() {
            return this._label;
        }
        set label(value) {
            if (value !== this._label) {
                this._label = value;
                this._changed();
            }
        }
        displayText() {
            return this._label || this._name;
        }
        proxy() {
            return {
                name: this._name,
                label: this._label,
                type: this._type,
                default: this.default,
                sortable: this.sortable
            };
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        _changed() {
            var _a;
            (_a = this._owner) === null || _a === void 0 ? void 0 : _a['$_fieldChanged'](this);
        }
    }
    ListDataField.comparers = {
        text: (v1, v2) => {
            if (v1 == null) {
                if (v2 == null)
                    return 0;
                else
                    return -1;
            }
            else if (v2 == null) {
                return 1;
            }
            return v1 > v2 ? 1 : v1 < v2 ? -1 : 0;
        },
        number: numberComparer,
        bool: (v1, v2) => {
            v1 = v1 ? 1 : 0;
            v2 = v2 ? 1 : 0;
            return v1 - v2;
        },
        date: (v1, v2) => {
            return v1 - v2;
        },
        bigint: numberComparer
    };
    /**
     * @internal
     *
     * 파생 필드.
     */
    class DerivedField extends ListDataField {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(name, extracter, type = DListDataType.TEXT) {
            super(name, type);
            if (typeof extracter !== 'function') {
                throw new DListDataError(null, "Derive field's value extracter must be exists.");
            }
            this._extracter = extracter;
        }
        //-------------------------------------------------------------------------
        // static members
        //-------------------------------------------------------------------------
        static createDerived(name, extracter, type = DListDataType.TEXT) {
            const fld = new DerivedField(name, extracter, type);
            return fld;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        extract(values) {
            return this._extracter(values);
        }
    }
    /**
     * 데이터행 상태.
     *
     * @see DListData.softDeleting
     */
    var DListDataRowState;
    (function (DListDataRowState) {
        /**
         * 수정 상태.
         */
        DListDataRowState["UPDATED"] = "u";
        /**
         * 삭제 상태. 수정할 수 없다.
         */
        DListDataRowState["DELETED"] = "d";
    })(DListDataRowState || (DListDataRowState = {}));
    let $_row_id_ = 0;
    /**
     * @internal
     *
     * List data row.
     */
    class DataRow {
        constructor() {
            //-------------------------------------------------------------------------
            // fields
            //-------------------------------------------------------------------------
            this.id = $_row_id_++;
            this.row = -1;
            this.values = {};
        }
        //-------------------------------------------------------------------------
        // consts
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // static members
        //-------------------------------------------------------------------------
        /**
         * 값이 지정되지 않은 필드 값은 undefined로 저장된다.
         */
        static createRow(fields, dfields, values, reader) {
            const row = new DataRow();
            if (Utils.isObject(values)) {
                const vals = row.values;
                for (const f in fields) {
                    vals[f] = fields[f].default;
                }
                for (const p in values) {
                    const fld = fields[p];
                    if (fld) {
                        vals[fld.name] = fld.readValue(reader ? reader(p, values[p]) : values[p]);
                    }
                }
                // derived fields
                for (const f in dfields) {
                    vals[f] = dfields[f].extract(vals);
                }
            }
            return row;
        }
        /**
         * @internal
         *
         * 값이 지정되지 않은 필드 값은 undefined로 저장된다.
         */
        static createRow2(fields, dfields, values) {
            const row = new DataRow();
            if (Utils.isObject(values)) {
                const vals = row.values;
                for (const f in fields) {
                    vals[f] = fields[f].default;
                }
                for (let p in values) {
                    const fld = fields[p];
                    if (fld) {
                        vals[fld.name] = fld.readValue(values[p]);
                    }
                }
                // derived fields
                for (const f in dfields) {
                    vals[f] = dfields[f].extract(vals);
                }
            }
            return row;
        }
        /**
         * @internal
         *
         * TODO: 정렬된 필드인 경우 binary search.
         */
        static findRow(drows, values, from, to) {
            if (Utils.isObject(values)) {
                if (to < 0)
                    to = drows.length;
                for (let i = from, n = Math.min(to, drows.length); i < n; i++) {
                    if (drows[i].match(values)) {
                        return i;
                    }
                }
            }
            return -1;
        }
        static findRows(drows, values, from, to) {
            const rows = [];
            if (Utils.isObject(values)) {
                if (to < 0)
                    to = drows.length;
                for (let i = from, n = Math.min(to, drows.length); i < n; i++) {
                    if (drows[i].match(values)) {
                        rows.push(drows[i].row);
                    }
                }
            }
            return rows;
        }
        static findDistinctRows(drows, fields, from, to) {
            function equals(v1, v2) {
                for (let f of fields) {
                    if (v1[f] !== v2[f]) {
                        return false;
                    }
                }
                return true;
            }
            function contains(vals, list) {
                for (let v of list) {
                    if (equals(v, vals)) {
                        return true;
                    }
                }
                return false;
            }
            const rows = [];
            if (Array.isArray(fields) && fields.length > 0) {
                const list = [];
                if (to < 0)
                    to = drows.length;
                for (let i = from, n = Math.min(to, drows.length); i < n; i++) {
                    const vals = drows[i].getValues(fields);
                    if (!contains(vals, list)) {
                        rows.push(drows[i].row);
                        list.push(vals);
                    }
                }
            }
            return rows;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        // fillDefaults(fields: ListDataField[]): void {
        //     if (!this.values) {
        //         this.values = {};
        //     }
        //     fields.forEach(field => {
        //         this.values[field.name] = field.default;
        //     });
        // }
        getValues(fields) {
            const vals = this.values;
            const v = {};
            fields.forEach(f => {
                if (f in vals) {
                    v[f] = vals[f];
                }
            });
            return v;
        }
        match(obj) {
            const vals = this.values;
            for (const field in obj) {
                const v = obj[field];
                if (field in vals) {
                    if (v instanceof RegExp) {
                        if (!v.test(vals[field])) {
                            return false;
                        }
                    }
                    else if (v !== vals[field]) {
                        return false;
                    }
                }
                else {
                    return false;
                }
            }
            return true;
        }
        getProp(field, props) {
            let v = this.values[field];
            let i = 0;
            while (v != null && i < props.length) {
                v = v[props[i++]];
            }
            return v;
        }
    }
    class DListDataError extends Error {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(data, message) {
            super(message);
            this.data = data;
        }
        //-------------------------------------------------------------------------
        // static members
        //-------------------------------------------------------------------------
        static throw(data, message) {
            throw new DListDataError(data, message);
        }
        static throwFormat(data, message, value) {
            throw new DListDataError(data, formatMessage(message, value));
        }
        static throwFormat2(data, message, value1, value2) {
            throw new DListDataError(data, formatMessage2(message, value1, value2));
        }
    }
    class DListDataFieldError extends DListDataError {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(data, field, message) {
            super(data, message);
            this.field = field;
        }
    }
    class DListDataRowError extends DListDataError {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(data, error) {
            super(data, error.message || error);
            this.error = error;
        }
    }
    const ROW_CHECKED = 0x1;
    const ROW_CHECKABLE = 0x2;
    const ROW_SEARCHED = 0x4;
    const ROW_DETAILED = 0x8;
    const UI_FLAG = 0x0F;
    const USER_FLAG = 0x10;
    /**
     * @internal
     */
    class DataFlags extends DObject {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(data) {
            super();
            this._checkedCount = 0;
            if (this._data = data) {
                const count = data.rowCount();
                const rows = this._rows = new Array(count);
                for (let i = 0; i < count; i++) {
                    rows[i] = 0;
                }
            }
            else {
                this._rows = [];
            }
        }
        //-------------------------------------------------------------------------
        // static members
        //-------------------------------------------------------------------------
        static isCheckedFlag(flag) {
            return flag === ROW_CHECKED;
        }
        static isCheckableFlag(flag) {
            return flag === ROW_CHECKABLE;
        }
        static isDetailedFlag(flag) {
            return flag === ROW_DETAILED;
        }
        static isUserFlag(flag) {
            return flag >> USER_FLAG;
        }
        _doDestory() {
            this._data = null;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        get count() {
            return this._rows.length;
        }
        checkedCount() {
            return this._checkedCount;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        isChecked(row) {
            return (this._rows[row] & ROW_CHECKED) !== 0;
        }
        setChecked(row, checked) {
            return this.$_changeFlag(row, ROW_CHECKED, checked);
        }
        checkRows(rows, checked) {
            return this.$_changeRows(rows, ROW_CHECKED, checked);
        }
        checkRange(row, count, checked) {
            return this.$_changeRange(row, count, ROW_CHECKED, checked);
        }
        checkAll(checked) {
            return this.$_changeAll(ROW_CHECKED, checked);
        }
        getCheckedRows(checked) {
            return this.$_getFlagged(ROW_CHECKED, checked);
        }
        isCheckable(row) {
            return (this._rows[row] & ROW_CHECKABLE) === 0;
        }
        setCheckable(row, checkable) {
            return this.$_changeFlag(row, ROW_CHECKABLE, !checkable);
        }
        setCheckables(rows, checkable) {
            return this.$_changeRows(rows, ROW_CHECKABLE, !checkable);
        }
        setCheckableRange(row, count, checkable) {
            return this.$_changeRange(row, count, ROW_CHECKABLE, !checkable);
        }
        setCheckaleAll(checkable) {
            return this.$_changeAll(ROW_CHECKABLE, checkable);
        }
        getCheckableRows(checkable) {
            return this.$_getFlagged(ROW_CHECKABLE, !checkable);
        }
        getSearchedRows() {
            return this.$_getFlagged(ROW_SEARCHED, true);
        }
        isSearched(row) {
            return (this._rows[row] & ROW_SEARCHED) !== 0;
        }
        setSearched(row, searched) {
            return this.$_changeFlag(row, ROW_SEARCHED, searched);
        }
        clearSearched() {
            return this.$_changeAll(ROW_SEARCHED, false);
        }
        isDetailed(row) {
            return (this._rows[row] & ROW_DETAILED) !== 0;
        }
        setDetailed(row, detailed, exclusive) {
            if (exclusive) {
                this.detailAll(false);
            }
            return this.$_changeFlag(row, ROW_DETAILED, detailed);
        }
        detailRows(rows, detailed) {
            return this.$_changeRows(rows, ROW_DETAILED, detailed);
        }
        detailRange(row, count, detailed) {
            return this.$_changeRange(row, count, ROW_DETAILED, detailed);
        }
        detailAll(detailed) {
            return this.$_changeAll(ROW_DETAILED, detailed);
        }
        getDetailedRows(detailed) {
            return this.$_getFlagged(ROW_DETAILED, detailed);
        }
        hasUserFlag(row, flag) {
            flag = 1 << (USER_FLAG + flag);
            return (this._rows[row] & flag) !== 0;
        }
        getUserFlaggedRows(flag, set) {
            return this.$_getFlagged(1 << (USER_FLAG + flag), set);
        }
        setUserFlag(row, flag, set) {
            if (set !== this.hasUserFlag(row, flag)) {
                this.$_setFlag(row, 1 << (USER_FLAG + flag), set);
                return true;
            }
            return false;
        }
        setUserFlags(rows, flag, set) {
            return this.$_changeRows(rows, 1 << (USER_FLAG + flag), set);
        }
        setUserFlagRange(row, count, flag, set) {
            return this.$_changeRange(row, count, 1 << (USER_FLAG + flag), set);
        }
        setUserFlagAll(flag, set) {
            return this.$_changeAll(1 << (USER_FLAG + flag), set);
        }
        hasUiFlag(row, flag) {
            flag = 1 << (UI_FLAG + flag);
            return (this._rows[row] & flag) !== 0;
        }
        getUiFlaggedRows(flag, set) {
            return this.$_getFlagged(1 << (UI_FLAG + flag), set);
        }
        setUiFlag(row, flag, set) {
            if (set !== this.hasUserFlag(row, flag)) {
                this.$_setFlag(row, 1 << (UI_FLAG + flag), set);
                return true;
            }
            return false;
        }
        setUiFlags(rows, flag, set) {
            return this.$_changeRows(rows, 1 << (UI_FLAG + flag), set);
        }
        setUiFlagRange(row, count, flag, set) {
            return this.$_changeRange(row, count, 1 << (UI_FLAG + flag), set);
        }
        setUiFlagAll(flag, set) {
            return this.$_changeAll(1 << (UI_FLAG + flag), set);
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        $_setFlag(row, flag, set) {
            if (set) {
                this._rows[row] |= flag;
            }
            else {
                this._rows[row] &= ~flag;
            }
        }
        $_changeFlag(row, flag, set) {
            if (row >= 0 && row < this._rows.length) {
                const v = (this._rows[row] & flag) !== 0;
                if (v !== set) {
                    this.$_setFlag(row, flag, set);
                    if (flag === ROW_CHECKED)
                        this._checkedCount += set ? 1 : -1;
                    this._data && this._data['_fireEvent']('onDataFlagChanged', this, row, flag);
                    return true;
                }
            }
            return false;
        }
        $_changeRows(rows, flag, set) {
            const list = [];
            if (Array.isArray(rows) && rows.length > 0) {
                const rows2 = this._rows;
                rows.forEach(r => {
                    const v = (rows2[r] & flag) !== 0;
                    if (set !== v) {
                        this.$_setFlag(r, flag, set);
                        list.push(r);
                    }
                });
            }
            if (this._data && list.length > 0) {
                if (flag === ROW_CHECKED)
                    this._checkedCount += set ? list.length : -list.length;
                this._data['_fireEvent']('onDataFlagsChanged', this, list, flag);
            }
            return list;
        }
        $_changeRange(row, count, flag, set) {
            const rows = this._rows;
            const list = [];
            if (count > 0 && row >= 0 && row < rows.length) {
                for (let r = row, end = Math.min(rows.length, row + count); r < end; r++) {
                    const v = (rows[r] & flag) !== 0;
                    if (set !== v) {
                        this.$_setFlag(r, flag, set);
                        list.push(r);
                    }
                }
            }
            if (this._data && list.length > 0) {
                if (flag === ROW_CHECKED)
                    this._checkedCount += set ? list.length : -list.length;
                this._data['_fireEvent']('onDataFlagsChanged', this, list, flag);
            }
            return list;
        }
        $_changeAll(flag, set) {
            const rows = this._rows;
            let changed = false;
            for (let r = rows.length - 1; r >= 0; r--) {
                const v = (rows[r] & flag) !== 0;
                if (set !== v) {
                    this.$_setFlag(r, flag, set);
                    changed = true;
                }
            }
            if (this._data && changed) {
                if (flag === ROW_CHECKED)
                    this._checkedCount = set ? rows.length : 0;
                this._data['_fireEvent']('onDataFlagAllChanged', this, flag);
            }
            return changed;
        }
        $_getFlagged(flag, set) {
            const rows = this._rows;
            const list = [];
            for (let r = 0, n = rows.length; r < n; r++) {
                const v = (rows[r] & flag) !== 0;
                if (set === v) {
                    list.push(r);
                }
            }
            return list;
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    DataFlags.MAX_UI_FLAG = UI_FLAG;
    DataFlags.MAX_USER_FLAG = USER_FLAG;
    class DummyDataFlags extends DataFlags {
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        checkedCount() {
            return 0;
        }
        isChecked(row) {
            return false;
        }
        setChecked(row, checked) {
            return false;
        }
        checkRows(rows, checked) {
            return [];
        }
        checkRange(row, count, checked) {
            return [];
        }
        checkAll(checked) {
            return false;
        }
        getCheckedRows(checked) {
            return [];
        }
        isCheckable(row) {
            return false;
        }
        setCheckable(row, checkable) {
            return false;
        }
        setCheckables(rows, checkable) {
            return [];
        }
        setCheckableRange(row, count, checkable) {
            return [];
        }
        setCheckaleAll(checkable) {
            return false;
        }
        getCheckableRows(checkable) {
            return [];
        }
        getSearchedRows() {
            return [];
        }
        isSearched(row) {
            return false;
        }
        setSearched(row, searched) {
            return false;
        }
        clearSearched() {
            return false;
        }
        isDetailed(row) {
            return false;
        }
        setDetailed(row, detailed, exclusive) {
            return false;
        }
        detailRows(rows, detailed) {
            return [];
        }
        detailRange(row, count, detailed) {
            return [];
        }
        detailAll(detailed) {
            return false;
        }
        getDetailedRows(detailed) {
            return [];
        }
        hasUserFlag(row, flag) {
            return false;
        }
        getUserFlaggedRows(flag, set) {
            return [];
        }
        setUserFlag(row, flag, set) {
            return false;
        }
        setUserFlags(rows, flag, set) {
            return [];
        }
        setUserFlagRange(row, count, flag, set) {
            return [];
        }
        setUserFlagAll(flag, set) {
            return false;
        }
        hasUiFlag(row, flag) {
            return false;
        }
        getUiFlaggedRows(flag, set) {
            return [];
        }
        setUiFlag(row, flag, set) {
            return false;
        }
        setUiFlags(rows, flag, set) {
            return [];
        }
        setUiFlagRange(row, count, flag, set) {
            return [];
        }
        setUiFlagAll(flag, set) {
            return false;
        }
    }
    //-------------------------------------------------------------------------
    // static members
    //-------------------------------------------------------------------------
    DummyDataFlags.Instance = new DummyDataFlags(null);
    /**
     * @internal
     */
    class DataFlagsCollection extends DObject {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(data) {
            super();
            this._flags = {};
            this._data = data;
        }
        _doDestory() {
            for (let p in this._flags) {
                this._flags[p].destroy();
            }
            this._data = null;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        isEmpty() {
            let empty = true;
            for (const p in this._flags) {
                empty = false;
                break;
            }
            return empty;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        _rowAdded(row) {
            const flags = this._flags;
            for (let f in flags) {
                flags[f]._rows.splice(row, 0, 0);
            }
        }
        // rows는 정렬됐다고 가정.
        _rowsAdded(rows) {
            const flags = this._flags;
            for (let f in flags) {
                const frows = flags[f]._rows;
                rows.forEach(r => {
                    frows.splice(r, 0, 0);
                });
            }
        }
        _rowRangeAdded(row, count) {
            const flags = this._flags;
            for (let f in flags) {
                const frows = flags[f]._rows;
                for (let i = 0; i < count; i++) {
                    frows.splice(row + i, 0, 0);
                }
            }
        }
        _cleared(oldCount) {
            const flags = this._flags;
            for (let owner in flags) {
                const f = flags[owner];
                const frows = f._rows;
                frows.length = 0;
                f._checkedCount = 0;
            }
        }
        _rowDeleted(row) {
            const flags = this._flags;
            for (let owner in flags) {
                const f = flags[owner];
                const frows = f._rows;
                if ((frows[row] & ROW_CHECKED) !== 0)
                    f._checkedCount--;
                frows.splice(row, 1);
            }
        }
        // rows는 정렬됐다고 가정.
        _rowsDeleted(rows) {
            const flags = this._flags;
            for (let owner in flags) {
                const f = flags[owner];
                const frows = f._rows;
                for (let i = rows.length - 1; i >= 0; i--) {
                    if ((frows[rows[i]] & ROW_CHECKED) !== 0)
                        f._checkedCount--;
                    frows.splice(rows[i], 1);
                }
            }
        }
        _rangeDeleted(row, count) {
            const flags = this._flags;
            for (let owner in flags) {
                const f = flags[owner];
                const frows = f._rows;
                for (let i = 0; i < count; i++) {
                    if ((frows[row + i] & ROW_CHECKED) !== 0)
                        f._checkedCount--;
                }
                frows.splice(row, count);
            }
        }
        _rowMoved(row, to) {
            const flags = this._flags;
            for (let owner in flags) {
                const f = flags[owner];
                const frows = f._rows;
                const v = frows.splice(row, 1)[0];
                frows.splice(to, 0, v);
            }
        }
        _rowsMoved(row, count, to) {
            const flags = this._flags;
            for (let owner in flags) {
                const f = flags[owner];
                const frows = f._rows;
                const vals = frows.splice(row, count)[0];
                frows.splice.apply(frows, [to, 0].concat(vals));
            }
        }
        // sorting, filtering 후에 호출된다.
        _reset(drows, newCount) {
            const flags = this._flags;
            for (let owner in flags) {
                const f = flags[owner];
                const frows = f._rows;
                const rows = new Array(newCount);
                drows.forEach((drow, i) => rows[drow.newIdx] = frows[i]);
                f._rows = rows;
            }
        }
        get(owner) {
            return this._flags[owner.hash];
        }
        /**
         * DListData 행들에 대해 자신만의 flag를 관리해야 하는 객체(대개 list control)가 플래그 셋 생성을 요청한다.
         * 이미 존재하면 그 flag set을 리턴한다.
         *
         * @param owner 생성되는 flag set을 소유할 객체.
         */
        add(owner) {
            const h = owner.hash;
            let flags = this._flags[h];
            if (!flags) {
                flags = this._flags[h] = new DataFlags(this._data);
            }
            return flags;
        }
        /**
         * owner의 요청으로 생성된 플래그 셋을 제거한다.
         */
        remove(owner) {
            this._flags[owner.hash].destroy();
            delete this._flags[owner.hash];
        }
    }
    let _data_name_ = Math.random() * 10000000 >> 0;
    class ListDataOjbject extends DEventProvider {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(name) {
            super();
            // DataLink 등에서 data 이름을 필수값으로 사용한다.
            this._name = name || ('@_dlist_dv_' + _data_name_++);
            this._flags = new DataFlagsCollection(this);
        }
        //-------------------------------------------------------------------------
        // static members
        //-------------------------------------------------------------------------
        static checkRow(dv, row) {
            if (row < 0 || row >= dv.rowCount()) {
                DListDataError.throwFormat(dv.wrapperOrThis(), locale.invalidRowIndex, row);
            }
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        name() {
            return this._name;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        addFlags(owner) {
            return this._flags.add(owner);
        }
        removeFlags(owner) {
            this._flags.remove(owner);
        }
        getFlags(owner) {
            return this._flags.get(owner);
        }
        flagChanged(flags, row, flag) {
            this._fireEvent('onDataFlagChanged', flags, row, flag);
        }
        flagsChanged(flags, rows, flag) {
            this._fireEvent('onDataFlagsChanged', flags, rows, flag);
        }
        flagAllChanged(flags, flag) {
            this._fireEvent('onDataFlagAllChanged', flags, flag);
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    class RowCellObject extends DWrappableObject {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(owner, defaults) {
            super();
            this._styleArgs = {
                context: void 0,
                row: -1
            };
            this._owner = owner;
            this._defs = defaults;
            !defaults && this._doInitDefaults();
        }
        _doInitDefaults() {
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * 이미지의 alt,
         * 혹은 text가 불분명한 button의 aria-label 등으로 사용.
         */
        hint() {
            return pickProp(this._hint, this._defs && this._defs._hint);
        }
        setHint(value) {
            if (value !== this._hint) {
                this._hint = value;
                this._changed();
            }
        }
        /** cellStyle */
        cellStyle() {
            return pickProp(this._cellStyle, this._defs && this._defs._cellStyle);
        }
        setCellStyle(value) {
            if (value !== this._cellStyle) {
                this._cellStyle = value;
                this._cellStyleChanged = true;
                this._changed();
            }
        }
        /**
         * cellStyleCallback
         */
        cellStyleCallback() {
            return pickProp(this._cellStyleCallback, this._defs && this._defs._cellStyleCallback);
        }
        setCellStyleCallback(value) {
            if (value !== this._cellStyleCallback) {
                this._cellStyleCallback = value;
                this._changed();
            }
        }
        /** style */
        style() {
            return pickProp(this._style, this._defs && this._defs._style);
        }
        setStyle(value) {
            if (value !== this._style) {
                this._style = value;
                this._styleChanged = true;
                this._changed();
            }
        }
        /**
         * styleCallback
         */
        styleCallback() {
            return pickProp(this._styleCallback, this._defs && this._defs._styleCallback);
        }
        setStyleCallback(value) {
            if (value !== this._styleCallback) {
                this._styleCallback = value;
                this._changed();
            }
        }
        runCellStyle(force) {
            return (force || this._cellStyleChanged) && this._runCellStyle;
        }
        runStyle(force) {
            return (force || this._styleChanged) && this._runStyle;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        getCellStyle(row) {
            const cb = this._runCellStyleCallback;
            if (cb) {
                this._styleArgs.row = row;
                return cb(this._styleArgs) || this._runCellStyle;
            }
            return this._runCellStyle;
        }
        getStyle(row) {
            const cb = this._runStyleCallback;
            if (cb) {
                this._styleArgs.row = row;
                return cb(this._styleArgs) || this._runStyle;
            }
            return this._runStyle;
        }
        prepareRender() {
            this._cellStyleChanged = this._cellStyleChanged || this._defs && this._defs._cellStyleChanged;
            this._runCellStyle = this.cellStyle();
            this._runCellStyleCallback = this.cellStyleCallback();
            this._styleChanged = this._styleChanged || this._defs && this._defs._styleChanged;
            this._runStyle = this.style();
            this._runStyleCallback = this.styleCallback();
            this._styleArgs.context = this.wrapperOrThis();
            this._doPrepareRender();
        }
        unprepareRender() {
            this._styleChanged = false;
            this._cellStyleChanged = false;
            // this._defs && this._defs.unprepareRender(); // rowBar나 editBar에서 호출한다.
            this._doUnprepareRender();
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        _changed() {
            this._owner && this._owner.rowCellObjectChanged(this);
        }
        _doPrepareRender() {
        }
        _doUnprepareRender() {
        }
    }
    /**
     * @internal
     *
     * 행 이동 핸들.
     * [접근성] 'moveUp', 'moveDown' 버튼을 추가한다.
     */
    class RowMover extends RowCellObject {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        _doInitDefaults() {
            super._doInitDefaults();
            this._size = RowMover.SIZE;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * size
         */
        size() {
            return pickProp(this._size, this._defs && this._defs._size);
        }
        setSize(value) {
            if (value !== this._size) {
                this._size = value;
                this._changed();
            }
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    RowMover.SIZE = 24;
    /**
     * {@link DListRowBar Row Bar}나 {@link DListEditBar Edit Bar}에 표시되는
     * {@link DListRowOrder 행번호 셀}에 표시될 값의 종류.
     * <br>
     * {@link DListRowOrder.display} 속성으로 사용된다.
     *
     * @see concepts.row_bar Row Bar 개요
     * @see concepts.edit_bar Edit Bar 개요
     */
    var DListRowOrderDisplay;
    (function (DListRowOrderDisplay) {
        /**
         * 행 번호.
         */
        DListRowOrderDisplay["ROW"] = "row";
        /**
         * DataLink에서 행이 포한된 level 내에서의 index.
         * data link가 아니면 {@link ROW}와 동일하다.
         */
        DListRowOrderDisplay["LEVEL_ROW"] = "levelRow";
    })(DListRowOrderDisplay || (DListRowOrderDisplay = {}));
    class RowOrder extends RowCellObject {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        _doInitDefaults() {
            super._doInitDefaults();
            this._display = DListRowOrderDisplay.ROW;
            this._minWidth = RowOrder.MIN_WIDTH;
            this._fitWidth = true;
            this._rowOffset = 1;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * 표시할 값의 종류.
         */
        display() {
            return pickProp(this._display, this._defs && this._defs._display);
        }
        setDisplay(value) {
            this._display = value;
        }
        /**
         * min width
         */
        minWidth() {
            return pickProp(this._minWidth, this._defs && this._defs._minWidth);
        }
        setMinWidth(value) {
            value = pickNum(value, NaN);
            if (value !== this._minWidth) {
                this._minWidth = value;
                this._changed();
            }
        }
        /**
         * fit width
         */
        fitWidth() {
            return pickProp(this._fitWidth, this._defs && this._defs._fitWidth);
        }
        setFitWidth(value) {
            if (value !== this._fitWidth) {
                this._fitWidth = value;
                this._changed();
            }
        }
        /**
         * row offset.
         */
        rowOffset() {
            return pickProp(this._rowOffset, this._defs && this._defs._rowOffset);
        }
        setRowOffset(value) {
            value = pickNum(value, 0);
            if (value !== this._rowOffset) {
                this._rowOffset = value;
                this._changed();
            }
        }
        /**
         * prefix.
         */
        prefix() {
            return pickProp(this._prefix, this._defs && this._defs._prefix);
        }
        setPrefix(value) {
            if (value !== this._prefix) {
                this._prefix = value;
                this._changed();
            }
        }
        /**
         * suffix.
         */
        suffix() {
            return pickProp(this._suffix, this._defs && this._defs._suffix);
        }
        setSuffix(value) {
            if (value !== this._suffix) {
                this._suffix = value;
                this._changed();
            }
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        getText(dv, row) {
            if (this.runDisplay === DListRowOrderDisplay.LEVEL_ROW) {
                row = dv.levelRowOfRow(row);
            }
            return this.runPrefix + (row + this.runOffset) + this.runSuffix;
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doPrepareRender() {
            this.runDisplay = this.display();
            this.runOffset = this.rowOffset();
            this.runPrefix = this.prefix() || '';
            this.runSuffix = this.suffix() || '';
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    RowOrder.MIN_WIDTH = 20;
    /**
     * {@link DListRowBar Row Bar}의 check 상자들을 드래그할 때 개별 체크 상자들에 적용할 방식.
     * <br>
     * {@link DListRowCheckBox.dragMode} 속성으로 사용된다.
     *
     * @see concepts.row_bar Row Bar 개요
     */
    var DListDragCheckMode;
    (function (DListDragCheckMode) {
        DListDragCheckMode["NONE"] = "none";
        DListDragCheckMode["TOGGLE"] = "toggle";
        DListDragCheckMode["CHECK"] = "check";
        DListDragCheckMode["UNCHECK"] = "uncheck";
    })(DListDragCheckMode || (DListDragCheckMode = {}));
    class RowCheckBox extends RowCellObject {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        _doInitDefaults() {
            super._doInitDefaults();
            this._size = RowCheckBox.SIZE;
            this._masterVisible = false;
            this._dragMode = DListDragCheckMode.CHECK;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /** size */
        size() {
            return pickProp(this._size, this._defs && this._defs._size);
        }
        setSize(value) {
            if (value != this._size) {
                this._size = value;
                this._changed();
            }
        }
        /**
         * master행에 표시할 것인가?
         */
        masterVisible() {
            return pickProp(this._masterVisible, this._defs && this._defs._masterVisible);
        }
        setMasterVisible(value) {
            if (value !== this._masterVisible) {
                this._masterVisible = value;
                this._changed();
            }
        }
        /**
         * check 상자들을 드래그할 때 개별 체크 상자들에 적용할 방식.
         */
        dragMode() {
            return pickProp(this._dragMode, this._defs && this._defs._dragMode);
        }
        setDragMode(value) {
            this._dragMode = value;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        canDrag() {
            const mode = this.dragMode();
            return mode && mode !== DListDragCheckMode.NONE;
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    RowCheckBox.SIZE = 22;
    /**
     * @internal
     *
     * 데이터 행의 rowBar 나 editBar 영역에 표시되는 버튼 설정 정보 모델.
     */
    class RowButton extends RowCellObject {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(owner, label, defaults) {
            super(owner, defaults);
            if (!defaults) {
                this._label = this._label || label;
                this._doInitButton(owner);
            }
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * 버튼 label.
         */
        label() {
            return pickProp(this._label, this._defs && this._defs._label);
        }
        setLabel(value) {
            if (value !== this._label) {
                this._label = value;
                this._changed();
            }
        }
        /**
         * 버튼 image url.
         */
        imageUrl() {
            return pickProp(this._imageUrl, this._defs && this._defs._imageUrl);
        }
        setImageUrl(value) {
            if (value !== this._imageUrl) {
                this._imageUrl = value;
                this._changed();
            }
        }
        /**
         * 버튼 너비.
         * 지정하지 않으면 계산된 너비.
         */
        width() {
            return pickProp(this._width, this._defs && this._defs._width);
        }
        setWidth(value) {
            if (value !== this._width) {
                this._width = value;
                this._changed();
            }
        }
        /**
         * 버튼 높이.
         * 지정하지 않으면 계산된 높이.
         */
        height() {
            return pickProp(this._height, this._defs && this._defs._height);
        }
        setHeight(value) {
            if (value !== this._height) {
                this._height = value;
                this._heightD = parsePercentSize(value, false);
                this._changed();
            }
        }
        isRelativeHeight() {
            if (this._height !== void 0) {
                return this._heightD && !this._heightD.fixed;
            }
            else if (this._defs) {
                return this._defs.isRelativeHeight();
            }
        }
        /**
         * 기본 class에 추가될 css class 이름.
         */
        className() {
            return pickProp(this._className, this._defs && this._defs._className);
        }
        setClassName(value) {
            if (value !== this._className) {
                this._className = value;
                this._changed();
            }
        }
        letter() {
            return pickProp(this._letter, this._defs && this._defs._letter);
        }
        setLetter(value) {
            if (value !== this._letter) {
                this._letter = Utils.copyObject(value);
                this._changed();
            }
        }
        /**
         * true를 리턴하면 기본 기능이 실행되지 않는다.
         */
        onClick() {
            return pickProp(this._onClick, this._defs && this._defs._onClick);
        }
        setOnClick(value) {
            this._onClick = value;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        click(hint, row) {
            const cb = this.onClick();
            if (!cb || !cb(this._getArgs(row))) {
                this._doClick(hint, row);
            }
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        _doInitButton(owner) {
        }
        _getArgs(row) {
            return { button: this.wrapperOrThis(), row };
        }
        _doClick(hint, row) {
            return false;
        }
    }
    /**
     * @internal
     *
     * 데이터 행의 rowBar 나 editBar 영역에 표시되는 이미지 설정 정보 모델.
     */
    class RowImage extends RowCellObject {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        _doInitDefaults() {
            super._doInitDefaults();
            this._width = RowImage.DEF_SIZE;
            this._height = RowImage.DEF_SIZE;
            this._clickable = false;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * image url.
         */
        imageUrl() {
            return pickProp(this._imageUrl, this._defs && this._defs._imageUrl);
        }
        setImageUrl(value) {
            if (value !== this._imageUrl) {
                this._imageUrl = value;
                this._changed();
            }
        }
        /**
         * 이미지 표시 너비.
         */
        width() {
            return pickProp(this._width, this._defs && this._defs._width);
        }
        setWidth(value) {
            value = pickNum(value, 0);
            if (value !== this._width) {
                this._width = value;
                this._changed();
            }
        }
        /**
         * 이미지 표시 높이.
         */
        height() {
            return pickProp(this._height, this._defs && this._defs._height);
        }
        setHeight(value) {
            value = pickNum(value, 0);
            if (value !== this._height) {
                this._height = value;
                this._changed();
            }
        }
        /**
         * clickable
         */
        clickable() {
            return pickProp(this._clickable, this._defs && this._defs._clickable);
        }
        setClickable(value) {
            if (value !== this._clickable) {
                this._clickable = value;
                this._changed();
            }
        }
        /**
         * url callback.
         */
        urlCallback() {
            return pickProp(this._urlCallback, this._defs && this._defs._urlCallback);
        }
        setUrlCallback(value) {
            this._urlCallback = value;
        }
        /**
         * click callback.
         */
        onClick() {
            return pickProp(this._onClick, this._defs && this._defs._onClick);
        }
        setOnClick(value) {
            this._onClick = value;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        getImageUrl(row) {
            const cb = this.urlCallback();
            return pickProp((cb && cb({ model: this.wrapperOrThis(), row })), this.imageUrl());
        }
        click(row, imageUrl) {
            if (this._clickable) {
                const cb = this.onClick();
                cb && cb({ model: this.wrapperOrThis(), row, imageUrl });
            }
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    RowImage.DEF_SIZE = 24;
    class RowShape extends RowCellObject {
        constructor() {
            super(...arguments);
            //-------------------------------------------------------------------------
            // fields
            //-------------------------------------------------------------------------
            this._shapeArgs = {
                model: void 0,
                row: -1
            };
            this._clickArgs = {
                model: void 0,
                row: -1,
                shape: void 0
            };
        }
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        _doInitDefaults() {
            super._doInitDefaults();
            this._size = RowShape.SIZE;
            this._shape = RowShape.SHAPE;
            this._clickable = false;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * size
         */
        size() {
            return pickProp(this._size, this._defs && this._defs._size);
        }
        setSize(value) {
            if (value !== this._size) {
                this._size = value;
                this._changed();
            }
        }
        /**
         * shape name
         */
        shape() {
            return pickProp(this._shape, this._defs && this._defs._shape);
        }
        setShape(value) {
            if (value !== this._shape) {
                this._shape = value;
                this._changed();
            }
        }
        /**
         * clickable
         */
        clickable() {
            return pickProp(this._clickable, this._defs && this._defs._clickable);
        }
        setClickable(value) {
            if (value !== this._clickable) {
                this._clickable = value;
                this._changed();
            }
        }
        /**
         * shape callback.
         */
        shapeCallback() {
            return pickProp(this._shapeCallback, this._defs && this._defs._shapeCallback);
        }
        setShapeCallback(value) {
            this._shapeCallback = value;
        }
        /**
         * click callback;
         */
        onClick() {
            return pickProp(this._onClick, this._defs && this._defs._onClick);
        }
        setOnClick(value) {
            this._onClick = value;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        getShape(row) {
            const cb = this.shapeCallback();
            if (cb) {
                const args = this._shapeArgs;
                args.model = this.wrapperOrThis();
                args.row = row;
                const s = cb(args);
                return s !== void 0 ? s : this.shape();
            }
            return this.shape();
        }
        click(row, shapeName) {
            const cb = this.clickable() && this.onClick();
            if (cb) {
                const args = this._clickArgs;
                args.model = this.wrapperOrThis();
                args.row = row;
                args.shape = shapeName;
                cb(args);
            }
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    RowShape.SIZE = 20;
    RowShape.SHAPE = '@star';
    class RowLetter extends RowCellObject {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        _doInitDefaults() {
            super._doInitDefaults();
            this._letter = 'Σ';
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /** letter */
        letter() {
            return pickProp(this._letter, this._defs && this._defs._letter);
        }
        setLetter(value) {
            if (value !== this._letter) {
                this._letter = value;
                this._changed();
            }
        }
    }
    var DRowExpanderPosition;
    (function (DRowExpanderPosition) {
        DRowExpanderPosition["NONE"] = "none";
        DRowExpanderPosition["HEAD"] = "head";
        DRowExpanderPosition["FOOT"] = "foot";
    })(DRowExpanderPosition || (DRowExpanderPosition = {}));
    class RowExpander extends RowButton {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(owner, defaults) {
            super(owner, '>', defaults);
        }
        _doInitDefaults() {
            this._position = DRowExpanderPosition.FOOT;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * 버튼 위치.
         */
        position() {
            return pickProp(this._position, this._defs && this._defs._position);
        }
        setPosition(value) {
            if (value !== this._position) {
                this._position = value;
                this._changed();
            }
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    var DListEditBarAction;
    (function (DListEditBarAction) {
        /**
         * 아무것도 표시하지 않고 자리만 차지.
         */
        DListEditBarAction["NONE"] = "none";
        /**
         * 행 이동 상자 표시.
         * 접근성을 위해 Up/Down 대체 버튼을 (화면에 보이이지 않는 위치에)표시.
         */
        DListEditBarAction["MOVE"] = "move";
        /**
         * 데이터 행 상세 정보. {@link DListControl.showInfoPage 행 정보 뷰}를 표시한다.
         */
        DListEditBarAction["INFO"] = "info";
        /**
         * 행 삭제.
         */
        DListEditBarAction["DELETE"] = "delete";
        /**
         * 신규 데이터행 추가. {@link DListControl.showEditPage 행 편집 뷰}를 추가 모드로 표시한다.
         */
        DListEditBarAction["ADD"] = "add";
        /**
         * 데이터행 수정. {@link DListControl.showEditPage 행 편집 뷰}를 수정 모드로 표시한다.
         */
        DListEditBarAction["EDIT"] = "edit";
        /**
         * 데이터행과 관련된 url로 페이지 전환.
         */
        DListEditBarAction["LINK"] = "link";
        /**
         * 사용자 action.
         */
        DListEditBarAction["CUSTOM"] = "custom";
    })(DListEditBarAction || (DListEditBarAction = {}));
    class RowDeleteButton extends RowButton {
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * 삭제 확인 메시지. 이 속성이 설정되면 버튼 클릭 시 행 삭제 전 확인 창이 표시된다.
         */
        confirmMessage() {
            return pickProp(this._confirmMessage, this._defs && this._defs._confirmMessage);
        }
        setConfirmMessage(value) {
            this._confirmMessage = value;
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doClick(bar, row) {
            const s = this.confirmMessage();
            if (!s || confirm(s)) {
                bar.owner().data().deleteRow(row, false);
            }
            return true;
        }
    }
    class RowEditButton extends RowButton {
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * edit view header
         */
        editHeader() {
            return pickProp(this._editHeader, this._defs && this._defs._editHeader);
        }
        setEditHeader(value) {
            if (value !== this._editHeader) {
                this._editHeader = value;
                this._changed();
            }
        }
        /**
         * edit view layout template
         */
        editTemplate() {
            return pickProp(this._editTemplate, this._defs && this._defs._editTemplate);
        }
        setEditTemplate(value) {
            if (value !== this._editTemplate) {
                this._editTemplate = value;
                this._changed();
            }
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doClick(bar, row) {
            const view = {
                header: this.editHeader(),
                template: this.editTemplate()
            };
            bar.control()['showEditPage'](row, view, true);
            return true;
        }
    }
    class RowAddButton extends RowEditButton {
        //-------------------------------------------------------------------------
        // property fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        _doInitButton(owner) {
            this.appending = false;
            this.setLetter({
                letter: '+',
                size: 25
            });
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doClick(bar, row) {
            return super._doClick(bar, -1);
        }
    }
    /**
     * @internal
     *
     * 문자가 'ⓘ'이고, transparent인 {@link letter}가 기본 설정된다.
     */
    class RowInfoButton extends RowButton {
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * info view header
         */
        infoHeader() {
            return pickProp(this._infoHeader, this._defs && this._defs._infoHeader);
        }
        setInfoHeader(value) {
            if (value !== this._infoHeader) {
                this._infoHeader = value;
                this._changed();
            }
        }
        /**
         * info view layout template
         */
        infoTemplate() {
            return pickProp(this._infoTemplate, this._defs && this._defs._infoTemplate);
        }
        setInfoTemplate(value) {
            if (value !== this._infoTemplate) {
                this._infoTemplate = value;
                this._changed();
            }
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doInitButton(IRowCellObjectOwner) {
            this.setLetter({
                letter: 'ⓘ',
                transparent: true
            });
            this.setStyle({
                fontSize: '28px',
            });
        }
        _doClick(bar, row) {
            const view = {
                header: this.infoHeader(),
                template: this.infoTemplate()
            };
            bar.control()['showInfoPage'](row, view, true);
            return true;
        }
    }
    class RowLinkButton extends RowButton {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        _doInitDefaults() {
            this._target = '_self'; // '_blank'
            this.setLetter({
                letter: '→',
                transparent: true
            });
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * window.open target.
         */
        target() {
            return pickProp(this._target, this._defs && this._defs._target);
        }
        setTarget(value) {
            this._target = value;
        }
        /**
         * 문자열에 포함된 '${row}'는 버튼이 포함된 데이터행의 번호로 변환된다.
         */
        url() {
            return pickProp(this._url, this._defs && this._defs._url);
        }
        setUrl(value) {
            this._url = value;
        }
        /**
         * url 속성보다 우선한다.
         */
        urlCallback() {
            return pickProp(this._urlCallback, this._defs && this._defs._urlCallback);
        }
        setUrlCallback(value) {
            this._urlCallback = value;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        getUrl(row) {
            const cb = this.urlCallback();
            return pickProp(cb && cb(this._getArgs(row)), this.url());
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doClick(bar, row) {
            const url = this.getUrl(row);
            if (url)
                window.open(url, this._target); // window.location.href = url;
            return true;
        }
    }
    /**
     * @internal
     *
     * List 컨트롤의 오른쪽에 표시. 행단위 액션 실행.
     * NOTE: 버튼 등의 높이나 크기를 '%'로 지정하면 셀의 높이로 지정하고 버튼 등의 높이는 100%로 지정한다.
     */
    class EditBar extends ListControlBar {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(control, owner, defaults) {
            super(control, defaults);
            this._buttons = {};
            this._handles = {};
            this._owner = owner;
            this._delete = new RowDeleteButton(this, EditBar.DELETE_LABEL, defaults && defaults._delete);
            this._add = new RowAddButton(this, EditBar.ADD_LABEL, defaults && defaults._add);
            this._edit = new RowEditButton(this, EditBar.EDIT_LABEL, defaults && defaults._edit);
            this._info = new RowInfoButton(this, EditBar.INFO_LABEL, defaults && defaults._info);
            this._link = new RowLinkButton(this, EditBar.LINK_LABEL, defaults && defaults._link);
            this._custom = new RowButton(this, EditBar.CUSTOM_LABEL, defaults && defaults._custom);
            this._move = new RowMover(this, defaults && defaults._move);
            this._buttons[DListEditBarAction.DELETE] = this._delete;
            this._buttons[DListEditBarAction.ADD] = this._add;
            this._buttons[DListEditBarAction.EDIT] = this._edit;
            this._buttons[DListEditBarAction.INFO] = this._info;
            this._buttons[DListEditBarAction.LINK] = this._link;
            this._buttons[DListEditBarAction.CUSTOM] = this._custom;
            this._handles[DListEditBarAction.MOVE] = this._move;
        }
        ;
        ;
        _doInitDefaults() {
            super._doInitDefaults();
            this.setVisible(false);
            this.setPosition(DListControlBarPosition.FAR);
            this._action = DListEditBarAction.CUSTOM;
            // this._size = EditBar.SIZE;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        owner() {
            return this._owner;
        }
        /**
         * action.
         */
        action() {
            return pickProp(this._action, this._defs && this._defs._action);
        }
        setAction(value) {
            if (value !== this._action) {
                this._action = value;
                this._changed();
            }
        }
        delete() {
            return this._delete;
        }
        add() {
            return this._add;
        }
        edit() {
            return this._edit;
        }
        info() {
            return this._info;
        }
        link() {
            return this._link;
        }
        /**
         * custom action 버튼 정보.
         */
        custom() {
            return this._custom;
        }
        move() {
            return this._move;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        getAction(row) {
            // if (this._rowInfos) {
            //     const dv = this._dg.dataViewOfRow(row);
            //     return dv && dv.name && this._rowInfos.getEditBar(dv.name);
            // }
            return this._runAction;
        }
        getButton(action) {
            return this._buttons[action];
        }
        getHandle(action) {
            return this._handles[action];
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doPrepareRender() {
            super._doPrepareRender();
            switch (this._runAction = this.action()) {
                case DListEditBarAction.INFO:
                    this._info.prepareRender();
                    break;
                case DListEditBarAction.DELETE:
                    this._delete.prepareRender();
                    break;
                case DListEditBarAction.ADD:
                    this._add.prepareRender();
                    break;
                case DListEditBarAction.EDIT:
                    this._edit.prepareRender();
                    break;
                case DListEditBarAction.LINK:
                    this._link.prepareRender();
                    break;
                case DListEditBarAction.CUSTOM:
                    this._custom.prepareRender();
                    break;
                case DListEditBarAction.MOVE:
                    this._move.prepareRender();
                    break;
            }
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    // defaults
    // static readonly SIZE = 50;
    EditBar.DELETE_LABEL = 'Delete';
    EditBar.DETAIL_LABEL = 'More';
    EditBar.LINK_LABEL = '>';
    EditBar.ADD_LABEL = 'Add';
    EditBar.EDIT_LABEL = 'Edit';
    EditBar.INFO_LABEL = 'Info'; // 'ⓘ';
    EditBar.CUSTOM_LABEL = '?';

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * {@link DListRowbar Row Bar} 셀에 표시할 내용의 종류.
     * <br>
     * {@link DListRowBar.display} 속성으로 지정한다.
     *
     * ```
     *  list.setConfig({
     *      options: {
     *          rowBar: {
     *              visible: true,
     *              display: DList.DListRowBarDisplay.ORDER,
     *              order: {
     *                  suffix: '.',
     *                  style: {
     *                      fontSize: '19px'
     *                  }
     *              }
     *          }
     *      }
     *  });
     * ```
     *
     * @see concepts.row_bar Row Bar 개요
     * @see concepts.edit_bar Edit Bar 개요
     */
    var DListRowBarDisplay;
    (function (DListRowBarDisplay) {
        /**
         * 아무것도 표시하지 않고 자리만 차지한다.
         * <br>
         * 자리를 차지하지 않게 하려면 {@link DListRowBar.visible}을 false로 지정해서 row bar를 감춰야 한다.
         */
        DListRowBarDisplay["NONE"] = "none";
        /**
         * **행 번호**를 표시한다.
         * <br>
         * {@link IListRowOrder} 셀 모델 객체인 {@link DListRowBar.order} 속성으로 설정한다.
         */
        DListRowBarDisplay["ORDER"] = "order";
        /**
         * **체크** 상자로 {@link DListControl.isRowChecked 행 checked 여부}를 표시한다.
         * <br>
         * {@link IListRowCheckBox} 모델 객체인 {@link DListRowBar.check} 속성으로 설정한다.
         */
        DListRowBarDisplay["CHECK"] = "check";
        /**
         * **Svg shape**로 행 상태등을 표시한다.
         * <br>
         * {@link IListRowShape} 모델 객체인 {@link DListRowBar.shape} 속성으로 설정한다.
         */
        DListRowBarDisplay["SHAPE"] = "shape";
        /**
         * **한 글자**로 생 상태 등을 표시한다.
         * <br>
         * {@link IListRowLetter} 모델 객체인 {@link DListRowBar.letter} 속성으로 설정한다.
         * 행 별로 표시할 shape는 {@link DListRowShape.shapeCallback}으로 설정한다.
         */
        DListRowBarDisplay["LETTER"] = "letter";
        /**
         * **이미지**로 행 상태 등을 표시한다.
         * <br>
         * {@link IListRowImage} 모델 객체인 {@link DListRowBar.image} 속성으로 설정한다.
         */
        DListRowBarDisplay["IMAGE"] = "image";
        /**
         * **버튼**을 표시한다.
         * <br>
         * {@link IListRowButton} 모델 객체인 {@link DListRowBar.button} 속성으로 설정한다.
         */
        DListRowBarDisplay["BUTTON"] = "button";
        /**
         * 데이터행 이동을 시작하는 handle을 표시한다.
         * <br>
         * {@link IListRowMover} 모델 객체인 {@link DListRowBar.move} 속성으로 설정한다.
         */
        DListRowBarDisplay["MOVE"] = "move";
    })(DListRowBarDisplay || (DListRowBarDisplay = {}));
    class RowBarButton extends RowButton {
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doInitDefaults() {
            this.setLabel('...');
        }
    }
    /**
     * @internal
     *
     * 컨트롤의 왼쪽 혹은 (수평 모드일 때)상단에 행별 번호, 상태 및 기타 UI 등을 표시하는 영역.
     * NOTE: 버튼 등의 높이나 크기를 '%'로 지정하면 셀의 높이로 지정하고 버튼 등의 높이는 100%로 지정한다.
     */
    class RowBar extends ListControlBar {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(control, owner, defaults) {
            super(control, defaults);
            this.minOrderWidth = 0;
            this.needOrderWidth = false;
            this.orderWidth = NaN;
            this._owner = owner;
            this._order = new RowOrder(this, defaults && defaults._order);
            this._check = new RowCheckBox(this, defaults && defaults._check);
            this._shape = new RowShape(this, defaults && defaults._shape);
            this._letter = new RowLetter(this, defaults && defaults._letter);
            this._image = new RowImage(this, defaults && defaults._image);
            this._button = new RowBarButton(this, void 0, defaults && defaults._button);
            this._move = new RowMover(this, defaults && defaults._move);
        }
        _doInitDefaults() {
            super._doInitDefaults();
            this.setVisible(false);
            this._display = RowBar.DISPLAY;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        owner() {
            return this._owner;
        }
        /**
         * display mode.
         */
        display() {
            return pickProp(this._display, this._defs && this._defs._display);
        }
        setDisplay(value) {
            if (value !== this._display) {
                this._display = value;
                this._displayChanged = true;
                this.needOrderWidth = true;
                this._changed();
            }
        }
        order() {
            return this._order;
        }
        check() {
            return this._check;
        }
        shape() {
            return this._shape;
        }
        letter() {
            return this._letter;
        }
        image() {
            return this._image;
        }
        button() {
            return this._button;
        }
        move() {
            return this._move;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        getDisplay(row) {
            // if (this._rowInfos) {
            //     const dv = this._dg.dataViewOfRow(row);
            //     return dv && dv.name && this._rowInfos.getRowBar(dv.name);
            // }
            return this.disp;
        }
        isMaster(row) {
            return this._owner.isMaster(row);
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doPrepareRender() {
            super._doPrepareRender();
            switch (this.disp = this.display()) {
                case DListRowBarDisplay.ORDER:
                    this.minOrderWidth = pickNum(this._order.minWidth(), 0);
                    this.needOrderWidth = this._order.fitWidth();
                    this.orderWidth = 0;
                    this._order.prepareRender();
                    break;
                case DListRowBarDisplay.CHECK:
                    this._check.prepareRender();
                    break;
                case DListRowBarDisplay.SHAPE:
                    this._shape.prepareRender();
                    break;
                case DListRowBarDisplay.LETTER:
                    this._letter.prepareRender();
                    break;
                case DListRowBarDisplay.IMAGE:
                    this._image.prepareRender();
                    break;
                case DListRowBarDisplay.BUTTON:
                    this._button.prepareRender();
                    break;
                case DListRowBarDisplay.MOVE:
                    this._move.prepareRender();
                    break;
            }
            this._displayChanged = this._displayChanged || (this._defs && this._defs._displayChanged);
        }
        _doUnprepareRender() {
            super._doUnprepareRender();
            switch (this.disp = this.display()) {
                case DListRowBarDisplay.ORDER:
                    this._order.unprepareRender();
                    break;
                case DListRowBarDisplay.CHECK:
                    this._check.unprepareRender();
                    break;
                case DListRowBarDisplay.SHAPE:
                    this._shape.unprepareRender();
                    break;
                case DListRowBarDisplay.LETTER:
                    this._letter.unprepareRender();
                    break;
                case DListRowBarDisplay.IMAGE:
                    this._image.unprepareRender();
                    break;
                case DListRowBarDisplay.BUTTON:
                    this._button.unprepareRender();
                    break;
                case DListRowBarDisplay.MOVE:
                    this._move.unprepareRender();
                    break;
            }
            this._displayChanged = false;
            this._defs && (this._defs.unprepareRender());
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    // defaults
    RowBar.DISPLAY = DListRowBarDisplay.ORDER;
    RowBar.TAG = 'rowBar';

    /**
     * https://github.com/gre/bezier-easing
     * BezierEasing - use bezier curve for transition easing function
     * by Gaëtan Renaudeau 2014 - 2015 – MIT License
     */

    // These values are established by empiricism with tests (tradeoff: performance VS precision)
    var NEWTON_ITERATIONS = 4;
    var NEWTON_MIN_SLOPE = 0.001;
    var SUBDIVISION_PRECISION = 0.0000001;
    var SUBDIVISION_MAX_ITERATIONS = 10;

    var kSplineTableSize = 11;
    var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);

    var float32ArraySupported = typeof Float32Array === 'function';

    function A (aA1, aA2) { return 1.0 - 3.0 * aA2 + 3.0 * aA1; }
    function B (aA1, aA2) { return 3.0 * aA2 - 6.0 * aA1; }
    function C (aA1)      { return 3.0 * aA1; }

    // Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.
    function calcBezier (aT, aA1, aA2) { return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT; }

    // Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.
    function getSlope (aT, aA1, aA2) { return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1); }

    function binarySubdivide (aX, aA, aB, mX1, mX2) {
      var currentX, currentT, i = 0;
      do {
        currentT = aA + (aB - aA) / 2.0;
        currentX = calcBezier(currentT, mX1, mX2) - aX;
        if (currentX > 0.0) {
          aB = currentT;
        } else {
          aA = currentT;
        }
      } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
      return currentT;
    }

    function newtonRaphsonIterate (aX, aGuessT, mX1, mX2) {
     for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
       var currentSlope = getSlope(aGuessT, mX1, mX2);
       if (currentSlope === 0.0) {
         return aGuessT;
       }
       var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
       aGuessT -= currentX / currentSlope;
     }
     return aGuessT;
    }

    function LinearEasing (x) {
      return x;
    }

    var src = function bezier (mX1, mY1, mX2, mY2) {
      if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {
        throw new Error('bezier x values must be in [0, 1] range');
      }

      if (mX1 === mY1 && mX2 === mY2) {
        return LinearEasing;
      }

      // Precompute samples table
      var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
      for (var i = 0; i < kSplineTableSize; ++i) {
        sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
      }

      function getTForX (aX) {
        var intervalStart = 0.0;
        var currentSample = 1;
        var lastSample = kSplineTableSize - 1;

        for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
          intervalStart += kSampleStepSize;
        }
        --currentSample;

        // Interpolate to provide an initial guess for t
        var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
        var guessForT = intervalStart + dist * kSampleStepSize;

        var initialSlope = getSlope(guessForT, mX1, mX2);
        if (initialSlope >= NEWTON_MIN_SLOPE) {
          return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
        } else if (initialSlope === 0.0) {
          return guessForT;
        } else {
          return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
        }
      }

      return function BezierEasing (x) {
        // Because JavaScript number are imprecise, we should guarantee the extremes are right.
        if (x === 0) {
          return 0;
        }
        if (x === 1) {
          return 1;
        }
        return calcBezier(getTForX(x), mY1, mY2);
      };
    };

    ////////////////////////////////////////////////////////////////////////////////
    const pow = Math.pow;
    const sqrt = Math.sqrt;
    const sin = Math.sin;
    const cos = Math.cos;
    const PI = Math.PI;
    const c1 = 1.70158;
    const c2 = c1 * 1.525;
    const c3 = c1 + 1;
    const c4 = (2 * PI) / 3;
    const c5 = (2 * PI) / 4.5;
    const bounceOut = function (x) {
        const n1 = 7.5625;
        const d1 = 2.75;
        if (x < 1 / d1) {
            return n1 * x * x;
        }
        else if (x < 2 / d1) {
            return n1 * (x -= 1.5 / d1) * x + 0.75;
        }
        else if (x < 2.5 / d1) {
            return n1 * (x -= 2.25 / d1) * x + 0.9375;
        }
        else {
            return n1 * (x -= 2.625 / d1) * x + 0.984375;
        }
    };
    //const bezier = Bezier(0.000, 0.775, 0.005, 1.005);
    const bezier = src(.01, .99, .01, .99);
    const Easings = {
        linear(x) {
            return x;
        },
        inQuad(x) {
            return x * x;
        },
        outQuad(x) {
            return 1 - (1 - x) * (1 - x);
        },
        inOutQuad(x) {
            return x < 0.5 ? 2 * x * x : 1 - pow(-2 * x + 2, 2) / 2;
        },
        inCubic(x) {
            return x * x * x;
        },
        outCubic(x) {
            return 1 - pow(1 - x, 3);
        },
        outCubic2(x) {
            return 1 - pow(1 - x, 4);
        },
        inOutCubic(x) {
            return x < 0.5 ? 4 * x * x * x : 1 - pow(-2 * x + 2, 3) / 2;
        },
        inQuart(x) {
            return x * x * x * x;
        },
        outQuart(x) {
            return 1 - pow(1 - x, 4);
        },
        inOutQuart(x) {
            return x < 0.5 ? 8 * x * x * x * x : 1 - pow(-2 * x + 2, 4) / 2;
        },
        inQuint(x) {
            return x * x * x * x * x;
        },
        outQuint(x) {
            return 1 - pow(1 - x, 5);
        },
        inOutQuint(x) {
            return x < 0.5 ? 16 * x * x * x * x * x : 1 - pow(-2 * x + 2, 5) / 2;
        },
        inSine(x) {
            return 1 - cos((x * PI) / 2);
        },
        outSine(x) {
            return sin((x * PI) / 2);
        },
        inOutSine(x) {
            return -(cos(PI * x) - 1) / 2;
        },
        inExpo(x) {
            return x === 0 ? 0 : pow(2, 10 * x - 10);
        },
        outExpo(x) {
            return x === 1 ? 1 : 1 - pow(2, -10 * x);
        },
        outExpo2(x) {
            return x === 1 ? 1 : 1 - pow(2, -12 * x);
        },
        inOutExpo(x) {
            return x === 0
                ? 0
                : x === 1
                    ? 1
                    : x < 0.5
                        ? pow(2, 20 * x - 10) / 2
                        : (2 - pow(2, -20 * x + 10)) / 2;
        },
        inCirc(x) {
            return 1 - sqrt(1 - pow(x, 2));
        },
        outCirc(x) {
            return sqrt(1 - pow(x - 1, 2));
        },
        inOutCirc(x) {
            return x < 0.5
                ? (1 - sqrt(1 - pow(2 * x, 2))) / 2
                : (sqrt(1 - pow(-2 * x + 2, 2)) + 1) / 2;
        },
        inBack(x) {
            return c3 * x * x * x - c1 * x * x;
        },
        outBack(x) {
            return 1 + c3 * pow(x - 1, 3) + c1 * pow(x - 1, 2);
        },
        inOutBack(x) {
            return x < 0.5
                ? (pow(2 * x, 2) * ((c2 + 1) * 2 * x - c2)) / 2
                : (pow(2 * x - 2, 2) * ((c2 + 1) * (x * 2 - 2) + c2) + 2) / 2;
        },
        inElastic(x) {
            return x === 0
                ? 0
                : x === 1
                    ? 1
                    : -pow(2, 10 * x - 10) * sin((x * 10 - 10.75) * c4);
        },
        outElastic(x) {
            return x === 0
                ? 0
                : x === 1
                    ? 1
                    : pow(2, -10 * x) * sin((x * 10 - 0.75) * c4) + 1;
        },
        inOutElastic(x) {
            return x === 0
                ? 0
                : x === 1
                    ? 1
                    : x < 0.5
                        ? -(pow(2, 20 * x - 10) * sin((20 * x - 11.125) * c5)) / 2
                        : (pow(2, -20 * x + 10) * sin((20 * x - 11.125) * c5)) / 2 + 1;
        },
        inBounce(x) {
            return 1 - bounceOut(1 - x);
        },
        outBounce: bounceOut,
        inOutBounce(x) {
            return x < 0.5
                ? (1 - bounceOut(1 - 2 * x)) / 2
                : (1 + bounceOut(2 * x - 1)) / 2;
        },
        cubicBezier(x) {
            function cb(t, p0, p1, p2, p3) {
                const c = 3 * (p1 - p0), b = 3 * (p2 - p1) - c, a = p3 - p0 - c - b;
                return a * Math.pow(t, 3) + b * Math.pow(t, 2) + (c * t) + p0;
            }
            // return cb(x, 0.000, 0.775, 0.005, 1.005);
            return cb(x, .01, .99, .01, .99);
        },
        cubicBezier2(x) {
            return bezier(x);
        }
    };
    class DAnimation extends DObject {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(duration, easing) {
            super();
            this._duration = duration;
            this._easing = (easing && Easings[easing]) || Easings.linear;
        }
        //-------------------------------------------------------------------------
        // consts
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // static members
        //-------------------------------------------------------------------------
        static create(onstep, onfinish, duration = 1000, easing = 'linear') {
            return new CustomAnimation(onstep, onfinish, duration, easing).start();
        }
        _doDestory() {
            this.stop();
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        isFinished() {
            return !this._timer;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        start() {
            this.stop();
            this._started = +new Date();
            this._timer = Utils.setInterval(() => {
                const step = this.$_getStep();
                if (step >= 1) {
                    this._doStep(1);
                    this.$_stop(step);
                }
                else {
                    try {
                        this._doStep(step);
                    }
                    catch (err) {
                        this.$_stop(step);
                        throw err;
                    }
                }
            }, 20);
            this._doStep(0);
            // for testing
            if (this._timer.runner) {
                this._timer.runner();
            }
            return this;
        }
        stop() {
            if (this._timer) {
                this.$_stop(this.$_getStep());
            }
        }
        $_getStep() {
            const s = isNaN(this._timer.step) ? (+new Date() - this._started) / this._duration : this._timer.step;
            return this._easing(s);
        }
        $_stop(step) {
            Utils.clearInterval(this._timer);
            this._timer = undefined;
            this._doStop(step, step < 1);
        }
    }
    class CustomAnimation extends DAnimation {
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        constructor(onstep, onfinish, duration, easing) {
            super(duration, easing);
            this.onstep = onstep;
            this.onfinish = onfinish;
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doStep(step) {
            this.onstep(step);
        }
        _doStop(step, canceled) {
            var _a;
            (_a = this.onfinish) === null || _a === void 0 ? void 0 : _a.call(this, step, canceled);
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    const DRAG_THRESHOLD = 3;
    const DOUBLE_TAP_THRESHOLD = 300;
    /** @internal */
    class DEditTool {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(control) {
            this._touchIds = [];
            this._touches = [];
            this._tapped = 0;
            this._firstTime = 0;
            this._secondTime = 0;
            this._control = control;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        get control() {
            return this._control;
        }
        /**
         * drag tracker
         */
        get dragTracker() {
            return this._dragTracker;
        }
        setDragTracker(value) {
            if (value != this._dragTracker) {
                if (this._dragTracker) {
                    this._dragTracker.cancel();
                }
                this._dragTracker = value;
            }
        }
        get dragging() {
            return this._dragTracker && this._dragTracker.dragging;
        }
        touchX() {
            return this._touchX;
        }
        touchY() {
            return this._touchY;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        touchStart(ev) {
            clearTimeout(this._longTimer);
            const dom = this._touchElement = Utils.cast(ev.target, Element);
            if (!dom)
                return;
            const touches = ev.changedTouches;
            let t;
            let p;
            if (touches.length > 0) {
                t = touches[0];
                p = this.$_touchPoint(t);
                if (this._dragTracker) {
                    this.$_stopDragTracker(dom, p.x, p.y);
                }
                this._prevX = p.x;
                this._prevY = p.y;
            }
            // 기존 touch에 추가되거나, 컨트롤 밖에 나갔다가 들어오는 경우(?)...
            if (ev.touches.length > 1 || this._touchIds.length > 0) {
                for (let i = 0; i < touches.length; i++) {
                    this._touchIds.push(touches[i].identifier);
                }
                this._touchId = this._touchId || touches[0].identifier;
            }
            else if (t) {
                this._touchIds.push(this._touchId = t.identifier);
                if (this._tapped === 0) {
                    this._firstTime = ev.timeStamp;
                    this._touchX = p.x;
                    this._touchY = p.y;
                }
                else {
                    this._secondTime = ev.timeStamp;
                }
                this._touches = [{ x: p.x, y: p.y, t: ev.timeStamp }];
                this._longTimer = setTimeout(() => {
                    this._touchId = void 0;
                    this._tapped = 0;
                    this._doLongPressed(dom, this._touchX, this._touchY);
                }, this._control.longPressDelay);
            }
            return this._doTouchStart(dom);
        }
        _stopEvent(ev) {
            ev.cancelable && ev.preventDefault();
            ev.stopImmediatePropagation();
        }
        $_doDrag(ev, dom, x, y) {
            if (!this.$_drag(dom, this._prevX, this._prevY, x, y)) {
                this.$_stopDragTracker(dom, x, y, true);
                this._stopEvent(ev);
                return true;
            }
        }
        touchMove(ev) {
            const t = this.$_findTouch(ev);
            // this._clearTouchEffects();
            if (t) {
                const { x, y } = this.$_touchPoint(t);
                // 왜 ev.target 대신 elementFromPoint를 사용했지? testing(jsdom)에서는 elementFromPoint가 미지원.
                // ev.target에 toucheStart으 target과 동일해서 그랬던가?
                const dom = document.elementFromPoint ? document.elementFromPoint(x, y) : ev.target;
                if (x < 0 || x >= this._control.dom().offsetWidth || y < 0 || y >= this._control.dom().offsetHeight) {
                    this.dragging && this.$_stopDragTracker(dom, x, y, true);
                }
                else if (this.dragging) {
                    this.$_doDrag(ev, dom, x, y);
                }
                else if (!this._dragTracker && Math.abs(this._prevX - x) > DRAG_THRESHOLD || Math.abs(this._prevY - y) > DRAG_THRESHOLD) {
                    clearTimeout(this._longTimer);
                    this._tapped = 0;
                    if (this.$_startDrag(dom, this._prevX, this._prevY, x, y)) {
                        this._clearTouchEffects();
                        if (x !== this._prevX || y !== this._prevY) {
                            this.$_doDrag(ev, dom, x, y);
                        }
                        else {
                            this._stopEvent(ev);
                        }
                    }
                }
                this._prevX = x;
                this._prevY = y;
                this._touches.push({ x, y, t: ev.timeStamp });
                this._doTouchMove(dom);
            }
            if (this.dragging) {
                this._stopEvent(ev);
            }
        }
        touchEnd(ev) {
            const dom = Utils.cast(ev.target, Element);
            clearTimeout(this._longTimer);
            this._clearTouchEffects();
            if (this._touchId === void 0) {
                this.$_clearTouches();
            }
            else {
                const t = this.$_findTouch(ev);
                if (t) {
                    if (this.$_checkSwipe(dom, ev)) {
                        this._touchId = undefined;
                        this._tapped = 0;
                    }
                    else {
                        const { x, y } = this.$_touchPoint(t);
                        let elt = document.elementFromPoint(x, y);
                        if (dom && dom.contains(elt))
                            elt = dom;
                        if (this.dragging) {
                            this._touchId = undefined;
                            this._tapped = 0;
                            this.$_stopDragTracker(elt, x, y);
                        }
                        else if (this._tapped === 0) {
                            this._tapped = 1;
                            this._doTap(elt, this._touchX, this._touchY, x, y);
                        }
                        else if (this._tapped === 1) {
                            this._touchId = undefined;
                            if (ev.timeStamp - this._firstTime < DOUBLE_TAP_THRESHOLD) {
                                this._tapped = 0;
                                this._doDoubleTap(elt, this._touchX, this._touchY, x, y);
                            }
                            else {
                                this._firstTime = this._secondTime;
                                this._touchX = this._prevX;
                                this._touchY = this._prevY;
                                this._doTap(elt, this._touchX, this._touchY, x, y);
                            }
                        }
                    }
                }
                else if (this.dragging) {
                    this.$_stopDragTracker(dom, this._prevX, this._prevY);
                }
            }
            this._dragTracker = null;
            ev.touches.length <= 0 && this.$_clearTouches();
            this.$_removeTouches(ev.changedTouches);
            if (this._doTouchEnd(dom)) {
                // 여기서 끝내지 않으면 (복수 리스트가 존재할 때) 다른 리스트 컨트롤에서 클릭 이벤트가 발생한다. (Why?)
                this._stopEvent(ev);
            }
        }
        touchCancel(ev) {
            console.log('CANCEL');
            clearTimeout(this._longTimer);
            this._clearTouchEffects();
        }
        touchLeave(ev) {
            console.log('LEAVE');
            clearTimeout(this._longTimer);
            this._clearTouchEffects();
            if (this.dragging) {
                const dom = Utils.cast(ev.target, Element);
                this.$_stopDragTracker(dom, this._prevX, this._prevY);
            }
        }
        click(ev) {
            const dom = Utils.cast(ev.target, Element);
            if (!dom)
                return;
            // doTap()에서 호출한다.
            this._doClick(dom);
        }
        keyPress(ev) {
            this._doKeyPress(ev);
        }
        requestDrag(request) {
            const tracker = this.getTrackerFromRequest(request);
            tracker && this.setDragTracker(tracker);
        }
        getTrackerFromRequest(request) {
            return;
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        _doClick(dom) {
        }
        _doTouchStart(dom) {
            return false;
        }
        _doTouchMove(dom) {
        }
        // true를 리턴하면 stopEvent()가 호출된다.
        _doTouchEnd(dom) {
            return true;
        }
        _doTap(dom, xStart, yStart, x, y) {
        }
        _doDoubleTap(dom, xStart, yStart, x, y) {
        }
        _doLongPressed(dom, x, y) {
        }
        _doKeyPress(ev) {
        }
        _doSwipe(dom, prevTracker, dir, duration, distance) {
            return false;
        }
        _getDragTracker(dom, dx, dy) {
            return null;
        }
        $_startDrag(dom, xStart, yStart, x, y) {
            this.setDragTracker(this._getDragTracker(dom, x - xStart, y - yStart));
            if (this._dragTracker) {
                return this._dragTracker.start(dom, xStart, yStart, x, y);
            }
            return false;
        }
        $_drag(dom, xPrev, yPrev, x, y) {
            return this._dragTracker.drag(dom, xPrev, yPrev, x, y);
        }
        $_stopDragTracker(dom, x, y, canceled = false) {
            if (this.dragging) {
                if (canceled) {
                    this._dragTracker.cancel();
                }
                else {
                    this._dragTracker.drop(null, x, y);
                }
                this._dragTracker = null;
            }
        }
        $_touchPoint(touch) {
            const r = this._control.dom().getBoundingClientRect();
            const x = touch.pageX - r.left; // touch.clientX ?
            const y = touch.pageY - r.top;
            return { x, y };
        }
        $_clearTouches() {
            this._touchIds = [];
        }
        $_removeTouches(touches) {
            for (let i = touches.length - 1; i >= 0; i--) {
                const t = this._touchIds.indexOf(touches[i].identifier);
                if (t >= 0) {
                    this._touchIds.splice(t, 1);
                }
            }
        }
        $_findTouch(event) {
            const touches = event.changedTouches;
            for (let i = 0, n = touches.length; i < n; i++) {
                const t = touches[i];
                if (t.identifier === this._touchId) {
                    return t;
                }
            }
        }
        $_checkSwipe(dom, event) {
            const touches = this._touches;
            const count = touches.length;
            if (count < 2)
                return;
            const t2 = touches[count - 1];
            let t1 = touches[count - 2];
            if (t2.t - t1.t <= 100) {
                for (let i = count - 3; i >= 0; i--) {
                    t1 = touches[i];
                    if (t2.t - t1.t > 100) {
                        break;
                    }
                }
            }
            const x1 = t1.x;
            const y1 = t1.y;
            const x2 = t2.x;
            const y2 = t2.y;
            const d = Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
            const dt = Math.max(16, t2.t - t1.t);
            const v = d / dt;
            const vMin = 0.1;
            const friction = 0.998;
            if (v > vMin) {
                const tracker = this._dragTracker;
                const duration = Math.log(vMin / v) / Math.log(friction);
                const distance = v * (1 - Math.pow(friction, duration + 1)) / (1 - friction);
                let a = Math.round(Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI);
                let dir;
                if (a < 0) {
                    a = 360 + a;
                }
                if (a > 45 && a <= 135) {
                    dir = Direction.DOWN;
                }
                else if (a > 135 && a <= 225) {
                    dir = Direction.LEFT;
                }
                else if (a > 225 && a <= 315) {
                    dir = Direction.UP;
                }
                else {
                    dir = Direction.RIGHT;
                }
                if (this.dragging) {
                    if (tracker.swipe(dir)) {
                        return true;
                    }
                    this.$_stopDragTracker(dom, this._prevX, this._prevY);
                }
                return this._doSwipe(dom, tracker, dir, duration * 1.6, distance * 1.3);
            }
            return false;
        }
        /**
         * 터치 시작 시점에 실행한 설정 등을 이 후 touch 이벤트가 발생하면 초기화한다.
         * ex) touch feedback, ...
         *     iphone 메시지 편집 창에서 touch 하면 행을 선택하고 이 후 다른 이벤트가 발생하면 선택을 해제한다.
         */
        _clearTouchEffects() {
        }
    }
    class DragRequest extends DObject {
    }
    class DragTracker extends DObject {
        //-------------------------------------------------------------------------
        // constructors
        //-------------------------------------------------------------------------
        constructor(control) {
            super();
            this._dragging = false;
            this._control = control;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        get control() {
            return this._control;
        }
        /** dragging */
        get dragging() {
            return this._dragging;
        }
        /** startWhenCreated */
        get startWhenCreated() {
            return false;
        }
        get cursor() {
            return;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        canSwipe() {
            return false;
        }
        start(eventTarget, xStart, yStart, x, y) {
            this.cancel();
            if (this._doStart(eventTarget, xStart, yStart, x, y)) {
                // console.log('DRAG START')
                this._dragging = true;
                this._showFeedback(x, y);
                return true;
            }
            return false;
        }
        drag(eventTarget, xPrev, yPrev, x, y) {
            if (this._dragging) {
                if (this._doDrag(eventTarget, xPrev, yPrev, x, y)) {
                    this._moveFeedback(x, y);
                    return true;
                }
            }
            return false;
        }
        cancel() {
            if (this._dragging) {
                try {
                    this._dragging = false;
                    this._doCanceled();
                }
                finally {
                    this.end();
                }
            }
        }
        drop(eventTarget, x, y) {
            if (this._dragging) {
                try {
                    this._dragging = false;
                    if (this._canAccept(eventTarget, x, y)) {
                        this._doCompleted(eventTarget, x, y);
                    }
                    else {
                        this._doCanceled();
                    }
                }
                finally {
                    this.end();
                }
            }
        }
        swipe(dir) {
            if (this._doSwipe(dir)) {
                this.end();
                return true;
            }
        }
        end() {
            try {
                this._dragging = false;
                this._hideFeedback();
            }
            finally {
                this._doEnded();
            }
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        _doSwipe(dir) {
            return false;
        }
        _showFeedback(x, y) {
        }
        _moveFeedback(x, y) {
        }
        _hideFeedback() {
        }
        _doStart(eventTarget, xStart, yStart, x, y) {
            return true;
        }
        _doCanceled() {
        }
        _canAccept(eventTarget, x, y) {
            return true;
        }
        _doCompleted(eventTarget, x, y) {
        }
        _doEnded() {
        }
    }
    class FlingScroller extends DObject {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(distance, duration, threshold, handler, endHandler, startHandler) {
            super();
            this.distance = distance;
            this.duration = duration;
            this.threshold = threshold;
            this.handler = handler;
            this.endHandler = endHandler;
            this.startHandler = startHandler;
            // private _easing = Easings.cubicBezier2;
            // private _easing = Easings.outExpo2;
            this._easing = Easings.outExpo;
        }
        _doDestory() {
            this.stop();
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        run() {
            var _a;
            this.stop();
            this._started = +new Date();
            this._prev = 0;
            this._timer = setInterval(() => {
                try {
                    const t = +new Date();
                    const elapsed = t - this._started;
                    if (elapsed > this.duration) {
                        this.stop();
                    }
                    else {
                        const t = +new Date();
                        const e = this._easing((t - this._started) / this.duration);
                        const d = this.distance * (e - this._prev);
                        if (d < this.threshold) {
                            this.stop();
                        }
                        else {
                            if (this.handler(d, elapsed / this.duration) === true) {
                                this.stop();
                            }
                            else {
                                this._prev = e;
                            }
                        }
                    }
                }
                catch (err) {
                    this.stop();
                    throw err;
                }
            }, 20);
            (_a = this.startHandler) === null || _a === void 0 ? void 0 : _a.call(this);
            return this;
        }
        stop() {
            var _a;
            if (this._timer) {
                clearInterval(this._timer);
                this._timer = undefined;
                (_a = this.endHandler) === null || _a === void 0 ? void 0 : _a.call(this);
            }
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    const resetStyleOrClass2 = function (dom, className, st) {
        const css = dom.style;
        let prev = dom[T_STYLES];
        if (dom instanceof HTMLElement) {
            dom.className = className;
        }
        else {
            Dom.resetClassList(dom, className);
        }
        if (prev) {
            for (const p in prev) {
                css[p] = '';
            }
        }
        prev = {};
        if (typeof st === 'string') {
            dom.classList.add(st);
        }
        else if (st) {
            Object.assign(prev, st);
            Object.assign(css, st);
        }
        dom[T_STYLES] = prev;
    };
    class RowCellElement extends DElement {
        constructor() {
            super(...arguments);
            this._prevStyle = {};
        }
        //-------------------------------------------------------------------------
        // static members
        //-------------------------------------------------------------------------
        static measureButton(cell, model, button) {
            const dom = cell.dom;
            const letter = model.letter();
            let w = +model.width();
            let h = +model.height();
            if (letter) {
                w = letter.size || w;
                h = letter.size || h;
                button.dataset.type = letter.transparent ? 'letter-transparent' : 'letter';
                button.textContent = letter.letter;
            }
            else {
                delete button.dataset.type;
                button.textContent = model.label();
            }
            Dom.setAttr(button, 'aria-label', model.hint());
            // width
            if (!isNaN(w)) {
                button.style.width = w + 'px';
            }
            else {
                button.style.width = '';
            }
            // height
            if (cell.hRelative = model.isRelativeHeight()) {
                button.style.height = '100%';
                dom.style.height = String(h);
            }
            else {
                button.style.height = isNaN(h) ? '' : (h + 'px');
                dom.style.height = '';
            }
            // dom.offsetWidth가 floor()해서 리턴될 수 있다. getBoundingClientRect().width가 정확한 값을 리턴한다.
            // +1을 하지 않으면 '...'가 표시될 수 있다.
            return { width: button.offsetWidth + 1, height: dom.offsetHeight }; // button.offsetHeight
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        getDragRequest(dom, options) {
            if (this._move && this._move.dom().contains(dom)) {
                return new MoveRowRequest(this.row);
            }
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _getOverflow() {
            return 'hidden';
        }
        _doInitDom(doc, dom) {
            const css = dom.style;
            DElement.BOUNDING && (css.border = DElement.BOUNDING_BORDER);
            css.display = 'flex';
            css.alignItems = 'center';
            css.justifyContent = 'center';
        }
        isDom(dom) {
            return this._move && this._move.dom().contains(dom);
        }
        $_prepareMove(model, row, cellStyle, style) {
            const dom = this.dom;
            let shape = this._move;
            if (!shape) {
                shape && shape.destroy();
                shape = this._move = this.control.shapes().createStock(dom.ownerDocument, '@drag');
                shape.appendTo(dom);
            }
            else {
                if (!shape.attached()) {
                    shape.appendTo(dom);
                }
            }
            shape.resize(model.size());
            resetStyleOrClass2(dom, RowBarCell.CLASS_NAME, cellStyle);
            resetStyleOrClass2(shape.dom(), RowBarCell.MOVE_CLASS, style);
            return shape.dom();
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    RowCellElement.MOVE_CLASS = 'dlist-rowbar-move';
    const CHECK_MARK_STYLE = {
        fill: 'none',
        stroke: 'white',
        strokeWidth: '1px',
        width: '100%',
        height: '100%',
        display: 'block',
        position: 'relative',
        boxSizing: 'border-box',
        border: '1px solid #00000040',
        borderRadius: '50%'
    };
    class MoveRowRequest extends DragRequest {
        constructor(row) {
            super();
            this.row = row;
        }
    }
    class CheckDragRequest extends DragRequest {
        constructor(row) {
            super();
            this.row = row;
        }
    }
    /**
     * @internal
     *
     * 데이터행에 표시되는 row bar cell view.
     * 접근성 등을 고려해 row bar view를 별도의 div 영역으로 구성하지 않고 개별 item view에 셀을 포함시킨다.
     *
     */
    class RowBarCell extends RowCellElement {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(doc) {
            super(doc, null, RowBarCell.CLASS_NAME);
        }
        //-------------------------------------------------------------------------
        // static members
        //-------------------------------------------------------------------------
        static none_measure(cell, dom, model, dv, row) {
            cell.$_prepareNone();
            return { width: 0, height: 0 };
        }
        static order_measure(cell, dom, model, dv, row) {
            const order = model.order();
            const span = cell.$_prepareOrder(order.getCellStyle(row), order.getStyle(row));
            // 모든 행의 셀 너비를 가장 긴 번호로 동일하게 한다.
            if (model.needOrderWidth) {
                const n = Math.log10(dv.rowCount() + order.rowOffset());
                span.textContent = (order.prefix() || '') + '8'.repeat(n) + (order.suffix() || '');
                model.orderWidth = dom.offsetWidth;
                model.needOrderWidth = false;
            }
            // span.textContent = dv.getRowId(row) + '';
            span.textContent = order.getText(dv, row);
            return { width: Math.max(model.minOrderWidth, model.orderWidth, dom.offsetWidth), height: dom.offsetHeight };
        }
        static check_measure(cell, dom, model, dv, row) {
            const check = model.check();
            if (!model.isMaster(row) || check.masterVisible()) {
                const size = check.size();
                cell.$_prepareCheck(size, check.getCellStyle(row), check.getStyle(row), true);
                return { width: dom.offsetWidth, height: dom.offsetHeight };
            }
            else {
                cell.$_prepareCheck(0, check.runStyle(model._displayChanged), check.getStyle(row), false);
                return { width: 0, height: 0 };
            }
        }
        static letter_measure(cell, dom, model, dv, row) {
            const letter = model.letter();
            const span = cell.$_prepareLetter(letter.getCellStyle(row), letter.getStyle(row));
            span.textContent = model.letter().letter();
            return { width: dom.offsetWidth, height: dom.offsetHeight };
        }
        static shape_measure(cell, dom, model, dv, row) {
            const shape = model.shape();
            const size = shape.size();
            cell.$_prepareShape(shape, row, shape.getCellStyle(row), shape.getStyle(row));
            return { width: size, height: size };
        }
        static image_measure(cell, dom, model, dv, row) {
            const image = model.image();
            const width = image.width();
            const height = image.height();
            cell.$_prepareImage(image, row, image.getCellStyle(row), image.getStyle(row), width, height);
            return { width: width, height: height };
        }
        static button_measure(cell, dom, model, dv, row) {
            const button = model.button();
            return RowCellElement.measureButton(cell, button, cell.$_prepareButton(button.getCellStyle(row), button.getStyle(row)));
        }
        static move_measure(cell, dom, model, dv, row) {
            const move = model.move();
            const size = move.size();
            cell.$_prepareMove(move, row, move.getCellStyle(row), move.getStyle(row));
            return { width: size, height: size };
        }
        static none_render(cell, width, height) {
        }
        static order_render(cell, width, height) {
        }
        static check_render(cell, width, height) {
            if (cell.visible) {
                const dom = cell.dom;
                dom.firstElementChild.lastElementChild.checked = cell.checked;
                // Dom.setAttribute(cell._check, 'checked', cell.checked); attr은 checkbox 초기 상태값을 지정하는 것.
                Dom.setAttr(dom.firstElementChild.lastElementChild, 'aria-checked', cell.checked); // checkbox input을 사용하는데도 이게 꼭 필요한가?
                dom.firstElementChild.firstElementChild.style.background = cell.checked ? 'rgb(56, 128, 255)' : 'white';
            }
        }
        static letter_render(cell, width, height) {
        }
        static shape_render(cell, width, height) {
        }
        static image_render(cell, width, height) {
        }
        static button_render(cell, width, height) {
        }
        static move_render(cell, width, height) {
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        measure(model, dv, row, hintWidth, hintHeight) {
            const m = RowBarCell.Measurers[this._display = model.getDisplay(row)];
            const dom = this.dom;
            this.dv = dv;
            this.row = row;
            dom.dataset.row = String(row);
            this.checked = model.owner().isRowChecked(row);
            this.hRelative = false;
            this.internalClearSize(); // 너비/높이가 새로 계산되도록...
            const sz = m ? m(this, dom, model, dv, row) : { width: 0, height: 0 };
            this.wMeasure = sz.width;
            this.hMeasure = sz.height;
            return { width: sz.width, height: sz.height };
        }
        render(model, width, height) {
            this.internalResize(width, height);
            const r = RowBarCell.Renderrs[this._display];
            if (r) {
                r(this, this.wMeasure, this.hMeasure);
            }
        }
        click(model, dom) {
            const row = this.row;
            if (this._check && this._check.contains(dom)) {
                model.owner().toggleChecked(row);
            }
            else if (dom === this._button) {
                model.button().click(this, row);
            }
            else if (this._shape && this._shape.containsDom(dom)) {
                model.shape().click(row, this._shape[T_URL]);
            }
            else if (dom === this._image) {
                model.image().click(row, this._image[T_URL]);
            }
        }
        // for testing
        getCheck() {
            return this._check.lastElementChild;
        }
        displayOfDom(dom) {
            if (this._check && this._check.contains(dom)) {
                return DListRowBarDisplay.CHECK;
            }
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        isDom(dom) {
            return super.isDom(dom) ||
                (this._check && this._check.contains(dom)) ||
                (this._shape && this._shape.dom().contains(dom)) ||
                dom === this._image ||
                dom === this._button ||
                super.isDom(dom);
        }
        getDragRequest(dom, options) {
            if (this._check && this._check.contains(dom)) {
                if (options._rowBar.check().canDrag()) {
                    return new CheckDragRequest(this.row);
                }
            }
            return super.getDragRequest(dom, options);
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        $_prepareNone() {
            Dom.removeChildren(this.dom, [this._order, this._check, this._image, this._letter, this._shape, this._button, this._move]);
        }
        $_prepareOrder(cellStyle, style) {
            const dom = this.dom;
            let order = this._order;
            Dom.removeChildren(dom, [this._check, this._image, this._letter, this._shape, this._button, this._move]);
            if (!order) {
                order = this._order = dom.ownerDocument.createElement('span');
                order.style.whiteSpace = 'pre';
                dom.appendChild(order);
            }
            else if (!order.parentElement) {
                dom.appendChild(order);
            }
            resetStyleOrClass2(dom, RowBarCell.CLASS_NAME, cellStyle);
            resetStyleOrClass2(order, RowBarCell.ORDER_CLASS, style);
            return this._order;
        }
        $_prepareCheck(size, cellStyle, style, visible) {
            if (this.visible = visible) {
                const dom = this.dom;
                const doc = dom.ownerDocument;
                let check = this._check;
                let input;
                let shape;
                Dom.removeChildren(dom, [this._order, this._image, this._letter, this._shape, this._button, this._move]);
                if (!check) {
                    check = this._check = doc.createElement('div');
                    dom.appendChild(check);
                    shape = this.control.shapes().create(CheckMark, null);
                    shape.setStyle(CHECK_MARK_STYLE);
                    shape.resize(size);
                    shape.appendTo(check);
                    input = doc.createElement('input');
                    input.type = 'checkbox';
                    Object.assign(input.style, {
                        position: 'absolute',
                        left: '0',
                        top: '0',
                        opacity: '0',
                        clipPath: 'circle(0)',
                        appearance: 'none'
                    });
                    check.appendChild(input);
                }
                else if (!check.parentElement) {
                    dom.appendChild(check);
                }
                resetStyleOrClass2(dom, RowBarCell.CLASS_NAME, cellStyle);
                resetStyleOrClass2(check, RowBarCell.CHECK_CLASS, style);
                return check;
            }
        }
        $_prepareImage(model, row, cellStyle, style, width, height) {
            const dom = this.dom;
            let image = this._image;
            Dom.removeChildren(dom, [this._order, this._check, this._letter, this._shape, this._button, this._move]);
            if (!image) {
                image = this._image = dom.ownerDocument.createElement('img');
                dom.appendChild(image);
            }
            else if (!image.parentElement) {
                dom.appendChild(image);
            }
            resetStyleOrClass2(dom, RowBarCell.CLASS_NAME, cellStyle);
            resetStyleOrClass2(image, RowBarCell.IMAGE_CLASS, style);
            image.width = width;
            image.height = height;
            image[T_URL] = image.src = model.getImageUrl(row);
            return image;
        }
        $_prepareLetter(cellStyle, style) {
            const dom = this.dom;
            let letter = this._letter;
            Dom.removeChildren(dom, [this._order, this._check, this._image, this._shape, this._button, this._move]);
            if (!letter) {
                letter = this._letter = dom.ownerDocument.createElement('span');
                letter.style.whiteSpace = 'pre';
                dom.appendChild(letter);
            }
            else if (!letter.parentElement) {
                dom.appendChild(letter);
            }
            resetStyleOrClass2(dom, RowBarCell.CLASS_NAME, cellStyle);
            resetStyleOrClass2(letter, RowBarCell.LETTER_CLASS, style);
            return letter;
        }
        $_prepareShape(model, row, cellStyle, style) {
            const dom = this.dom;
            const s = model.getShape(row);
            let shape = this._shape;
            Dom.removeChildren(dom, [this._order, this._check, this._image, this._letter, this._button, this._move]);
            if (!shape || s !== shape[T_URL]) {
                shape && shape.destroy();
                shape = this._shape = this.control.shapes().createStock(dom.ownerDocument, s) || this.control.shapes().createCustom(s, null, null);
                shape.appendTo(dom);
            }
            else {
                if (shape instanceof DCustomShape) {
                    shape.setShape(this.control.shapes().getCustom(s));
                }
                if (!shape.attached()) {
                    shape.appendTo(dom);
                }
            }
            shape.resize(model.size());
            shape[T_URL] = s;
            resetStyleOrClass2(dom, RowBarCell.CLASS_NAME, cellStyle);
            resetStyleOrClass2(shape.dom(), RowBarCell.SHAPE_CLASS, style);
            return shape.dom();
        }
        $_prepareButton(cellStyle, style) {
            const dom = this.dom;
            let button = this._button;
            Dom.removeChildren(dom, [this._order, this._image, this._letter, this._check, this._shape, this._move]);
            if (!button) {
                button = this._button = dom.ownerDocument.createElement('button');
                Object.assign(button.style, RowBarCell.BUTTON_STYLE);
                dom.appendChild(button);
            }
            else if (!button.parentElement) {
                dom.appendChild(button);
            }
            resetStyleOrClass2(dom, RowBarCell.CLASS_NAME, cellStyle);
            resetStyleOrClass2(button, RowBarCell.BUTTON_CLASS, style);
            return button;
        }
        $_prepareMove(model, row, cellStyle, style) {
            Dom.removeChildren(this.dom, [this._order, this._check, this._image, this._letter, this._button, this._shape]);
            return super.$_prepareMove(model, row, cellStyle, style);
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    RowBarCell.CLASS_NAME = 'dlist-rowbar-cell';
    RowBarCell.ORDER_CLASS = 'dlist-rowbar-order';
    RowBarCell.IMAGE_CLASS = 'dlist-rowbar-image';
    RowBarCell.CHECK_CLASS = 'dlist-rowbar-check';
    RowBarCell.SHAPE_CLASS = 'dlist-rowbar-shape';
    RowBarCell.LETTER_CLASS = 'dlist-rowbar-letter';
    RowBarCell.BUTTON_CLASS = 'dlist-row-button';
    RowBarCell.BUTTON_STYLE = {
        margin: 0,
        whiteSpace: 'nowrap',
        textOverflow: 'ellipsis',
        overflow: 'hidden',
    };
    RowBarCell.Measurers = {
        none: RowBarCell.none_measure,
        order: RowBarCell.order_measure,
        check: RowBarCell.check_measure,
        letter: RowBarCell.letter_measure,
        shape: RowBarCell.shape_measure,
        image: RowBarCell.image_measure,
        button: RowBarCell.button_measure,
        move: RowBarCell.move_measure
    };
    RowBarCell.Renderrs = {
        none: RowBarCell.none_render,
        order: RowBarCell.order_render,
        check: RowBarCell.check_render,
        letter: RowBarCell.letter_render,
        shape: RowBarCell.shape_render,
        image: RowBarCell.image_render,
        button: RowBarCell.button_render,
        move: RowBarCell.move_render
    };

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     *
     * 접근성 등을 고려해 edit bar view를 별도로 구성하지 않고 개별 item view에 edit 셀을 포함시킨다.
     */
    class EditBarCell extends RowCellElement {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(doc) {
            super(doc, null, EditBarCell.CLASS_NAME);
        }
        //-------------------------------------------------------------------------
        // static members
        //-------------------------------------------------------------------------
        static none_measure(cell, m, dv, row) {
            cell.$_prepareNone();
            return { width: 0, height: 0 };
        }
        static button_measure(cell, m, dv, row) {
            return RowCellElement.measureButton(cell, m, cell.$_prepareButton(m.getCellStyle(row), m.getStyle(row)));
        }
        static move_measure(cell, m, dv, row) {
            const size = m.size();
            cell.$_prepareMove(m, row, m.getCellStyle(row), m.getStyle(row));
            return { width: size, height: size };
        }
        static handle_measure(cell, m, dv, row) {
            return { width: 0, height: 0 };
        }
        static button_render(m, width, height) {
        }
        static move_render(m, width, height) {
        }
        static handle_render(m, width, height) {
        }
        _doDestory() {
            this._handle = this._handle.destroy();
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        measure(model, dv, row, hintWidth, hintHeight) {
            const a = this._action = model.getAction(row);
            const button = model.getButton(a);
            let sz;
            this.dv = dv;
            this.row = row;
            this.dom.dataset.row = String(row);
            this.hRelative = false;
            this.dom.style.width = ''; // 너비가 새로 계산되도록...
            if (button) {
                sz = EditBarCell.ButtonMeasurers[a](this, button, dv, row);
            }
            else if (a === DListEditBarAction.MOVE) {
                sz = EditBarCell.move_measure(this, model.move(), dv, row);
            }
            else {
                const handle = model.getHandle(a);
                if (handle) {
                    sz = EditBarCell.HandleMeasurers[a](this, handle, dv, row);
                }
                else {
                    sz = EditBarCell.none_measure(this, button, dv, row);
                }
            }
            this.wMeasure = sz.width;
            this.hMeasure = sz.height;
            return { width: sz.width, height: sz.height };
        }
        render(model, width, height) {
            this.internalResize(width, height);
            const a = this._action;
            const button = model.getButton(a);
            if (button) {
                EditBarCell.ButtonRenderers[a](button, this.wMeasure, this.hMeasure);
            }
            else if (a === DListEditBarAction.MOVE) {
                EditBarCell.move_render(model.move(), this.wMeasure, this.hMeasure);
            }
            else {
                const handle = model.getHandle(a);
                if (handle) {
                    EditBarCell.HandleRenderers[a](handle, this.wMeasure, this.hMeasure);
                }
            }
        }
        click(model, dom) {
            if (dom === this._button) {
                const row = this.row;
                const button = model.getButton(model.getAction(row));
                button && button.click(model, row);
                // const obj = dom.animate([
                //     { transform: 'translateY(0)'},
                //     { transform: 'translateY(50px)'}
                // ], {
                //     duration: 500,
                //     iterations: 1
                // });
                // // obj.addEventListener('finish', (ev) => {
                // //     (ev.target as HTMLElement).style.top = '0px';
                // // })
                // obj.addEventListener('finish', () => {
                //     // (dom as HTMLElement).style.top = '-20px';
                // });
                // (dom as HTMLElement).style.top = '-20px';
            }
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        isDom(dom) {
            return dom === this._button || super.isDom(dom);
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        $_prepareNone() {
            this._button && this._button.remove();
        }
        $_prepareButton(cellStyle, style) {
            const dom = this.dom;
            let button = this._button;
            Dom.removeChildren(dom, [this._move]);
            if (!button) {
                button = this._button = dom.ownerDocument.createElement('button');
                Object.assign(button.style, RowBarCell.BUTTON_STYLE);
                dom.appendChild(button);
            }
            else if (!button.parentElement) {
                dom.appendChild(button);
            }
            resetStyleOrClass2(dom, EditBarCell.CLASS_NAME, cellStyle);
            resetStyleOrClass2(button, RowBarCell.BUTTON_CLASS, style);
            return this._button;
        }
        $_prepareMove(model, row, cellStyle, style) {
            Dom.removeChildren(this.dom, [this._button]);
            return super.$_prepareMove(model, row, cellStyle, style);
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    EditBarCell.CLASS_NAME = 'dlist-editbar-cell';
    EditBarCell.ButtonMeasurers = {
        delete: EditBarCell.button_measure,
        add: EditBarCell.button_measure,
        edit: EditBarCell.button_measure,
        info: EditBarCell.button_measure,
        detail: EditBarCell.button_measure,
        link: EditBarCell.button_measure,
        custom: EditBarCell.button_measure
    };
    EditBarCell.HandleMeasurers = {
        move: EditBarCell.handle_measure,
    };
    EditBarCell.ButtonRenderers = {
        delete: EditBarCell.button_render,
        add: EditBarCell.button_render,
        edit: EditBarCell.button_render,
        info: EditBarCell.button_render,
        detail: EditBarCell.button_render,
        link: EditBarCell.button_render,
        custom: EditBarCell.button_render,
    };
    EditBarCell.HandleRenderers = {
        move: EditBarCell.handle_render,
    };

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     *
     * IListRenderer impl base.
     * 사용자가 값 변경 이벤트를 받으려면 id를 설정하거나 field가 연결돼야 한다.
     */
    class DListRendererImpl extends DObject {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(model) {
            super();
            this._styleArgs = {
                row: -1,
                value: void 0
            };
            this._model = model;
        }
        //-------------------------------------------------------------------------
        // consts
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // static members
        //-------------------------------------------------------------------------
        static getDomId(row, gindex, id) {
            if (isNaN(gindex)) {
                return `-dlist-${row}-${id}`;
            }
            else {
                return `-dlist-g-${gindex}-${id}`;
            }
        }
        _doDestory() {
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * model
         */
        model() {
            return this._model;
        }
        setModel(value) {
            if (value !== this._model) {
                this._model = value;
                // this._modelChanged = true;
            }
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        // getClassOfRenderDom(): string {
        //     return;
        // }
        // containsDom(div: HTMLDivElement, id: string): boolean {
        //     const cls = this.getClassOfRenderDom();
        //     return cls && div.getElementsByClassName(cls)[0].id === id;
        // }
        /**
         * layout view의 _doApplyStyles() 호출 시점에 적당한 dom에 스타일을 설정할 수 있도록
         * 여기에서 필요한 dom들을 미리 생성한다.
         */
        prepare(ctx, layout) {
            // div가 즉, layoutview가 이전에 다른 renderer에 의해 render()됐다면 내용을 지운다.
            if (layout[T_RENDERER] !== this._model.type) {
                layout[T_RENDERER] && this.$_clearContent(ctx, layout);
                layout[T_RENDERER] = this._model.type;
            }
            this._value = this._getValue(ctx);
            this._doPrepare(ctx, layout);
        }
        _setClass(dom, row) {
            const cb = this._model['_classCallback'];
            let s;
            if (cb) {
                this._styleArgs.row = row;
                this._styleArgs.value = this._value;
                const cls = cb(this._styleArgs);
                if (cls)
                    s = cls;
            }
            s = s || this._model['_class'];
            s ? dom.classList.add(s) : dom.classList.remove(s);
        }
        _getStyleTarget(div) {
            return div.style;
        }
        getStyle(row) {
            let st = this._model['_style'];
            const cb = this._model['_styleCallback'];
            if (cb) {
                this._styleArgs.row = row;
                this._styleArgs.value = this._value;
                const obj = cb(this._styleArgs);
                if (obj) {
                    if (st) {
                        Object.assign(st, obj);
                    }
                    else {
                        return obj;
                    }
                }
            }
            return st;
        }
        applyStyle(div, style) {
            const css = this._getStyleTarget(div);
            if (css) {
                if (this._prevStyle) {
                    for (let p in this._prevStyle) {
                        css[p] = '';
                    }
                }
                if (style) {
                    Object.assign(css, style);
                    this._prevStyle = Object.assign({}, style);
                }
                else {
                    this._prevStyle = void 0;
                }
            }
        }
        measureLayout(ctx, div, hintWidth, hintHeight) {
            return this._doMeasure(ctx, div, hintWidth, hintHeight);
        }
        renderLayout(ctx, div, width, height) {
            this._doRender(ctx, div, width, height);
        }
        unprepare(ctx, div) {
            // this._modelChanged = false;
            this._doUnprepare(ctx, div);
        }
        needBounds() {
            return false;
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        $_clearContent(ctx, div) {
            this._doDisposeContent(div);
            Dom.clearChildren(div);
            div.style.display = 'block';
            // this._prevStyle = void 0; // ?
        }
        // 자식 dom들에 설정된 이벤트 핸들러 등의 연결을 끊는다.
        _doDisposeContent(div) { }
        _setContext(ctx, dom, model) {
            dom.id = DListRendererImpl.getDomId(ctx.row, ctx.gindex, model.id);
            if (ctx.layout instanceof DLayoutField && ctx.layout.field) {
                dom[T_FIELD] = ctx.layout.field;
            }
            dom[T_ROW] = ctx.row;
        }
        _getValue(ctx) {
            return;
        }
        _getValues(ctx, baseValue) {
            const arr = this._getValue(ctx);
            let len;
            if (Array.isArray(arr) && (len = arr.length)) {
                const values = new Array(len);
                let min = arr[0];
                let max = arr[0];
                let hasBelow = false;
                let i = 0;
                while (isNaN(min) && i < len) {
                    min = max = +arr[++i];
                }
                for (; i < len; i++) {
                    const v = +arr[i];
                    values[i] = v;
                    if (!isNaN(v)) {
                        if (v < min)
                            min = v;
                        if (v > max)
                            max = v;
                        if (v < baseValue)
                            hasBelow = true;
                    }
                }
                return { min, max, values, hasBelow };
            }
            else {
                return {
                    values: []
                };
            }
        }
    }
    class ValueRendererImpl extends DListRendererImpl {
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _getValue(ctx) {
            const v = this._model['_value'];
            return v !== void 0 ? v : ctx.value();
        }
    }
    class EditableRendererImpl extends ValueRendererImpl {
    }
    class DSvgRendererImpl extends ValueRendererImpl {
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _getStyleTarget(div) {
            return this._svg.svg.style;
        }
        _doPrepare(ctx, div) {
            div[SVG] = (this._svg = this.$_getSvg(ctx, div)).svg;
        }
        _doUnprepare(ctx, div) {
            this._svg = this._svg && this._svg.destroy();
            div[SVG] = null;
        }
        $_getSvg(ctx, div) {
            const cls = this._getSvgClass();
            let svg = div.getElementsByClassName(cls)[0];
            if (!svg) {
                svg = DSvg.create(ctx.doc);
                div.appendChild(svg);
                return new DSvg(svg, cls);
            }
            else {
                return new DSvg(svg, null); // 이미 cls와 동일한 className.
            }
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     *
     * Spacer renderer impl for {@link SpacerRenderer}.
     */
    class SpacerRendererImpl extends DListRendererImpl {
        //-------------------------------------------------------------------------
        // static members
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // property fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doPrepare(ctx, div) { }
        _getStyleTarget(div) {
            return div.style;
        }
        _doMeasure(ctx, div, hintWidth, hintHeight) {
            const layout = ctx.layout._parent;
            const width = layout.canContainHspace() ? this.model().space : 1;
            const height = layout.canContainVspace() ? this.model().space : 1;
            return { width, height };
        }
        _doRender(ctx, div, width, height) { }
        _doUnprepare(ctx, div) { }
        setValue(layout, newValue) {
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    SpacerRendererImpl.SPAN_CLASS = 'dlist-spacer-span';

    ////////////////////////////////////////////////////////////////////////////////
    class LayoutChildView extends DListElement {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(doc, model, contentable, className) {
            super(doc, contentable, className);
            this._model = model;
            this._relWidth = getRelativeSize(model._widthDim);
            this._relHeight = getRelativeSize(model._heightDim);
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        model() {
            return this._model;
        }
        manager() {
            return this._manager;
        }
        isSpacer() {
            return false;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        setRelativePositions() {
            const m = this._model;
            this._relLeft = getPercent(m._leftDim);
            this._relRight = getPercent(m._rightDim);
            this._relTop = getPercent(m._topDim);
            this._relBottom = getPercent(m._bottomDim);
        }
        setRelativeHorz() {
            this._relLeft = getPercent(this._model._leftDim);
            this._relRight = getPercent(this._model._rightDim);
        }
        setRelativeVert() {
            this._relTop = getPercent(this._model._topDim);
            this._relBottom = getPercent(this._model._bottomDim);
        }
        prepareLayout(doc, hint) {
            const css = this.dom.style;
            this._doPrepareRender(doc, hint);
            this._doApplyStyles(css);
            this._doApplyImportantStyles(css);
            this._prevMax = { width: NaN, height: NaN };
            this.mw = this.mh = NaN;
            const p = this._padding = this.getPadding2();
            p.horz = p.left + p.right + p.borderLeft + p.borderRight;
            p.vert = p.top + p.bottom + p.borderTop + p.borderBottom;
        }
        measureLayout(doc, hint, maxWidth, maxHeight) {
            const p = this._padding;
            maxWidth -= p.horz;
            maxHeight -= p.vert;
            const sz = this._doMeasureLayout(doc, hint, maxWidth, maxHeight);
            this.mw = sz.width += p.horz;
            this.mh = sz.height += p.vert;
            return sz;
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        getLabel() {
            return this._label;
        }
    }
    /**
     * @internal
     *
     * View of DListLayout.
     *
     * 1. layout의 너비가 자식 layout이나 field의 크기에 영향을 주는가?
     *    - 기본적으로 자식들의 너비로부터 부모 layout의 너비가 결정된다.
     *    - 하자민, wrap 가능한 자식인 경우, 부모 너비를 최대 크기로 간주한다.
     */
    class ListLayoutView extends LayoutChildView {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(doc, model) {
            super(doc, model, true, ListLayoutView.CLASS_NAME);
            if (!model) {
                throwError(locale.layoutMustSet);
            }
            this._model = model;
        }
        //-------------------------------------------------------------------------
        // static members
        //-------------------------------------------------------------------------
        static isView(dom) {
            return dom.classList.contains(this.CLASS_NAME);
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        tag() {
            return this._model.tag;
        }
        isRoot() {
            return !(this.parent instanceof ListLayoutView);
        }
        scrollable() {
            return false;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        /**
         * 처음 생성될 때,
         * item view의 measure 직전 {@link ListItemView._doPrepareLayout}에서 호출한다.
         */
        build(doc, manager) {
            for (const child of this._model.children()) {
                if (this._canContain(child)) {
                    if (child instanceof DLayoutField) {
                        this.addChild(new LayoutFieldView(doc, child)); //.setRow(dv, row, gindex));
                    }
                    else if (child instanceof DLayoutLiteral) {
                        this.addChild(new LayoutLiteralView(doc, child)); //.setRow(dv, row, gindex));
                    }
                    else if (child instanceof DListLayout) {
                        const view = manager.createLayoutView(doc, child);
                        view.build(doc, manager);
                        this.addChild(view);
                    }
                }
            }
        }
        /**
         * 모델이 변경됐을 때,
         */
        refreshModels(layout) {
            this._model = layout;
            for (let i = 0, n = this.childCount; i < n; i++) {
                const v = this.getChild(i);
                const l = layout.getChild(i);
                if (v instanceof SimpleLayoutView) {
                    v['_model'] = l;
                    // v.setRow(dv, row, gindex);
                }
                else if (v instanceof ListLayoutView) {
                    v.refreshModels(l);
                }
            }
        }
        saveEditValues(manager) {
            for (let i = 0, n = this.childCount; i < n; i++) {
                const v = this.getChild(i);
                if (v instanceof SimpleLayoutView) {
                    v.saveEditValue(manager);
                }
                else if (v instanceof ListLayoutView) {
                    v.saveEditValues(manager);
                }
            }
        }
        fieldBy(field, deep) {
            if (deep)
                return this.findDescendant(child => child instanceof LayoutFieldView && child.model().field === field);
            return this.findChild(child => child instanceof LayoutFieldView && child.model().field === field);
        }
        childByTag(tag, deep = false) {
            if (deep)
                this.findDescendant(child => child.tag() === tag);
            return this.findChild(child => child.tag() === tag);
        }
        simpleById(id, deep) {
            if (deep)
                return this.findDescendant(child => child instanceof SimpleLayoutView && child.model().id() === id);
            return this.findChild(child => child instanceof SimpleLayoutView && child.model().id() === id);
        }
        simpleByModel(layout, deep) {
            if (deep)
                return this.findDescendant(child => child instanceof SimpleLayoutView && child.model().tid === layout.tid);
            return this.findChild(child => child instanceof SimpleLayoutView && child.model().id === layout.id());
        }
        simpleByDom(dom, deep) {
            if (deep)
                return this.findDescendant(child => child instanceof SimpleLayoutView && child.containsDom(dom));
            return this.findChild(child => child instanceof SimpleLayoutView && child.containsDom(dom));
        }
        getRenderer(dom) {
            const sv = this.simpleByDom(dom, true);
            return sv && sv.renderer();
        }
        simpleBy(tag, deep) {
            if (deep)
                this.findDescendant(child => child instanceof SimpleLayoutView && child.layout.tag === tag);
            return this.findChild(child => child instanceof SimpleLayoutView && child.tag() === tag);
        }
        literalBy(tag, deep) {
            if (deep)
                return this.findDescendant(child => child instanceof LayoutLiteralView && child.tag() === tag);
            return this.findChild(child => child instanceof LayoutLiteralView && child.tag() === tag);
        }
        simplesByRenderer(renderer) {
            const views = [];
            this.findDescendants(child => child instanceof SimpleLayoutView && child.renderer().type() === renderer, views);
            return views;
        }
        getValues(manager) {
            const values = {};
            this._getValues(manager, values);
            return values;
        }
        _getValues(manager, values) {
            this._visibles.forEach(lv => {
                if (lv instanceof SimpleLayoutView) {
                    const value = lv.getEditValue(manager);
                    value && (values[value.field] = value.value);
                }
                else if (lv instanceof ListLayoutView) {
                    lv._getValues(manager, values);
                }
            });
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doInitContent(doc, div) {
            if (DElement.BOUNDING) {
                div.style.boxSizing = 'border-box';
                div.style.border = DElement.BOUNDING_BORDER_2;
            }
            // 이렇게 하면 layout 경계를 넘어선 자식들이 잘린다. ex) top = -20...
            // div.style.overflow = 'hidden';
        }
        prepareView(manager) {
        }
        _doPrepareRender(doc, manager) {
            this._manager = manager;
            this._visibles = [];
            this.forEach((child) => {
                if (child._internalVisible(child.model().visible)) {
                    this._visibles.push(child);
                    child._explicitWidth = child._explicitHeight = child.mw = child.mh = NaN;
                }
            });
        }
        _doApplyStyles(css) {
            const styles = this.model().style;
            if (styles) {
                Object.assign(css, styles);
            }
        }
        _doApplyImportantStyles(css) {
            this.setImportantStyle(css, 'position', 'absolute');
        }
        _doMeasure(doc, maxWidth, maxHeight) {
            throw new Error('Not used override.');
        }
        prepareLayout(doc, hint) {
            super.prepareLayout(doc, hint);
            this._visibles.forEach(v => v.prepareLayout(doc, hint));
        }
        _doRender(doc, width, height) {
            const visibles = this._visibles;
            const p = this._padding;
            if (!p)
                debugger;
            // if (p) {
            width -= p.horz;
            height -= p.vert;
            // }
            this.resizeContent(width, height);
            this._doLayoutContent(doc, width, height);
            visibles.forEach((child) => {
                child.render(doc);
            });
            // layout에 포함된 simple들의 renderer 재생성 순서가 일치되도록 거꾸로 push되게한다.
            for (let i = visibles.length - 1; i >= 0; i--) {
                if (visibles[i] instanceof SimpleLayoutView) {
                    visibles[i].freeRenderer();
                }
            }
        }
        _doAfterRender() {
            super._doAfterRender();
            this._manager = null;
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        _canContain(layout) {
            return true;
        }
        _getChildMaxWidth(child, maxWidth) {
            if (child._leftDim) {
                maxWidth -= calcPercent(child._leftDim, maxWidth);
            }
            if (child._rightDim) {
                maxWidth -= calcPercent(child._rightDim, maxWidth);
            }
            return maxWidth;
        }
        _getChildMaxHeight(child, maxHeight) {
            if (child._topDim) {
                maxHeight -= calcPercent(child._leftDim, maxHeight);
            }
            if (child._bottomDim) {
                maxHeight -= calcPercent(child._rightDim, maxHeight);
            }
            return maxHeight;
        }
        _defaultExplicitWidth(maxWidth) {
            return NaN;
        }
        _defaultExplicitHeight(maxHeight) {
            return NaN;
        }
        _measureChildren(visibles, doc, hint, maxWidth, maxHeight, callback) {
            let h;
            let w;
            for (const v of visibles) {
                const m = v.model();
                const wDim = m._widthDim;
                const hDim = m._heightDim;
                v._explicitWidth = this._defaultExplicitWidth(maxWidth);
                v._explicitHeight = this._defaultExplicitHeight(maxHeight);
                if (wDim) {
                    if (wDim.fixed) {
                        v._explicitWidth = w = wDim.size;
                    }
                    else if (!isNaN(this._explicitWidth)) {
                        v._explicitWidth = w = maxWidth * wDim.size / 100;
                    }
                    else {
                        w = maxWidth;
                    }
                }
                else {
                    w = maxWidth;
                }
                if (hDim) {
                    if (hDim.fixed) {
                        v._explicitHeight = h = hDim.size;
                    }
                    else if (!isNaN(this._explicitHeight)) {
                        v._explicitHeight = h = maxHeight * hDim.size / 100;
                    }
                    else {
                        h = maxHeight;
                    }
                }
                else {
                    h = maxHeight;
                }
                v.measureLayout(doc, hint, w, h);
                if (!isNaN(v._explicitHeight))
                    v.mh = v._explicitHeight;
                if (!isNaN(v._explicitWidth))
                    v.mw = v._explicitWidth;
                callback && callback(v);
            }
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    // NOTE: 이 class 이름으로 css 파일에 추가하면 안된다.
    //       getPadding() 호출 전제가 model.style()이므로
    //       padding 스타일이 외부에서 설정되면 안된다.
    ListLayoutView.CLASS_NAME = '-dlist-layout-';
    /**
     * @internal
     *
     * View base for a {@link DLayoutField}.
     *
     * 1. 'table' div는 renderer element의 수평/수직 정렬에 필요하다.
     * 2. layout dom을 'table'로 하지 않는 것은 layout의 명시적 크기를 반영하기 위해서다. (table-layout을 'fixed'로 해주면 되는 데 ios에서 문제가 있다.)
     * 3. table의 offset 크기를 반영하므로 포함된 renderer element는 measure에서 계산된 값(offset size)을 리턴할 필요가 없다.
     * 4. layout의 style은 table div가 아니라 layout dom에 적용한다.
     */
    class SimpleLayoutView extends LayoutChildView {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(doc, model) {
            super(doc, model, false, null);
            this._selected = false;
            this._focused = false;
            this._ctx = { row: -1, value: undefined };
        }
        //-------------------------------------------------------------------------
        // IListRenderContext
        //-------------------------------------------------------------------------
        get layout() {
            return this._model;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        model() {
            return this._model;
        }
        value() {
            return this._value;
        }
        renderer() {
            return this._model.renderer;
        }
        /**
         * 주의: rendering 중에만 유효하다.
         */
        rendererImpl() {
            return this._renderer;
        }
        tag() {
            return this._model.tag;
        }
        get selected() {
            return this._selected;
        }
        get focused() {
            return this._focused;
        }
        get row() {
            return this._model.row;
        }
        get gindex() {
            return this._model.gindex;
        }
        field() {
            return this._model.getField();
        }
        align() {
            return this._model.align;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        getValue(field) {
            return this.layout.dv.getValue(this.layout.row, field, true);
        }
        useImage(src) {
            this._manager.useImage(src);
        }
        getImageSize(src) {
            return this._manager.getImageSize(src);
        }
        getIcon(iconSet, iconName) {
            return this._manager.getIcon(iconSet, iconName);
        }
        inflate(ps) {
            return this._manager.owner().inflateField(ps, this.field());
        }
        textFormatter() {
            return this._manager.textFormatter;
        }
        boolFormatter() {
            return this._manager.boolFormatter;
        }
        numberFormatter() {
            return this._manager.numberFormatter;
        }
        dateFormatter() {
            return this._manager.dateFormatter;
        }
        getEditValue(manager) {
            const field = this.field();
            if (field) {
                const renderer = manager.borrowRenderer(this._model.renderer);
                try {
                    if (renderer instanceof EditableRendererImpl) {
                        const value = renderer.getValue(this.dom);
                        return { field, value };
                    }
                }
                finally {
                    renderer && manager.freeRenderer(renderer);
                }
            }
        }
        setEditValue(manager, value) {
            const field = this.field();
            if (field) {
                const renderer = manager.borrowRenderer(this._model.renderer);
                try {
                    if (renderer instanceof EditableRendererImpl) {
                        renderer.setValue(this.dom, value);
                    }
                }
                finally {
                    renderer && manager.freeRenderer(renderer);
                }
            }
        }
        saveEditValue(manager) {
            const v = this.getEditValue(manager);
            this._editValue = v && v.value;
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        isSpacer() {
            return this._spacer;
        }
        _doInitDom(doc, dom) {
            DElement.BOUNDING && (dom.style.border = DElement.BOUNDING_BORDER);
            dom.style.overflow = 'hidden';
            this._table = doc.createElement('div');
            Object.assign(this._table.style, {
                display: 'table',
                // tableLayout: 'fixed', // 'fixed'로 지정하면 text가 잘릴 수 있다. iOS에서 망가진다.
                width: '100%',
                height: '100%'
            });
            dom.appendChild(this._table);
        }
        isDom(dom) {
            // renderer impl에서 필요한 dom들을 생성하고 이 element에 추가하므로,
            // 여기서는 무엇이 추가된 상태인 지 구체적으로 알 수 없다.
            // 자손 dom인 지를 확인한다.
            return super.isDom(dom) || this.containsDom(dom);
        }
        prepareView(manager) {
            this._renderer = manager.borrowRenderer(this._model.renderer);
            this._spacer = this._renderer instanceof SpacerRendererImpl;
        }
        _doPrepareRender(doc, manager) {
            const div = this._table; // this.dom as HTMLDivElement;
            // _doAfterRender()에서 연결을 끊는다.
            this._manager = manager;
            this._renderer.prepare(this, div);
            const child = div.firstElementChild;
            const model = this._model;
            if (child) {
                child.style.display = 'table-cell';
                child.style.verticalAlign = model.valign;
            }
            model.align && (div.style.textAlign = model.align);
            // class name
            const cb = model.classCallback;
            let cls;
            if (cb) {
                cls = cb(this);
            }
            else {
                cls = model.class;
            }
            if (cls) {
                this.dom.className = cls;
            }
            else {
                delete this.dom.className;
            }
        }
        _doApplyStyles(css) {
            const cb = this._model.styleCallback;
            for (let p in this._prevStyles) {
                css[p] = '';
            }
            const st = this._prevStyles = {};
            let mst = this._model.style;
            if (mst) {
                Object.assign(st, mst);
            }
            if (cb) {
                this._ctx.row = this._model.row;
                this._ctx.value = this._value;
                let st2 = cb(this._ctx);
                st2 && Object.assign(st, st2);
            }
            Object.assign(css, st);
            const rst = this._renderer.getStyle(this._model.row);
            // TODO: renderer element에? _table과 관련된 것은 외부에서 전혀 손댈 수 없도록...
            this._renderer.applyStyle(this._table, rst);
        }
        _doApplyImportantStyles(css) {
            this.setImportantStyle(css, 'position', 'absolute');
        }
        _doMeasure(doc, hintWidth, hintHeight) {
            const dom = this._table; // this.dom;
            // this.setHeight(this._explicitHeight); // 필요한가?
            // text renderer가 wrap 계산을 할 수 있도록 너비를 만들어 줘야 한다.
            this.setWidth(this._renderer.needBounds() ? hintWidth : NaN);
            this.setHeight(NaN);
            const sz = this._renderer.measureLayout(this, dom, hintWidth, hintHeight);
            this._renderer.needBounds() && this.setWidth(NaN);
            let width = this._explicitWidth;
            let height = this._explicitHeight;
            if (isNaN(width)) {
                // display가 table이어서 대부분 renderer 계산이 필요 없다. 이 div의 offset 크기를 바로 리턴한다.
                // text renderer는 계산한 걸 뱉는다.
                width = sz ? sz.width : dom.offsetWidth;
            }
            else {
                width -= this._padding.horz;
            }
            if (isNaN(height)) {
                height = sz ? sz.height : dom.offsetHeight;
            }
            else {
                height -= this._padding.vert;
            }
            return { width, height };
        }
        _doRender(doc, width, height) {
            const p = this._padding;
            const dom = this._table; // this.dom;
            width -= p.horz;
            height -= p.vert;
            this._renderer.renderLayout(this, dom, width, height);
        }
        freeRenderer() {
            this._renderer.unprepare(this, this._table); // this.dom as HTMLDivElement);
            this._manager.freeRenderer(this._renderer);
            this._manager = null;
            // _renderer를 테스트할 수 있도록...
            if (!this._testing()) {
                this._renderer = null;
            }
        }
        _doMeasureLayout(doc, hint, maxWidth, maxHeight) {
            return this._doMeasure(doc, maxWidth, maxHeight);
        }
    }
    /**
     * @internal
     */
    class LayoutFieldView extends SimpleLayoutView {
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        field() {
            return this.layout.field;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doPrepareRender(doc, manager) {
            this._value = this._editValue !== void 0 ? this._editValue : this.layout.getValue();
            super._doPrepareRender(doc, manager);
        }
    }
    /**
     * @internal
     *
     * View for a {@link DLiteralLayout}.
     */
    class LayoutLiteralView extends SimpleLayoutView {
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doPrepareRender(doc, manager) {
            this._value = this._editValue !== void 0 ? this._editValue : this.layout.value;
            super._doPrepareRender(doc, manager);
        }
    }
    /**
     * @internal
     *
     * 자식들의 위치를 left|right|top|bottom 고정값 혹은 %값으로 지정된다.
     * 위치를 지정하지 않으면 상하/좌우 중앙에 표시된다.
     */
    class PositionableLayoutView extends ListLayoutView {
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        /**
         * 1. 자식들의 고정된 위치와 계산된 크기로 최대 크기를 계산한다.
         *    자식 위치가 '%'인 경우 지식 크기를 기준으로 최대 크기를 계산한다.
         *    (ex) top: 40%, mh: 100 => 100이 60%가 되게 맞춘다. 100 : x = 0.6 : 1, x = 100 / 0.6;
         */
        _doMeasureLayout(doc, hint, maxWidth, maxHeight) {
            const visibles = this._visibles;
            let width = this._explicitWidth;
            let height = this._explicitHeight;
            this._measureChildren(this._visibles, doc, hint, maxWidth, maxHeight, null);
            if (isNaN(width) || this.model().canGrow()) {
                let wCalced = 0;
                visibles.forEach(v => {
                    let w = v.mw;
                    let dim = v.model()._leftDim || v.model()._rightDim;
                    if (dim) {
                        if (dim.fixed) {
                            w += dim.size;
                        }
                        else {
                            w /= (100 - dim.size) / 100;
                        }
                    }
                    wCalced = Math.max(wCalced, w);
                });
                width = isNaN(this.mw) ? wCalced : Math.max(this.mw, wCalced);
            }
            if (isNaN(height) || this.model().canGrow()) {
                let hCalced = 0;
                visibles.forEach(v => {
                    let h = v.mh;
                    let dim = v.model()._topDim || v.model()._bottomDim;
                    if (dim) {
                        if (dim.fixed) {
                            h += dim.size;
                        }
                        else {
                            h /= (100 - dim.size) / 100;
                        }
                    }
                    hCalced = Math.max(h, hCalced);
                });
                height = isNaN(this.mh) ? hCalced : Math.max(this.mh, hCalced);
            }
            return { width, height };
        }
        _doLayoutContent(doc, width, height) {
            for (let v of this._visibles) {
                const m = v.model();
                const left = pickNum(v._explicitLeft, m.getLeftIn(width));
                const top = pickNum(v._explicitTop, m.getTopIn(height));
                let x = 0;
                let y = 0;
                // horz
                if (!isNaN(left)) {
                    x = left;
                }
                else {
                    const right = isNaN(left) ? pickNum(v._explicitRight, m.getRightIn(width)) : 0;
                    if (!isNaN(right)) {
                        x = width - v.mw - right;
                    }
                    else {
                        x = (width - v.mw) / 2;
                    }
                }
                // vert
                if (!isNaN(top)) {
                    y = top;
                }
                else {
                    const bottom = isNaN(top) ? pickNum(v._explicitBottom, m.getBottomIn(height)) : 0;
                    if (!isNaN(bottom)) {
                        y = height - v.mh - bottom;
                    }
                    else {
                        y = (height - v.mh) / 2;
                    }
                }
                v.mx = x;
                v.my = y;
                v.applyMeasuredBounds();
            }
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * 자동 스크롤 진행 방식.
     * <br>
     * {@link AutoScroll.mode} 속성으로 사용된다.
     */
    var DListAutoScrollMode;
    (function (DListAutoScrollMode) {
        DListAutoScrollMode["DEFAULT"] = "default";
        DListAutoScrollMode["REPEAT"] = "repeat";
        DListAutoScrollMode["LOOP"] = "loop";
        DListAutoScrollMode["RANDOM"] = "random";
    })(DListAutoScrollMode || (DListAutoScrollMode = {}));
    /**
     * @internal
     */
    class AutoScroll extends DWrappableOptions {
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        _doInitDefaults() {
            this._enabled = false;
            this._mode = DListAutoScrollMode.DEFAULT;
            this._backward = false;
            this._duration = AutoScroll.DURATION;
            this._changeDuration = AutoScroll.CHANGE_DURATION;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * 활성화 여부.
         */
        enabled() {
            return pickProp(this._enabled, this._defs && this._defs._enabled);
        }
        setEnabled(value) {
            if (value !== this._enabled) {
                this._enabled = value;
                this.owner().autoScrollChanged(this);
            }
        }
        /**
         * scroll mode
         */
        mode() {
            return pickProp(this._mode, this._defs && this._defs._mode);
        }
        setMode(value) {
            this._mode = value;
        }
        /**
         * 이전 행 방향으로 스크롤 진행.
         */
        backward() {
            return pickProp(this._backward, this._defs && this._defs._backward);
        }
        setBackward(value) {
            this._backward = value;
        }
        /**
         * 행 표시 기간. ms 단위.
         */
        duration() {
            return pickNum3(this._duration, this._defs && this._defs._duration, AutoScroll.DURATION);
        }
        setDuration(value) {
            this._duration = value;
        }
        /**
         * 행 이동 기간. ms 단위.
         */
        changeDuration() {
            return pickNum3(this._changeDuration, this._defs && this._defs._changeDuration, AutoScroll.CHANGE_DURATION);
        }
        setChangeDuration(value) {
            this._changeDuration = value;
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    AutoScroll.DURATION = 5000;
    AutoScroll.CHANGE_DURATION = 300;

    ////////////////////////////////////////////////////////////////////////////////
    class ListRowLink extends DWrappableOptions {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        _doInitDefaults() {
            this._target = '_blank';
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /** rootUrl */
        rootUrl() {
            return pickProp(this._rootUrl, this._defs && this._defs._rootUrl);
        }
        setRootUrl(value) {
            this._rootUrl = value;
        }
        /** linkField */
        linkField() {
            return pickProp(this._linkField, this._defs && this._defs._linkField);
        }
        setLinkField(value) {
            this._linkField = value;
        }
        /** linkCallback */
        linkCallback() {
            return pickProp(this._linkCallback, this._defs && this._defs._linkCallback);
        }
        setLinkCallback(value) {
            this._linkCallback = value;
        }
        /** target */
        target() {
            return pickProp(this._target, this._defs && this._defs._target);
        }
        setTarget(value) {
            this._target = value;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        getLink(control, dv, row) {
            const cb = this.linkCallback();
            let s;
            if (cb) {
                s = cb({ control, row });
            }
            if (s !== void 0 && this.linkField) {
                s = dv.getValue(row, this.linkField(), true);
            }
            return (this.rootUrl() || '') + (s || '');
        }
    }
    /**
     * 데이터행 경계선이나 focus 마스크 들여쓰기 방식.
     * <br>
     * {@link DListRowBorder.nearIndent}나 {@link DListRowBorder.farIndent} 속성으로 사용된다.
     * {@link DListRowBorder}는 {@link DListRow.border} 속성 객체이다.
     *
     * ```
     *  list.setOptions({
     *      row: {
     *          border: {
     *              nearIndent: 'none'
     *          }
     *      }
     *  });
     * ```
     *
     * @see concepts.data_row 데이터행 개요
     */
    var DListRowIndent;
    (function (DListRowIndent) {
        /**
         * 들여쓰기 없이 데이터행 너비나 높이에 맞게 표시한다.
         * <br>
         */
        DListRowIndent["NONE"] = "none";
        /**
         * 데이터행 padding 크기에 맞춰 들여쓴다.
         */
        DListRowIndent["PADDING"] = "padding";
        /**
         * {@link concepts.row_bar Row Bar}나 {@link concepts.edit_bar Edit Bar} 표시 크기만큼
         * 들여쓴다.
         * <br>
         */
        DListRowIndent["BAR"] = "bar";
    })(DListRowIndent || (DListRowIndent = {}));
    class RowBorderLine extends DWrappableOptions {
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        _doInitDefaults() {
            this._visible = true;
            this._nearIndent = DListRowIndent.BAR;
            this._farIndent = DListRowIndent.NONE;
            this._skipLast = false;
            this._skipGroupLast = false;
            this._leafOnly = false;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /** visible */
        visible() {
            return pickProp(this._visible, this._defs && this._defs._visible);
        }
        setVisible(value) {
            if (value !== this._visible) {
                this._visible = value;
                this._changed();
            }
        }
        /** style */
        style() {
            return pickProp(this._style, this._defs && this._defs._style);
        }
        setStyle(value) {
            if (value !== this._style) {
                this._style = value;
                this._changed();
            }
        }
        /** masterStyle */
        masterStyle() {
            return pickProp(this._masterStyle, this._defs && this._defs._masterStyle);
        }
        setMasterStyle(value) {
            if (value !== this._masterStyle) {
                this._masterStyle = value;
                this._changed();
            }
        }
        /** nearIndent */
        nearIndent() {
            return pickProp(this._nearIndent, this._defs && this._defs._nearIndent);
        }
        setNearIndent(value) {
            if (value !== this._nearIndent) {
                this._nearIndent = value;
                this._changed();
            }
        }
        /** farIndent */
        farIndent() {
            return pickProp(this._farIndent, this._defs && this._defs._farIndent);
        }
        setFarIndent(value) {
            if (value !== this._farIndent) {
                this._farIndent = value;
                this._changed();
            }
        }
        /** skipLast */
        skipLast() {
            return pickProp(this._skipLast, this._defs && this._defs._skipLast);
        }
        setSkipLast(value) {
            if (value !== this._skipLast) {
                this._skipLast = value;
                this._changed();
            }
        }
        /**
         * 행 그룹핑일 때, 그룹 footer와 붙어 있는 데이터행에는 표시하지 않는다.
         */
        skipGroupLast() {
            return pickProp(this._skipGroupLast, this._defs && this._defs._skipGroupLast);
        }
        setSkipGroupLast(value) {
            if (value !== this._skipGroupLast) {
                this._skipGroupLast = value;
                this._changed();
            }
        }
        /**
         * 데이터그룹에 연결된 경우 detail 행들에만 표시.
         * 이 속성이 true이고 innerOnly가 true이면 master 행과 붙어있는 leaf 행에는 표시하지 않는다.
         */
        leafOnly() {
            return pickProp(this._leafOnly, this._defs && this._defs._leafOnly);
        }
        setLeafOnly(value) {
            if (value !== this._leafOnly) {
                this._leafOnly = value;
                this._changed();
            }
        }
    }
    class RowFocusMask extends DWrappableOptions {
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        _doInitDefaults() {
            this._visible = true;
            this._nearIndent = DListRowIndent.NONE;
            this._farIndent = DListRowIndent.NONE;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /** visible */
        visible() {
            return pickProp(this._visible, this._defs && this._defs._visible);
        }
        setVisible(value) {
            if (value !== this._visible) {
                this._visible = value;
                this._changed();
            }
        }
        /** nearIndent */
        nearIndent() {
            return pickProp(this._nearIndent, this._defs && this._defs._nearIndent);
        }
        setNearIndent(value) {
            if (value !== this._nearIndent) {
                this._nearIndent = value;
                this._changed();
            }
        }
        /** farIndent */
        farIndent() {
            return pickProp(this._farIndent, this._defs && this._defs._farIndent);
        }
        setFarIndent(value) {
            if (value !== this._farIndent) {
                this._farIndent = value;
                this._changed();
            }
        }
    }
    class ListRowScroll extends AutoScroll {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        _doInitDefaults() {
            super._doInitDefaults();
            this._rowsPerScroll = 1;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * 스크롤 당 이동 행 수.
         */
        rowsPerScroll() {
            return pickNum(this._rowsPerScroll, this._defs && this._defs._rowsPerScroll);
        }
        setRowsPerScroll(value) {
            this._rowsPerScroll = value;
        }
    }
    /**
     * @internal
     *
     * 데이터행 모델.
     */
    class ListRow extends DWrappableOptions {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(owner, defaults) {
            super(owner, defaults);
            this._link = new ListRowLink(owner, defaults && defaults._link);
            this._borderLine = new RowBorderLine(owner, defaults && defaults._borderLine);
            this._focusMask = new RowFocusMask(owner, defaults && defaults._focusMask);
            this._autoScroll = new ListRowScroll(owner, defaults && defaults._autoScroll);
        }
        _doInitDefaults() {
            this._tempalte = 'row';
            this._clickAction = DListRowClickAction.NONE;
            this._masterClickAction = DListRowClickAction.EXPAND;
            this._pressAction = DListRowClickAction.NONE;
            this._swipeAction = DListRowSwipeAction.COMMAND;
            this._focusable = false;
            this._touchEffect = true;
            this._deleteAnimation = true;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /** template */
        template() {
            return pickProp(this._tempalte, this._defs && this._defs._tempalte);
        }
        setTemplate(value) {
            if (value !== this._tempalte) {
                this._tempalte = value;
                this._changed();
            }
        }
        /**
         * default large screen row template name for rows.
         */
        largeTemplate() {
            return pickProp(this._largeTemplate, this._defs && this._defs._largeTemplate);
        }
        setLargeTemplate(value) {
            if (value !== this._largeTemplate) {
                this._largeTemplate = value;
                this._changed();
            }
        }
        /**
         * 데이터행 별 template을 리턴하는 콜백.
         */
        templateCallback() {
            return pickProp(this._templateCallback, this._defs && this._defs._templateCallback);
        }
        setTemplateCallback(value) {
            if (value !== this._templateCallback) {
                this._templateCallback = value;
                this._changed();
            }
        }
        /**
         * row template params.
         * <br>
         * [주의] getter로 리턴된 object의 속성을 변경해도 control에 반영되지 않는다.
         */
        templateParams() {
            return Object.assign({}, this.$_internalParams());
        }
        setTemplateParams(value) {
            let dirty = false;
            if (!value) {
                if (this._templateParams) {
                    this._templateParams = void 0;
                    dirty = true;
                }
            }
            else if (!Utils.equalObjects(value, this._templateParams)) {
                this._templateParams = Object.assign({}, value);
                dirty = true;
            }
            dirty && this._changed();
        }
        /** @internal */
        $_internalParams() {
            return pickProp(this._templateParams, this._defs && this._defs._templateParams);
        }
        /**
         * default row background styles.
         * <br>
         */
        style() {
            return pickProp(this._style, this._defs && this._defs._style);
        }
        setStyle(value) {
            const styles = Utils.copyObject(value);
            if (styles !== this._style) {
                this._style = styles;
                this._changed();
            }
        }
        /**
         * 0보다 큰 값으로 설정되면 행의 내용으로 높이를 계산하지 않고
         * 이 속성 값으로 행들의 높이가 동일하게 설정된다.
         * <br>
         * 이 속성이 설정되면 {@link minHeight}, {@link maxHeight}, {@link DListControl.rowCount}
         * 속성들은 무시된다.
         */
        height() {
            return pickNum(this._height, this._defs && this._defs._height);
        }
        setHeight(value) {
            if (value !== this._height) {
                this._height = value;
                this._changed();
            }
        }
        /**
         * 0보다 큰 값으로 설정되면 행의 최소 표시 높이가 된다.
         * <br>
         * {@link height}나, {@link DListControl.rowCount} 속성이 타당한 값으로 설정되면 이 속성 값은 무시된다.
         */
        minHeight() {
            return pickNum(this._minHeight, this._defs && this._defs._minHeight);
        }
        setMinHeight(value) {
            if (value !== this._minHeight) {
                this._minHeight = value;
                this._changed();
            }
        }
        /**
         * 0보다 큰 값으로 설정되면 행의 최대 표시 높이가 된다.
         * <br>
         * {@link height}나, {@link DListControl.rowCount} 속성이 타당한 값으로 설정되면 이 속성 값은 무시된다.
         * 또, {@link minHeight}가 이 속성보다 큰 값으로 설정되면 이 속성은 의미가 없다.
         */
        maxHeight() {
            return pickNum(this._maxHeight, this._defs && this._defs._maxHeight);
        }
        setRowHeight(value) {
            if (value !== this._maxHeight) {
                this._maxHeight = value;
                this._changed();
            }
        }
        /**
         * 데이터행을 tap했을 때 실행되는 {@link DListRowClickAction action}.
         */
        clickAction() {
            return pickProp(this._clickAction, this._defs && this._defs._clickAction);
        }
        setClickAction(value) {
            if (value !== this._clickAction) {
                this._clickAction = value;
                this._changed();
            }
        }
        /**
         * {@link concepts.data_grouping 데이터그룹핑} 상태일 때, 마스터 데이터행을 클릭하면 실행될 action.
         * 설정하지 않으면 {@link clickAction} 설정을 따른다.
         */
        masterClickAction() {
            return pickProp(this._masterClickAction, this._defs && this._defs._masterClickAction);
        }
        setMasterClickAction(value) {
            if (value !== this._masterClickAction) {
                this._masterClickAction = value;
                this._changed();
            }
        }
        /**
         * 데이터행을 길게 눌렀을(long press) 때 실행되는 {@link DListRowClickAction action}.
         */
        pressAction() {
            return pickProp(this._pressAction, this._defs && this._defs._pressAction);
        }
        setPressAction(value) {
            if (value !== this._pressAction) {
                this._pressAction = value;
                this._changed();
            }
        }
        /**
         * {@link concepts.data_grouping 데이터그룹핑} 상태일 때, 마스터 데이터행을 길게 눌렀을(long press) 때 실행되는 {@link DListRowClickAction action}.
         */
        masterPressAction() {
            return pickProp(this._masterPressAction, this._defs && this._defs._masterPressAction);
        }
        setMasterPressAction(value) {
            if (value !== this._masterPressAction) {
                this._masterPressAction = value;
                this._changed();
            }
        }
        /**
         * 데이터행을 좌우 혹은 상하(수평 모드)로 swipe할 때 실행될 {@link DListRowSwipeAction action}을 지정한다.
         * <br>
         * 단, {@link DListControl.onRowSwipe} 이벤트 핸들러에서 매개변수 객체의 cancel을 true로 지정하면
         * 이 속성 설정은 무시된다.
         * 이 속성은 무시된다.
         */
        swipeAction() {
            return pickProp(this._swipeAction, this._defs && this._defs._swipeAction);
        }
        setSwipeAction(value) {
            return this._swipeAction = value;
        }
        /** commands */
        commands() {
            const cmds = pickProp(this._commands, this._defs && this._defs._commands);
            return cmds ? cmds.slice(0) : void 0;
        }
        setCommands(value) {
            if (!Utils.equalArrays(value, this._commands)) {
                this._commands = value ? value.slice(0) : void 0;
                this._changed();
            }
        }
        /** link */
        link() {
            return this._link;
        }
        /** borderLine */
        borderLine() {
            return this._borderLine;
        }
        /** focusMask */
        focusMask() {
            return this._focusMask;
        }
        /** autoScroll */
        autoScroll() {
            return this._autoScroll;
        }
        /**
         * 사용자가 데이터행을 tap 해서 focused 상태로 지정할 수 있다.
         */
        focusable() {
            return pickProp(this._focusable, this._defs && this._defs._focusable);
        }
        setFocusable(value) {
            return this._focusable = value;
        }
        /**
         * 데이터행을 tap할 때 다른 배경색등으로 구분해서 표시한다.
         */
        touchEffect() {
            return pickProp(this._touchEffect, this._defs && this._defs._touchEffect);
        }
        setTouchEffect(value) {
            this._touchEffect = value;
        }
        deleteAnimation() {
            return pickProp(this._deleteAnimation, this._defs && this._defs._deleteAnimation);
        }
        setDeleteAnimation(value) {
            this._deleteAnimation = value;
        }
    }
    /**
     * @internal
     *
     * 레이아웃 템플릿으로 페이지가 구성되는 모델 기반 class.
     */
    class LayoutedPage extends DWrappableOptions {
        //-------------------------------------------------------------------------
        // IParamInflater
        //-------------------------------------------------------------------------
        inflateParam(target, field, param) {
            const params = this.templateParams2();
            if (params) {
                const p = param.name;
                const v = params[p];
                if (typeof v === 'function') {
                    return v({
                        context: this,
                        control: this.owner().wrapperOrThis(),
                        param: p
                    });
                }
                else if (v !== void 0) {
                    return v;
                }
            }
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * 기본값 대신 사용되는 페이지 레이아웃 템플릿 이름.
         */
        template() {
            return pickProp(this._template, this._defs && this._defs._template);
        }
        setTemplate(value) {
            this._template = value;
        }
        /**
         * template 속성으로 사용자 템플릿을 지정한 경우 param 계산 모델.
         */
        templateParams2() {
            return pickProp(this._templateParams, this._defs && this._defs._templateParams);
        }
        setTemplateParams2(value) {
            this._templateParams = value;
        }
    }
    class EmptyPage extends LayoutedPage {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        _doInitDefaults() {
        }
        //-------------------------------------------------------------------------
        // IParamInflater
        //-------------------------------------------------------------------------
        inflateParam(target, field, param) {
        }
        inflateStock(target, field, param) {
            switch (param.name) {
                case 'message_visible':
                    return this.messageVisible();
                case 'message':
                    return this.message();
                case 'load_visible':
                    return this.loadVisible();
                case 'load_label':
                    return this.loadLabel();
                case 'load_callback':
                    return () => this.onLoadClick();
            }
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /** message visible */
        messageVisible() {
            return pickProp(this._messageVisible, this._defs && this._defs._messageVisible);
        }
        setMessageVisible(value) {
            this._messageVisible = value;
        }
        /** message */
        message() {
            return pickProp(this._message, this._defs && this._defs._message);
        }
        setMessage(value) {
            if (value !== this._message) {
                this._message = value;
                this._changed();
            }
        }
        /** load visible */
        loadVisible() {
            return pickProp(this._loadVisible, this._defs && this._defs._loadVisible);
        }
        setLoadVisible(value) {
            this._loadVisible = value;
        }
        /** load label */
        loadLabel() {
            return pickProp(this._loadLabel, this._defs && this._defs._loadLabel);
        }
        setLoadLabel(value) {
            if (value !== this._loadLabel) {
                this._loadLabel = value;
                this._changed();
            }
        }
        /**
         * load button click callback.
         */
        onLoadClick() {
            return pickProp(this._onLoadClick, this._defs && this._defs._onLoadClick);
        }
        setOnLoadClick(value) {
            this._onLoadClick = value;
        }
    }
    class LoadingPage extends LayoutedPage {
        //-------------------------------------------------------------------------
        // property fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        _doInitDefaults() {
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        inflateStock(target, field, param) {
            return;
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    class ItemExpanderView extends SvgButton {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(doc) {
            super(doc, ItemExpanderView.CLASS_NAME);
            //-------------------------------------------------------------------------
            // fields
            //-------------------------------------------------------------------------
            this._expanded = true;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        reset(size, expanded) {
            this.setSize(size);
            if (expanded !== this._expanded) {
                this._expanded = expanded;
                this._svg.clear();
                this._svg.path(expanded ? ItemExpanderView.EXPANDED_PATH : ItemExpanderView.COLLAPSED_PATH);
            }
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doInitSvg(svg) {
            svg.setViewSize(512);
            svg.path(ItemExpanderView.EXPANDED_PATH); // right triangle
            svg.setStyle({
                fill: 'none',
                strokeWidth: 48,
                strokeLinecap: 'round',
                strokeLinejoin: 'round'
            });
            this.reset(18, true);
        }
        _doClick() {
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    ItemExpanderView.CLASS_NAME = 'dlist-item-expander';
    ItemExpanderView.EXPANDED_PATH = 'M 184 112 l 144 144 -144 144';
    ItemExpanderView.COLLAPSED_PATH = 'M 112 184 l 144 144 144 -144';
    /**
     * @internal
     *
     * ListControl view에 data 행 하나를 표시하는 구성 요소 view.
     */
    class ListItemView extends DListElement {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(doc) {
            super(doc, true, 'dlist-item-view');
            this._prevStyles = {};
            this._layoutChanged = false;
            this.indent = 0;
            this.bodyIndent = 0;
            this.bodyMargin = 0;
            this.detailed = false;
            this.alternate = false;
            this.checked = false;
            this.selected = false;
            this.searched = false;
        }
        layout() {
            return this._layout;
        }
        layoutView() {
            return this._layoutView;
        }
        isFixedHeight() {
            return false;
        }
        isFixedWidth() {
            return false;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        /**
         * @internal
         *
         * body view에서 호출한다.
         */
        setLayout(rowLayout) {
            // layout 객체 자체는 매번 새로 생성된다.
            // id는 템플릿 id이다.
            // param으로 설정된 속성들의 값이 매번 달라질 수 있다.
            const layout = rowLayout.layout;
            // main layout에는 extra가 설정될 수 있다.
            const extra = layout._extra;
            this._layoutChanged = !this._layout || (layout.tid !== this._layout.tid) ||
                (this._extra != extra) || (extra && extra.tid !== this._extra.tid);
            this._layout = layout;
            this._extra = extra;
            this._rowStyle = rowLayout.rowStyle;
            this._rowProps = rowLayout.rowProps;
        }
        simpleViewByModel(layout, deep) {
            return this._layoutView instanceof ListLayoutView && this._layoutView.simpleByModel(layout, deep) ||
                this._extraView instanceof ListLayoutView && this._extraView.simpleByModel(layout, deep);
        }
        simpleViewByDom(dom, deep) {
            return this._layoutView instanceof ListLayoutView && this._layoutView.simpleByDom(dom, deep) ||
                this._extraView instanceof ListLayoutView && this._extraView.simpleByDom(dom, deep);
        }
        simpleViewByTag(tag, deep) {
            return this._layoutView instanceof ListLayoutView && this._layoutView.simpleBy(tag, deep) ||
                this._extraView instanceof ListLayoutView && this._extraView.simpleBy(tag, deep);
        }
        fieldViewByField(fieldName, deep) {
            return this._layoutView instanceof ListLayoutView && this._layoutView.fieldBy(fieldName, deep) ||
                this._extraView instanceof ListLayoutView && this._extraView.fieldBy(fieldName, deep);
        }
        valueViewByTag(tag, deep) {
            const v = this._layoutView instanceof ListLayoutView && this._layoutView.simpleBy(tag, deep) ||
                this._extraView instanceof ListLayoutView && this._extraView.simpleBy(tag, deep);
            return v instanceof LayoutLiteralView ? v : undefined;
        }
        setTheme(theme) {
            Dom.setData(this.dom, 'theme', theme);
        }
        setItemData(name, value) {
            Dom.setData(this.dom, name, value);
        }
        // protected _createBack(doc: Document): HTMLElement {
        //     // item view의 padding이 rowCell, editCell 위치를 뭉개버리므로
        //     // row style들이 적용되는 레이어를 별도로 둔다.
        //     // 또, end border line을 content와 구분 시킬 수 있다.
        //     this._back = doc.createElement('div');
        //     this._back.className = this.dom.className;
        //     Object.assign(this._back.style, BACK_STYLE);
        //     return this._back;
        // }
        _getOverflow() {
            return 'hidden';
        }
        _getContentPosition() {
            return 'absolute';
        }
        _doPrepareExpander(doc) {
            const expander = this._getExpander();
            if (expander) {
                this._expanderPos = expander.pos;
                this._expanderSize = expander.size;
                if (!this._expander) {
                    this._expander = new ItemExpanderView(doc);
                    this.addChild(this._expander);
                }
                else {
                    this._expander.setVisible(true);
                }
            }
            else if (this._expander) {
                this._expander.setVisible(false);
            }
        }
        /**
         * @param owner 현재 {@link ListView}에서 구현.
         */
        _doPrepareRender(doc, owner) {
            const layout = this._layout;
            this._owner = owner;
            this._vertical = owner.isVertical(); // || owner.owner().isSingleRow();
            this._fullMode = owner.owner().fullMode();
            this.dom.dataset.dir = this._vertical ? 'v' : 'h';
            layout.setRow(this.dv(), this.row(), this.gindex());
            this._extra && this._extra.setRow(this.dv(), this.row(), this.gindex());
            this._doPrepareExpander(doc);
            if (this._layoutChanged && this._layoutView) {
                this.removeChild(this._layoutView);
                this._layoutView = null;
                if (this._extraView) {
                    this.removeChild(this._extraView);
                    this._extraView = null;
                }
            }
            if (!this._layoutView) {
                this.addChild(this._layoutView = owner.createLayoutView(doc, layout));
                this._layoutView.dom.style.overflow = 'hidden';
                this._layoutView.build(doc, owner);
                if (this._extra) {
                    this.addChild(this._extraView = owner.createLayoutView(doc, this._extra));
                    this._extraView.dom.style.overflow = 'hidden';
                    this._extraView.build(doc, owner);
                }
            }
            else {
                // child들의 layout 모델을 갱신한다.
                this._layoutView.refreshModels(layout); // as any는 억지다. _layoutView와 _layout의 종류가 일치한다고 가정한다.
                this._extraView && this._extraView.refreshModels(this._extra);
            }
            this._layoutView.prepareLayout(doc, this._owner);
            this._extraView && this._extraView.prepareLayout(doc, this._owner);
        }
        /**
         * NOTE: className은 classList에 추가된 순서가 아니라, css에 선언된 순서의 반대로 우선 적용된다!
         *       사용자가 주의해서 아래의 순서대로 css 파일을 작성햐야 한다.
         */
        _doApplyStyles(css) {
            function apply(v) {
                if (typeof (v) === 'string') {
                    dom.classList.add(v);
                }
                else {
                    Object.assign(st, v);
                }
            }
            function applyAll(st, rst) {
                Object.assign(st, rst.default);
                this.alternate && rst.alternate && apply(rst.alternate);
                if (this.rowState === DListDataRowState.UPDATED) {
                    rst.updated && apply(rst.updated);
                }
                else if (this.rowState === DListDataRowState.DELETED) {
                    rst.deleted && apply(rst.deleted);
                }
                this.checked && rst.checked && apply(rst.checked);
                this.selected && rst.selected && apply(rst.selected);
                this.searched && rst.searched && apply(rst.searched);
            }
            const dom = this.dom;
            css = dom.style;
            // 기존 스타일 설정을 제거한다.
            for (let p in this._prevStyles) {
                css[p] = '';
            }
            dom.className = this.getItemClass();
            const st = this._prevStyles = {};
            // control에 설정된 기본 row styles
            const sts = this.getItemStyle(this._owner);
            const rst = this._rowStyle;
            sts.itemDef && apply(sts.itemDef);
            sts.levelDef && apply(sts.levelDef);
            // row template에 설정된 row styles
            rst && applyAll.call(this, st, rst);
            // 동적 styles
            sts.dynamic && apply(sts.dynamic);
            // 모아진 스타일 속성들을 적용한다.
            for (let p in st) {
                if (!ListItemView.MANDATORY_STYLES.hasOwnProperty(p)) {
                    css[p] = st[p];
                }
            }
        }
        /**
         * template 및 동적으로 설정되는 rowStyle이 dom이 아니라 _back에 설정되므로,
         * padding도 _back에 설정된 값을 기준으로 한다.
         * 단, dlist-row, dlist-group-header, dlist-group-footer css가 반영되도록 한다.
         * content-view의 left, top을 css가 아니라 여기서 결정되는 것이 아쉽다.
         */
        _doMeasure(doc, hintWidth, hintHeight) {
            const lv = this._layoutView;
            const vertical = this._vertical;
            const wSave = hintWidth;
            const hSave = hintHeight;
            const p = this._padding = Dom.getPadding(this.dom); //back);
            const wPad = p.left + p.right;
            const hPad = p.top + p.bottom;
            hintWidth -= wPad;
            hintHeight -= hPad;
            this._szNear = this._doMeasureSide(DListControlBarPosition.NEAR, vertical, hintWidth, hintHeight);
            this._szFar = this._doMeasureSide(DListControlBarPosition.FAR, vertical, hintWidth, hintHeight);
            if (vertical) {
                hintWidth -= this.indent + this._szNear.width + this._szFar.width + this._owner.rightMargin;
                lv._explicitWidth = hintWidth;
                lv._explicitHeight = NaN;
                if (this.isFixedHeight()) {
                    lv._explicitHeight = hintHeight;
                }
            }
            else {
                hintHeight -= this._szNear.height + this._szFar.height;
                lv._explicitHeight = hintHeight;
                lv._explicitWidth = NaN;
                if (this.isFixedWidth()) {
                    lv._explicitWidth = hintWidth;
                }
            }
            // const sz = lv.measure(doc, this._owner, hintWidth, hintHeight);
            // lv.measureLayout(doc, this._owner, hintWidth, hintHeight, false);
            const sz = lv.measureLayout(doc, this._owner, hintWidth, hintHeight);
            if (vertical) {
                sz.height = Math.max(sz.height, this._szNear.height, this._szFar.height);
            }
            else {
                sz.width = Math.max(sz.width, this._szNear.width, this._szFar.width);
            }
            if (this._extraView) {
                const sz2 = this._extraView.measureLayout(doc, this._owner, hintWidth, hintHeight);
                sz.width = Math.max(sz.width, sz2.width);
                sz.height += sz2.height;
            }
            if (vertical) {
                sz.width = wSave;
                sz.height += hPad;
            }
            else {
                sz.width += wPad;
                sz.height = hSave;
            }
            return sz;
        }
        _doRender(doc, width, height) {
            const vLayout = this._layoutView;
            const vExtra = this._extraView;
            const p = this._padding;
            let x = this.indent;
            let y = 0;
            width -= this._owner.rightMargin + p.left + p.right;
            height -= p.top + p.bottom;
            // Dom.move(this['_content'], p.left, p.top);
            // this.resizeContent(width, height);
            this.setContentBounds(p.left, p.top, width, height);
            // item expander
            if (this._expander && this._expander.visible) {
                if (this._expanderPos === DListControlBarPosition.NEAR) {
                    this._expander.move(this.indent, 0);
                }
                else {
                    this._expander.move(width - this._expander.size() - 2, 0);
                }
            }
            if (this._vertical) {
                if (this._szNear.width > 0) {
                    this._doRenderNear(true, x, y, this._szNear.width, height);
                }
                if (this._szFar.width > 0) {
                    this._doRenderFar(true, width - this._szFar.width, y, this._szFar.width, height);
                }
                x += this._szNear.width;
                width -= this._szNear.width + this._szFar.width;
            }
            else {
                if (this._szNear.height > 0) {
                    this._doRenderNear(false, x, y, width, this._szNear.height);
                }
                if (this._szFar.height > 0) {
                    this._doRenderFar(false, x, height - this._szFar.height, width, this._szFar.height);
                }
                y += this._szNear.height;
                height -= this._szNear.height + this._szFar.height;
            }
            // height가 vLayout.mh와 다를 수 있다.
            let h = height;
            if (vExtra)
                h -= vExtra.mh;
            vLayout.resize(width, h).move(x, y); //vLayout.mh).move(x, y);
            vLayout.render(doc);
            if (vExtra) {
                vExtra.resize(width, vExtra.mh).move(x, y + vLayout.mh);
                vExtra.render(doc);
            }
        }
        _doAfterRender() {
            this._layoutChanged = false;
            this._owner = null;
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        _getExpander() {
            return;
        }
        _isExpanded() {
            return false;
        }
        _doMeasureSide(pos, vertical, hintWidth, hintHeight) {
            if (this._expander && this._expander.visible && (pos === this._expanderPos)) {
                this._expander.reset(this._expanderSize, this._isExpanded());
                return { width: this._expander.size() + 2, height: this._expander.size() + 2 };
            }
            return { width: 0, height: 0 };
        }
        _doRenderNear(vertical, x, y, width, height) { }
        _doRenderFar(vertical, x, y, width, height) { }
        // pool에서 가져올 때 호출된다.
        $_borrowed() {
            if (!this._fullMode) {
                // 이렇게 하지 않으면 기존 image가 잠시 보일 수 있다.
                // NOTE: 어쨋든 시간을 잡어먹는다. 개선 가능한 지 확인 필요.
                for (let i = 0; i < 20; i++) {
                    const elts = this.dom.getElementsByTagName('img');
                    for (let i = 0; i < elts.length; i++) {
                        elts[i].src = '';
                    }
                }
            }
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    ListItemView.MANDATORY_STYLES = {
        display: 'block',
        position: 'absolute',
        boxSizing: 'content-box' // 'border-box'
    };
    /**
     * @internal
     *
     * 데이터 행을 표시하는 item view.
     */
    class ListRowView extends ListItemView {
        //-------------------------------------------------------------------------
        // static members
        //-------------------------------------------------------------------------
        static isRowView(dom) {
            // return dom.firstElementChild && dom.firstElementChild.classList.contains(ListRowView.ROW_CLASS);
            return dom.classList.contains(ListRowView.ROW_CLASS);
        }
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        dv() {
            return this._dv;
        }
        row() {
            return this._row;
        }
        model() {
            return this._model;
        }
        group() {
            return this._model.group;
        }
        gindex() {
            return this._gindex;
        }
        vindex() {
            return isNaN(this._gindex) ? this._row : this._gindex;
        }
        get rowCell() {
            return this._rowCell;
        }
        get editCell() {
            return this._editCell;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        getItemClass() {
            return ListRowView.CLASS_NAME;
        }
        isRow(row) {
            return row === this._row;
        }
        setRow(dv, row, id, model) {
            this._dv = dv;
            this.dom[T_ROW] = this._row = row;
            this._rowid = id;
            this._last = dv.isLast(row);
            if (model) {
                this._model = model;
                this._groupLast = model.group.isLast(row);
                this._master = !model.isLeaf();
            }
            else {
                this._model = void 0;
                this._groupLast = this._master = false;
            }
            return this;
        }
        setTouched(touched) {
            Dom.setData(this.dom, 'touched', touched ? '1' : void 0);
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        getItemStyle(manager) {
            return manager.owner().getRowStyle(this._row);
        }
        _getExpander() {
            if (this._model instanceof DataGroupRow && !this._model.isLeaf()) {
                this.row();
                const e = this._owner.getExpander(this.row());
                if (e) {
                    const p = e.position();
                    const pos = p === DRowExpanderPosition.HEAD ? DListControlBarPosition.NEAR :
                        p === DRowExpanderPosition.FOOT ? DListControlBarPosition.FAR : undefined;
                    if (p) {
                        return { pos, size: 18 };
                    }
                }
            }
        }
        _isExpanded() {
            return this._model instanceof DataGroupRow && this._model.group.expanded();
        }
        _doPrepareRender(doc, owner) {
            super._doPrepareRender(doc, owner);
            const rowBar = owner.rowBar;
            const editBar = owner.editBar;
            const rowBorder = owner.borderLine;
            let rowCell = this._rowCell;
            let editCell = this._editCell;
            let line = this._line;
            let state;
            if (this.searched) {
                state = owner.isVertical() ? 'vs' : 'hs';
            }
            state && Dom.setData(this.dom, 'state', state);
            if (rowBar) {
                if (!rowCell) {
                    rowCell = this._rowCell = new RowBarCell(doc);
                }
                !rowCell.parent && this.addChild(rowCell);
            }
            else if (rowCell && rowCell.parent) {
                this.removeChild(rowCell);
            }
            if (editBar) {
                if (!editCell) {
                    editCell = this._editCell = new EditBarCell(doc);
                }
                !editCell.parent && this.addChild(editCell);
            }
            else if (editCell && editCell.parent) {
                this.removeChild(editCell);
            }
            if (rowBorder && owner.rowBorderVisible(this)) {
                if (!line) {
                    line = this._line = doc.createElement('span');
                    line.className = 'dlist-row-border';
                    Object.assign(line.style, ListRowView.LINE_STYLES);
                }
                const st = this._master ? owner.owner().rowBorder.masterStyle : owner.owner().rowBorder.style;
                Object.assign(line.style, {
                    // horz/vert 변경시 이전 너비나 높이가 유지되지 않도록...
                    width: '',
                    height: '',
                    borderBottom: this._vertical ? st : '',
                    borderRight: this._vertical ? '' : st
                });
                !line.parentElement && this.dom.appendChild(line);
            }
            else if (line && line.parentNode) {
                line.remove();
            }
        }
        _doMeasureSide(pos, vertical, hintWidth, hintHeight) {
            const rowBar = this._owner.rowBar;
            const editBar = this._owner.editBar;
            let { width, height } = super._doMeasureSide(pos, vertical, hintWidth, hintHeight);
            if (vertical) {
                if (rowBar && rowBar.position() === pos) {
                    const cell = this._rowCell;
                    const sz = cell.measure(rowBar, this._dv, this._row, hintWidth, hintHeight);
                    // const w2 = Utils.clamp(pickNum(rowBar.size(), sz.width), rowBar.minWidth(), rowBar.maxWidth());
                    const w2 = pickNum(rowBar.size(), sz.width);
                    cell.wCell = w2;
                    cell.wMeasure = Math.min(sz.width, w2);
                    width += w2 + rowBar.gapHorz();
                    height = sz.height;
                }
                if (editBar && editBar.position() === pos) {
                    const cell = this._editCell;
                    const sz = cell.measure(editBar, this._dv, this._row, hintWidth, hintHeight);
                    // const w2 = Utils.clamp(pickNum(editBar.size(), sz.width), editBar.minWidth(), editBar.maxWidth());
                    const w2 = pickNum(editBar.size(), sz.width);
                    cell.wCell = w2;
                    cell.wMeasure = Math.min(sz.width, w2);
                    width += w2 + editBar.gapHorz();
                    height = Math.max(height, sz.height);
                }
            }
            else {
                if (rowBar && rowBar.position() === pos) {
                    const cell = this._rowCell;
                    const sz = cell.measure(rowBar, this._dv, this._row, hintWidth, hintHeight);
                    // const w2 = Utils.clamp(pickNum(rowBar.size(), sz.width), rowBar.minWidth(), rowBar.maxWidth());
                    const h2 = pickNum(rowBar.size(), sz.height);
                    cell.hCell = h2;
                    cell.hMeasure = Math.min(sz.height, h2);
                    height += h2 + rowBar.gapVert();
                    width = sz.width;
                }
                if (editBar && editBar.position() === pos) {
                    const cell = this._editCell;
                    const sz = cell.measure(editBar, this._dv, this._row, hintWidth, hintHeight);
                    // const w2 = Utils.clamp(pickNum(editBar.size(), sz.width), editBar.minWidth(), editBar.maxWidth());
                    const h2 = pickNum(editBar.size(), sz.height);
                    cell.wCell = h2;
                    cell.wMeasure = Math.min(sz.height, h2);
                    height += h2 + editBar.gapVert();
                    width = Math.max(width, sz.width);
                }
            }
            return { width: width, height: height };
        }
        _doMeasure(doc, hintWidth, hintHeight) {
            const sz = super._doMeasure(doc, hintWidth, hintHeight);
            if (this._line && this._line.parentNode) {
                if (this._vertical) {
                    sz.height += this._szLine = this._line.offsetHeight;
                }
                else {
                    sz.width += this._szLine = this._line.offsetWidth;
                }
            }
            else {
                this._szLine = 0;
            }
            return sz;
        }
        _doRenderNear(vertical, x, y, width, height) {
            const owner = this._owner;
            const rowBar = owner.rowBar;
            const editBar = owner.editBar;
            if (vertical) {
                if (rowBar && rowBar.position() === DListControlBarPosition.NEAR) {
                    const cell = this._rowCell;
                    // x1 = x + rowBar.gapLeft() + (cell.wCell - cell.wMeasure) / 2 >> 0;
                    // cell.dom.style.height 가 '%'로 설정되어 있다.
                    if (cell.hRelative) {
                        cell.hMeasure = cell.dom.offsetHeight;
                    }
                    // y1 = y + (height - cell.hMeasure) / 2 >> 0;
                    // cell.resize(cell.wMeasure, cell.hMeasure);
                    // cell.move(Math.max(0, x1), Math.max(0, y1));
                    // cell.render(rowBar, cell.width, cell.height);
                    cell.resize(cell.wCell, height);
                    cell.move(x, 0);
                    cell.render(rowBar, cell.width, cell.height);
                    x += cell.wCell + rowBar.gapRight();
                }
                if (editBar && editBar.position() === DListControlBarPosition.NEAR) {
                    const cell = this._editCell;
                    // x1 = x + editBar.gapLeft() + (cell.wCell - cell.wMeasure) / 2 >> 0;
                    // cell.dom.style.height 가 '%'로 설정되어 있다.
                    if (cell.hRelative) {
                        cell.hMeasure = cell.dom.offsetHeight;
                    }
                    // cell.resize(cell.wMeasure, cell.hMeasure);
                    // cell.move(Math.max(0, x1), Math.max(0, y1));
                    // cell.render(editBar, cell.width, cell.height);
                    cell.resize(cell.wCell, height);
                    cell.move(x, 0);
                    cell.render(editBar, cell.width, cell.height);
                }
            }
            else {
                if (rowBar && rowBar.position() === DListControlBarPosition.NEAR) {
                    const cell = this._rowCell;
                    // y1 = y + rowBar.gapTop() + (cell.hCell - cell.hMeasure) / 2 >> 0;
                    // cell.dom.style.height 가 '%'로 설정되어 있다.
                    // if (cell.wRelative) {
                    //     cell.wMeasure = cell.dom.offsetHeight;
                    // } 
                    // x1 = x + (width - cell.wMeasure) / 2 >> 0;
                    // cell.resize(cell.wMeasure, cell.hMeasure);
                    // cell.move(Math.max(0, x1), Math.max(0, y1));
                    // cell.render(rowBar, cell.width, cell.height);
                    cell.resize(width, cell.wCell);
                    cell.move(0, y);
                    cell.render(rowBar, cell.width, cell.height);
                    y += cell.hCell + rowBar.gapBottom();
                }
                if (editBar && editBar.position() === DListControlBarPosition.NEAR) {
                    const cell = this._editCell;
                    // y1 = y + editBar.gapTop() + (cell.hCell - cell.hMeasure) / 2 >> 0;
                    // // cell.dom.style.height 가 '%'로 설정되어 있다.
                    // if (cell.hRelative) {
                    //     cell.hMeasure = cell.dom.offsetHeight;
                    // } 
                    // x1 = x + (width - cell.wMeasure) / 2 >> 0;
                    // cell.resize(cell.wMeasure, cell.hMeasure);
                    // cell.move(Math.max(0, x1), Math.max(0, y1));
                    // cell.render(editBar, cell.width, cell.height);
                    cell.resize(width, cell.wCell);
                    cell.move(0, y);
                    cell.render(editBar, cell.width, cell.height);
                }
            }
        }
        _doRenderFar(vertical, x, y, width, height) {
            const owner = this._owner;
            const rowBar = owner.rowBar;
            const editBar = owner.editBar;
            if (vertical) {
                if (editBar && editBar.position() === DListControlBarPosition.FAR) {
                    const cell = this._editCell;
                    x += editBar.gapRight();
                    // x1 = x + (cell.wCell - cell.wMeasure) / 2 >> 0;
                    // cell.dom.style.height 가 '%'로 설정되어 있다.
                    if (cell.hRelative) {
                        cell.hMeasure = cell.dom.offsetHeight;
                    }
                    // y1 = y + (height - cell.hMeasure) / 2 >> 0;
                    // cell.resize(cell.wMeasure, cell.hMeasure);
                    // cell.move(Math.max(x, x1), Math.max(0, y1));
                    // cell.render(editBar, cell.width, cell.height);
                    // x1 = x;
                    cell.resize(cell.wCell, height);
                    cell.move(x, 0);
                    cell.render(editBar, cell.width, cell.height);
                    x += cell.wCell + editBar.gapLeft();
                }
                if (rowBar && rowBar.position() === DListControlBarPosition.FAR) {
                    const cell = this._rowCell;
                    x += rowBar.gapRight();
                    // x1 = x + (cell.wCell - cell.wMeasure) / 2 >> 0;
                    // cell.dom.style.height 가 '%'로 설정되어 있다.
                    if (cell.hRelative) {
                        cell.hMeasure = cell.dom.offsetHeight;
                    }
                    // y1 = y + (height - cell.hMeasure) / 2 >> 0;
                    // cell.resize(cell.wMeasure, cell.hMeasure);
                    // cell.move(Math.max(x, x1), Math.max(0, y1));
                    // cell.render(rowBar, cell.width, cell.height);
                    // x1 = x;
                    cell.resize(cell.wCell, height);
                    cell.move(x, 0);
                    cell.render(rowBar, cell.width, cell.height);
                }
            }
            else {
                if (editBar && editBar.position() === DListControlBarPosition.FAR) {
                    const cell = this._editCell;
                    y += editBar.gapBottom();
                    // y1 = y + (cell.hCell - cell.hMeasure) / 2 >> 0;
                    // cell.dom.style.height 가 '%'로 설정되어 있다.
                    // if (cell.wRelative) {
                    //     cell.wMeasure = cell.dom.offsetWidth;
                    // } 
                    // x1 = x + (width - cell.wMeasure) / 2 >> 0;
                    // cell.resize(cell.wMeasure, cell.hMeasure);
                    // cell.move(Math.max(0, x1), Math.max(y, y1));
                    // cell.render(editBar, cell.width, cell.height);
                    cell.resize(width, cell.wCell);
                    cell.move(0, y);
                    cell.render(editBar, cell.width, cell.height);
                    y += cell.hCell + editBar.gapTop();
                }
                if (rowBar && rowBar.position() === DListControlBarPosition.FAR) {
                    const cell = this._rowCell;
                    y += rowBar.gapBottom();
                    // y1 = y + (cell.hCell - cell.hMeasure) / 2 >> 0;
                    // cell.dom.style.height 가 '%'로 설정되어 있다.
                    // if (cell.wRelative) {
                    //     cell.wMeasure = cell.dom.offsetWidth;
                    // } 
                    // x1 = x + (width - cell.wMeasure) / 2 >> 0;
                    // cell.resize(cell.wMeasure, cell.hMeasure);
                    // cell.move(Math.max(0, x1), Math.max(y, y1));
                    // cell.render(rowBar, cell.width, cell.height);
                    cell.resize(width, cell.wCell);
                    cell.move(0, y);
                    cell.render(rowBar, cell.width, cell.height);
                }
            }
        }
        getNearIndent(indent) {
            switch (indent) {
                case DListRowIndent.BAR:
                    return (this._szNear.width > 0 ? this._padding.left : 0) + this._szNear.width;
                case DListRowIndent.PADDING:
                    return this._padding.left;
            }
            return 0;
        }
        getFarIndent(indent) {
            switch (indent) {
                case DListRowIndent.BAR:
                    return (this._szFar.width > 0 ? this._padding.right : 0) + this._szFar.width;
                case DListRowIndent.PADDING:
                    return this._padding.right;
            }
            return 0;
        }
        _doRender(doc, width, height) {
            super._doRender(doc, width, height);
            // bottom border line
            if (this._line && this._line.parentNode) {
                const szLine = this._szLine;
                if (this._vertical) {
                    const x = this.getNearIndent(this._owner.borderLine.nearIndent());
                    width -= x + this.getFarIndent(this._owner.borderLine.farIndent());
                    Dom.setBounds(this._line, x, height - szLine, width, szLine);
                    // this._back.style.height = (height - szLine) + 'px';
                    // this._back.style.width = '100%';
                }
                else {
                    Dom.setBounds(this._line, width - szLine, 0, szLine, height);
                    // this._back.style.width = (width - szLine) + 'px';
                    // this._back.style.height = '100%';
                }
            }
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    ListRowView.ROW_CLASS = 'dlist-row';
    ListRowView.CLASS_NAME = 'dlist-item ' + ListRowView.ROW_CLASS;
    ListRowView.LINE_STYLES = {
        position: 'absolute',
        boxSizing: 'border-box',
        margin: '0',
        padding: '0'
    };

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * 패널 등에 표시되는 버튼 종류.
     * <br>
     *
     * @see {@link IListButton}
     * @see {@link DListFilterPanel}
     */
    var DListButtonType;
    (function (DListButtonType) {
        /**
         * 이 버튼을 누르면 작업을 완료하고 패널이나 창을 닫는다.
         */
        DListButtonType["SUBMIT"] = "submit";
        /**
         * 이 버튼을 누르면 작업을 취소하고 패널이나 창을 닫는다.
         */
        DListButtonType["CANCEL"] = "cancel";
    })(DListButtonType || (DListButtonType = {}));
    /**
     * @internal
     */
    class ListButton extends DObject {
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(config) {
            super();
            /** visible */
            this.visible = true;
            this._setDefaults();
            if (typeof config === 'string') {
                this.name = config;
            }
            else if (config) {
                Object.assign(this, config);
            }
        }
        /** style */
        get style() {
            return this._style && Object.assign({}, this._style);
        }
        set style(value) {
            this._style = value && Object.assign({}, value);
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        isEnabled(control) {
            if (typeof this.enabled === 'function') {
                return this.enabled({ control, button: this.getProxy() });
            }
            else {
                return this.enabled;
            }
        }
        getStyle() {
            return this._style;
        }
        update(config) {
            if (config) {
                Object.assign(this, config);
            }
        }
        click(owner) {
            var _a;
            (_a = this.onClick) === null || _a === void 0 ? void 0 : _a.call(this, { control: owner.wrapperOrThis(), button: this.getProxy() });
        }
        getProxy() {
            return {
                name: this.name,
                label: this.label,
                state: this.state
            };
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        _setDefaults() {
            this.enabled = true;
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * 컨트롤에 사용되는 패널들의 표시 위치.
     * <br>
     * {@link DListPanel.position} 속성으로 사용된다.
     *
     * @see DListSearchPanel
     * @see DListFilterPanel
     * @see DListButtonPanel
     * @see DListFormPanel
     */
    var DListPanelPosition;
    (function (DListPanelPosition) {
        /**
         * 컨트롤이 패널 성격에 맞게 알아서 표시한다.
         */
        DListPanelPosition["AUTO"] = "auto";
        // /**
        //  * 리스트 헤더와 가까운 쪽에 표시한다.
        //  */
        // NEAR = 'near',
        // /**
        //  * 리스트 헤더와 먼 쪽에 표시한다.
        //  */
        // FAR = 'far',
        /**
         * 상단 헤더 아래 표시한다.
         */
        DListPanelPosition["TOP"] = "top";
        /**
         * 하단에 표시한다.
         */
        DListPanelPosition["BOTTOM"] = "bottom";
        /**
         * 왼쪽에 붙여 표시한다.
         */
        DListPanelPosition["LEFT"] = "left";
        /**
         * 오른쪽에 붙여 표시한다.
         */
        DListPanelPosition["RIGHT"] = "right";
        /**
         * 중앙에 표시한다.
         */
        DListPanelPosition["CENTER"] = "center";
    })(DListPanelPosition || (DListPanelPosition = {}));
    /**
     * @noimpl
     *
     * 리스트 패널을 드러내는 방식.
     * <br>
     * {@link DListPanel.showMode} 속성으로 사용된다.
     *
     * @see concepts.button_panel 버튼 패널
     * @see concepts.search_panel 검색 패널
     */
    var DListPanelShowMode;
    (function (DListPanelShowMode) {
        /**
         * 리스트 본체 위에 겹쳐 표시한다.
         */
        DListPanelShowMode["POPUP"] = "popup";
        /**
         * 리스트 본체를 패넡 크기만큼 밀어내고 표시한다.
         */
        DListPanelShowMode["PUSH"] = "push";
    })(DListPanelShowMode || (DListPanelShowMode = {}));
    /**
     * @internal
     *
     * List panel base.
     */
    class ListPanel extends DControlObject {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(owner, defaults) {
            super(owner);
            if (!(this._defs = defaults)) {
                this._doInitDefaults();
            }
        }
        _doInitDefaults() {
            this._position = DListPanelPosition.AUTO;
            this._showMode = DListPanelShowMode.POPUP;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        owner() {
            return this.control();
        }
        isFullWidth() {
            const p = this.getPosition();
            return p === DListPanelPosition.TOP || p === DListPanelPosition.BOTTOM;
        }
        isFullHeight() {
            const p = this.getPosition();
            return p === DListPanelPosition.LEFT || p === DListPanelPosition.RIGHT;
        }
        /**
         * Panel 표시 위치.
         */
        position() {
            return pickProp(this._position, this._defs && this._defs._position);
        }
        setPosition(value) {
            this._position = value;
        }
        /**
         * Panel을 드러내는 방식.
         */
        showMode() {
            return pickProp(this._showMode, this._defs && this._defs._showMode);
        }
        setShowMode(value) {
            this._showMode = value;
        }
        /**
         * 이 속성을 NaN이 아닌 값으로 지정하면 내용과 상관없이 이 속성 값으로 panel의 높이나 너비가 결정된다.
         * 단, {@link minSize}와 {@link maxSize} 사이의 값으로 조정된다.
         */
        size() {
            return pickProp(this._size, this._defs && this._defs._size);
        }
        setSize(value) {
            if (value !== this._size) {
                this._size = value;
                this._szSize = parsePercentSize(value, false);
            }
        }
        /**
         * 최소 크기.
         * NaN이 아닌 값으로 지정되면 내용이나 size, maxSize 값과 관계없이
         * 항상 이 속성값 이상의 크기로 표시된다.
         */
        minSize() {
            return pickProp(this._minSize, this._defs && this._defs._minSize);
        }
        setMinSize(value) {
            if (value !== this._minSize) {
                this._minSize = value;
                this._szMin = parsePercentSize(value, false);
            }
        }
        /**
         * 최대 크기.
         * NaN이 아닌 값으로 지정되면 내용이나 size 값과 관계없이
         * 항상 이 속성값 이하의 크기로 표시된다.
         */
        maxSize() {
            return pickProp(this._maxSize, this._defs && this._defs._maxSize);
        }
        setMaxSize(value) {
            if (value !== this._maxSize) {
                this._maxSize = value;
                this._szMax = parsePercentSize(value, false);
            }
        }
        /**
         * 스타일셋 혹은 className
         */
        style() {
            return pickProp(this._style, this._defs && this._defs._style);
        }
        setStyle(value) {
            this._style = value;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        getPosition() {
            let pos = this.position();
            if (!pos || pos === DListPanelPosition.AUTO) {
                pos = this._getAutoPosition();
            }
            return pos;
        }
        getSize(hint, size) {
            const szSize = this._szSize || (this._defs && this._defs._szSize);
            const szMin = this._szMin || (this._defs && this._defs._szMin);
            const szMax = this._szMax || (this._defs && this._defs._szMax);
            let sz = calcPercent(szSize, hint);
            const min = calcPercent(szMin, hint);
            const max = calcPercent(szMax, hint);
            if (!isNaN(sz)) {
                return Utils.clamp(sz, min, max);
            }
            else if (!isNaN(size)) {
                return Utils.clamp(size, min, max);
            }
            else {
                return min;
            }
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        _getAutoPosition() {
            return DListPanelPosition.TOP;
        }
    }
    class ButtonPanelBase extends ListPanel {
        constructor() {
            super(...arguments);
            this._buttonGap = 16;
        }
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * buttons.
         */
        buttons() {
            return pickProp(this._buttons, this._defs && this._defs._buttons);
        }
        setButtons(value) {
            if (value !== this._buttons) {
                this._buttons = value;
                this._buttonImpls = [];
                if (value) {
                    value.forEach(a => this._buttonImpls.push(new ListButton(a)));
                }
                this._changed();
            }
        }
        buttonGap() {
            return pickProp(this._buttonGap, this._defs && this._defs._buttonGap);
        }
        setButtonGap(value) {
            value = Utils.toNumber(value, 0);
            if (value !== this._buttonGap) {
                this._buttonGap = value;
                this._changed();
            }
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        getButtons() {
            return this._buttonImpls !== void 0 ? this._buttonImpls : (this._defs && this._defs._buttonImpls);
        }
        getButton(name) {
            return this.getButtons().find(b => b.name === name);
        }
    }
    var DListPanelButtonPosition;
    (function (DListPanelButtonPosition) {
        DListPanelButtonPosition["AUTO"] = "auto";
        DListPanelButtonPosition["HIDDEN"] = "hidden";
        DListPanelButtonPosition["BOTTOM"] = "bottom";
        DListPanelButtonPosition["LEFT"] = "left";
        DListPanelButtonPosition["RIGHT"] = "right";
    })(DListPanelButtonPosition || (DListPanelButtonPosition = {}));
    /**
     * @internal
     *
     * content 영역과 버튼 영역으로 구분되는 panel.
     * 버튼 영역에는 기본적으로 입력을 승인하는 것과 취소 하는 기능의 두 버튼이 표시된다.
     */
    class DialogPanel extends ButtonPanelBase {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        _doInitDefaults() {
            super._doInitDefaults();
            this._buttonPosition = DListPanelButtonPosition.AUTO;
            this._cancelLabel = 'Cancel';
            this._okLabel = 'OK';
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * 버튼들 표시 위치.
         */
        buttonPosition() {
            return pickProp(this._buttonPosition, this._defs && this._defs._buttonPosition);
        }
        setButtonPosition(value) {
            this._buttonPosition = value;
        }
        /**
         * cancel label.
         */
        cancelLabel() {
            return pickProp(this._cancelLabel, this._defs && this._defs._cancelLabel);
        }
        setCancelLabel(value) {
            this._cancelLabel = value;
        }
        /**
         * ok label
         */
        okLabel() {
            return pickProp(this._okLabel, this._defs && this._defs._okLabel);
        }
        setOkLabel(value) {
            this._okLabel = value;
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        getButtons() {
            let btns = super.getButtons();
            if (!btns || btns.length < 1) {
                btns = this._defButtons;
                if (!btns) {
                    btns = this._defButtons = [{
                            name: DialogPanel.OK,
                            type: DListButtonType.SUBMIT,
                            label: this.okLabel()
                        }, {
                            name: DialogPanel.CANCEL,
                            type: DListButtonType.CANCEL,
                            label: this.cancelLabel()
                        }].map(b => new ListButton(b));
                }
                else {
                    btns[0].label = this.okLabel();
                    btns[1].label = this.cancelLabel();
                }
            }
            return btns;
        }
        okButton() {
            return this.getButton(DialogPanel.OK);
        }
        cancelButton() {
            return this.getButton(DialogPanel.CANCEL);
        }
    }
    //-------------------------------------------------------------------------
    // static members
    //-------------------------------------------------------------------------
    DialogPanel.OK = 'ok';
    DialogPanel.CANCEL = 'cancel';

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * {@link DListButtonPanel 버튼 패널}에 버튼을 배치하는 방식.
     * <br>
     * {@link DListButtonPanel.display} 속성으로 지정한다.
     *
     * ```
     *  list.setConfig({
     *      options: {
     *          buttonPanel: {
     *              postion: 'right',
     *              display: 'auto',
     *              buttons: [...],
     *          }
     *      }
     *  });
     * ```
     *
     * @see concepts.button_panel 버튼 패널 개요
     * @see DListButtonPanel
     */
    var DListButtonArrange;
    (function (DListButtonArrange) {
        /**
         * 패널 상태에 맞춰 자동 배치한다.
         * <br>
         *
         * 기기가 **portrait** 상태이고 패널 {@link DListPanel.position position}이
         * {@link DListPanelPosition.LEFT}이나
         * {@link DListPanelPosition.RIGHT}이면 {@link VERTICAL}로 배치한다.
         * 아니면 {@link DEFAULT}로 배치한다.
         */
        DListButtonArrange["AUTO"] = "auto";
        /**
         * 버튼들을 수평 중앙에 배치한다.
         * <br>
         */
        DListButtonArrange["DEFAULT"] = "default";
        /**
         * 버튼들을 수직으로 배치한다.
         * <br>
         */
        DListButtonArrange["VERTICAL"] = "vertical";
    })(DListButtonArrange || (DListButtonArrange = {}));
    /**
     * @internal
     *
     * Button panel.
     */
    class ButtonPanel extends ButtonPanelBase {
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(owner, defaults) {
            super(owner, defaults);
        }
        _doInitDefaults() {
            super._doInitDefaults();
            this._arrange = DListButtonArrange.AUTO;
            this.setMinSize(ButtonPanel.MIN_SIZE);
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * panel 항목 배치 방식.
         * <br>
         *
         * @default DListButtonArrange.AUTO
         */
        arrange() {
            return pickProp(this._arrange, this._defs && this._defs._arrange);
        }
        setArrange(value) {
            this._arrange = value;
        }
        /**
         * 버튼들 위치.
         * <br>
         */
        align() {
            return pickProp(this._align, this._defs && this._defs._align);
        }
        setAlign(value) {
            this._align = value;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        getDisplay(landscape) {
            const d = this.arrange() || DListButtonArrange.AUTO;
            const p = this.getPosition();
            switch (d) {
                case DListButtonArrange.AUTO:
                    if (landscape) {
                        return DListButtonArrange.DEFAULT;
                    }
                    else {
                        if (p === DListPanelPosition.LEFT || p === DListPanelPosition.RIGHT) {
                            return DListButtonArrange.VERTICAL;
                        }
                        else {
                            return DListButtonArrange.DEFAULT;
                        }
                    }
                default:
                    return d;
            }
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    // panel type
    ButtonPanel.TYPE = 'button';
    // defaults
    ButtonPanel.MIN_SIZE = 30;

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     *
     * Form panel.
     * form layout + buttons
     */
    class FormPanel extends DialogPanel {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(owner, defaults) {
            super(owner, defaults);
        }
        _doInitDefaults() {
            super._doInitDefaults();
            this.setMinSize(FormPanel.MIN_SIZE);
        }
        //-------------------------------------------------------------------------
        // IParamInflater
        //-------------------------------------------------------------------------
        inflateParam(target, field, param) {
            return;
        }
        inflateStock(target, field, param) {
            return;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * Layout template.
         */
        template() {
            return pickProp(this._template, this._defs && this._defs._template);
        }
        setTemplate(value) {
            this._template = value;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        getTemplate() {
            return this.owner().getTemplate(this._actionTemplate || this.template());
        }
        getLayout() {
            const t = this.getTemplate();
            this._actionTemplate = null;
            return LayoutFactory.Instance.layoutFromTemplate(this.wrapperOrThis(), this, false, false, t, this);
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doPrepareRender() {
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        _setActionTemplate(template) {
            this._actionTemplate = template;
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    // panel type
    FormPanel.TYPE = 'form';
    // defaults
    FormPanel.MIN_SIZE = 20;

    ////////////////////////////////////////////////////////////////////////////////
    var DListSearchPanelDisplay;
    (function (DListSearchPanelDisplay) {
        DListSearchPanelDisplay["AUTO"] = "auto";
        DListSearchPanelDisplay["DEFAULT"] = "default";
        DListSearchPanelDisplay["LONG"] = "long";
        DListSearchPanelDisplay["VERTICAL"] = "vertical";
    })(DListSearchPanelDisplay || (DListSearchPanelDisplay = {}));
    /**
     * @internal
     *
     * Search panel.
     */
    class SearchPanel extends DialogPanel {
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        _doInitDefaults() {
            super._doInitDefaults();
            this._display = DListSearchPanelDisplay.AUTO;
            this._matchCaseLabel = '대소문자 구분'; // 'Match Case';
            this._wholeWordLabel = '전체 단어 일치'; // 'Match Whole Word';
            this._regExpLabel = '정규식 사용'; // 'Use Regular Expression';
            this._searchNextLabel = '다음 찾기'; // 'Search Next'
            this._searchAllLabel = '모두 찾기'; // 'Search All'
            this._lineGap = 12;
            this.setOkLabel('검 색');
            this.setCancelLabel('취 소');
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * panel 항목 배치 방식.
         */
        display() {
            return pickProp(this._display, this._defs && this._defs._display);
        }
        setDisplay(value) {
            this._display = value;
        }
        /** matchCaseLabel */
        matchCaseLabel() {
            return pickProp(this._matchCaseLabel, this._defs && this._defs._matchCaseLabel);
        }
        setMatchCaseLabel(value) {
            this._matchCaseLabel = value;
        }
        /** wholeLabel */
        wholeWordLabel() {
            return pickProp(this._wholeWordLabel, this._defs && this._defs._wholeWordLabel);
        }
        setWholeWordLabel(value) {
            this._wholeWordLabel = value;
        }
        /** regExpLabel */
        regExpLabel() {
            return pickProp(this._regExpLabel, this._defs && this._defs._regExpLabel);
        }
        setRegExpLabel(value) {
            this._regExpLabel = value;
        }
        /** searchNextLabel */
        searchNextLabel() {
            return pickProp(this._searchNextLabel, this._defs && this._defs._searchNextLabel);
        }
        setSearchNextLabel(value) {
            this._searchNextLabel = value;
        }
        /** searchAllLabel */
        searchAllLabel() {
            return pickProp(this._searchAllLabel, this._defs && this._defs._searchAllLabel);
        }
        setSearchAllLabel(value) {
            this._searchAllLabel = value;
        }
        /** line gap */
        lineGap() {
            return pickProp(this._lineGap, this._defs && this._defs._lineGap);
        }
        setLineGap(value) {
            this._lineGap = toNumProp(value, void 0);
        }
        /**
         * '모두 검색' 설정일 때 결과 view가 표시되는 데, 검색 결과가 0건이어도 표시한다.
         *
         * @default false
         */
        alwaysResult() {
            return pickProp(this._alwaysResult, this._defs && this._defs._alwaysResult);
        }
        setAlwaysResult(value) {
            this._alwaysResult = value;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        getDisplay(landscape) {
            const d = this.display() || DListSearchPanelDisplay.AUTO;
            const p = this.getPosition();
            switch (d) {
                case DListSearchPanelDisplay.AUTO:
                    if (landscape) {
                        return DListSearchPanelDisplay.LONG;
                    }
                    else {
                        if (p === DListPanelPosition.LEFT || p === DListPanelPosition.RIGHT) {
                            return DListSearchPanelDisplay.VERTICAL;
                        }
                        else {
                            return DListSearchPanelDisplay.DEFAULT;
                        }
                    }
                default:
                    return d;
            }
        }
        search(key, options) {
            this.owner().search(options, key);
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    // panel type
    SearchPanel.TYPE = 'search';

    ////////////////////////////////////////////////////////////////////////////////
    const valueToType = {
        'string': DListDataType.TEXT,
        'number': DListDataType.NUMBER,
        'boolean': DListDataType.BOOL,
        'bigint': DListDataType.BIGINT,
    };
    function checkFields(dv, names) {
        const flds = [];
        for (let name of names) {
            const fld = dv.fieldByName(name);
            if (!fld)
                DListDataError.throwFormat(dv.wrapperOrThis(), locale.notExistsDataField, name);
            flds.push(fld);
        }
        return flds;
    }
    /**
     * {@link DListData.loadData} 호출로 읽어 들이는 원본 값 묶음의 형식.
     * <br>
     */
    var DListDataValueSourceType;
    (function (DListDataValueSourceType) {
        /**
         * json 객체들이 포함된 배열.
         * <br>
         */
        DListDataValueSourceType["JSON"] = "json";
        /**
         * 필드별로 모든 행의 값이 배열로 포함.
         * <br>
         * { field1: [...], field2: [...], ...} 형태로 저장된다.
         */
        DListDataValueSourceType["FIELD"] = "field";
        /**
         * comma로 분리된 line들이 '\r\n'이나 '\n'으로 연결된 텍스트
         * <br>
         */
        DListDataValueSourceType["CSV"] = "csv";
        /**
         * tab으로 분리된 line들이 '\r\n'이나 '\n'으로 연결된 텍스트
         * <br>
         */
        DListDataValueSourceType["TSV"] = "tsv";
    })(DListDataValueSourceType || (DListDataValueSourceType = {}));
    function _getSummary(field, rows, start, end) {
        const s = {
            count: 0,
            sum: 0,
            min: NaN,
            max: NaN,
            avg: NaN,
            std: NaN,
            stdp: NaN,
            var: NaN,
            varp: NaN,
            ncount: 0,
            nmin: NaN,
            nmax: NaN,
            navg: NaN,
            nstd: NaN,
            nstdp: NaN,
            nvar: NaN,
            nvarp: NaN,
        };
        if (isNaN(start)) {
            start = 0;
        }
        else {
            start = Math.max(0, start);
        }
        if (isNaN(end)) {
            end = rows.length;
        }
        else {
            end = Math.min(rows.length, end) + 1;
        }
        const count = s.count = end - start;
        if (s.count < 1)
            return s;
        const f = field.name;
        let n = 0;
        let sum = 0;
        let min = NaN;
        let max = NaN;
        let i = start;
        while (i < end) {
            const v = rows[i++].values[f];
            if (!isNaN(v)) {
                n++;
                sum = min = max = v;
                break;
            }
        }
        while (i < end) {
            const v = rows[i++].values[f];
            if (!isNaN(v)) {
                n++;
                sum += v;
                if (v < min)
                    min = v;
                if (v > max)
                    max = v;
            }
        }
        if (n > 0) {
            s.sum = sum;
            s.min = min;
            s.max = max;
            s.avg = sum / count;
            s.ncount = n;
            s.navg = sum / n;
            const avg = s.avg;
            const navg = s.navg;
            let vars = 0;
            let nvars = 0;
            let i = start;
            while (i < end) {
                const v = rows[i++].values[f];
                if (!isNaN(v)) {
                    vars += Math.pow(v - avg, 2);
                    nvars += Math.pow(v - navg, 2);
                }
            }
            s.varp = vars / count;
            s.var = vars / (count - 1);
            s.stdp = Math.sqrt(s.varp);
            s.std = Math.sqrt(s.var);
            s.nvarp = nvars / n;
            s.nvar = nvars / (n - 1);
            s.nstdp = Math.sqrt(s.nvarp);
            s.nstd = Math.sqrt(s.nvar);
        }
        return s;
    }
    const SV_LINES = 'sv:lines';
    /**
     * @internal
     *
     * ListControl data model.
     */
    class ListData extends ListDataOjbject {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        /**
         * options에 fields 정보를 지정하지 않고, data가 지정되면 첫 번째 row의 값들을 기준으로 필드들을 자동 생성한다.
         *
         * @param options 필드 설정 정보 등.
         * @param data field 자료형에 맞게 변환해서 저장한다. 배열이 아닌 값이면 한 행 추가된다.
         */
        constructor(name, options, source, wrapper) {
            super(name);
            this._readOnly = false;
            this._softDeleting = false;
            this._restorable = false; // 수정 시 기존 값들 저장, 이 후 복원.
            // wrapper
            this._wrapper = wrapper;
            // args
            Object.freeze(this._args = { data: this });
            // options
            if (typeof options === 'string') {
                options = { name: options };
            }
            else {
                options = options || {};
            }
            this._title = options.title;
            this._readOnly = !!options.readOnly;
            this._restorable = !!options.restorable;
            this._softDeleting = !!options.softDeleting;
            this._validator = Utils.asFunction(options.validator);
            // fields
            this._fields = this.$_buildFields(options, source); // 실행 중에 SV_LINES를 만들어낼 수 있다.
            if (!Array.isArray(this._fields) || this._fields.length === 0) {
                DListDataError.throw(this.wrapperOrThis(), locale.notSpecifiedDataField);
            }
            this._derivedFields = this.$_buildDerivedFields(options.derivedFields);
            // maps
            this._fieldNames = this._fields.map(f => f.name).concat(this._derivedFields.map(f => f.name));
            this._fieldMap = {};
            for (let f of this._fields) {
                this._fieldMap[f.name] = f;
            }
            this._derivedMap = {};
            for (let f of this._derivedFields) {
                this._fieldMap[f.name] = f;
                this._derivedMap[f.name] = f;
            }
            // data
            this.$_loadRows(source);
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        wrapper() {
            return this._wrapper;
        }
        wrapperOrThis() {
            return this._wrapper || this;
        }
        title() {
            return this._title;
        }
        readOnly() {
            return this._readOnly;
        }
        softDeleting() {
            return this._softDeleting;
        }
        restorable() {
            return this._restorable;
        }
        validator() {
            return this._validator;
        }
        /**
         * field count.
         */
        fieldCount() {
            return this._fields.length;
        }
        /**
         * row count.
         */
        rowCount() {
            return this._rows.length;
        }
        setRowCount(value) {
            function changeRowCount(rows, count, oldCount) {
                rows.length = count;
                if (count > oldCount) {
                    for (let i = oldCount; i < count; i++) {
                        rows[i] = void 0;
                    }
                }
            }
            if (!isNaN(value) && value !== this._rows.length) {
                const w = this.wrapperOrThis();
                const oldCount = this._rows.length;
                changeRowCount(this._rows, value, oldCount);
                this.onRowCountChange && this.onRowCountChange({ data: w, newCount: value, oldCount });
                this.$_triggerDataChange(w);
            }
        }
        visRowCount() {
            return this._rows.length;
        }
        /**
         * 필드 배열 복사본.
         */
        fields() {
            return this._fields.slice(0);
        }
        derivedFields() {
            return this._derivedFields.slice(0);
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        source() {
            return this;
        }
        canSort() {
            return false;
        }
        canMove() {
            return false;
        }
        getRowId(row) {
            return this._rows[row].id;
        }
        levelRowOfRow(row) {
            return row;
        }
        getDataRow(row) {
            return this._rows[row];
        }
        // O(n)
        rowOfDataRow(dataRow) {
            return this._rows.indexOf(dataRow);
        }
        isLast(row) {
            return row === this._rows.length - 1;
        }
        isMaster(row) {
            return false;
        }
        containsField(field) {
            return field in this._fieldMap;
        }
        getField(index) {
            if (index < 0 || index >= this._fields.length) {
                DListDataError.throwFormat(this.wrapperOrThis(), locale.invalidFieldIndex, index);
            }
            return this._fields[index];
        }
        fieldByName(name) {
            return this._fieldMap[name];
        }
        getFieldNames() {
            return this._fieldNames.slice(0);
        }
        isSortable(field) {
            const f = this._fieldMap[field];
            return f && f.sortable;
        }
        setSortable(fields, sortable) {
            if (Array.isArray(fields)) {
                for (const fld of fields) {
                    const f = this._fieldMap[fld];
                    f && (f.sortable = sortable);
                }
            }
            else {
                const f = this._fieldMap[fields];
                f && (f.sortable = sortable);
            }
        }
        isEmpty(row) {
            return !this._rows[row];
        }
        getRowValues(row) {
            ListDataOjbject.checkRow(this, row);
            return Object.assign({}, this._rows[row].values);
        }
        internalRowValues(row) {
            return Object.assign({}, this._rows[row].values);
        }
        /**
         * 한 행의 필드 값을 가져온다.
         * row가 범위를 벗어나거나 field가 존재하지 않는 필드명이면 예외가 발생한다.
         * @example
         * const v = data.getValue(3, 'address');
         *
         * @param row 행 번호.
         * @param field 필드 명.
         * @param fieldCheck false면 필드명 존재 여부를 검사하지 않는다. 지정하지 않으면 true.
         * @returns 필드 값.
         */
        getValue(row, field, fieldCheck) {
            ListDataOjbject.checkRow(this, row);
            fieldCheck && this.checkField(field);
            const drow = this._rows[row];
            return drow ? drow.values[field] : void 0;
        }
        getProp(row, field, prop, fieldCheck) {
            ListDataOjbject.checkRow(this, row);
            fieldCheck && this.checkField(field);
            return this._rows[row].getProp(field, prop);
        }
        getValueAt(row, fieldIndex) {
            ListDataOjbject.checkRow(this, row);
            if (fieldIndex < 0 || fieldIndex >= this._fields.length) {
                DListDataError.throwFormat(this.wrapperOrThis(), locale.invalidFieldIndex, fieldIndex);
            }
            const drow = this._rows[row];
            return drow ? drow.values[this._fields[fieldIndex].name] : void 0;
        }
        getValues(row, fields, fieldCheck) {
            if (Array.isArray(fields)) {
                ListDataOjbject.checkRow(this, row);
                const ret = {};
                const drow = this._rows[row];
                if (drow) {
                    const vals = drow.values;
                    fields.forEach(f => {
                        fieldCheck && this.checkField(f);
                        ret[f] = vals[f];
                    });
                }
                return ret;
            }
            else {
                return this.getRowValues(row);
            }
        }
        getFieldValues(field, from, to) {
            this.checkField(field);
            const rows = this._rows;
            if (isNaN(from)) {
                from = 0;
            }
            else {
                this.$_checkRow(from, false);
            }
            if (isNaN(to) || to < 0) {
                to = rows.length;
            }
            else {
                this.$_checkRow(to, true);
            }
            const vals = [];
            while (from < to) {
                const drow = rows[from++];
                drow && vals.push(drow.values[field]);
            }
            return vals;
        }
        $_loadRows(source) {
            if (source) {
                this._rows = this.$_buildRows(source);
                this.$_resetIndices(0);
            }
            else {
                this._rows = [];
            }
        }
        loadData(source) {
            const w = this.wrapperOrThis();
            const oldCount = this._rows.length;
            this.$_loadRows(source);
            const newCount = this._rows.length;
            this._fireEvent('onDataLoaded', oldCount);
            if (newCount !== oldCount) {
                this._fireEvent('onDataCountChanged', newCount, oldCount);
                this._fireEvent('onDataChanged');
                this.onRowCountChange && this.onRowCountChange({ data: w, newCount: newCount, oldCount });
                this.$_triggerDataChange(w);
            }
            else if (newCount > 0) {
                this._fireEvent('onDataChanged');
                this.$_triggerDataChange(w);
            }
            return this;
        }
        /**
         * 지정한 행과 필드의 값을 지정한 값으로 변경한다.
         * 지정한 행 위치가 범위를 벗어나거나, 존재하지 않는 필드명이면 예외가 발생된다.
         * 실제로 변경되면 true를 리턴한다.
         *
         * @param row
         * @param field
         * @param value
         * @returns
         */
        updateValue(row, field, value) {
            this.$_checkReadOnly();
            this.$_checkRow(row, false);
            this.checkField(field);
            const fldMap = this._fieldMap;
            let drow = this._rows[row];
            if (!drow) {
                drow = this._rows[row] = DataRow.createRow2(this._fieldMap, this._derivedMap, void 0);
            }
            const vals = drow.values;
            const old = vals[field];
            if (value !== old) {
                const w = this.wrapperOrThis();
                this.$_validate(fldMap[field], value);
                vals[field] = value;
                this.$_clearDerived(vals);
                drow.state = DListDataRowState.UPDATED;
                this._fireEvent('onDataValueUpdated', row, field, value, old);
                this._fireEvent('onDataChanged');
                this.onValueUpdate && this.onValueUpdate({ data: w, row, field, value, oldValue: old });
                this.$_triggerDataChange(w);
                return true;
            }
            return false;
        }
        $_updateRow(drow, values, forceEmpty, list) {
            const flds = this._fieldMap;
            const oldVals = drow.values;
            let newVals = oldVals ? Object.assign({}, oldVals) : void 0;
            let changed = false;
            if (Utils.isObject(values)) {
                if (newVals) {
                    for (let f of this._fieldNames) {
                        if ((forceEmpty || f in values) && newVals[f] !== values[f]) {
                            this.$_validate(flds[f], values[f]);
                            newVals[f] = values[f];
                            changed = true;
                        }
                    }
                }
                else {
                    newVals = Object.assign({}, values);
                    changed = true;
                }
            }
            else if (newVals && forceEmpty) {
                newVals = {};
                changed = true;
            }
            if (changed) {
                this.$_validateRow(drow.row, newVals);
                drow.values = newVals;
                this.$_clearDerived(oldVals);
                if (drow.state !== DListDataRowState.UPDATED) {
                    this._restorable && (drow.save = oldVals);
                    drow.state = DListDataRowState.UPDATED;
                    if (list) {
                        list.push(drow);
                    }
                    else {
                        this._fireEvent('onDataStateChanged', drow.row);
                    }
                }
            }
            return changed;
        }
        /**
         * 지정한 행의 필드 값들을 지정한 값들로 변경한다.
         * 지정한 행 위치가 범위를 벗어나면 예외가 발생된다.
         * 실제로 하나 이상 필드의 값이 변경되면 true를 리턴한다.
         * forceEmpty가 true면 values에 지정되지 않은 필드값들은 undefined로 변경한다.
         */
        updateRow(row, values, forceEmpty) {
            this.$_checkReadOnly();
            this.$_checkRow(row, false);
            if (!this._rows[row]) {
                this._rows[row] = DataRow.createRow2(this._fieldMap, this._derivedMap, void 0);
            }
            const drow = this.$_checkUpdate(this._rows[row]);
            const oldVals = drow.values;
            const changed = this.$_updateRow(drow, values, forceEmpty, null);
            if (changed) {
                this._fireEvent('onDataRowUpdated', row, oldVals);
                this._fireEvent('onDataChanged');
                const w = this.wrapperOrThis();
                this.onRowUpdate && this.onRowUpdate({ data: w, row, oldValues: oldVals });
                this.$_triggerDataChange(w);
            }
            return changed;
        }
        /**
         * 지정한 행들의 의 필드 값들을 지정한 값들로 변경한다.
         * 범위를 벗위난 행이 포함되면 예외가 발생된다.
         * 실제로 하나 이상 행의 값이 변경되면 true를 리턴한다.
         *
         * @param rows 행 번호 목록.
         * @param values 값 목록.
         * @returns
         */
        updateRows(rows, values, forceEmpty) {
            if (!Array.isArray(rows))
                return [];
            if (rows.length === 1) {
                if (this.updateRow(rows[0], values[0], forceEmpty)) {
                    return [rows[0]];
                }
            }
            else {
                this.$_checkReadOnly();
                this.$_checkRows(rows, false);
                const count = Math.min(rows.length, values.length);
                const list = [];
                for (let i = 0; i < count; i++) {
                    const r = rows[i];
                    if (!this._rows[r]) {
                        this._rows[r] = DataRow.createRow2(this._fieldMap, this._derivedMap, void 0);
                    }
                    const drow = this.$_checkUpdate(this._rows[r]);
                    this.$_updateRow(drow, values[i], forceEmpty, list);
                }
                if (list.length > 0) {
                    rows = list.map(drow => drow.row);
                    this._fireEvent('onDataRowsUpdated', rows);
                    this._fireEvent('onDataChanged');
                    const w = this.wrapperOrThis();
                    this.onRowsUpdate && this.onRowsUpdate({ data: w, rows });
                    this.$_triggerDataChange(w);
                    return rows;
                }
            }
            return [];
        }
        /**
         * row로 지정행 행부터 count 행만큼 values의 값들로 수정한다.
         * values 개수가 count보다 적으면 values 개수만큼만 수정된다.
         * row가 범위를 벗어나면 예외가 발생한다.
         * row 이후 기존 행번호를 넘어서면 나머지는 무시된다.
         *
         * @param row 시작 행. 범위를 벗어나면 예외가 발생된다.
         * @param count 행 수.
         * @param values 변경값 목록.
         * @returns 실제 하나 행 이상 수정되면 true.
         */
        updateRange(row, count, values, forceEmpty) {
            if (count < 1 || !Array.isArray(values) || values.length < 1) {
                return false;
            }
            if (count === 1) {
                return this.updateRow(row, values[0], forceEmpty);
            }
            this.$_checkReadOnly();
            this.$_checkRow(row, false);
            const rows = this._rows;
            const list = [];
            let changed = false;
            count = Math.min(count, values.length);
            for (let i = 0; i < count; i++) {
                const r = row + i;
                if (!rows[r]) {
                    rows[r] = DataRow.createRow2(this._fieldMap, this._derivedMap, void 0);
                }
                const drow = this.$_checkUpdate(rows[r]);
                this.$_updateRow(drow, values[i], forceEmpty, list);
            }
            if (changed = list.length > 0) {
                const rows = list.map(drow => drow.row);
                this._fireEvent('onDataRowsUpdated', rows);
                this._fireEvent('onDataChanged');
                const w = this.wrapperOrThis();
                this.onRowsUpdate && this.onRowsUpdate({ data: w, rows });
                this.$_triggerDataChange(w);
            }
            return changed;
        }
        /**
         * 데이터행이 하나라도 존재하면 모두 삭제하고 true를 리턴한다.
         *
         * @param force true면 softDeleting이어도 물리적으로 삭제한다.
         * @returns 하나 이상의 행들이 존재하고 실제 모두 삭제되면 true.
         */
        deleteAll(force) {
            const oldCount = this._rows.length;
            if (oldCount > 0) {
                this.$_checkReadOnly();
                const w = this.wrapperOrThis();
                if (this._softDeleting && !force) {
                    const list = [];
                    const rows = this._rows;
                    for (let r = 0; r < oldCount; r++) {
                        if (rows[r].state !== DListDataRowState.DELETED) {
                            rows[r].state = DListDataRowState.DELETED;
                            list.push(r);
                        }
                    }
                    if (list.length > 0) {
                        this._fireEvent('onDataStatesChanged', list);
                        this.onRowStatesChange && this.onRowStatesChange({ data: w, rows: list });
                    }
                }
                else {
                    this._rows = [];
                    this._flags._cleared(oldCount);
                    this._fireEvent('onDataCleared', oldCount);
                    this._fireEvent('onDataCountChanged', 0, oldCount);
                    this._fireEvent('onDataChanged');
                    this.onRowsClear && this.onRowsClear({ data: w, oldCount });
                    this.onRowCountChange && this.onRowCountChange({ data: w, newCount: 0, oldCount });
                }
                this.$_triggerDataChange(w);
                return true;
            }
            return false;
        }
        /**
         * 지정한 행 번호에 위치한 데이터행을 삭제한다.
         * 행 번호가 범위를 벗어나면 예외가 발생된다.
         * 둘 이상의 행들을 동시에 삭제할 때는 {@link deleteRows}를 호출한다.
         *
         * @param row
         */
        deleteRow(row, force) {
            this.$_checkReadOnly();
            this.$_checkRow(row, false);
            const w = this.wrapperOrThis();
            const rows = this._rows;
            const drow = rows[row];
            const id = drow.id;
            if (this._softDeleting && !force) {
                if (drow.state !== DListDataRowState.DELETED) {
                    drow.state = DListDataRowState.DELETED;
                    this._fireEvent('onDataStateChanged', row);
                    this.onRowStateChange && this.onRowStateChange({ data: w, row });
                }
            }
            else {
                rows.splice(row, 1);
                this.$_resetIndices(row);
                this._flags._rowDeleted(row);
                this._fireEvent('onDataRowDeleted', row, id);
                this._fireEvent('onDataCountChanged', rows.length, rows.length + 1);
                this._fireEvent('onDataChanged');
                const n = rows.length;
                this.onRowDelete && this.onRowDelete({ data: w, row, values: drow.values });
                this.onRowCountChange && this.onRowCountChange({ data: w, newCount: n, oldCount: n + 1 });
            }
            this.$_triggerDataChange(w);
        }
        /**
         * 지정한 번호들에 위치한 데이터행들을 삭제한다.
         * 범위를 벗어난 행 번호가 포함되면 예외가 발생된다.
         *
         * @param rows 삭제할 데이터행 번호 목록
         * @returns 실제 삭제된 행 수.
         */
        deleteRows(rows, force) {
            if (Array.isArray(rows) && rows.length > 0) {
                this.$_checkReadOnly();
                this.$_checkRows(rows, false);
                const oldCount = this._rows.length;
                rows = Utils.dedupe(rows.filter(r => r >= 0 && r < oldCount));
                if (rows.length > 1) {
                    const w = this.wrapperOrThis();
                    const ids = [];
                    let list;
                    let cnt = 0;
                    rows = rows.sort((r1, r2) => r1 - r2);
                    if (this._softDeleting && !force) {
                        list = [];
                        for (let i = 0, n = rows.length; i < n; i++) {
                            const drow = this._rows[rows[i]];
                            if (drow.state !== DListDataRowState.DELETED) {
                                drow.state = DListDataRowState.DELETED;
                                list.push(rows[i]);
                            }
                        }
                        if (list.length > 0) {
                            cnt = list.length;
                            this._fireEvent('onDataStatesChanged', list);
                        }
                    }
                    else {
                        for (let i = rows.length - 1; i >= 0; i--) {
                            ids.push(this._rows[rows[i]].id);
                            this._rows.splice(rows[i], 1);
                        }
                        this.$_resetIndices(0);
                        this._flags._rowsDeleted(rows);
                        this._fireEvent('onDataRowsDeleted', rows, ids);
                        this._fireEvent('onDataCountChanged', this._rows.length, oldCount);
                        this._fireEvent('onDataChanged');
                        cnt = rows.length;
                        this.onRowsDelete && this.onRowsDelete({ data: w, rows });
                        this.onRowCountChange && this.onRowCountChange({ data: w, newCount: oldCount - cnt, oldCount: oldCount });
                        list = rows;
                    }
                    this.$_triggerDataChange(w);
                    return list;
                }
                else {
                    this.deleteRow(rows[0], force);
                    return [rows[0]];
                }
            }
            return [];
        }
        /**
         * 지정한 행 부터 지정한 개수의 행들을 삭제한다.
         * 지정한 행이 범위를 벗어나면 예외가 발생된다.
         * 지정한 개수가 전체 행수를 벗어나면 나머지는 무시된다.
         *
         * @param row 삭제 시작 행.
         * @param count 삭제 행 수.
         * @returns {number} 실제 삭제된 행수.
         */
        deleteRange(row, count, force) {
            this.$_checkReadOnly();
            this.$_checkRow(row, false);
            if (isNaN(count) || count <= 0)
                return 0;
            const rows = this._rows;
            const oldCount = rows.length;
            count = Math.min(oldCount - row, count);
            if (count > 0) {
                const w = this.wrapperOrThis();
                if (this._softDeleting && !force) {
                    const list = [];
                    for (let r = row, n = row + count; r < n; r++) {
                        const drow = rows[r];
                        if (drow.state !== DListDataRowState.DELETED) {
                            drow.state = DListDataRowState.DELETED;
                            list.push(r);
                        }
                    }
                    if (list.length > 0) {
                        this._fireEvent('onDataStatesChanged', list);
                    }
                }
                else {
                    rows.splice(row, count);
                    this.$_resetIndices(row);
                    this._flags._rangeDeleted(row, count);
                    this._fireEvent('onDataRangeDeleted', row, count);
                    this._fireEvent('onDataCountChanged', this._rows.length, oldCount);
                    this._fireEvent('onDataChanged');
                    this.onRowRangeDelete && this.onRowRangeDelete({ data: w, row, count });
                    this.onRowCountChange && this.onRowCountChange({ data: w, newCount: oldCount - count, oldCount: oldCount });
                }
                this.$_triggerDataChange(w);
            }
            return count;
        }
        $_checkInsert(row, values) {
            const flds = this._fieldMap;
            const vals = {};
            for (let f in this._fieldMap) {
                if (f in values) {
                    if (values[f] === void 0) {
                        if (flds[f].default !== void 0) {
                            vals[f] = flds[f].default;
                        }
                    }
                    else {
                        vals[f] = values[f];
                    }
                }
                else if (flds[f].default !== void 0) {
                    vals[f] = flds[f].default;
                }
                this.$_validate(flds[f], vals[f]);
            }
            this.$_validateRow(row, vals);
            return vals;
        }
        /**
         * 지정한 위치에 새로운 행을 추가한다.
         * 범위를 벗어난 위치이면 예외가 발생된다.
         *
         * @param row 행 추가 위치.
         * @param values 추가할 값. json object.
         * @returns 실제로 추가되면 true
         */
        insertRow(row, values) {
            this.$_checkReadOnly();
            this.$_checkRow(row, true);
            if (Utils.isObject(values)) {
                const rows = this._rows;
                const oldCount = rows.length;
                const drow = DataRow.createRow2(this._fieldMap, this._derivedMap, values = this.$_checkInsert(-1, values));
                rows.splice(row, 0, drow);
                this.$_resetIndices(row);
                this._flags._rowAdded(row);
                this._fireEvent('onDataRowAdded', row);
                this._fireEvent('onDataCountChanged', oldCount, oldCount - 1);
                this._fireEvent('onDataChanged');
                const w = this.wrapperOrThis();
                this.onRowAdd && this.onRowAdd({ data: w, row });
                this.onRowCountChange && this.onRowCountChange({ data: w, newCount: oldCount - 1, oldCount: oldCount });
                this.$_triggerDataChange(w);
                return true;
            }
            return false;
        }
        /**
         * 마지막 행 다음에 새로운 행을 추가한다.
         * @param values 추가할 값. json object.
         * @returns 실제로 추가되면 true
         */
        appendRow(values) {
            return this.insertRow(this._rows.length, values);
        }
        /**
         * 지정한 위치에 새로운 하나 이상의 행들을 추가한다.
         * 범위를 벗어난 위치이면 예외가 발생된다.
         *
         * @param row 행 추가 위치.
         * @param values 추가할 값들. json object 배열.
         * @returns 추가 후 총 행 수.
         */
        insertRows(row, values) {
            this.$_checkReadOnly();
            this.$_checkRow(row, true);
            let drows;
            if (Utils.isObject(values)) {
                drows = this.$_buildRows(values);
            }
            else if (Array.isArray(values) && values.length > 0) {
                const fields = this._fieldMap;
                const dfields = this._derivedMap;
                drows = [];
                for (let i = 0; i < values.length; i++) {
                    let vals = values[i];
                    if (Utils.isObject(vals)) {
                        drows.push(DataRow.createRow2(fields, dfields, vals = this.$_checkInsert(-1, vals)));
                    }
                }
            }
            const rows = this._rows;
            const n = drows ? drows.length : 0;
            if (n > 0) {
                const oldCount = rows.length;
                // 차이가 있나? TODO: use spread operator
                if (row >= rows.length) {
                    for (let i = 0; i < n; i++) {
                        rows.push(drows[i]);
                    }
                }
                else {
                    for (let i = 0; i < n; i++) {
                        rows.splice(row + i, 0, drows[i]);
                    }
                }
                this.$_resetIndices(row);
                this._flags._rowRangeAdded(row, n);
                this._fireEvent('onDataRowsAdded', row, n);
                this._fireEvent('onDataCountChanged', oldCount + n, oldCount);
                this._fireEvent('onDataChanged');
                const w = this.wrapperOrThis();
                this.onRowsAdd && this.onRowsAdd({ data: w, row, count: n });
                this.onRowCountChange && this.onRowCountChange({ data: w, newCount: oldCount + n, oldCount: oldCount });
                this.$_triggerDataChange(w);
            }
            return rows.length;
        }
        /**
         * 마지막 행 다음에 새로운 하나 이상의 행들을 추가한다.
         *
         * @param values 추가할 값들. json object 배열.
         * @returns 추가 후 총 행 수.
         */
        appendRows(values) {
            return this.insertRows(this._rows.length, values);
        }
        findRow(where, from = 0, to = -1) {
            return DataRow.findRow(this._rows, where, from, to);
        }
        findRows(where, from = 0, to = -1) {
            return DataRow.findRows(this._rows, where, from, to);
        }
        findDistinctRows(fields, from = 0, to = -1) {
            return DataRow.findDistinctRows(this._rows, fields, from, to);
        }
        getSummary(field, start, end) {
            const f = this.fieldByName(field);
            return f && _getSummary(f, this._rows, start, end);
        }
        getRowState(row) {
            this.$_checkRow(row, false);
            return this._rows[row].state;
        }
        internalRowState(row) {
            return this._rows[row].state;
        }
        $_restore(drow) {
            if (drow.state === DListDataRowState.UPDATED && this._restorable) {
                drow.values = drow.save;
                delete drow.save;
                delete drow.state;
                return true;
            }
            else if (drow.state === DListDataRowState.DELETED) {
                delete drow.state;
                return true;
            }
            return false;
        }
        /**
         * 수정행: 이전 데이터로 복원 시키고 상태 제거.
         * 삭제행: 삭제 상태 제거.
         */
        restoreRow(row) {
            this.$_checkReadOnly();
            this.$_checkRow(row, false);
            if (this.$_restore(this._rows[row])) {
                this._fireEvent('onDataStateChanged', row);
                this._fireEvent('onDataChanged');
                const w = this.wrapperOrThis();
                this.onRowStateChange && this.onRowStateChange({ data: w, row });
                this.$_triggerDataChange(w);
                return true;
            }
            return false;
        }
        restoreRows(rows) {
            if (!Array.isArray(rows))
                return [];
            this.$_checkReadOnly();
            this.$_checkRows(rows, false);
            const drows = this._rows;
            const list = [];
            rows.forEach(row => {
                if (this.$_restore(drows[row])) {
                    list.push(row);
                }
            });
            return list;
        }
        restoreAllRows() {
            let n = 0;
            this._rows.forEach(drow => {
                if (this.$_restore(drow))
                    n++;
            });
            return n;
        }
        restoreUpdatedRows() {
            let n = 0;
            this._rows.forEach(drow => {
                if (drow.state === DListDataRowState.UPDATED && this.$_restore(drow))
                    n++;
            });
            return n;
        }
        restoreDeletedRows() {
            let n = 0;
            this._rows.forEach(drow => {
                if (drow.state === DListDataRowState.DELETED && this.$_restore(drow))
                    n++;
            });
            return n;
        }
        moveRow(from, to) {
            this.$_checkRow(from, false);
            this.$_checkRow(to, false);
            if (from !== to) {
                const w = this.wrapperOrThis();
                const rows = this._rows;
                const drow = rows.splice(from, 1)[0];
                rows.splice(to, 0, drow);
                this.$_resetIndices(Math.min(from, to));
                this._flags._rowMoved(from, to);
                this._fireEvent('onDataRowMoved', from, to);
                this._fireEvent('onDataChanged');
                this.onRowMove && this.onRowMove({ data: w, from, to });
                this.$_triggerDataChange(w);
                return true;
            }
            return false;
        }
        moveRows(from, count, to) {
            const rows = this._rows;
            count = Math.min(count, rows.length - from);
            if (to > rows.length - count) {
                DListDataError.throwFormat(this.wrapperOrThis(), locale.invalidToIndex, to);
            }
            if (count === 1) {
                if (this.moveRow(from, to)) {
                    return 1;
                }
            }
            else if (from !== to && count > 1) {
                this.$_checkRow(from, false);
                this.$_checkRow(to, true);
                const w = this.wrapperOrThis();
                const drows = rows.splice(from, count);
                rows.splice.apply(rows, [to, 0].concat(drows));
                this.$_resetIndices(Math.min(from, to));
                this._flags._rowsMoved(from, count, to);
                this._fireEvent('onDataRowsMoved', from, count, to);
                this._fireEvent('onDataChanged');
                this.onRowsMove && this.onRowsMove({ data: w, from, count, to });
                this.$_triggerDataChange(w);
                return count;
            }
            return 0;
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        $_triggerDataChange(w) {
            if (this.onDataChange) {
                this._args.data = w;
                this.onDataChange(this._args);
            }
        }
        $_checkReadOnly() {
            if (this._readOnly) {
                DListDataError.throw(this.wrapperOrThis(), locale.canNotModifyData);
            }
        }
        $_checkRow(row, inclusive) {
            if (row < 0 || (row >= this._rows.length + (inclusive ? 1 : 0))) {
                DListDataError.throwFormat(this.wrapperOrThis(), locale.invalidRowIndex, row);
            }
        }
        $_checkRows(rows, inclusive) {
            const n = this._rows.length + (inclusive ? 1 : 0);
            rows.forEach(row => {
                if (row < 0 || row >= n) {
                    DListDataError.throwFormat(this.wrapperOrThis(), locale.invalidRowIndex, row);
                }
            });
        }
        $_checkUpdate(drow) {
            if (drow.state === DListDataRowState.DELETED) {
                DListDataError.throwFormat(this.wrapperOrThis(), locale.canNotModifyDeleted, drow.row);
            }
            return drow;
        }
        checkField(field) {
            if (!(field in this._fieldMap || field in this._derivedMap)) {
                DListDataError.throwFormat(this.wrapperOrThis(), locale.invalidFieldName, field);
            }
        }
        $_validate(fld, value) {
            const w = this.wrapperOrThis();
            if ((value == void 0 || value === '') && fld.required) {
                throw new DListDataFieldError(w, fld, formatMessage(locale.requiredField, fld.displayText()));
            }
            if (fld.domain && fld.domain.indexOf(value) < 0) {
                throw new DListDataFieldError(w, fld, formatMessage(locale.invalidValueInDomain, fld.displayText()));
            }
            if (fld.minimum !== void 0 && value < fld.minimum || fld.maximum !== void 0 && value > fld.maximum) {
                throw new DListDataFieldError(w, fld, formatMessage(locale.invalidValueInRange, fld.displayText()));
            }
        }
        $_validateRow(row, values) {
            if (this._validator) {
                const e = this._validator(this.wrapperOrThis(), row, values);
                if (e) {
                    throw new DListDataRowError(this.wrapperOrThis(), e);
                }
            }
        }
        $_buildFields(options, data) {
            if (Array.isArray(options.fields)) {
                return options.fields.map(f => {
                    let fld;
                    if (typeof f === 'string') {
                        fld = ListDataField.create(f, DListDataType.TEXT);
                    }
                    else {
                        fld = ListDataField.create(f);
                    }
                    fld && (fld['_owner'] = this);
                    return fld;
                }).filter(f => f != null);
            }
            else if (data) {
                return this.$_extractFields(data);
            }
        }
        $_buildDerivedFields(fields, data) {
            const dfields = [];
            if (Array.isArray(fields)) {
                for (let f of fields) {
                    if (Utils.isObject(f) && f.name && f.extractor) {
                        const fld = DerivedField.createDerived(f.name, f.extractor, f.type || DListDataType.TEXT);
                        fld['_owner'] = this;
                        dfields.push(fld);
                    }
                }
                return dfields;
            }
            return dfields;
        }
        $_resetIndices(from) {
            const rows = this._rows;
            if (rows) {
                for (let r = from, n = rows.length; r < n; r++) {
                    rows[r].row = r;
                }
            }
        }
        $_extractFields(data) {
            function createFields(values, reader, fieldMap) {
                for (let p in values) {
                    const v = reader ? reader(p, values[p]) : values[p];
                    const t = v instanceof Date ? DListDataType.DATE : (valueToType[typeof v] || DListDataType.ANY);
                    const name = (fieldMap && fieldMap[p]) || p;
                    const fld = ListDataField.create(name, t);
                    fld.sourceProp = p;
                    flds.push(fld);
                }
            }
            const flds = [];
            if (Array.isArray(data)) {
                const vals = data[0];
                for (let p in vals) {
                    const v = vals[p];
                    const t = v instanceof Date ? DListDataType.DATE : (valueToType[typeof v] || DListDataType.ANY);
                    const fld = ListDataField.create(p, t);
                    flds.push(fld);
                }
            }
            else if (Utils.isObject(data) && data.values) {
                const values = data.values;
                let csv = false;
                let obj;
                switch (data.type) {
                    case DListDataValueSourceType.FIELD:
                        if (Utils.isObject(values)) {
                            obj = {};
                            for (const p in values) {
                                obj[p] = values[p][0];
                            }
                        }
                        break;
                    case DListDataValueSourceType.CSV:
                        csv = true;
                    case DListDataValueSourceType.TSV:
                        if (typeof (values) === 'string' && values.length > 0) {
                            const lines = data[SV_LINES] = values.split(LINE_SEP);
                            const rFlds = data.fieldHeader;
                            if (rFlds >= 0 && lines.length > rFlds) {
                                const start = data.startRow || 0;
                                data.reader;
                                const quoted = data.quoted;
                                if (lines.length > start && start > rFlds) {
                                    let flds2;
                                    let vals;
                                    if (csv) {
                                        flds2 = lines[rFlds].split(data.quoted ? CSV_SPLIT : ',');
                                        if (quoted) {
                                            for (let i = flds2.length - 1; i >= 0; i--) {
                                                flds2[i] = Utils.stripQuotes(flds2[i]);
                                            }
                                        }
                                        vals = lines[start].split(data.quoted ? CSV_SPLIT : ',');
                                        if (quoted) {
                                            for (let i = vals.length - 1; i >= 0; i--) {
                                                vals[i] = Utils.stripQuotes(vals[i]);
                                            }
                                        }
                                    }
                                    else {
                                        flds2 = lines[rFlds].split(data.multiTabs ? MULTI_TAB_SPLIT : TAB_SPLIT);
                                        vals = lines[start].split(data.multiTabs ? MULTI_TAB_SPLIT : TAB_SPLIT);
                                    }
                                    const nFld = Math.min(flds2.length, pickNum(data.fieldCount, flds2.length));
                                    obj = {};
                                    for (let i = 0; i < nFld; i++) {
                                        obj[flds2[i]] = vals[i];
                                    }
                                }
                            }
                        }
                        break;
                    default:
                        if (Array.isArray(values) && values.length > 0) {
                            obj = values[0];
                        }
                        break;
                }
                obj && createFields(obj, data.reader, data.fieldMap);
            }
            return flds;
        }
        $_buildRows(data) {
            const fields = this._fieldMap;
            const dfields = this._derivedMap;
            if (Array.isArray(data)) {
                const rows = new Array();
                data.forEach((d, i) => rows.push(DataRow.createRow2(fields, dfields, d)));
                return rows;
            }
            else if (Utils.isObject(data) && data.values) {
                const values = data.values;
                const reader = data.reader;
                let fldMap = fields;
                if (Utils.isObject(data.fieldMap)) {
                    const map = {};
                    for (let f in fldMap) {
                        const fld = fldMap[f];
                        if (fld.sourceProp) {
                            map[fld.sourceProp] = fld;
                        }
                        else {
                            map[f] = fld;
                        }
                    }
                    fldMap = map;
                }
                let max = +data.rowCount;
                max = (isNaN(max) || max < 0) ? Number.MAX_SAFE_INTEGER : (max >> 0);
                switch (data.type) {
                    case DListDataValueSourceType.FIELD:
                        return this.$_loadFieldArray(values, data, fldMap, reader, max);
                    case DListDataValueSourceType.CSV:
                        return this.$_loadCsv(values, data, fldMap, reader, max);
                    case DListDataValueSourceType.TSV:
                        return this.$_loadTsv(values, data, fldMap, reader, max);
                    default:
                        return this.$_loadJson(values, data, fldMap, reader, max);
                }
            }
            else if (Utils.isObject(data)) {
                return [DataRow.createRow2(fields, dfields, data)];
            }
        }
        $_loadJson(values, data, fldMap, reader, max) {
            const dfields = this._derivedMap;
            if (Array.isArray(values)) {
                const rows = [];
                for (let i = 0, n = Math.min(max, values.length); i < n; i++) {
                    rows.push(DataRow.createRow(fldMap, dfields, values[i], reader));
                }
                return rows;
            }
            else if (Utils.isObject(values)) {
                return [DataRow.createRow(fldMap, dfields, values, reader)];
            }
        }
        $_loadFieldArray(values, data, fldMap, reader, max) {
            const dfields = this._derivedMap;
            const rows = [];
            const lens = {};
            for (const f in values) {
                lens[f] = Array.isArray(values[f]) ? values[f].length : 0;
            }
            let len = data.lengthField && lens[data.lengthField];
            if (isNaN(len) || len < 1) {
                len = 0;
                for (const f in lens) {
                    len = Math.max(lens[f], len);
                }
            }
            len = Math.min(max, len);
            for (let i = 0; i < len; i++) {
                const obj = {};
                for (const f in lens) {
                    if (lens[f] > i) {
                        obj[f] = values[f][i];
                    }
                }
                rows.push(DataRow.createRow(fldMap, dfields, obj, reader));
            }
            return rows;
        }
        $_trimLines(data, lines) {
            // 빈 줄들을 제거한다.
            if (data.skipBlank) {
                for (let i = lines.length - 1; i >= 0; i--) {
                    if (!lines[i].trim()) {
                        lines.splice(i, 1);
                    }
                }
            }
            // 마지막 빈 line들은 제거한다.
            else if (data.trimLast !== false) {
                while (lines.length > 0) {
                    if (lines[lines.length - 1].trim() === '') {
                        lines.pop();
                    }
                    else {
                        break;
                    }
                }
            }
            return lines;
        }
        $_loadCsv(values, data, fldMap, reader, max) {
            if (typeof (values) === 'string' && values.length > 0) {
                const dfields = this._derivedMap;
                const lines = this.$_trimLines(data, data[SV_LINES] || values.split(LINE_SEP));
                const len = lines.length;
                const rFlds = data.fieldHeader;
                const flds = this._fieldNames.slice(0);
                const rows = [];
                const nFld = flds.length;
                const start = data.startRow || 0;
                const quoted = data.quoted;
                if (rFlds >= 0 && len > rFlds) {
                    const arr = lines[rFlds].split(CSV_SPLIT);
                    for (let i = 0, n = Math.min(nFld, arr.length); i < n; i++) {
                        flds[i] = arr[i] || flds[i];
                    }
                }
                for (let i = start, n = Math.min(max + start, len); i < n; i++) {
                    const line = quoted ? lines[i].split(CSV_SPLIT) : lines[i].split(',');
                    const obj = {};
                    for (let i = 0; i < nFld; i++) {
                        obj[flds[i]] = quoted ? Utils.stripQuotes(line[i]) : line[i];
                    }
                    rows.push(DataRow.createRow(fldMap, dfields, obj, reader));
                }
                delete data[SV_LINES];
                return rows;
            }
        }
        // TODO: 구현할 것!
        $_loadTsv(values, data, fldMap, reader, max) {
            if (typeof (values) === 'string' && values.length > 0) {
                const dfields = this._derivedMap;
                const lines = this.$_trimLines(data, data[SV_LINES] || values.split(LINE_SEP));
                const len = lines.length;
                const rFlds = data.fieldHeader;
                const flds = this._fieldNames.slice(0);
                const rows = [];
                const nFld = flds.length;
                const start = data.startRow || 0;
                const sep = data.multiTabs ? MULTI_TAB_SPLIT : TAB_SPLIT;
                if (rFlds >= 0 && len > rFlds) {
                    const arr = lines[rFlds].split(sep);
                    for (let i = 0, n = Math.min(nFld, arr.length); i < n; i++) {
                        flds[i] = arr[i] || flds[i];
                    }
                }
                for (let i = start, n = Math.min(max + start, len); i < n; i++) {
                    const line = lines[i].split(sep);
                    const obj = {};
                    for (let i = 0; i < nFld; i++) {
                        obj[flds[i]] = line[i];
                    }
                    rows.push(DataRow.createRow(fldMap, dfields, obj, reader));
                }
                delete data[SV_LINES];
                return rows;
            }
        }
        $_clearDerived(values) {
            for (let f of this._derivedFields) {
                delete values[f.name];
            }
        }
        getRows() {
            return this._rows.slice(0);
        }
        internalValue(row, field) {
            return this._rows[row] && this._rows[row].values[field];
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * 복수 필터 결합 방식.
     * <br>
     * {@link DListDataView}에 적용하는 {@link IListDataFilterSet 필터셋}의 {@link IListDataFilterSet.op op} 속성으로 사용된다.
     *
     * @see concepts/filtering 필터링 개요
     */
    var DListDataFilterOp;
    (function (DListDataFilterOp) {
        /**
         * 필터들 중 하나만 통과해도 데이터행을 선택한다.
         */
        DListDataFilterOp["OR"] = "or";
        /**
         * 모든 필터들을 통과해야 데이터행을 선택한다.
         */
        DListDataFilterOp["AND"] = "and";
    })(DListDataFilterOp || (DListDataFilterOp = {}));
    class ListDataFilter {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(name, label) {
            this.name = name;
            this.label = label;
            this.enabled = true;
        }
        //-------------------------------------------------------------------------
        // static members
        //-------------------------------------------------------------------------
        static saveOrders(rows) {
            rows.forEach((row, i) => row.newIdx = i);
        }
        static restoreOrders(rows) {
            return rows.sort((r1, r2) => r1.newIdx - r2.newIdx);
        }
    }
    class ListDataFilterSet extends ListDataFilter {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(name, label, children, op, dv) {
            super(name, label);
            this._filterMap = {};
            children = Array.isArray(children) ? children.slice(0) : [];
            this.op = op || DListDataFilterOp.OR;
            const list = [];
            for (const filter of children) {
                let f;
                if (filter['filters']) {
                    f = new ListDataFilterSet(filter.name, filter['label'], filter['op'], filter['filters'], dv);
                }
                else if (filter['filter']) {
                    f = this.$_createFilter(filter.name, filter['label'], filter['filter'], dv);
                }
                if (f) {
                    f.parent = this;
                    f.enabled = pickProp(filter.enabled, true);
                    this._filterMap[filter.name] = f;
                    list.push(f);
                }
            }
            this.children = list;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        isNotEmpty() {
            return this.children.length > 0;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        add(name, filter, label, enabled, dv) {
            if (filter instanceof ListDataFilter && this.children.indexOf(filter) >= 0) {
                return filter;
            }
            const f = filter instanceof ListDataFilter ? filter : this.$_createFilter(name, label, filter, dv);
            if (f) {
                f.enabled = enabled;
                f.parent = this;
                this.children.push(f);
                this._filterMap[name] = f;
            }
            return f;
        }
        addSet(name, filters, op, label, enabled, dv) {
            const fs = new ListDataFilterSet(name, label, filters, op, dv);
            fs && this.add(name, fs, label, enabled, dv);
            return fs;
        }
        remove(filter) {
            if (filter instanceof ListDataFilter) {
                const i = this.children.indexOf(filter);
                if (i >= 0) {
                    this.children.splice(i, 1);
                    delete this._filterMap[filter.name];
                    return true;
                }
            }
            else {
                const f = this.getFilter(filter);
                if (f && f.parent) {
                    return f.parent.remove(f);
                }
            }
        }
        getFilter(name) {
            let filter = this._filterMap[name];
            if (!filter) {
                for (let f of this.children) {
                    if (f instanceof ListDataFilterSet) {
                        filter = f.getFilter(name);
                        if (filter)
                            break;
                    }
                }
            }
            return filter;
        }
        getAll() {
            function _getAll(s) {
                for (let f of s.children) {
                    list.push(f);
                }
            }
            const list = [];
            _getAll(this);
            return list;
        }
        clear() {
            if (this.children.length > 0) {
                this.children = [];
                this._filterMap = {};
                return true;
            }
        }
        enabledAll(enabled) {
            let changed = false;
            if (this.enabled != enabled) {
                this.enabled = enabled;
                changed = true;
            }
            this.children.forEach(f => {
                if (f instanceof ListDataFilterSet) {
                    changed = changed || f.enabledAll(enabled);
                }
                else if (f.enabled != enabled) {
                    f.enabled = enabled;
                    changed = true;
                }
            });
            return changed;
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        select(rows) {
            if (rows.length > 0) {
                let filters = this.children.filter(f => f.enabled);
                const nFilter = filters.length;
                if (nFilter > 0) {
                    let list;
                    if (this.op === DListDataFilterOp.AND) {
                        list = filters[0].select(rows);
                        for (let i = 1; i < nFilter; i++) {
                            list = filters[i].select(list);
                        }
                    }
                    else {
                        // 주의: 순서가 헝클어지면 안된다.
                        ListDataFilter.saveOrders(rows);
                        list = [];
                        for (let i = 0; i < nFilter; i++) {
                            list = list.concat(filters[i].select(rows));
                        }
                        list = Utils.dedupe(list, (r1, r2) => r1.row - r2.row);
                        // 순서를 복원한다.
                        list = ListDataFilter.restoreOrders(list);
                    }
                    return list;
                }
                else {
                    return rows;
                }
            }
            return [];
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        $_createFilter(name, label, filter, dv) {
            if (!name) {
                DListDataError.throw(null, locale.requireFilterName);
            }
            if (name) {
                let dfilter;
                if (Utils.isNumberArray(filter)) {
                    dfilter = new SliceFilter(name, void 0, filter);
                }
                else if (typeof filter === 'number') {
                    if (!isNaN(filter)) {
                        dfilter = new SliceFilter(name, void 0, [0, filter]);
                    }
                }
                else if (Utils.isStringArray(filter)) {
                    dfilter = new DedupeFilter(name, void 0, filter, dv);
                }
                else if (typeof filter === 'function') {
                    dfilter = new SelectFilter(name, void 0, filter);
                }
                dfilter.label = label;
                return dfilter;
            }
        }
    }
    class SelectFilter extends ListDataFilter {
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(name, label, selector) {
            super(name, label);
            this.selector = selector;
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        selectRow(row, values) {
            return this.selector(row, values);
        }
        select(rows) {
            const selector = this.selector;
            return rows.filter((drow, i) => selector(i, drow.values));
        }
    }
    class DedupeFilter extends ListDataFilter {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(name, label, keyFields, dv) {
            super(name, label);
            this.keyFields = [];
            this.comparers = [];
            for (let f of keyFields) {
                const fld = dv.fieldByName(f);
                if (fld) {
                    this.keyFields.push(f);
                    this.comparers.push(fld.comparer);
                }
            }
            this.keyFields = keyFields.slice(0);
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        select(rows) {
            function compare(vals1, vals2) {
                for (let i = 0; i < nFld; i++) {
                    const fld = flds[i];
                    const v1 = vals1[fld];
                    const v2 = vals2[fld];
                    const diff = comparers[i](v1, v2);
                    if (diff)
                        return diff;
                }
                return 0;
            }
            const flds = this.keyFields;
            const nFld = flds.length;
            const comparers = this.comparers;
            // 순서가 헝클어져서는 안된다. 기존 순서를 저장한다.
            ListDataFilter.saveOrders(rows);
            rows = rows.sort((r1, r2) => compare(r1.values, r2.values));
            let prev = rows[0];
            let rows2 = [prev];
            let i = 1;
            while (i < rows.length) {
                const drow = rows[i++];
                if (compare(prev.values, drow.values) !== 0) {
                    rows2.push(prev = drow);
                }
            }
            // 기존 순서를 복원한다.
            rows2 = ListDataFilter.restoreOrders(rows2);
            return rows2;
        }
    }
    /**
     * @internal
     *
     * 지정된 행번호 범위들에 포함된 행들을 선택한다.
     * and 필터 셋에 포함되는 경우 이전 필터가 실행 된 후 선택하므로 순서가 중요하다.
     * 각 range의 to가 from과 같거나 커야 한다.
     */
    class SliceFilter extends ListDataFilter {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(name, label, ranges) {
            super(name, label);
            this._ranges = this.$_buildRanges(ranges);
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        select(rows) {
            if (this._ranges) {
                let rows2 = [];
                for (let rng of this._ranges) {
                    rows2 = rows2.concat(rows.slice(rng.from, rng.to));
                }
                return rows2;
            }
            return rows;
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        $_buildRanges(src) {
            const len = src.length;
            const ranges = [];
            if (len === 1 && src[0] >= 0) {
                ranges.push({ from: 0, to: src[0] });
            }
            else if (len > 1) {
                let prev = -1;
                for (let i = 0, n = Math.floor(len / 2); i < n; i++) {
                    const from = src[i * 2], to = src[i * 2 + 1];
                    if (from > prev && to >= from) {
                        ranges.push({ from, to });
                        prev = to;
                    }
                }
            }
            return ranges.length > 0 ? ranges : null;
        }
    }
    /**
     * @internal
     *
     * [filtering]
     * 원본 데이터에 대해 정렬 및 필터링을 한 row 셋을 보관한다.
     * 필터링은 정렬을 기준으로 적용한 순서에 따라 정렬 이전/이후 필터로 실행된다.
     * 즉, sort() 이전에 추가한 필터는 pre, 이후에 추가한 필터는 post 필터가 된다.
     * 적용한 필터들은 activate/deactivate할 수 있다.
     * 최상위 필터셋은 and 이고, 한 필터셋 내에서 필터들은 지정할 수 있다.
     * slice(), dedupe()는 간략화된 필터이다.
     * 정렬은 다시 적용할 수 있지만, pre/post 필터의 위치는 변경되지 않는다.
     * 사용자는 필터명으로만 필터에 접근할 수 있다.
     *
     * 사용이 끝난 후 반드시 dispose()를 호출해야 한다!
     */
    class ListDataView extends ListDataOjbject {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(name, data, options, wrapper) {
            super(name);
            this._dirty = false;
            this._sortDirty = false;
            this._defaultFilterOp = DListDataFilterOp.AND;
            this._filtered = false;
            this._nextSorter = 1;
            this._sortMap = {};
            this._sorted = false;
            //-------------------------------------------------------------------------
            // property fields
            //-------------------------------------------------------------------------
            this._autoSort = true;
            this._wrapper = wrapper;
            if (!(data instanceof ListData)) {
                DListDataError.throw(null, locale.requireSourceData);
            }
            this._data = data;
            data.addListener(this);
            this._fields = data.fields();
            this.$_buildOptions(options);
            this._rows = this.$_buildRows();
        }
        _doDestory() {
            if (this._data) {
                this._data.removeListener(this);
                this._data = this._fields = this._rows = null;
            }
            this._wrapper = null;
        }
        //-------------------------------------------------------------------------
        // IListDataView
        //-------------------------------------------------------------------------
        wrapper() {
            return this._wrapper;
        }
        wrapperOrThis() {
            return this._wrapper || this;
        }
        readOnly() {
            return this._data.readOnly();
        }
        fields() {
            return this._fields.slice(0);
        }
        rowCount() {
            return this._rows.length;
        }
        visRowCount() {
            return this._rows.length;
        }
        canSort() {
            return true;
        }
        canMove() {
            return false;
        }
        containsField(field) {
            return this._data.containsField(field);
        }
        checkField(field) {
            this._data.checkField(field);
        }
        fieldByName(field) {
            return this._data.fieldByName(field);
        }
        filter() {
            return this._filter;
        }
        postFilter() {
            return this._postFilter;
        }
        hasFilter() {
            return this._filter.isNotEmpty() || this._postFilter.isNotEmpty();
        }
        filtered() {
            return this._filtered;
        }
        sorted() {
            return this._sorted;
        }
        getDataRow(row) {
            return this._rows[row];
        }
        // O(n)
        rowOfDataRow(dataRow) {
            const rows = this._rows;
            for (let r = rows.length - 1; r >= 0; r--) {
                if (rows[r] === dataRow) {
                    return r;
                }
            }
            return -1;
        }
        getRowId(row) {
            // if (!this._rows[row]) debugger;
            return this._rows[row].id;
        }
        isLast(row) {
            return row === this._rows.length - 1;
        }
        isMaster(row) {
            return false;
        }
        levelRowOfRow(row) {
            return row;
        }
        getRowValues(row) {
            ListDataOjbject.checkRow(this, row);
            return Object.assign({}, this._rows[row].values);
        }
        internalRowValues(row) {
            return Object.assign({}, this._rows[row].values);
        }
        getValues(row, fields, fieldCheck) {
            if (Array.isArray(fields)) {
                ListDataOjbject.checkRow(this, row);
                const dv = this._data;
                const ret = {};
                fields.forEach(f => {
                    fieldCheck && dv.checkField(f);
                    ret[f] = this.internalValue(row, f);
                });
                return ret;
            }
            else {
                return this.getRowValues(row);
            }
        }
        getValue(row, field, fieldCheck) {
            ListDataOjbject.checkRow(this, row);
            fieldCheck && this._data.checkField(field);
            return this._rows[row].values[field];
        }
        internalValue(row, field) {
            return this._rows[row].values[field];
        }
        getProp(row, field, prop, fieldCheck) {
            ListDataOjbject.checkRow(this, row);
            fieldCheck && this._data.checkField(field);
            return this._rows[row].getProp(field, prop);
        }
        getSummary(field, start, end) {
            const f = this._fields.find(f => f.name === field);
            return f && _getSummary(f, this._rows, start, end);
        }
        updateValue(row, field, value) {
            return this._data.updateValue(this._rows[row].row, field, value);
        }
        findRow(values, from = 0, to = -1) {
            return DataRow.findRow(this._rows, values, from, to);
        }
        findRows(values, from = 0, to = -1) {
            return DataRow.findRows(this._rows, values, from, to);
        }
        findDistinctRows(fields, from, to) {
            return DataRow.findDistinctRows(this._rows, fields, from, to);
        }
        deleteRow(row, force) {
            ListData.checkRow(this, row);
            this._data.deleteRow(this._rows[row].row, force);
        }
        deleteRows(rows, force) {
            if (Array.isArray(rows) && rows.length > 0) {
                rows.forEach(row => ListDataOjbject.checkRow(this, row));
                rows = rows.map(row => this._rows[row].row);
                this._data.deleteRows(rows, force);
            }
        }
        updateRow(row, values, forceEmpty = false) {
            ListData.checkRow(this, row);
            return this._data.updateRow(this._rows[row].row, values, forceEmpty);
        }
        appendRow(values) {
            return this._data.appendRow(values);
        }
        getRowState(row) {
            ListData.checkRow(this, row);
            return this._data.internalRowState(this._rows[row].row);
        }
        internalRowState(row) {
            return this._data.internalRowState(this._rows[row].row);
        }
        //-------------------------------------------------------------------------
        // IListDataListener
        //-------------------------------------------------------------------------
        $_getRowsOfSourceIds(ids) {
            const rList = [];
            ids.forEach(id => {
                const r = this.rowOfSourceId(id);
                r >= 0 && rList.push(r);
            });
            return rList;
        }
        $_getRowsOfData(rows) {
            const rList = [];
            rows.forEach(row => {
                const r = this.rowOfSourceRow(row);
                r >= 0 && rList.push(r);
            });
            return rList;
        }
        $_getRowsOfDataRange(row, count) {
            const rList = [];
            for (let i = 0; i < count; i++) {
                const r = this.rowOfSourceRow(row + i);
                r >= 0 && rList.push(r);
            }
            return rList;
        }
        onDataValueUpdated(data, row, field, value, oldValue) {
            if (this._sorted || this.hasFilter()) {
                // TODO: reset()이 필요 없는 경우...
                const oldCount = this._rows.length;
                this.$_reset();
                if (this._rows.length !== oldCount) {
                    this._fireEvent('onDataCountChanged', this._rows.length, oldCount);
                }
                this._fireEvent('onDataChanged');
            }
            else {
                const r = this.rowOfSourceRow(row);
                if (r >= 0) {
                    this._fireEvent('onDataValueUpdated', r, field, value, oldValue);
                    this._fireEvent('onDataChanged');
                }
            }
        }
        onDataRowUpdated(data, row, oldValues) {
            if (this._sorted || this.hasFilter()) {
                // TODO: reset()이 필요 없는 경우...
                const oldCount = this._rows.length;
                this.$_reset();
                if (this._rows.length !== oldCount) {
                    this._fireEvent('onDataCountChanged', this._rows.length, oldCount);
                }
                this._fireEvent('onDataChanged');
            }
            else {
                const r = this.rowOfSourceRow(row);
                if (r >= 0) {
                    this._fireEvent('onDataRowUpdated', r, oldValues);
                    this._fireEvent('onDataChanged');
                }
            }
        }
        onDataRowsUpdated(data, rows) {
            rows = this.$_getRowsOfData(rows);
            if (rows.length === 0)
                return;
            const oldCount = this._rows.length;
            this.$_reset();
            if (this._rows.length !== oldCount) {
                this._fireEvent('onDataCountChanged', this._rows.length, oldCount);
            }
            this._fireEvent('onDataChanged');
        }
        onDataRangeUpdated(data, row, count) {
            const rows = this.$_getRowsOfDataRange(row, count);
            if (rows.length === 0)
                return;
            const oldCount = this._rows.length;
            this.$_reset();
            if (this._rows.length !== oldCount) {
                this._fireEvent('onDataCountChanged', this._rows.length, oldCount);
            }
            this._fireEvent('onDataChanged');
        }
        onDataRowAdded(data, row) {
            const oldCount = this._rows.length;
            // TODO: 필터링 없으면 별도 처리.
            this.$_reset();
            if (this._rows.length !== oldCount) {
                const r = this.rowOfSourceRow(row);
                this._flags._rowAdded(r);
                this._fireEvent('onDataCountChanged', this._rows.length, oldCount);
            }
            this._fireEvent('onDataChanged');
        }
        onDataRowsAdded(data, row, count) {
            const oldCount = this._rows.length;
            // TODO: 필터링 없으면 별도 처리.
            this.$_reset();
            if (this._rows.length !== oldCount) {
                const rows = [];
                for (let i = 0; i < count; i++) {
                    const r = this.rowOfSourceRow(row + i);
                    r >= 0 && rows.push(r);
                }
                rows.length > 0 && this._flags._rowsAdded(Utils.sortNum(rows));
                this._fireEvent('onDataCountChanged', this._rows.length, oldCount);
            }
            this._fireEvent('onDataChanged');
        }
        onDataCleared(data, oldCount) {
            const count = this._rows.length;
            if (count > 0) {
                this._rows = [];
                this._flags._cleared(count);
                this._fireEvent('onDataCleared');
                this._fireEvent('onDataCountChanged', 0, count);
                this._fireEvent('onDataChanged');
            }
        }
        onDataRowDeleted(data, row, rowid) {
            // const r = this.rowOfSourceRow(row);
            const r = this.rowOfSourceId(rowid);
            if (r < 0)
                return;
            const oldCount = this._rows.length;
            // this.$_reset();
            // this._fireEvent('onDataReset');
            this._rows.splice(r, 1);
            this._fireEvent('onDataRowDeleted', r, rowid);
            //if (this._rows.length !== oldCount) {
            this._flags._rowDeleted(r);
            this._fireEvent('onDataCountChanged', this._rows.length, oldCount);
            //}
            this._fireEvent('onDataChanged');
        }
        onDataRowsDeleted(data, rows, ids) {
            // rows = this.$_getRowsOfData(rows);
            rows = this.$_getRowsOfSourceIds(ids);
            if (rows.length === 0)
                return;
            const oldCount = this._rows.length;
            rows = Utils.sortNum(rows);
            for (let i = rows.length - 1; i >= 0; i--) {
                this._rows.splice(rows[i], 1);
            }
            this._fireEvent('onDataRowsDeleted', rows, ids);
            // this.$_reset();
            // this._fireEvent('onDataReset');
            // if (this._rows.length !== oldCount) {
            this._flags._rowsDeleted(rows);
            this._fireEvent('onDataCountChanged', this._rows.length, oldCount);
            // }
            this._fireEvent('onDataChanged');
        }
        onDataRangeDeleted(data, row, count) {
            let rows = this.$_getRowsOfDataRange(row, count);
            if (rows.length === 0)
                return;
            const oldCount = this._rows.length;
            this.$_reset();
            if (this._rows.length !== oldCount) {
                this._flags._rowsDeleted(Utils.sortNum(rows));
                this._fireEvent('onDataCountChanged', this._rows.length, oldCount);
            }
            this._fireEvent('onDataChanged');
        }
        onDataRowMoved(data, from, to) {
        }
        onDataRowsMoved(data, from, count, to) {
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        source() {
            return this._data;
        }
        /**
         * 원본 데이터 수정/추가 시 재정렬한다.
         */
        autoSort() {
            return this._autoSort;
        }
        setAutoSort(value) {
            this._autoSort = value;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        snapshot(options, wrapper) {
            const opts = {};
            let fields;
            if (options) {
                opts.name = options.name;
                fields = opts.fields = Array.isArray(options.fields) ? this._fields.filter(f => options.fields.indexOf(f.name) >= 0).map(f => f.proxy()) : null;
            }
            if (!opts.fields) {
                opts.fields = this._fields.map(f => f.proxy());
            }
            const rows = this._rows;
            const len = rows.length;
            const start = Math.max(0, pickNum(options && options.start, 0));
            const count = Math.max(0, pickNum(options && options.count, len));
            const end = Math.min(len, start + count);
            const ignoreEmpty = !options || !options.skipEmpty;
            !options || !options.skipBlank;
            const values = [];
            if (fields) {
                for (let i = start; i < end; i++) {
                    const drow = rows[i];
                    if (drow) {
                        const vals = drow.values;
                        const obj = {};
                        for (const p in fields) {
                            obj[p] = vals[p];
                        }
                        values.push(obj);
                    }
                    else if (ignoreEmpty) {
                        values.push(void 0);
                    }
                }
            }
            else {
                for (let i = start; i < end; i++) {
                    const drow = rows[i];
                    if (drow) {
                        values.push(Object.assign({}, drow.values));
                    }
                    else if (ignoreEmpty) {
                        values.push(void 0);
                    }
                }
            }
            return new ListData(options ? options.name : void 0, opts, values, wrapper);
        }
        build(force) {
            if (force || this._dirty) {
                this._sortDirty = true;
                this.$_reset();
                this._dirty = false;
            }
            return this;
        }
        isSorted(field) {
            const s = this._sortMap[field.name];
            return s ? { dir: s.dir, order: this._sorts.indexOf(s) } : null;
        }
        getFilter(name, post) {
            const f = post ? this._postFilter : this._filter;
            return f.getFilter(name);
        }
        getFilters() {
            return this._filter.getAll().concat(this._postFilter.getAll());
        }
        addFilter(filter, post, build) {
            const enabled = pickProp(filter.enabled, true);
            const f = (post ? this._postFilter : this._filter).add(filter.name, filter.filter, filter.label, enabled, this);
            f && this.$_filterChanged(build);
            return f;
        }
        addFilterSet(filter, post, build) {
            const enabled = pickProp(filter.enabled, true);
            const f = (post ? this._postFilter : this._filter).addSet(filter.name, filter.filters, filter.op, filter.label, enabled, this);
            f && this.$_filterChanged(build);
            return f;
        }
        removeFilter(filter, build) {
            if (this._filter.remove(filter) || this._postFilter.remove(filter)) {
                this.$_filterChanged(build);
            }
        }
        removeFilters(filters, build) {
            let changed = false;
            if (Array.isArray(filters)) {
                for (let i = filters.length - 1; i >= 0; i--) {
                    changed || (changed = this._filter.remove(filters[i]) || this._postFilter.remove(filters[i]));
                }
                changed && this.$_filterChanged(build);
            }
        }
        clearFilters(build) {
            if (this._filter.clear() || this._postFilter.clear()) {
                this.$_filterChanged(build);
            }
        }
        enableFilter(filter, enabled, build) {
            const f = filter instanceof ListDataFilter ? filter : this.$_getFilter(filter);
            if (f && f.enabled != enabled) {
                f.enabled = enabled;
                this.$_filterChanged(build);
            }
        }
        toggleFilter(filter, build) {
            const f = filter instanceof ListDataFilter ? filter : this.$_getFilter(filter);
            if (f) {
                f.enabled = !f.enabled;
                this.$_filterChanged(true);
            }
        }
        enableFilters(filters, enabled, build) {
            let changed = false;
            if (Array.isArray(filters)) {
                filters.forEach(filter => {
                    const f = filter instanceof ListDataFilter ? filter : this.$_getFilter(filter);
                    if (f && f.enabled != enabled) {
                        f.enabled = enabled;
                        changed = true;
                    }
                });
                changed && this.$_filterChanged(build);
            }
        }
        toggleFilters(filters, build) {
            let changed = false;
            if (Array.isArray(filters)) {
                filters.forEach(filter => {
                    const f = filter instanceof ListDataFilter ? filter : this.$_getFilter(filter);
                    if (f) {
                        f.enabled = !f.enabled;
                        changed = true;
                    }
                });
                changed && this.$_filterChanged(build);
            }
        }
        enableAllFilters(enabled, build) {
            if (this._filter.enabledAll(enabled) || this._postFilter.enabledAll(enabled)) {
                this.$_filterChanged(build);
            }
        }
        /**
         * 기존 정렬 상태를 취소하고 새로 정렬한다.
         *
         * @param options 정렬 옵션. 지정하지 않거나 빈 배여리면 정렬 상태를 취소한다.
         */
        sort(options, build) {
            // 기존 정렬 설정과 다른 경우에만 다시 적용한다.
            let sorts;
            if (typeof options === 'function') {
                sorts = [{ field: '_dl_sorter_' + this._nextSorter++, comparer: options }];
            }
            else if (options) {
                const opts = Array.isArray(options) ? options : [options];
                sorts = [];
                for (let i = 0; i < opts.length; i++) {
                    const opt = opts[i];
                    if (typeof opt === 'string') {
                        if (opt)
                            sorts.push({ field: opt });
                    }
                    else if (opt.field) {
                        sorts.push(opt);
                    }
                }
                if (sorts.length === 0) {
                    sorts = null;
                }
            }
            const map = this._sortMap = {};
            // null 이면
            if (sorts == this._sorts) {
                return;
            }
            const len = sorts ? sorts.length : 0;
            const oldLen = this._sorts ? this._sorts.length : 0;
            // 기존과 동일한 지 확인
            if (len > 0 && len === oldLen) {
                let diff = false;
                for (let i = 0; i < sorts.length; i++) {
                    if (sorts[i].field != this._sorts[i].field || sorts[i].dir != this._sorts[i].dir || sorts[i].comparer != this._sorts[i].comparer) {
                        diff = true;
                        break;
                    }
                }
                if (!diff)
                    return;
            }
            sorts.forEach(s => map[s.field] = s);
            this._sorts = sorts;
            this._dirty = this._sortDirty = true;
            build && this.build(false);
            this.$_fireSortChanged();
            return this;
        }
        addSort(field, dir, before, build) {
            if (this._sortMap[field]) {
                // DListDataError.throw(this, '이미 정렬된 필드입니다: ' + field);
                return this;
            }
            if (field) {
                if (!this._fields.find(f => f.name === field)) {
                    DListDataError.throwFormat(this, locale.invalidFieldName, field);
                }
                const sorts = this._sorts = this._sorts || [];
                const sort = { field, dir };
                if (before && sorts.length > 0) {
                    const i = this.$_indexOfSort(before);
                    i >= 0 ? sorts.splice(i, 0, sort) : sorts.push(sort);
                }
                else {
                    sorts.push(sort);
                }
                this._sortMap[field] = sort;
                this._dirty = this._sortDirty = true;
                build && this.build(false);
                this.$_fireSortChanged();
            }
            return this;
        }
        appendSort(field, dir, build) {
            return this.addSort(field, dir, null, build);
        }
        addSorter(name, sorter, before, build) {
            return this;
        }
        appendSorter(name, sorter, before, build) {
            return this.addSorter(name, sorter, null, build);
        }
        removeSort(field, build) {
            let removed = false;
            if (Array.isArray(field)) {
                for (let f of field) {
                    if (f && this.$_removeSort(f)) {
                        removed = true;
                    }
                }
            }
            else if (field && this.$_removeSort(field)) {
                removed = true;
            }
            if (removed) {
                this._dirty = this._sortDirty = true;
                build && this.build(false);
                this.$_fireSortChanged();
            }
            return this;
        }
        /**
         * 데이터필드의 정렬 상태를 추가하거나 제거한다.
         *
         * @param field 필드 명
         * @param build true면 데이터행 목록을 새로 구축한다.
         */
        toggleSort(field, build) {
            if (typeof field === 'string') {
                field = this.fieldByName(field);
            }
            if (field instanceof ListDataField) {
                const sort = this.isSorted(field);
                if (sort) {
                    this.removeSort(field.name, false);
                    if (sort.dir === DListSortDirection.ASCENDING) {
                        this.appendSort(field.name, DListSortDirection.DESCENDING, false);
                    }
                }
                else {
                    this.appendSort(field.name, DListSortDirection.ASCENDING, false);
                }
                build && this.build(false);
            }
        }
        cleraSort(build) {
            this.sort(null, build);
        }
        getSourceRow(row) {
            return this._rows[row].row;
        }
        rowOfSourceId(rowid) {
            const rows = this._rows;
            for (let i = 0, n = rows.length; i < n; i++) {
                if (rows[i].id === rowid)
                    return i;
            }
            return -1;
        }
        rowOfSourceRow(sourceRow) {
            const rows = this._rows;
            for (let i = 0, n = rows.length; i < n; i++) {
                if (rows[i].row === sourceRow)
                    return i;
            }
            return -1;
        }
        getSortOption(field) {
            if (Array.isArray(this._sorts)) {
                const s = this._sorts.find(s => s.field == field);
                return s && Object.assign({}, s);
            }
        }
        setDataTags(rows, tag) {
            for (const r of this._rows)
                r.tag = void 0;
            for (const r of rows)
                this._rows[r].tag = tag;
        }
        getDataTag(row) {
            return this._rows[row].tag;
        }
        isDataTag(row, tag) {
            return this._rows[row].tag === tag;
        }
        getRows() {
            return this._rows.slice(0);
        }
        getFieldValues(field, from, to) {
            return;
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        $_buildOptions(options) {
            if (options) {
                if (options.filterOp) {
                    this._defaultFilterOp = options.filterOp;
                }
                let filter = options.filter;
                if (Utils.isObject(filter)) {
                    this._filter = new ListDataFilterSet(filter.name || 'main_filter', filter.label, Array.isArray(filter['filters']) ? filter['filters'] : [filter], filter['op'] || this._defaultFilterOp, this);
                }
                filter = options.postFilter;
                if (Utils.isObject(filter)) {
                    this._postFilter = new ListDataFilterSet(filter.name || 'main_post_filter', filter.label, Array.isArray(filter['filters']) ? filter['filters'] : [filter], filter['op'] || this._defaultFilterOp, this);
                }
            }
            if (!this._filter) {
                this._filter = new ListDataFilterSet('main_filter', null, null, this._defaultFilterOp, this);
            }
            if (!this._postFilter) {
                this._postFilter = new ListDataFilterSet('main_post_filter', null, null, this._defaultFilterOp, this);
            }
            options && options.sort && this.sort(options.sort, false);
        }
        $_sort(fields, rows) {
            let sorts = this._sorts;
            if (this._sorted = Array.isArray(sorts)) {
                sorts = sorts.filter(s => s.comparer || (s['_f_'] = fields.find(f => f.name === s.field)));
                if (sorts.length === 1 && sorts[0].comparer) {
                    const comparer = sorts[0].comparer;
                    rows = rows.sort((r1, r2) => {
                        let diff = comparer(r1.row, r1.values, r2.row, r2.values);
                        if (!diff) {
                            diff = r1.row - r2.row;
                        }
                        return diff;
                    });
                }
                else if (sorts.length > 0) {
                    rows = rows.sort((r1, r2) => {
                        let diff = 0;
                        for (let s of sorts) {
                            if (s.comparer) {
                                diff = s.comparer(r1.row, r1.values, r2.row, r2.values);
                            }
                            else {
                                const v1 = r1.values[s.field];
                                const v2 = r2.values[s.field];
                                diff = s['_f_'].comparer(v1, v2);
                                if (diff && s.dir === DListSortDirection.DESCENDING) {
                                    diff *= -1;
                                }
                            }
                            if (diff)
                                break;
                        }
                        if (!diff) {
                            diff = r1.row - r2.row;
                        }
                        return diff;
                    });
                    sorts.forEach(s => delete s['_f_']);
                }
            }
            return rows;
        }
        $_buildRows() {
            const fields = this._fields;
            let rows = this._rows = this._data.getRows();
            const count = rows.length;
            if (this._filter.isNotEmpty()) {
                rows = this._filter.select(rows);
            }
            if (this._sortDirty || this._autoSort) {
                rows = this.$_sort(fields, rows);
                this._sortDirty = false;
            }
            if (this._postFilter.isNotEmpty()) {
                rows = this._postFilter.select(rows);
            }
            this._filtered = rows.length < count;
            if (!this._flags.isEmpty()) {
                for (const r of this._rows)
                    r.newIdx = -1;
                for (let i = rows.length - 1; i >= 0; i--)
                    rows[i].newIdx = i;
                this._flags._reset(this._rows, rows.length);
            }
            return rows;
        }
        $_isRowSelected(rows, r, oldValues) {
            return;
        }
        $_indexOfSort(field) {
            const sorts = this._sorts;
            if (sorts) {
                for (let i = 0; i < sorts.length; i++) {
                    if (sorts[i].field === field) {
                        return i;
                    }
                }
            }
            return -1;
        }
        $_removeSort(field) {
            const i = this.$_indexOfSort(field);
            if (i >= 0) {
                this._sorts.splice(i, 1);
                delete this._sortMap[field];
                return true;
            }
        }
        $_reset() {
            this._rows = this.$_buildRows();
            this._fireEvent('onDataReset');
        }
        $_getFilter(filter) {
            return this._filter.getFilter(filter) || this._postFilter.getFilter(filter);
        }
        $_filterChanged(build) {
            this._dirty = true;
            pickProp(build, true) && this.build(false);
            this.$_fireFilterChanged();
        }
        $_fireFilterChanged() {
            this._fireEvent('onDataViewFilterChanged');
            this.onFilterChange && this.onFilterChange({ dv: this.wrapperOrThis() });
        }
        $_fireSortChanged() {
            this._fireEvent('onDataViewSortChanged');
            this.onSortChange && this.onSortChange({ dv: this.wrapperOrThis() });
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     *
     * Filter panel.
     */
    class FilterPanel extends DialogPanel {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        _doInitDefaults() {
            super._doInitDefaults();
            this._autoApply = false;
            this.setOkLabel('Apply');
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * 개별 필터 항목 체크가 변경될 때마다 다시 필터링한다.
         * false면 ok/cancel 버튼을 표시하지 않는다.
         */
        autoApply() {
            return pickProp(this._autoApply, this._defs && this._defs._autoApply);
        }
        setAutoApply(value) {
            this._autoApply = value;
        }
        model() {
            return this._model;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        /**
         * filter 패널 호출 시 item들을 지정하지 않을 경우 기본 표시할 아이템들을 리턴한다.
         * 활성화된(enabled가 true) 모든 필터들을 리턴한다.
         */
        getItems() {
            return (this._model && this._model.filters) || this.$_getFilters();
        }
        setModel(model) {
            this._model = model;
        }
        prepare(data) {
            this._data = data;
        }
        unprepare() {
            this._data = null;
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        $_getFilters() {
            if (this._data instanceof ListDataView) {
                const filters = this._data.filter().children;
                const items = [];
                filters.forEach(f => {
                    items.push({
                        filter: f,
                        label: f.label || f.name
                    });
                });
                return items;
            }
            return [];
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    // panel type
    FilterPanel.TYPE = 'filter';

    ////////////////////////////////////////////////////////////////////////////////
    class ListSectionInflater {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(owner) {
            this._owner = owner;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        inflateStock(param) {
            const n = param.name;
            const owner = this._owner;
            const data = owner.data();
            switch (n) {
                case 'row_count':
                    return data ? data.rowCount() : 0;
                case 'leaf_count':
                    // data group일 때만 지원
                    return owner.leafRowCount();
                case 'check_count':
                    return owner.checkedRowCount();
                case 'no':
                    // NOTE: single row 모드에서만 지원
                    return isNaN(this.topRow) ? '' : this.topRow + 1;
                case 'is_landscape':
                    return owner.isLandscape();
                case 'is_portrait':
                    return owner.isPortrait();
                default:
                    if (n.endsWith('_sum')) {
                        if (data) {
                            const field = n.slice(0, -4);
                            return data.getSummary(field).sum;
                        }
                    }
                    else if (n.endsWith('_avg')) {
                        if (data) {
                            const field = n.slice(0, -4);
                            return data.getSummary(field).avg;
                        }
                    }
                    break;
            }
        }
    }
    /**
     * @internal
     *
     * List control의 일정 영역을 차지하는 view들의 모델 base class.
     */
    class ListSection extends DWrappableObject {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(owner, defaults) {
            super();
            this._owner = owner;
            this._defs = defaults;
            !defaults && this._doInitDefaults();
        }
        /**
         * 컨트롤 default option에 포함된 경우 호출된다.
         */
        _doInitDefaults() {
            this._visible = true;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        owner() {
            return this._owner;
        }
        data() {
            return this._owner.data();
        }
        /**
         * visible
         */
        visible() {
            return pickProp(this._visible, this._defs && this._defs._visible);
        }
        setVisible(value) {
            if (value !== this._visible) {
                this._visible = value;
                this._layoutChanged();
            }
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        _changed() {
            this._owner && this._owner.sectionChanged(this);
        }
        _layoutChanged() {
            this._owner && this._owner.sectionLayoutChanged(this);
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    ListSection.BUTTON_CLASS = 'dlist-section-button';
    /**
     * @internal
     *
     * DListLayout으로 view가 그려지는 section view의 모델 base class.
     */
    class LayoutedSection extends ListSection {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(owner, defaults) {
            super(owner, defaults);
            this._inflater = new ListSectionInflater(owner);
        }
        //-------------------------------------------------------------------------
        // IParamInflater
        //-------------------------------------------------------------------------
        inflateParam(target, field, param) {
            const n = param.name;
            if (this.templateParams) {
                const v = this.templateParams[n];
                if (v !== void 0)
                    return v;
            }
            const pv = this.layoutParams();
            return pv && pv[n];
        }
        inflateStock(target, field, param) {
            return this._inflater.inflateStock(param);
        }
        setTopRow(value) {
            this._inflater.topRow = value;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * template
         */
        template() {
            return pickProp(this._template, this._defs && this._defs._template);
        }
        setTemplate(value) {
            if (value !== this._template) {
                this._template = value;
                this._layoutChanged();
            }
        }
        /**
         * section 기본 스타일
         */
        style() {
            return pickProp(this._style, this._defs && this._defs._style);
        }
        setStyle(value) {
            if (value !== this._style) {
                this._style = value;
                this._changed();
            }
        }
        /**
         * section 내용의 기본 스타일
         */
        layoutStyle() {
            return pickProp(this._layoutStyle, this._defs && this._defs._layoutStyle);
        }
        setLayoutStyle(value) {
            if (value !== this._layoutStyle) {
                this._layoutStyle = value;
                this._changed();
            }
        }
        /**
         * template으로 부터 layout이 생성될 때 template param 들의 값 목록.
         * {@link paramCallback}으로 전달되는 값이 더 우선한다.
         */
        layoutParams() {
            return pickProp(this._layoutParams, this._defs && this._defs._layoutParams);
        }
        setLayoutParams(value) {
            let changed = false;
            if (!value) {
                if (this._layoutParams) {
                    this._layoutParams = value;
                    changed = true;
                }
            }
            else if (!Utils.equalObjects(value, this._layoutParams)) {
                this._layoutParams = Object.assign({}, value);
                changed = true;
            }
            if (changed) {
                this._changed();
            }
        }
        /**
         * @internal
         */
        layout() {
            const t = this.getTemplate();
            return {
                layout: LayoutFactory.Instance.layoutFromTemplate(this.wrapperOrThis(), this, false, false, t, this),
                rowStyle: this.style() || t.rowStyle && t.rowStyle.default
            };
        }
        getTemplate() {
            return this.owner().getTemplate(this.template()) || StockTemplates.get(this.defTemplate()) || DummyTemplate;
        }
        setLayoutItemProp(tag, prop, value) {
        }
        setLayoutItemsProp(group, prop, value) {
        }
        click() {
        }
    }
    var DListSectionButtonPosition;
    (function (DListSectionButtonPosition) {
        DListSectionButtonPosition["HEAD"] = "head";
        DListSectionButtonPosition["FOOT"] = "foot";
    })(DListSectionButtonPosition || (DListSectionButtonPosition = {}));
    /**
     * @internal
     */
    class ListSectionButton extends ListButton {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(config) {
            super(config);
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        getProxy() {
            const r = super.getProxy();
            r.position = this.position;
            r.action = this.action;
            return r;
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _setDefaults() {
            super._setDefaults();
            this.position = DListSectionButtonPosition.FOOT;
        }
        click(owner) {
            const a = this.action;
            if (a && a !== DListSectionAction.NONE) {
                ActionableSection.perform(owner, a);
            }
            else {
                super.click(owner);
            }
        }
    }
    /**
     * 섹션이나 섹션 버튼이 tap 됐을 때 실행되는 action 종류.
     *
     * @see DListActionableSection.clickAction
     * @see IListSectionButton.action
     */
    var DListSectionAction;
    (function (DListSectionAction) {
        /**
         * 아무것도 실행하지 않는다.
         * <br>
         */
        DListSectionAction["NONE"] = "none";
        /**
         * 폼 패널을 연다.
         * <br>
         */
        DListSectionAction["FORM"] = "form";
        /**
         * 버튼 패널을 연다.
         * <br>
         */
        DListSectionAction["BUTTON"] = "button";
        /**
         * 검색 패널을 연다.
         * <br>
         */
        DListSectionAction["SEARCH"] = "search";
        /**
         * @noimpl
         * 정렬 패널을 연다.
         * <br>
         */
        DListSectionAction["SORT"] = "sort";
        /**
         * 필터 패널을 연다.
         * <br>
         */
        DListSectionAction["FILTER"] = "filter";
        /**
         * {@link DListFieldBar 필드 Bar}를 표시하거나 감춘다.
         * <br>
         */
        DListSectionAction["FIELD"] = "field";
        /**
         * 컨트롤 {@link DListOptions}에 설정된 {@link DListOptions.menu}를 표시한다.
         * <br>
         */
        DListSectionAction["MENU"] = "menu";
    })(DListSectionAction || (DListSectionAction = {}));
    /**
     * @internal
     */
    class ActionableSection extends LayoutedSection {
        //-------------------------------------------------------------------------
        // static members
        //-------------------------------------------------------------------------
        static perform(owner, action) {
            switch (action) {
                case DListSectionAction.FORM:
                    owner.togglePanel(FormPanel.TYPE, true);
                    break;
                case DListSectionAction.BUTTON:
                    owner.togglePanel(ButtonPanel.TYPE, true);
                    break;
                case DListSectionAction.SEARCH:
                    owner.togglePanel(SearchPanel.TYPE, true);
                    break;
                case DListSectionAction.FILTER:
                    owner.togglePanel(FilterPanel.TYPE, true);
                    break;
                case DListSectionAction.FIELD:
                    owner.options().fieldBar().setVisible(!owner.options().fieldBar().visible());
                    break;
                case DListSectionAction.MENU:
                    owner.showMenu(null, true);
                    break;
            }
        }
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        _doInitDefaults() {
            super._doInitDefaults();
            this._buttonGap = 5;
            this._headButtons = [];
            this._footButtons = [];
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /** buttons */
        buttons() {
            const btns = pickProp(this._buttons, this._defs && this._defs._buttons);
            return btns && btns.slice(0);
        }
        setButtons(value) {
            if (value !== this._buttons) {
                this._buttons = value;
                this._listButtons = [];
                if (value) {
                    value.forEach(a => this._listButtons.push(new ListSectionButton(a)));
                }
                this.$_resetButtons();
                this._changed();
            }
        }
        buttonGap() {
            return pickProp(this._buttonGap, this._defs._buttonGap);
        }
        setButtonGap(value) {
            if (value !== this._buttonGap) {
                this._buttonGap = value;
                this._changed();
            }
        }
        clickAction() {
            return pickProp(this._clickAction, this._defs && this._defs._clickAction);
        }
        setClickAction(value) {
            if (value !== this._clickAction) {
                this._clickAction = value;
                this._changed();
            }
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        getButtonAt(pos, index) {
            const self = this._buttons !== void 0 ? this : this._defs;
            if (self) {
                return pos === DListSectionButtonPosition.HEAD ? self._headButtons[index] : self._footButtons[index];
            }
        }
        getButton(name) {
            const self = this._buttons !== void 0 ? this : this._defs;
            if (self) {
                const i = self.$_indexOfButton(name);
                return i >= 0 ? self._listButtons[i] : null;
            }
        }
        getButtons(position) {
            const self = this._buttons !== void 0 ? this : this._defs;
            if (self) {
                return position === DListSectionButtonPosition.HEAD ? self._headButtons : self._footButtons;
            }
        }
        /**
         * 기존에 동일한 이름의 action이 존재하면 속성들을 update하고,
         * 존재하지 않으면 새로 추가한다.
         */
        setButton(button) {
            if (button && button.name) {
                const i = this.$_indexOfButton(button.name);
                if (i >= 0) {
                    this._listButtons[i].update(button);
                }
                else {
                    const a = new ListSectionButton(button);
                    this._listButtons.push(a);
                }
                this.$_resetButtons();
            }
        }
        removeButton(name) {
            const i = this.$_indexOfButton(name);
            if (i >= 0) {
                this._listButtons.splice(i, 1);
                this.$_resetButtons();
            }
        }
        setButtonVisible(button, visible) {
            const b = this.$_getButton(button);
            if (b && b.visible !== visible) {
                b.visible = visible;
                this.$_resetButtons();
            }
        }
        setButtonEnabled(button, enabled) {
            const b = this.$_getButton(button);
            if (b && b.enabled !== enabled) {
                b.enabled = enabled;
                this.$_resetButtons();
            }
        }
        getButtonState(button) {
            const self = this._buttons !== void 0 ? this : this._defs;
            if (self) {
                const b = self.$_getButton(button);
                return b ? b.state : undefined;
            }
        }
        setButtonState(button, state) {
            const b = this.$_getButton(button);
            if (b)
                b.state = state;
        }
        click() {
            ActionableSection.perform(this.owner(), this.clickAction());
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        $_indexOfButton(name) {
            if (this._listButtons) {
                return this._listButtons.findIndex(action => action.name === name);
            }
            return -1;
        }
        $_getButton(name) {
            return this._listButtons && this._listButtons.find(act => act.name === name);
        }
        $_resetButtons() {
            const buttons = this._listButtons;
            this._headButtons = [];
            this._footButtons = [];
            if (buttons) {
                buttons.forEach(button => {
                    if (button.position === DListSectionButtonPosition.HEAD) {
                        this._headButtons.push(button);
                    }
                    else {
                        this._footButtons.push(button);
                    }
                });
                this._layoutChanged();
            }
        }
    }
    /**
     * @internal
     */
    class ListHeader extends ActionableSection {
        constructor() {
            super(...arguments);
            //-------------------------------------------------------------------------
            // fields
            //-------------------------------------------------------------------------
            this._checked = false;
            //-------------------------------------------------------------------------
            // internal members
            //-------------------------------------------------------------------------
        }
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        _doInitDefaults() {
            super._doInitDefaults();
            this._caption = ListHeader.CAPTION;
            this._showCheck = false;
            this._autoCheck = false;
            this.setVisible(false);
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * 리스트 헤더 기본 stock 템플릿에서 '@caption'으로 사용된다.
         *
         * @default 'Header'
         */
        caption() {
            return pickProp(this._caption, this._defs && this._defs._caption);
        }
        setCaption(value) {
            if (value !== this._caption) {
                this._caption = value;
                this._changed();
            }
        }
        /**
         * 리스트 헤더 기본 stock 템플릿에서 caption 문자열 정렬 스타일로 사용된다.
         *
         * @default 'Header'
         */
        captionAlign() {
            return pickProp(this._captionAlign, this._defs && this._defs._captionAlign);
        }
        setCaptionAlign(value) {
            if (value !== this._captionAlign) {
                this._captionAlign = value;
                this._changed();
            }
        }
        /**
         * 리스트 헤더 기본 stock 템플릿에서 caption 문자열 색상 스타일로 사용된다.
         */
        captionColor() {
            return pickProp(this._captionColor, this._defs && this._defs._captionColor);
        }
        setCaptionColor(value) {
            if (value !== this._captionColor) {
                this._captionColor = value;
                this._changed();
            }
        }
        /**
         * 체크박스 표시 여부.
         */
        showCheck() {
            return pickProp(this._showCheck, this._defs._showCheck);
        }
        setShowCheck(value) {
            if (value !== this._showCheck) {
                this._showCheck = value;
                this._changed();
            }
        }
        /**
         * 자동 check 모드.
         * true로 설정되면 컨트롤의 행이 모두 checked 상태가 되면 check되고,
         * 하나라도 checked가 아니면 check가 해제된다.
         */
        autoCheck() {
            return pickProp(this._autoCheck, this._defs._autoCheck);
        }
        setAutoCheck(value) {
            if (value != this._autoCheck) {
                this._autoCheck = value;
                this._changed();
            }
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        isChecked() {
            return this._checked;
        }
        setChecked(value = true) {
            if (value !== this._checked) {
                this._checked = value;
                this._changed();
            }
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        defTemplate() {
            return ListHeader.TEMPLATE;
        }
        getStyle() {
            return this.style();
        }
        inflateStock(target, field, param) {
            switch (param.name) {
                case 'caption':
                    return this.caption();
                case 'caption-align':
                    return this.captionAlign();
                case 'caption-color':
                    return this.captionColor();
                case 'style':
                    return this.layoutStyle();
                default:
                    return super.inflateStock(target, field, param);
            }
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    ListHeader.CAPTION = 'Header';
    ListHeader.TEMPLATE = '@it_list_header';
    ListHeader.ROW = -1;
    /**
     * @internal
     *
     * 리스트 컨트롤의 footer view model.
     * 데이터행들의 합계 등 요약 정보를 표시하는 데 사용될 수 있다.
     * 기본적으로 컨트롤 하단에 고정적으로 표시되지만,
     * 데이터행과 마찬가지로 {@link template 템플릿}으로 표시 내용을 설정한다.
     */
    class ListFooter extends ActionableSection {
        //-------------------------------------------------------------------------
        // property fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        _doInitDefaults() {
            super._doInitDefaults();
            // this.setFixed(false);
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        defTemplate() {
            return ListFooter.TEMPLATE;
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    ListFooter.TEMPLATE = '@it_list_footer';
    ListFooter.ROW = -2;

    ////////////////////////////////////////////////////////////////////////////////
    class DLayoutedElement extends DListElement {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(doc, className) {
            super(doc, true, className);
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        dv() {
            return null;
        }
        row() {
            return -1;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        setLayout(layout) {
            this._layoutChanged = !this._layout || (layout.tid !== this._layout.tid);
            this._layout = layout;
        }
        getRenderer(dom) {
            return this._layoutView instanceof ListLayoutView && this._layoutView.getRenderer(dom);
        }
        simpleViewByDom(dom, deep) {
            return this._layoutView instanceof ListLayoutView && this._layoutView.simpleByDom(dom, deep);
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doPrepareRender(doc, hint) {
            this._layout.setRow(this.dv(), this.row(), -1);
            if (this._layoutChanged && this._layoutView) {
                this.removeChild(this._layoutView);
                this._layoutView = null;
            }
            if (!this._layoutView) {
                this.addChild(this._layoutView = hint.createLayoutView(doc, this._layout));
                this._layoutView.build(doc, hint);
            }
            else {
                // child들의 layout 모델을 갱신한다.
                this._layoutView.refreshModels(this._layout); // as any는 ListItemView 참조.
            }
            this._owner = hint;
        }
        _doMeasure(doc, hintWidth, hintHeight) {
            this._layoutView._explicitWidth = hintWidth;
            // const sz = this._layoutView.measure(doc, this._owner, hintWidth, hintHeight);
            this._layoutView.prepareLayout(doc, this._owner);
            const sz = this._layoutView.measureLayout(doc, this._owner, hintWidth, hintHeight);
            return sz;
        }
        _doRender(doc, width, height) {
            this.resizeContent(width, height);
            this._layoutView.resize(width, height);
            this._layoutView.render(doc);
        }
        _doAfterRender() {
            this._layoutChanged = false;
            this._owner = null;
        }
    }
    /**
     * @internal
     *
     * View base for DListSection model.
     */
    class ListSectionView extends DListElement {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(doc, model, className) {
            super(doc, true, className);
            this._model = model;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /** model */
        model() {
            return this._model;
        }
        setModel(value) {
            this._model = value;
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doMeasure(doc, hintWidth, hintHeight) {
            const p = this._padding = this.getPadding();
            hintWidth -= p.left + p.right;
            hintHeight -= p.top + p.bottom;
            const sz = this._doMeasureContent(doc, hintWidth, hintHeight);
            sz.width += p.left + p.right;
            sz.height += p.top + p.bottom;
            return sz;
        }
        _doRender(doc, width, height) {
            const p = this._padding;
            width -= p.left + p.right;
            height -= p.top + p.bottom;
            this._doRenderContent(doc, width, height);
        }
    }
    class LayoutedSectionView extends ListSectionView {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(doc, model, className) {
            super(doc, model, className);
            this._layoutChanged = false;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        // for TESTING
        layoutView() {
            return this._layoutView;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        setLayout(layout) {
            // layout 객체 자체는 매번 새로 생성된다.
            // id는 템플릿 id이다.
            // param으로 설정된 속성들의 값이 매번 달라질 수 있다.
            this._layoutChanged = !this._layout || layout.layout.tid !== this._layout.tid;
            this._layout = layout.layout;
            this._rowStyle = layout.rowStyle;
        }
        click(dom, x, y) {
            this.model().click();
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        clickable() {
            return true;
        }
        _doInitContent(doc, div) {
            Object.assign(div.style, {
                overflow: 'hidden',
            });
            super._doInitContent(doc, div);
        }
        /**
         * @param manager 현재 {@link ListView}에서 구현.
         */
        _doPrepareRender(doc, manager) {
            manager.layoutContainer = this._model;
            if (this._layoutChanged && this._layoutView) {
                this.removeChild(this._layoutView);
                this._layoutView = null;
            }
            if (!this._layoutView) {
                this.addChild(this._layoutView = manager.createLayoutView(doc, this._layout));
                this._layoutView.build(doc, manager);
            }
            else {
                // child들의 layout 모델을 갱신한다.
                this._layoutView.refreshModels(this._layout); // as any는 ListItemView 참조.
            }
            this._layoutManager = manager;
        }
        _doApplyStyles(css) {
            if (typeof this._rowStyle === 'string') ;
            else if (this._rowStyle) {
                Object.assign(css, this._rowStyle);
            }
        }
        _doMeasureContent(doc, hintWidth, hintHeight) {
            this._layoutView._explicitWidth = hintWidth;
            this._layoutView.prepareLayout(doc, this._layoutManager);
            return this._layoutView.measureLayout(doc, this._layoutManager, hintWidth, hintHeight);
        }
        _doRenderContent(doc, width, height) {
            this.resizeContent(width, height);
            this._layoutView.resize(width, height);
            this._layoutView.render(doc);
        }
        _doAfterRender() {
            this._layoutChanged = false;
            this._layoutManager = null;
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    class SectionButtonView extends ButtonElement {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(doc) {
            super(doc, ListSection.BUTTON_CLASS);
        }
        _doDestory() {
            this.model = null;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        setModel(control, model) {
            this.model = model;
            this._setModel(control, model);
            return this;
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        click(owner) {
            this.model.click(owner);
        }
    }
    /**
     * @internal
     *
     * View for ActionableSection model.
     */
    class ActionableSectionView extends LayoutedSectionView {
        constructor() {
            super(...arguments);
            this._headButtons = [];
            this._footButtons = [];
            this._visHeadButtons = [];
            this._visTailButtons = [];
            this._gap = 0;
        }
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doInitContent(doc, div) {
            this.addChild(this._headView = new DElement(doc, false, ActionableSectionView.HEAD_CLASS));
            this.addChild(this._tailView = new DElement(doc, false, ActionableSectionView.TAIL_CLASS));
        }
        _doPrepareRender(doc, manager) {
            super._doPrepareRender(doc, manager);
            const m = this.model();
            this.$_prepareActions(doc, m);
            this._gap = m.buttonGap() || 0;
        }
        _doMeasureContent(doc, hintWidth, hintHeight) {
            const szHead = this._doMeasureHead(doc, hintWidth);
            const szFoot = this._doMeasureTail(doc, hintWidth);
            hintWidth -= this._wHead = szHead.width;
            hintWidth -= this._wTail = szFoot.width;
            this._layoutView._explicitWidth = hintWidth;
            // const sz = this._layoutView.measure(doc, this._layoutManager, hintWidth, hintHeight);
            this._layoutView.prepareLayout(doc, this._layoutManager);
            this._layoutView.measureLayout(doc, this._layoutManager, hintWidth, hintHeight);
            const sz = this._layoutView.measureLayout(doc, this._layoutManager, hintWidth, hintHeight);
            sz.width += this._wHead + this._wTail;
            sz.height = Math.max(sz.height, this._hHead = szHead.height, this._hTail = szFoot.height);
            return sz;
        }
        _doMeasureHead(doc, hintSize) {
            return this.$_measureButtons(this._headActions, this._headButtons, this._visHeadButtons = []);
        }
        _doMeasureTail(doc, hintSize) {
            return this.$_measureButtons(this._tailActions, this._footButtons, this._visTailButtons = []);
        }
        _doRenderContent(doc, width, height) {
            let w = width;
            let x = 0;
            this.resizeContent(width, height);
            if (this._wHead > 0) {
                this._headView.move(x, (height - this._hHead) / 2);
                this._doRenderHead(this._headView, this._wHead, this._hHead);
                w -= this._wHead;
                x += this._wHead;
            }
            if (this._wTail > 0) {
                this._tailView.move(width - this._wTail, (height - this._hTail) / 2);
                this._doRenderTail(this._tailView, this._wTail, this._hTail);
                w -= this._wTail;
            }
            this._layoutView.move(x, 0);
            this._layoutView.resize(w, height);
            this._layoutView.render(doc);
        }
        _doRenderHead(view, w, h) {
            let x = 0;
            let y = 0;
            this._visHeadButtons.forEach(button => {
                button.move(x, y);
                x += button.width + this._gap;
            });
        }
        _doRenderTail(view, w, h) {
            let x = this._gap;
            let y = 0;
            this._visTailButtons.forEach(button => {
                button.move(x, y);
                x += button.width + this._gap;
            });
        }
        _doAfterRender() {
            super._doAfterRender();
            this._headActions = this._tailActions = null;
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        $_prepareActions(doc, model) {
            let actions = this._headActions = model.getButtons(DListSectionButtonPosition.HEAD);
            let buttons = this._headButtons;
            while (buttons.length < actions.length) {
                const button = new SectionButtonView(doc);
                this._headView.addChild(button);
                buttons.push(button);
            }
            while (buttons.length > actions.length) {
                this._headView.removeChild(buttons.pop());
            }
            actions = this._tailActions = model.getButtons(DListSectionButtonPosition.FOOT);
            buttons = this._footButtons;
            while (buttons.length < actions.length) {
                const button = new SectionButtonView(doc);
                this._tailView.addChild(button);
                buttons.push(button);
            }
            while (buttons.length > actions.length) {
                this._tailView.removeChild(buttons.pop());
            }
        }
        $_measureButtons(actions, buttons, vButtons) {
            const control = this.control;
            let w = 0;
            let h = 0;
            buttons.forEach((button, i) => {
                const action = actions[i];
                if (action.visible) {
                    button.visible = true;
                    button.setEnabled(action.isEnabled(control.wrapperOrThis()));
                    vButtons.push(button);
                    button.setModel(control, action).syncSize();
                    w += button.width + this._gap;
                    h = Math.max(h, button.height);
                }
                else {
                    button.visible = false;
                }
            });
            return { width: w, height: h };
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    ActionableSectionView.HEAD_CLASS = 'dlist-section-head';
    ActionableSectionView.TAIL_CLASS = 'dlist-section-foot';

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     *
     * View for {@link ListFooter} model.
     */
    class ListFooterView extends ActionableSectionView {
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(doc, model) {
            super(doc, model, ListFooterView.CLASS_NAME);
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    ListFooterView.CLASS_NAME = 'dlist-footer';

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     *
     * View for {@link DListHeader} model.
     */
    class ListHeaderView extends ActionableSectionView {
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(doc, model) {
            super(doc, model, ListHeaderView.CLASS_NAME);
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    ListHeaderView.CLASS_NAME = 'dlist-header';

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     *
     * View of LinearLayout.
     * SpaceRenderer 양끝에는 gap을 적용하지 않는다.
     * 자식 layout view들이 상대 크기가 되려면 본 layout view가 고정 크기를 가지거나,
     * 상대 크기가 설정되지 않은 자식 view가 하나 이상 존재해야 한다.
     *
     * TODO: 모든 child가 고정일 때, explicit 사이즈로 child measure를 한 번만 실행 (옳은가?)
     *       30, (0(width), 1(grow)), (0, 1), ....
     */
    class LinearLayoutView extends ListLayoutView {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(doc, model) {
            super(doc, model);
        }
    }
    /**
     * @internal
     *
     * View of HLinearLayout.
     * _explicitWidth가 설정되지 않은 경우 자식들에 설정된 relative width들은 의미가 없다.
     * 그 경우 spacer 너비들은 0이 되고, 나머지는 계산된 너비로 설정된다.
     */
    class HLinearLayoutView extends LinearLayoutView {
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        isCheckVertExplicits() {
            return true;
        }
        _doPrepareRender(doc, manager) {
            super._doPrepareRender(doc, manager);
            // prepare children
            this._gaps = [];
            this._szGap = 0;
            if (this._visibles.length > 0) {
                const model = this.model();
                const gap = model.itemGap;
                const gaps = this._gaps;
                let prevSpace = true;
                this._visibles.forEach(child => {
                    child.prepareView(manager);
                    if (child.isSpacer()) {
                        gaps.push(0);
                        prevSpace = true;
                    }
                    else {
                        if (prevSpace) {
                            gaps.push(0);
                            prevSpace = false;
                        }
                        else {
                            gaps.push(gap);
                            this._szGap += gap;
                        }
                    }
                });
            }
        }
        _doMeasureLayout(doc, hint, maxWidth, maxHeight) {
            const visibles = this._visibles;
            let wCalced = this.mw;
            let hCalced = this.mh;
            maxWidth -= this._szGap;
            // 모두 계산되지 않았다면 자식들을 계산해서 더한다.
            if (maxWidth !== this._prevMax.width) {
                let wSum = 0;
                let hMax = 0;
                this._measureChildren(visibles, doc, hint, maxWidth, maxHeight, v => {
                    wSum += v.mw;
                    hMax = Math.max(hMax, v.mh);
                });
                wCalced = wSum;
                hCalced = hMax;
                this._prevMax.width = maxWidth;
            }
            if (!isNaN(this._explicitWidth)) {
                // 계산된 크기가 넘치거나 모자라면 조정한다.
                const dw = maxWidth - wCalced;
                let need = false;
                // 모자라면 shrink로 조정한다.
                // 본래 길이에 대한 상대값을 뺀다. 그래야 본 너비가 0인것이 0이된다.
                if (dw < 0 && this._model.canShrink()) {
                    const shrinks = [];
                    let wShrink = 0;
                    let wSum = 0;
                    for (const v of visibles) {
                        const s = pickNum(v.model().getChildProp('shrink'), 1);
                        if (s > 0) {
                            shrinks.push(v);
                            wShrink += v._expand = s;
                        }
                        wSum += v.mw;
                    }
                    if (need = wShrink !== 0) {
                        let dw = wSum - maxWidth;
                        let wSum2 = 0;
                        if (wShrink >= 1) {
                            // 본래 길이에 대한 상대값을 뺀다. 그래야 본 너비가 0인것이 0이된다.
                            for (const v of shrinks) {
                                wSum2 += v.mw * v._expand;
                            }
                            for (const v of shrinks) {
                                const w = v.mw - v._expand * v.mw / wSum2 * dw;
                                v.measureLayout(doc, hint, w, maxHeight);
                                v.mw = w;
                            }
                        }
                        else if (wShrink > 0) {
                            // shrink 합만큼 뺀다.
                            dw *= wShrink;
                            // 본래 길이에 대한 상대값을 뺀다. 그래야 본 너비가 0인것이 0이된다.
                            for (const v of shrinks) {
                                wSum2 += v.mw;
                            }
                            wShrink = 0;
                            for (const v of shrinks) {
                                wShrink += v._expand *= v.mw / wSum2;
                            }
                            for (const v of shrinks) {
                                const w = v.mw - dw * v._expand / wShrink;
                                v.measureLayout(doc, hint, w, maxHeight);
                                v.mw = w;
                            }
                        }
                    }
                }
                // 넘치면 grow로 조정한다.
                // 본래 길이와 상관없이 남은 너비를 grow 설정 비율대로 증가시킨다. 그래야 0인 너비도 커진다.
                else if (dw > 0 && this._model.canGrow()) {
                    const grows = [];
                    let wGrow = 0;
                    let wSum = 0;
                    for (const v of visibles) {
                        const s = pickNum(v.model().getChildProp('grow'), 0);
                        if (s > 0) {
                            grows.push(v);
                            wGrow += v._expand = s;
                        }
                        wSum += v.mw;
                    }
                    if (need = wGrow !== 0) {
                        let dw = maxWidth - wSum;
                        for (const v of grows) {
                            const w = v.mw + dw * v._expand / wGrow;
                            v.measureLayout(doc, hint, w, maxHeight);
                            v.mw = w;
                        }
                    }
                }
                if (need) {
                    let w = 0;
                    let h = 0;
                    visibles.forEach(v => {
                        w += v.mw;
                        h = Math.max(h, v.mh);
                    });
                    wCalced = w;
                    hCalced = h;
                }
            }
            return { width: wCalced + this._szGap, height: hCalced };
        }
        _doLayoutContent(doc, width, height) {
            const model = this._model;
            const visibles = this._visibles;
            const cnt = visibles.length;
            const gaps = this._gaps;
            let x = 0;
            const xOld = x;
            visibles.forEach((child, i) => {
                const g = gaps[i];
                child.mx = x + g;
                x += child.mw + g;
            });
            const wSum = x - xOld;
            width -= wSum;
            // 남는 경우 arrange
            if (width > 1) {
                const arrange = model.itemsArrange;
                let dx = 0;
                switch (arrange) {
                    case DListItemsArrange.CENTER:
                        dx = width / 2 | 0;
                        break;
                    case DListItemsArrange.END:
                        dx = width | 0;
                        break;
                    case DListItemsArrange.SPACE_BETWEEN:
                        let between = true;
                    case DListItemsArrange.SPACE_AROUND:
                        {
                            const gap = width / (between ? (cnt - 1) : (cnt + 1));
                            let dx = between ? 0 : gap;
                            visibles.forEach((child) => {
                                child.mx += dx | 0;
                                dx += gap;
                            });
                        }
                        break;
                }
                if (dx !== 0) {
                    visibles.forEach((child) => {
                        child.mx += dx;
                    });
                }
            }
            // 아이템들의 수직 정렬
            const align = model.itemsAlign;
            visibles.forEach((child) => {
                const m = child.model();
                const top = m.getTopIn(height);
                const bottom = m.getBottomIn(height);
                let y;
                // 자식의 높이가 넘치지 않게...
                if (child.mh > height || child.isSpacer()) {
                    child.mh = height;
                }
                if (!isNaN(top)) {
                    y = top;
                }
                else if (!isNaN(bottom)) {
                    y = height - child.mh - bottom;
                }
                else if (align === DListVerticalAlign.TOP) {
                    y = 0;
                }
                else if (align === DListVerticalAlign.BOTTOM) {
                    y = height - child.mh;
                }
                else {
                    y = (height - child.mh) / 2;
                }
                child.my = y;
                child.applyMeasuredBounds();
            });
        }
    }
    /**
     * @internal
     *
     * View of VLinearLayout.
     *
     */
    class VLinearLayoutView extends LinearLayoutView {
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        isCheckHorzExplicits() {
            return true;
        }
        _doPrepareRender(doc, manager) {
            super._doPrepareRender(doc, manager);
            // prepare children
            this._gaps = [];
            this._szGap = 0;
            if (this._visibles.length > 0) {
                const model = this.model();
                const gap = model.itemGap;
                const gaps = this._gaps;
                let prevSpace = true;
                this._visibles.forEach((child, i) => {
                    child.prepareView(manager);
                    if (child.isSpacer()) {
                        gaps.push(0);
                        prevSpace = true;
                    }
                    else {
                        if (prevSpace) {
                            gaps.push(0);
                            prevSpace = false;
                        }
                        else {
                            gaps.push(gap);
                            this._szGap += gap;
                        }
                    }
                });
            }
        }
        _doMeasureLayout(doc, hint, maxWidth, maxHeight) {
            const visibles = this._visibles;
            let wCalced = this.mw;
            let hCalced = this.mh;
            maxHeight -= this._szGap;
            // 모두 계산되지 않았다면 자식들을 계산해서 더한다.
            if (maxHeight !== this._prevMax.height) {
                let hSum = 0;
                let wMax = 0;
                this._measureChildren(visibles, doc, hint, maxWidth, maxHeight, v => {
                    hSum += v.mh;
                    wMax = Math.max(wMax, v.mw);
                });
                hCalced = hSum;
                wCalced = wMax;
                this._prevMax.height = maxHeight;
            }
            if (!isNaN(this._explicitHeight)) {
                // 계산된 크기가 넘치거나 모자라면 조정한다.
                const dh = maxHeight - hCalced;
                let need = false;
                // 모자라면 shrink로 조정한다.
                // 본래 길이에 대한 상대값을 뺀다. 그래야 본 너비가 0인것이 0이된다.
                if (dh < 0 && this._model.canShrink()) {
                    const shrinks = [];
                    let hShrink = 0;
                    let hSum = 0;
                    for (const v of visibles) {
                        const s = pickNum(v.model().getChildProp('shrink'), 1);
                        if (s > 0) {
                            shrinks.push(v);
                            hShrink += v._expand = s;
                        }
                        hSum += v.mh;
                    }
                    if (need = hShrink !== 0) {
                        let dh = hSum - maxHeight;
                        let hSum2 = 0;
                        if (hShrink >= 1) {
                            // 본래 길이에 대한 상대값을 뺀다. 그래야 본 높이가 0인것이 0이된다.
                            for (const v of shrinks) {
                                hSum2 += v.mh * v._expand;
                            }
                            for (const v of shrinks) {
                                const h = v.mh - v._expand * v.mh / hSum2 * dh;
                                v.measureLayout(doc, hint, maxWidth, h);
                                v.mh = h;
                            }
                        }
                        else if (hShrink > 0) {
                            // shrink 합만큼 뺀다.
                            dh *= hShrink;
                            // 본래 길이에 대한 상대값을 뺀다. 그래야 본 높이가 0인것이 0이된다.
                            for (const v of shrinks) {
                                hSum2 += v.mh;
                            }
                            hShrink = 0;
                            for (const v of shrinks) {
                                hShrink += v._expand *= v.mh / hSum2;
                            }
                            for (const v of shrinks) {
                                const h = v.mh - dh * v._expand / hShrink;
                                v.measureLayout(doc, hint, maxWidth, h);
                                v.mh = h;
                            }
                        }
                    }
                }
                // 넘치면 grow로 조정한다.
                // 본래 길이와 상관없이 남은 너비를 grow 설정 비율대로 증가시킨다. 그래야 0인 너비도 커진다.
                else if (dh > 0 && this._model.canGrow()) {
                    const grows = [];
                    let hGrow = 0;
                    let hSum = 0;
                    for (const v of visibles) {
                        const s = pickNum(v.model().getChildProp('grow'), 0);
                        if (s > 0) {
                            grows.push(v);
                            hGrow += v._expand = s;
                        }
                        hSum += v.mh;
                    }
                    if (need = hGrow !== 0) {
                        let dh = maxHeight - hSum;
                        for (const v of grows) {
                            const h = v.mh + dh * v._expand / hGrow;
                            v.measureLayout(doc, hint, maxWidth, h);
                            v.mh = h;
                        }
                    }
                }
                if (need) {
                    let h = 0;
                    let w = 0;
                    visibles.forEach(v => {
                        h += v.mh;
                        w = Math.max(w, v.mw);
                    });
                    wCalced = w;
                    hCalced = h;
                }
            }
            return { width: wCalced, height: hCalced + this._szGap };
        }
        _doLayoutContent(doc, width, height) {
            const model = this._model;
            const visibles = this._visibles;
            const cnt = visibles.length;
            const gaps = this._gaps;
            let y = 0;
            const yOld = y;
            visibles.forEach((child, i) => {
                const g = gaps[i];
                child.my = y + g;
                y += child.mh + g;
            });
            const hSum = y - yOld;
            height -= hSum;
            // 남는 경우 arrange
            if (height > 1) {
                const arrange = model.itemsArrange;
                let dy = 0;
                switch (arrange) {
                    case DListItemsArrange.CENTER:
                        dy = height / 2 | 0;
                        break;
                    case DListItemsArrange.END:
                        dy = height | 0;
                        break;
                    case DListItemsArrange.SPACE_BETWEEN:
                        let between = true;
                    case DListItemsArrange.SPACE_AROUND:
                        {
                            const gap = height / (between ? (cnt - 1) : (cnt + 1));
                            let dy = between ? 0 : gap;
                            visibles.forEach((child) => {
                                child.my += dy | 0;
                                dy += gap;
                            });
                        }
                        break;
                }
                if (dy !== 0) {
                    visibles.forEach((child) => {
                        child.my += dy;
                    });
                }
            }
            // 아이템들의 수평 정렬
            const align = model.itemsAlign;
            visibles.forEach((child) => {
                const m = child.model();
                const left = m.getLeftIn(width);
                const right = m.getRightIn(width);
                let x;
                // 자식의 너비가 넘치지 않게...
                if (child.mw > width || child.isSpacer()) {
                    child.mw = width;
                }
                if (!isNaN(left)) {
                    x = left;
                }
                else if (!isNaN(right)) {
                    x = width - child.mw - right;
                }
                else if (align === DListHorizontalAlign.LEFT) {
                    x = 0;
                }
                else if (align === DListHorizontalAlign.RIGHT) {
                    x = width - child.mw;
                }
                else {
                    x = (width - child.mw) / 2;
                }
                child.mx = x;
                child.applyMeasuredBounds();
            });
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     *
     * View of {@link FrameLayout}.

     * 자식들의 위치를 left|right|top|bottom 고정값 혹은 %값으로 지정된다.
     * 위치를 지정하지 않으면 상하/좌우 중앙에 표시된다.
     */
    class FrameLayoutView extends PositionableLayoutView {
        //-------------------------------------------------------------------------
        // consts
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // static members
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // property fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        // private _calcedWidth: number;
        // private _calcedHeight: number;
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(doc, model) {
            super(doc, model);
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doPrepareRender(doc, manager) {
            super._doPrepareRender(doc, manager);
            // prepare children
            this._visibles.forEach(view => {
                view.prepareView(manager);
                view.setRelativePositions();
            });
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     *
     * View of DGridLayout.
     */
    class GridLayoutView extends ListLayoutView {
        //-------------------------------------------------------------------------
        // consts
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // static members
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // property fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(doc, model) {
            super(doc, model);
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        // protected _doMeasureContent(doc: Document, hintWidth: number, hintHeight: number): ISize {
        //     return;
        // }
        _doLayoutContent(doc, width, height) {
        }
        _doMeasureLayout(doc, hint, maxWidth, maxHeight) {
            this._measureChildren(this._visibles, doc, hint, maxWidth, maxHeight, null);
            return; // this._doMeasureContent(doc, maxWidth, maxHeight);
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * 스크롤 인디케이터 표시 크기 기준.
     * <br>
     * 행단위 혹은 페이징 상태일 때 페이지 기준으로 현재 스크롤 상태를 표시할 수 있다.
     * {@link DListScrollIndicatorMode.AUTO}로 지정하면 페이징 상태일 때는 페이지 단위로,
     * 그 밖에는 데이터 행 수 기준으로 표시한다.
     * 페이징이 아닐 때 {@link DListScrollIndicatorMode.PAGE}로 지정하는 것은 의미가 없다.
     * {@link DScrollIndicator.mode} 속성으로 설정한다.
     *
     * @see concepts.scrolling 스크롤 개요
     * @see concepts.paging 페이징 개요
     */
    var DListScrollIndicatorMode;
    (function (DListScrollIndicatorMode) {
        /**
         * {@link DListControl.isPaging 페이징} 상태면 페이지 단위로,
         * 아니면 행 단위로 스크롤 위치를 표시한다.
         */
        DListScrollIndicatorMode["AUTO"] = "auto";
        /**
         * 행 단위로 스크롤 위치를 표시한다.
         */
        DListScrollIndicatorMode["ROW"] = "row";
        /**
         * page 단위로 스크롤 위치를 표시한다.
         */
        DListScrollIndicatorMode["PAGE"] = "page";
    })(DListScrollIndicatorMode || (DListScrollIndicatorMode = {}));
    /**
     * @internal
     *
     * 컨트롤 상단이나 하단에 얇은 bar로 스크롤 상태를 표시한다.
     * 행 단위의 스크롤 범위를 표시한다.
     *
     * TODO: no-cache 모드에서는 pixel 단위 스크롤이 가능하게 한다.
     */
    class ScrollIndicator extends PositionableControlObject {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        _doInitDefaults() {
            super._doInitDefaults();
            this._mode = DListScrollIndicatorMode.AUTO;
            this._barWidth = ScrollIndicator.DEF_BAR_WIDTH;
            this._showSelection = true;
            this._tooltipVisible = false;
            this._tooltipValue = 'top';
            this._firstTooltip = 'First';
            this._lastTooltip = 'Last';
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * 스크롤 인디케이터 표시 크기 기준. {@link DListScrollIndicatorMode} 참조.
         */
        mode() {
            return pickProp(this._mode, this._defs && this._defs._mode);
        }
        setMode(value) {
            if (value !== this._mode) {
                this._mode = value;
                this._changed();
            }
        }
        /**
         * 인디케이터 폭.
         * 숫자로 변환되지 않는 값을 지정하면 기본 너비가 사용된다.
         */
        barWidth() {
            return pickProp(this._barWidth, this._defs && this._defs._barWidth);
        }
        setBarWidth(value) {
            value = toNumProp(value);
            if (value !== this._barWidth) {
                this._barWidth = value;
                this._changed();
            }
        }
        /**
         * 컨트롤 선택 영역 다른 색상으로 범위를 표시한다.
         */
        showSelection() {
            return pickProp(this._showSelection, this._defs && this._defs._showSelection);
        }
        setShowSelection(value) {
            if (value !== this._showSelection) {
                this._showSelection = value;
                this._changed();
            }
        }
        /**
         * 인디케이터를 클릭한 지점에 해당하는 데이터행 위치로 스크롤한다.
         */
        clickable() {
            return pickProp(this._clickable, this._defs && this._defs._clickable);
        }
        setClickable(value) {
            if (value !== this._clickable) {
                this._clickable = value;
                this._changed();
            }
        }
        /**
         * 스크롤 위치를 표시하는 툴팁 표시 여부.
         */
        tooltipVisible() {
            return pickProp(this._tooltipVisible, this._defs && this._defs._tooltipVisible);
        }
        setTooltipVisible(value) {
            this._tooltipVisible = value;
        }
        /**
         * 툴팁에 표시할 값.
         */
        tooltipValue() {
            return pickProp(this._tooltipValue, this._defs && this._defs._tooltipValue);
        }
        setTooltipValue(value) {
            return this._tooltipValue = value;
        }
        /**
         * 첫 스크롤 위치일 때 메시지
         */
        firstTooltip() {
            return pickProp(this._firstTooltip, this._defs && this._defs._firstTooltip);
        }
        setFirstTooltip(value) {
            this._firstTooltip = value;
        }
        /**
         * 미자믹 스크롤 위치일 때 메시지
         */
        lastTooltip() {
            return pickProp(this._lastTooltip, this._defs && this._defs._lastTooltip);
        }
        setLastTooltip(value) {
            this._lastTooltip = value;
        }
        /**
         * 툴팁 스타일셋.
         */
        tooltipStyle() {
            return pickProp(this._tooltipStyle, this._defs && this._defs._tooltipStyle);
        }
        setTooltipStyle(value) {
            if (value !== this._tooltipStyle) {
                this._tooltipStyle = value;
                this._changed('style');
            }
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doPrepareRender() {
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    ScrollIndicator.DEF_BAR_WIDTH = 4;

    ////////////////////////////////////////////////////////////////////////////////
    class TooltipView extends TooltipElement {
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(doc) {
            super(doc, false, 'dlist-scroll-indicator-tooltip');
        }
        //-------------------------------------------------------------------------
        // members
        //-------------------------------------------------------------------------
        setText(s) {
            this.dom.textContent = s;
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _getDisplayStyle() {
            return 'inline-block';
        }
    }
    /**
     * @internal
     *
     * View for DScrollIndicator.
     * 스크롤 범위 및 선택 영역 범위를 표시한다.
     */
    class ScrollIndicatorView extends PositonableControlElement {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(doc, model) {
            super(doc, model, false, ScrollIndicatorView.CLASS_NAME);
            //-------------------------------------------------------------------------
            // property fields
            //-------------------------------------------------------------------------
            this._rate = 0;
            this._tipHandler = () => {
                if (+new Date() - this._tipped >= ScrollIndicatorView.TIP_DELAY) {
                    this.$_clearTipTimers();
                    if (this.canAnimate()) {
                        const ani = this._tip.dom.animate([
                            { opacity: 1 },
                            { opacity: 0 }
                        ], {
                            duration: 700,
                            fill: 'none'
                        });
                        ani.addEventListener('finish', () => {
                            this.listOwner().removeTooltipView(this._tip);
                        });
                    }
                    else {
                        this.listOwner().removeTooltipView(this._tip);
                    }
                }
            };
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /** rate */
        rate() {
            return this._rate;
        }
        setRate(value, render) {
            if (value !== this._rate) {
                this._rate = value;
                render && this.$_render();
            }
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        updateRate(owner, lastPos, lastHeight, lastOff, render) {
            if (this.visible) {
                const data = owner.data();
                let tip = this._tip;
                if (data) {
                    const paging = owner.isPaging();
                    let rate;
                    if (paging && this._model.mode() !== DListScrollIndicatorMode.ROW) {
                        rate = (owner.page() + 1) / owner.pageCount();
                    }
                    else {
                        const n = owner.isGrouped() ? owner.groupModel().visItemCount() : data.rowCount();
                        rate = (lastPos + 1 - (1 - lastOff / lastHeight)) / n;
                        // console.log(owner.scrollIndex() + 1, lastPos + 1, '/', n);
                    }
                    this.setRate(rate, render);
                    if (this._model.tooltipVisible()) {
                        if (tip) {
                            // getAnimations()를 지원하는 경우
                            if (tip.dom.getAnimations) {
                                const anis = tip.dom.getAnimations();
                                anis && anis.forEach(ani => ani.finish());
                            }
                            else {
                                // TODO: 이렇게 하면 기존 animation이 제거되나?
                                owner.removeTooltipView(tip);
                            }
                        }
                        else {
                            tip = this._tip = new TooltipView(owner.doc());
                        }
                        if (!tip.parent && !isNaN(this._tipped)) {
                            owner.addTooltipView(tip);
                        }
                        if (tip.parent) {
                            const p = owner.scrollIndex();
                            const s = p === 0 ? 'First' : rate >= 1 ? 'Last' : `${p + 1} / ${data.rowCount()}`;
                            tip.setText(s);
                            const w = tip.getOffsetSize().width;
                            const x = this.width * rate - w / 2;
                            tip.moveX(Math.max(0, Math.min(x, this.width - w)));
                            tip.moveY(this.height + 2);
                            if (!this._tipTimer) {
                                this._tipTimer = setInterval(this._tipHandler, 100);
                            }
                        }
                        this._tipped = +new Date();
                    }
                    else if (tip) {
                        owner.removeTooltipView(tip);
                        this.$_clearTipTimers();
                    }
                }
                else {
                    this.setRate(0, render);
                    tip && owner.removeTooltipView(tip);
                    this.$_clearTipTimers();
                }
            }
            else {
                this.$_clearTipTimers();
            }
        }
        $_clearTipTimers() {
            if (this._tipTimer) {
                clearInterval(this._tipTimer);
                this._tipTimer = void 0;
            }
            this._tipped = NaN;
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doInitDom(doc, dom) {
            this._bar = this.appendSpan(doc, ScrollIndicatorView.BAR_CLASS);
            Object.assign(this._bar.style, {
                position: 'absolute',
                height: '100%'
            });
        }
        _doMeasure(doc, hintWidth, hintHeight) {
            if (this.vertical) {
                return { width: this._model.barWidth(), height: hintHeight };
            }
            else {
                return { width: hintWidth, height: this._model.barWidth() };
            }
        }
        _doRender(doc, width, height) {
            this.$_render();
        }
        clickable() {
            return this._model.clickable();
        }
        click(dom, x, y) {
            alert(x + ', ' + y);
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        $_render() {
            const r = (this._rate || 0) * 100 + '%';
            if (this.vertical) {
                this._bar.style.width = '100%';
                this._bar.style.height = r;
            }
            else {
                this._bar.style.width = r;
                this._bar.style.height = '100%';
            }
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    ScrollIndicatorView.CLASS_NAME = 'dlist-scroll-indicator';
    ScrollIndicatorView.BAR_CLASS = 'dlist-scroll-indicator-bar';
    ScrollIndicatorView.SELECTION_CLASS = 'dlist-scroll-indicator-selection';
    ScrollIndicatorView.TIP_DELAY = 2000;

    ////////////////////////////////////////////////////////////////////////////////
    // from google material symbols: https://fonts.google.com/icons
    const SHAPES = {
        '@help': {
            width: 48,
            path: 'M24.2 35.65q.8 0 1.35-.55t.55-1.35q0-.8-.55-1.35t-1.35-.55q-.8 0-1.35.55t-.55 1.35q0 .8.55 1.35t1.35.55Zm-1.75-7.3h2.95q0-1.3.325-2.375T27.75 23.5q1.55-1.3 2.2-2.55.65-1.25.65-2.75 0-2.65-1.725-4.25t-4.575-1.6q-2.45 0-4.325 1.225T17.25 16.95l2.65 1q.55-1.4 1.65-2.175 1.1-.775 2.6-.775 1.7 0 2.75.925t1.05 2.375q0 1.1-.65 2.075-.65.975-1.9 2.025-1.5 1.3-2.225 2.575-.725 1.275-.725 3.375ZM24 44q-4.1 0-7.75-1.575-3.65-1.575-6.375-4.3-2.725-2.725-4.3-6.375Q4 28.1 4 24q0-4.15 1.575-7.8 1.575-3.65 4.3-6.35 2.725-2.7 6.375-4.275Q19.9 4 24 4q4.15 0 7.8 1.575 3.65 1.575 6.35 4.275 2.7 2.7 4.275 6.35Q44 19.85 44 24q0 4.1-1.575 7.75-1.575 3.65-4.275 6.375t-6.35 4.3Q28.15 44 24 44Zm0-3q7.1 0 12.05-4.975Q41 31.05 41 24q0-7.1-4.95-12.05Q31.1 7 24 7q-7.05 0-12.025 4.95Q7 16.9 7 24q0 7.05 4.975 12.025Q16.95 41 24 41Zm0-17Z'
        },
        '@info': {
            width: 48,
            path: 'M22.65 34h3V22h-3ZM24 18.3q.7 0 1.175-.45.475-.45.475-1.15t-.475-1.2Q24.7 15 24 15q-.7 0-1.175.5-.475.5-.475 1.2t.475 1.15q.475.45 1.175.45ZM24 44q-4.1 0-7.75-1.575-3.65-1.575-6.375-4.3-2.725-2.725-4.3-6.375Q4 28.1 4 23.95q0-4.1 1.575-7.75 1.575-3.65 4.3-6.35 2.725-2.7 6.375-4.275Q19.9 4 24.05 4q4.1 0 7.75 1.575 3.65 1.575 6.35 4.275 2.7 2.7 4.275 6.35Q44 19.85 44 24q0 4.1-1.575 7.75-1.575 3.65-4.275 6.375t-6.35 4.3Q28.15 44 24 44Zm.05-3q7.05 0 12-4.975T41 23.95q0-7.05-4.95-12T24 7q-7.05 0-12.025 4.95Q7 16.9 7 24q0 7.05 4.975 12.025Q16.95 41 24.05 41ZM24 24Z'
        },
        '@search': {
            width: 48,
            path: 'M39.8 41.95 26.65 28.8Q25.15 30.1 23.15 30.825Q21.15 31.55 18.9 31.55Q13.5 31.55 9.75 27.8Q6 24.05 6 18.75Q6 13.45 9.75 9.7Q13.5 5.95 18.85 5.95Q24.15 5.95 27.875 9.7Q31.6 13.45 31.6 18.75Q31.6 20.9 30.9 22.9Q30.2 24.9 28.8 26.65L42 39.75ZM18.85 28.55Q22.9 28.55 25.75 25.675Q28.6 22.8 28.6 18.75Q28.6 14.7 25.75 11.825Q22.9 8.95 18.85 8.95Q14.75 8.95 11.875 11.825Q9 14.7 9 18.75Q9 22.8 11.875 25.675Q14.75 28.55 18.85 28.55Z'
        },
        '@home': {
            width: 48,
            path: 'M8 42V18L24.1 6 40 18v24H28.3V27.75h-8.65V42Zm3-3h5.65V24.75H31.3V39H37V19.5L24.1 9.75 11 19.5Zm13-14.65Z'
        },
        '@menu': {
            width: 48,
            path: 'M6 36V33H42V36ZM6 25.5V22.5H42V25.5ZM6 15V12H42V15Z'
        },
        '@settings': {
            width: 48,
            path: 'M19.4 44 18.4 37.7Q17.45 37.35 16.4 36.75Q15.35 36.15 14.55 35.5L8.65 38.2L4 30L9.4 26.05Q9.3 25.6 9.275 25.025Q9.25 24.45 9.25 24Q9.25 23.55 9.275 22.975Q9.3 22.4 9.4 21.95L4 18L8.65 9.8L14.55 12.5Q15.35 11.85 16.4 11.25Q17.45 10.65 18.4 10.35L19.4 4H28.6L29.6 10.3Q30.55 10.65 31.625 11.225Q32.7 11.8 33.45 12.5L39.35 9.8L44 18L38.6 21.85Q38.7 22.35 38.725 22.925Q38.75 23.5 38.75 24Q38.75 24.5 38.725 25.05Q38.7 25.6 38.6 26.1L44 30L39.35 38.2L33.45 35.5Q32.65 36.15 31.625 36.775Q30.6 37.4 29.6 37.7L28.6 44ZM24 30.5Q26.7 30.5 28.6 28.6Q30.5 26.7 30.5 24Q30.5 21.3 28.6 19.4Q26.7 17.5 24 17.5Q21.3 17.5 19.4 19.4Q17.5 21.3 17.5 24Q17.5 26.7 19.4 28.6Q21.3 30.5 24 30.5ZM24 27.5Q22.55 27.5 21.525 26.475Q20.5 25.45 20.5 24Q20.5 22.55 21.525 21.525Q22.55 20.5 24 20.5Q25.45 20.5 26.475 21.525Q27.5 22.55 27.5 24Q27.5 25.45 26.475 26.475Q25.45 27.5 24 27.5ZM24 24Q24 24 24 24Q24 24 24 24Q24 24 24 24Q24 24 24 24Q24 24 24 24Q24 24 24 24Q24 24 24 24Q24 24 24 24Q24 24 24 24Q24 24 24 24Q24 24 24 24Q24 24 24 24Q24 24 24 24Q24 24 24 24Q24 24 24 24Q24 24 24 24ZM21.8 41H26.2L26.9 35.4Q28.55 35 30.025 34.15Q31.5 33.3 32.7 32.1L38 34.4L40 30.8L35.3 27.35Q35.5 26.5 35.625 25.675Q35.75 24.85 35.75 24Q35.75 23.15 35.65 22.325Q35.55 21.5 35.3 20.65L40 17.2L38 13.6L32.7 15.9Q31.55 14.6 30.1 13.725Q28.65 12.85 26.9 12.6L26.2 7H21.8L21.1 12.6Q19.4 12.95 17.925 13.8Q16.45 14.65 15.3 15.9L10 13.6L8 17.2L12.7 20.65Q12.5 21.5 12.375 22.325Q12.25 23.15 12.25 24Q12.25 24.85 12.375 25.675Q12.5 26.5 12.7 27.35L8 30.8L10 34.4L15.3 32.1Q16.5 33.3 17.975 34.15Q19.45 35 21.1 35.4Z'
        },
        '@close': {
            width: 48,
            path: 'M12.45 37.65 10.35 35.55 21.9 24 10.35 12.45 12.45 10.35 24 21.9 35.55 10.35 37.65 12.45 26.1 24 37.65 35.55 35.55 37.65 24 26.1Z'
        },
        '@edit': {
            width: 48,
            path: 'M9 39h2.2l22.15-22.15-2.2-2.2L9 36.8Zm30.7-24.3-6.4-6.4 2.1-2.1q.85-.85 2.1-.85t2.1.85l2.2 2.2q.85.85.85 2.1t-.85 2.1Zm-2.1 2.1L12.4 42H6v-6.4l25.2-25.2Zm-5.35-1.05-1.1-1.1 2.2 2.2Z'
        },
        '@delete': {
            width: 48,
            path: 'M13.05 42q-1.2 0-2.1-.9-.9-.9-.9-2.1V10.5H8v-3h9.4V6h13.2v1.5H40v3h-2.05V39q0 1.2-.9 2.1-.9.9-2.1.9Zm21.9-31.5h-21.9V39h21.9Zm-16.6 24.2h3V14.75h-3Zm8.3 0h3V14.75h-3Zm-13.6-24.2V39Z'
        },
        '@check': {
            width: 48,
            path: 'M18.9 35.7 7.7 24.5l2.15-2.15 9.05 9.05 19.2-19.2 2.15 2.15Z'
        },
        '@refresh': {
            width: 48,
            path: 'M24 40q-6.65 0-11.325-4.675Q8 30.65 8 24q0-6.65 4.675-11.325Q17.35 8 24 8q4.25 0 7.45 1.725T37 14.45V8h3v12.7H27.3v-3h8.4q-1.9-3-4.85-4.85Q27.9 11 24 11q-5.45 0-9.225 3.775Q11 18.55 11 24q0 5.45 3.775 9.225Q18.55 37 24 37q4.15 0 7.6-2.375 3.45-2.375 4.8-6.275h3.1q-1.45 5.25-5.75 8.45Q29.45 40 24 40Z'
        },
        '@back': {
            width: 48,
            path: 'M24 40 8 24 24 8l2.1 2.1-12.4 12.4H40v3H13.7l12.4 12.4Z'
        },
        '@forward': {
            width: 48,
            path: 'm24 40-2.1-2.15L34.25 25.5H8v-3h26.25L21.9 10.15 24 8l16 16Z'
        },
        '@first': {
            width: 48,
            path: 'M0 4 0 44 5 44 5 4Z M32 44 12 24 32 4 34.8 6.85 17.65 24 36.8 41.15Z'
        },
        '@prev': {
            width: 48,
            path: 'M20 44 0 24 20 4 22.8 6.85 5.65 24 22.8 41.15Z'
        },
        '@last': {
            width: 48,
            path: 'M33 3.9 33 45 38 45 38 3.9Z M5.2 43.9 2.4 41.05 19.55 23.9 2.4 6.75 5.2 3.9 25.2 23.9Z'
        },
        '@next': {
            width: 48,
            path: 'M15.2 43.9 12.4 41.05 29.55 23.9 12.4 6.75 15.2 3.9 35.2 23.9Z'
        },
        '@left': {
            width: 48,
            path: 'M8 24 40 40 40 8 Z'
        },
        '@right': {
            width: 48,
            path: 'M40 24 8 40 8 8 Z'
        },
        '@up': {
            width: 48,
            path: 'M24 8 8 40 40 40 Z'
        },
        '@down': {
            width: 48,
            path: 'M24 40 8 8 40 8 Z'
        },
        '@drag': {
            width: 48,
            path: 'M17.5 40q-1.45 0-2.475-1.025Q14 37.95 14 36.5q0-1.45 1.025-2.475Q16.05 33 17.5 33q1.45 0 2.475 1.025Q21 35.05 21 36.5q0 1.45-1.025 2.475Q18.95 40 17.5 40Zm13 0q-1.45 0-2.475-1.025Q27 37.95 27 36.5q0-1.45 1.025-2.475Q29.05 33 30.5 33q1.45 0 2.475 1.025Q34 35.05 34 36.5q0 1.45-1.025 2.475Q31.95 40 30.5 40Zm-13-12.5q-1.45 0-2.475-1.025Q14 25.45 14 24q0-1.45 1.025-2.475Q16.05 20.5 17.5 20.5q1.45 0 2.475 1.025Q21 22.55 21 24q0 1.45-1.025 2.475Q18.95 27.5 17.5 27.5Zm13 0q-1.45 0-2.475-1.025Q27 25.45 27 24q0-1.45 1.025-2.475Q29.05 20.5 30.5 20.5q1.45 0 2.475 1.025Q34 22.55 34 24q0 1.45-1.025 2.475Q31.95 27.5 30.5 27.5ZM17.5 15q-1.45 0-2.475-1.025Q14 12.95 14 11.5q0-1.45 1.025-2.475Q16.05 8 17.5 8q1.45 0 2.475 1.025Q21 10.05 21 11.5q0 1.45-1.025 2.475Q18.95 15 17.5 15Zm13 0q-1.45 0-2.475-1.025Q27 12.95 27 11.5q0-1.45 1.025-2.475Q29.05 8 30.5 8q1.45 0 2.475 1.025Q34 10.05 34 11.5q0 1.45-1.025 2.475Q31.95 15 30.5 15Z'
        }
    };
    class Shapes extends ShapeRegistry {
        //-------------------------------------------------------------------------
        // constructor  
        //-------------------------------------------------------------------------
        constructor(owner) {
            super();
            this._ctors = {};
            this._customs = {};
            this._owner = owner;
            this.$_prepareStocks();
            // this.$_prepareCustoms();
        }
        _doDestory() {
            super._doDestory();
            this._owner = null;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        create(clazz, svg) {
            const name = clazz.NAME;
            let shape = this.get(name);
            if (!shape && this._ctors[name]) {
                this.add(name, shape = this._ctors[name](svg || this._owner.doc()));
            }
            return shape && DShape.clone(shape, clazz);
        }
        createStock(doc, shapeName, className, style) {
            const ctor = this._ctors[shapeName];
            let shape = this.get(shapeName);
            if (!shape && ctor) {
                this.add(shapeName, shape = new ctor(doc, className));
            }
            if (shape) {
                if (doc instanceof Document) {
                    return new ctor(shape, className, style);
                }
                else if (doc) { // SVGSVGElement - testing에서 SVGSVGElement가 undefined 예외를 뱉는다.
                    return new ctor(doc, className, style);
                }
            }
        }
        createCustom(shapeName, svg, className) {
            const c = this._customs[shapeName];
            const shape = this.create(DCustomShape, svg);
            className && shape.setClass(className);
            shape.setShape(c);
            return shape;
        }
        registerCustom(shapeName, d, width, height) {
            if (shapeName && d) {
                if (shapeName.startsWith('@')) {
                    const s = SHAPES[shapeName];
                    if (s) {
                        s.path = d;
                        if (width > 0)
                            s.width = width;
                        if (height > 0)
                            s.height = height;
                    }
                }
                else {
                    this._customs[shapeName] = {
                        w: width,
                        h: height,
                        d: d
                    };
                }
            }
        }
        registerCustoms(shapes) {
            for (let s in shapes) {
                const c = shapes[s];
                if (c && c.d) {
                    if (s.startsWith('@')) {
                        const shape = SHAPES[s];
                        if (shape) {
                            shape.path = c.d;
                            if (c.width > 0)
                                shape.width = c.width;
                            if (c.height > 0)
                                shape.height = c.height;
                        }
                    }
                    else {
                        this._customs[s] = {
                            w: c.width,
                            h: c.height,
                            d: c.d
                        };
                    }
                }
            }
        }
        getCustom(shapeName) {
            return this._customs[shapeName];
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        $_prepareStocks() {
            const ctors = this._ctors;
            ctors[DCustomShape.NAME] = function (doc, className) {
                return new DCustomShape(doc, className, {
                    width: '100%',
                    height: '100%'
                });
            };
            ctors[CheckMark.NAME] = function (doc, className) {
                return new CheckMark(doc, className);
            };
            ctors[DeleteShape.NAME] = function (doc, className) {
                return new DeleteShape(doc, className);
            };
            ctors[CircleShape.NAME] = function (doc, className) {
                return new CircleShape(doc, className);
            };
            ctors[StarShape.NAME] = function (doc, className) {
                return new StarShape(doc, className);
            };
            for (let s in SHAPES) {
                ctors[s] = function (doc, className) {
                    const shape = SHAPES[s];
                    return new PathShape(doc, shape.width, shape.height, shape.path, className);
                };
            }
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    class PageButton extends SvgButton {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(doc, model) {
            super(doc, PageButton.CLASS_NAME);
            this.setModel(model);
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        setModel(model) {
            if (model !== this.model) {
                let shape;
                this.model = model;
                switch (model.label()) {
                    case '<<':
                        shape = SHAPES['@first'];
                        break;
                    case '<':
                        shape = SHAPES['@prev'];
                        break;
                    case '>>':
                        shape = SHAPES['@last'];
                        break;
                    case '>':
                        shape = SHAPES['@next'];
                        break;
                }
                this._svg.setShape(shape, true);
            }
            this.setSize(this.model.owner().buttonSize());
            this.setDisabled(model.disabled());
        }
        setVertical(v) {
            Dom.setData(this._svg.svg, 'dir', v ? 'v' : '');
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doInitSvg(svg) {
            // svg.setStyle({
            //     strokeWidth: 48,
            //     strokeLinecap: 'round',
            //     strokeLinejoin: 'round'
            // });
        }
        _doClick() {
            this.model.run();
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    PageButton.CLASS_NAME = 'dlist-page-navigator-item';
    /**
     * @internal
     *
     * View for DPageNavigator.
     */
    class PageNavigatorView extends PositonableControlElement {
        // private _hSpan: number;
        // private _wSpan: number;
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(doc, owner, model) {
            super(doc, model, false, PageNavigatorView.CLASS_NAME);
            this._itemGap = 0;
            this._owner = owner;
            this.addChild(this._container = new DElement(doc));
        }
        _doDestory() {
            super._doDestory();
            this._spans = null;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doInitDom(doc, dom) {
        }
        _doPrepareRender(doc, hint) {
            if (!this._slash) {
                const container = this._container;
                const model = this._model;
                const items = this._buttons = [
                    this._first = new PageButton(doc, model.first()),
                    this._prev = new PageButton(doc, model.prev()),
                    this._next = new PageButton(doc, model.next()),
                    this._last = new PageButton(doc, model.last())
                ];
                const indexs = this._spans = [
                    this._page = container.appendSpan(doc, PageNavigatorView.INDEX_CLASS),
                    this._total = container.appendSpan(doc, PageNavigatorView.INDEX_CLASS)
                ];
                items.forEach(button => {
                    container.addChild(button);
                });
                this._spans.push(this._slash = container.appendSpan(doc, PageNavigatorView.SLASH_CLASS));
                // this._slash.textContent = '/';
                indexs.forEach(v => {
                    v.style.position = 'absolute';
                    v.style.whiteSpace = 'nowrap';
                });
            }
        }
        $_getItemGap() {
            let g = this._model.itemGap();
            if (this.landscape && this.vertical) {
                let g2 = this._model.itemGap2();
                if (isNaN(g2) && !isNaN(g)) {
                    g2 = g * 0.5;
                }
                return g2;
            }
            return g;
        }
        _doMeasure(doc, hintWidth, hintHeight) {
            const owner = this._owner;
            const page = owner.page();
            const vertical = this.vertical;
            const itemGap = this._itemGap = this.$_getItemGap();
            let w = 0;
            let h = 0;
            let sz = { width: this._model.buttonSize(), height: this._model.buttonSize() };
            Dom.setData(this.dom, 'position', this.position);
            this._buttons.forEach(v => {
                v.setDisabled(v.model.disabled());
                v.setVertical(vertical);
                sz = v.measure();
                if (vertical) {
                    h += sz.height;
                    w = Math.max(w, sz.width);
                }
                else {
                    w += sz.width;
                    h = Math.max(h, sz.height);
                }
                v.resize(sz.width, sz.height);
            });
            this._page.textContent = `${page + 1}`;
            this._total.textContent = `${owner.pageCount()}`;
            this._slash.textContent = vertical ? '━' : '/';
            if (vertical) {
                // this._hSpan = this._wSpan = 0;
                // this._spans.forEach(v => {
                //     this._hSpan = Math.max(this._hSpan, v[T_HEIGHT] = v.offsetHeight);
                //     this._wSpan += v[T_WIDTH] = v.offsetWidth; 
                // });
                // w += this._wSpan;
                // h = Math.max(h, this._hSpan);
                this._spans.forEach(v => {
                    w = Math.max(w, v[T_WIDTH] = v.offsetWidth);
                    h += v[T_HEIGHT] = v.offsetHeight;
                });
            }
            else {
                this._spans.forEach(v => {
                    w += v[T_WIDTH] = v.offsetWidth;
                    h = Math.max(h, v[T_HEIGHT] = v.offsetHeight);
                });
            }
            if (vertical) {
                h += itemGap * 4;
            }
            else {
                w += itemGap * 4;
            }
            this._container.resize(w, h);
            if (vertical) {
                return { width: this._model.width() || this.dom.offsetWidth, height: hintHeight };
            }
            else {
                return { width: hintWidth, height: this._model.height() || this.dom.offsetHeight };
            }
        }
        _doRender(doc, width, height) {
            const c = this._container;
            const gap = this._itemGap;
            if (this.vertical) {
                const w = c.width;
                let y = 0;
                this._container.moveI((width - w) / 2, (height - c.height) / 2);
                this._first.moveI((w - this._first.mw) / 2, y);
                y += this._first.mh + gap;
                this._prev.moveI((w - this._prev.mw) / 2, y);
                y += this._prev.mh + gap;
                // const y2 = y;
                // let x = (w - this._wSpan) / 2;
                // Dom.moveI(this._page, x, y2 + (this._hSpan - this._page[T_HEIGHT]) / 2);
                // x += this._page[T_WIDTH];
                // Dom.moveI(this._slash, x, y2 + (this._hSpan - this._slash[T_HEIGHT]) / 2);
                // x += this._slash[T_WIDTH];
                // Dom.moveI(this._total, x, y2 + (this._hSpan - this._total[T_HEIGHT]) / 2);
                // y += this._hSpan + gap;
                Dom.moveI(this._page, (w - this._page[T_WIDTH]) / 2, y);
                y += this._page[T_HEIGHT];
                Dom.moveI(this._slash, (w - this._slash[T_WIDTH]) / 2, y);
                y += this._slash[T_HEIGHT];
                Dom.moveI(this._total, (w - this._total[T_WIDTH]) / 2, y);
                y += this._total[T_HEIGHT];
                y += gap;
                this._next.moveI((w - this._next.mw) / 2, y);
                y += this._next.mh + gap;
                this._last.moveI((w - this._last.mw) / 2, y);
                y += this._last.mh;
            }
            else {
                const gap = this._itemGap;
                const h = c.height;
                let x = 0;
                this._container.moveI((width - c.width) / 2, (height - h) / 2);
                this._first.moveI(x, (h - this._first.mh) / 2);
                x += this._first.mw + gap;
                this._prev.moveI(x, (h - this._prev.mh) / 2);
                x += this._prev.mw + gap;
                Dom.moveI(this._page, x, (h - this._page[T_HEIGHT]) / 2);
                x += this._page[T_WIDTH];
                Dom.moveI(this._slash, x, (h - this._slash[T_HEIGHT]) / 2);
                x += this._slash[T_WIDTH];
                Dom.moveI(this._total, x, (h - this._total[T_HEIGHT]) / 2);
                x += this._total[T_WIDTH];
                x += gap;
                this._next.moveI(x, (h - this._next.mh) / 2);
                x += this._next.mw + gap;
                this._last.moveI(x, (h - this._last.mh) / 2);
                x += this._last.mw;
            }
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    PageNavigatorView.CLASS_NAME = 'dlist-page-navigator';
    PageNavigatorView.INDEX_CLASS = 'dlist-page-navigator-index';
    PageNavigatorView.SLASH_CLASS = 'dlist-page-navigator-slash';

    ////////////////////////////////////////////////////////////////////////////////
    const PAGE = '$_page';
    /**
     * @internal
     *
     * View for DPageScroller.
     * 웹접근성을 위해 좌위 이동 버튼을 숨긴채로 표시한다(맞는 처리 방법인가?).
     *
     * TODO: 양 끝(first, last) container 안쪽으로 drop shadow 표시한다.
     */
    class PageScrollerView extends ListControlElement {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(doc, owner, model) {
            super(doc, model, false, PageScrollerView.CLASS_NAME);
            this._pagePool = [];
            this._pageViews = [];
            this._pageMap = {};
            this._scrollPos = 0;
            this._scrollOff = 0;
            this._indexClicked = (event) => {
                const button = event.target;
                const page = button[PAGE];
                this._owner.pageIndexClick(page);
            };
            this._owner = owner;
        }
        //-------------------------------------------------------------------------
        // static members
        //-------------------------------------------------------------------------
        static isPageIndex(dom) {
            return dom.classList.contains(this.INDEX_CLASS) ? dom[PAGE] : -1;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        get scrollPos() {
            return this._scrollPos;
        }
        get scrollOff() {
            return this._scrollOff;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        /**
         * @param delta 0보다 크면 scrollPos가 작아진다. 즉, 오른쪽으로 스크롤하면 delta가 0보다 크다.
         * @returns 실제 스크롤됐다면 true
         */
        scrollBy(delta) {
            const doc = this.doc;
            const gap = this._model.itemGap();
            let pos = this._scrollPos;
            let off = this._scrollOff;
            // 오른쪽(아래)으로 drag
            if (delta > 0) {
                if (off >= delta) {
                    off -= delta;
                }
                else if (pos === 0) {
                    off = 0;
                }
                else {
                    delta -= off;
                    off = 0;
                    let v;
                    while (pos > 0 && delta > 0) {
                        if (!v) {
                            v = this.$_getIndexView(doc);
                            this._pageContainer.appendChild(v);
                        }
                        this.$_measureIndexView(v, --pos);
                        const w = v.offsetWidth + gap;
                        if (w > delta) {
                            off = w - delta;
                            delta = 0;
                        }
                        else {
                            delta -= w;
                        }
                    }
                    if (v) {
                        this._pagePool.push(v);
                        this._pageContainer.removeChild(v);
                    }
                }
            }
            // 왼쪽(위)으로 drag
            else if (delta < 0) {
                const off2 = off > 0 ? (this._pageViews[0].offsetWidth + gap - off) : 0;
                delta *= -1;
                if (off2 >= delta) {
                    off += delta;
                }
                else {
                    const views = this._pageViews.slice(0);
                    if (off2 > 0) {
                        delta -= off2;
                        pos++;
                        off = 0;
                        views.shift();
                    }
                    while (delta > 0 && views.length > 0) {
                        const h = views.shift().offsetHeight;
                        if (delta > h) {
                            delta -= h;
                            pos++;
                        }
                        else {
                            off = -(delta - h);
                            delta = 0;
                        }
                    }
                }
            }
            this.$_refreshView(doc, pos, off);
        }
        scrollTo(page) {
            const pos = Math.max(0, Math.min(page, this._owner.pageCount()));
            this.$_refreshView(this.doc, pos, 0);
        }
        /**
         * 현재 페이지 인덱스가 보여지게 스크롤한다.
         * @param center true면 현재 페이지가 목록 중앙에 표시되록 스크롤한다.
         */
        makeVisible(page, center = false) {
            if (center) {
                const count = this._owner.pageCount();
                const pages = this._pageViews;
                if (count >= pages.length) {
                    this.scrollTo(page - Math.floor(pages.length / 2));
                }
            }
            else {
                const views = this._pageViews;
                const last = views[views.length - 1];
                if (page === this._scrollPos) {
                    if (this._scrollOff > 0) {
                        this.$_refreshView(this.doc, this._scrollPos, 0);
                    }
                }
                else if (page < this._scrollPos) {
                    this.scrollTo(page);
                }
                else if (page > last[PAGE]) {
                    this.scrollTo(page - Math.floor(views.length / 2));
                }
                else if (page < last[PAGE]) {
                    this._scrollOff = 0;
                }
                else if (page === last[PAGE]) {
                    // TODO: pag view가 넘친 상태면 조정...
                    let pos = this._scrollPos;
                    let off = this._scrollOff;
                    let dx = last.offsetLeft + last.offsetWidth - this._pageContainer.offsetWidth;
                    if (dx <= off) {
                        off -= dx;
                    }
                    else {
                        const pool = this._pagePool;
                        const map = this._pageMap;
                        const views = this._pageViews;
                        while (dx > 0 && pos <= page) {
                            const w = this._pageViews[0].offsetHeight;
                            if (dx >= w) {
                                let v = views.shift();
                                delete map[pos];
                                pool.push(v);
                                dx -= w;
                                pos++;
                            }
                            else {
                                off = dx;
                                dx = 0;
                            }
                        }
                    }
                    this._scrollPos = pos;
                    this._scrollOff = off;
                }
            }
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doPrepareRender(hint) {
            const dom = this.dom;
            const doc = dom.ownerDocument;
            if (!this._first) {
                const tag = this._tag = 'button';
                dom.appendChild(this._firstContainer = doc.createElement('div'));
                this._firstContainer.appendChild(this._first = doc.createElement(tag));
                this._first.classList.add(PageScrollerView.INDEX_CLASS, PageScrollerView.END_CLASS);
                // web 접근성 순서를 맞추기 위해
                dom.appendChild(this._pageContainer = doc.createElement('div'));
                dom.appendChild(this._lastContainer = doc.createElement('div'));
                this._lastContainer.appendChild(this._last = doc.createElement(tag));
                this._last.classList.add(PageScrollerView.INDEX_CLASS, PageScrollerView.END_CLASS);
            }
        }
        _doMeasure(doc, hintWidth, hintHeight) {
            const model = this._model;
            const owner = this._owner;
            const gap = model.itemGap();
            let w = 0;
            if (Dom.setVisible(this._firstContainer, model.first().visible())) {
                this._first[PAGE] = 0;
                this._first.textContent = '≪';
                w += this._first.offsetWidth + gap;
            }
            if (Dom.setVisible(this._lastContainer, model.last().visible())) {
                this._first[PAGE] = owner.pageCount() - 1;
                this._last.textContent = '≫';
                w += this._last.offsetWidth + gap;
            }
            this.$_preparePages(doc, this._pageContainer, hintWidth - w, gap);
            return { width: hintWidth, height: this._model.width() };
        }
        _doRender(doc, width, height) {
            const gap = this._model.itemGap();
            let x = 0;
            let y = 0;
            if (Dom.isVisible(this._lastContainer)) {
                const w = this._last.offsetWidth;
                Dom.setBounds(this._firstContainer, width - w, y, w, height);
                width -= w;
            }
            if (Dom.isVisible(this._firstContainer)) {
                const w = this._first.offsetWidth;
                Dom.setBounds(this._firstContainer, x, y, w, height);
                width -= w;
                x += w;
            }
            // pages
            Dom.setBounds(this._pageContainer, x, y, width, height);
            x = -this._scrollOff;
            for (let v of this._pageViews) {
                Dom.move(v, x, y);
                x += v.offsetWidth + gap;
            }
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        $_getIndexView(doc) {
            let v = this._pagePool.pop();
            if (!v) {
                v = doc.createElement(this._tag);
                v.classList.add(PageScrollerView.INDEX_CLASS);
                v.onclick = this._indexClicked;
            }
            return v;
        }
        $_measureIndexView(v, page) {
            v.classList.remove(PageScrollerView.CURRENT_CLASS);
            if (page === this._owner.page()) {
                v.classList.add(PageScrollerView.CURRENT_CLASS);
            }
            v.textContent = (page + 1) + '';
        }
        $_preparePages(doc, container, width, gap) {
            const count = this._owner.pageCount();
            let pos = this._scrollPos;
            let off = this._scrollOff;
            const pool = this._pagePool;
            const map = this._pageMap;
            const newMap = {};
            const pages = [];
            let w = width + off;
            while (w > 0 && pos < count) {
                let v = map[pos];
                if (!v) {
                    v = this.$_getIndexView(doc);
                }
                else {
                    delete map[pos];
                }
                this.$_measureIndexView(v, pos);
                w -= v.offsetWidth + gap;
                pages.push(v);
                newMap[pos] = v;
                v[PAGE] = pos;
                pos++;
            }
            // 끝 쪽에 여분 발생
            if (w > 0) {
                pos = this._scrollOff;
                if (w <= off) {
                    off -= w;
                }
                else {
                    w -= off;
                    while (w > 0 && pos > 0) {
                        const v = this.$_getIndexView(doc);
                        this.$_measureIndexView(v, --pos);
                        pages.unshift(v);
                        newMap[pos] = v;
                        v[PAGE] = pos;
                        const w2 = v.offsetWidth + gap;
                        if (w > w2) {
                            w -= w2;
                        }
                        else {
                            off = w2 - w;
                            w = 0;
                        }
                    }
                }
                this._scrollPos = pos;
                this._scrollOff = off;
            }
            for (let p in map) {
                pool.push(map[p]);
            }
            this._pageViews = pages;
            this._pageMap = newMap;
        }
        $_refreshView(doc, pos, off) {
            this._scrollPos = pos;
            this._scrollOff = off;
            this.$_preparePages(this.doc, this._pageContainer, this.width, this.height);
            this.render(doc);
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    PageScrollerView.CLASS_NAME = 'dlist-page-scroller';
    PageScrollerView.INDEX_CLASS = 'dlist-page-scroller-index';
    PageScrollerView.END_CLASS = 'dlist-page-scroller-end';
    PageScrollerView.CURRENT_CLASS = 'dlist-page-scroller-current';

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     *
     * View for DHeadRowOption.
     * Head row들을 표시한다.
     */
    class HeadRowsView extends DListElement {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(doc, model) {
            super(doc, false, HeadRowsView.CLASS_NAME);
            this._vertical = true;
            this._rowViews = [];
            this._model = model;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        get model() {
            return this._model;
        }
        get rowCount() {
            return this._rowViews.length;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        getRowView(index) {
            return this._rowViews[index];
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doInitDom(doc, dom) {
        }
        _doMeasure(doc, hintWidth, hintHeight) {
            if (this._vertical) {
                return this.$_measureVert(doc, hintWidth, hintHeight);
            }
            else {
                return this.$_measureHorz(doc, hintWidth, hintHeight);
            }
        }
        _doRender(doc, width, height) {
            if (this._vertical) {
                return this.$_renderVert(doc, width, height);
            }
            else {
                return this.$_renderHorz(doc, width, height);
            }
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        $_measureVert(doc, hintWidth, hintHeight) {
            const model = this._model;
            const listView = this.parent.parent;
            const owner = listView.owner();
            const dv = owner.data();
            const views = this._rowViews;
            const count = model.rowCount();
            let h = 0;
            let w = 0;
            while (views.length > count) {
                const v = views.pop();
                this.removeChild(v);
                v.destroy();
            }
            while (views.length < count) {
                const row = model.getRow(views.length);
                const layout = owner.getRowLayout(row);
                const v = new ListRowView(doc);
                v.setRow(dv, row, dv.getRowId(row), null);
                v.setLayout(layout);
                this.addChild(v);
                views.push(v);
            }
            views.forEach(view => {
                const sz = view.measure(doc, listView, hintWidth, hintHeight);
                h += sz.height;
                w = Math.max(w, sz.width);
            });
            return { width: w, height: h };
        }
        $_measureHorz(doc, hintWidth, hintHeight) {
            return;
        }
        $_renderVert(doc, width, height) {
            const x = 0;
            let y = 0;
            this._rowViews.forEach(view => {
                const h = view.mh;
                view.move(x, y).resize(width, h);
                view.render(doc);
                y += h;
            });
        }
        $_renderHorz(doc, width, height) {
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    HeadRowsView.CLASS_NAME = 'dlist-head-rows';

    ////////////////////////////////////////////////////////////////////////////////
    const KR_MAP = {
        '가': 'ㄱ',
        '까': 'ㄲ',
        '나': 'ㄴ',
        '다': 'ㄷ',
        '따': 'ㄸ',
        '라': 'ㄹ',
        '마': 'ㅁ',
        '바': 'ㅂ',
        '빠': 'ㅃ',
        '사': 'ㅅ',
        '싸': 'ㅆ',
        '아': 'ㅇ',
        '자': 'ㅈ',
        '짜': 'ㅉ',
        '차': 'ㅊ',
        '카': 'ㅋ',
        '타': 'ㅌ',
        '파': 'ㅍ',
        '하': 'ㅎ'
    };
    class LetterView extends ButtonElement {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(doc) {
            super(doc, LetterView.CLASS_NAME);
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        setLetter(c) {
            if (c !== this.letter) {
                this.letter = c;
                this.dom.textContent = KR_MAP[c] || c;
            }
        }
        isActive() {
            return Dom.getData(this.dom, 'active') === '1';
        }
        setActive(value) {
            Dom.setData(this.dom, 'active', value ? '1' : void 0);
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _getDisplayStyle() {
            return 'inline-block';
        }
        click() {
            this.parent.clickLetter(this);
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    LetterView.CLASS_NAME = 'dlist-index-bar-letter';
    /**
     * @internal
     *
     * View for DIndexBar.
     */
    class IndexBarView extends ListControlElement {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(doc, model) {
            super(doc, model, true, IndexBarView.CLASS_NAME);
            //-------------------------------------------------------------------------
            // static members
            //-------------------------------------------------------------------------
            //-------------------------------------------------------------------------
            // property fields
            //-------------------------------------------------------------------------
            //-------------------------------------------------------------------------
            // fields
            //-------------------------------------------------------------------------
            this._letterViews = [];
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        letterCount() {
            return this._letterViews.length;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        getLetterView(index) {
            return this._letterViews[index];
        }
        clickLetter(view) {
            const c = view.letter;
            this._model.clickLetter(c);
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doMeasure(doc, hintWidth, hintHeight) {
            function addView(self) {
                const v = new LetterView(doc);
                self.addChild(v);
                views.push(v);
                return v;
            }
            const model = this._model;
            const views = this._letterViews;
            const szChar = this._hChar = Math.ceil((views.length === 0 ? addView(this) : views[0]).dom.offsetHeight);
            const h = model.getLength(hintHeight);
            const nChar = (h / szChar) >> 0;
            const letters = model.getLetters(nChar);
            const count = letters.length;
            while (views.length > count) {
                const v = views.pop();
                this.removeChild(v);
            }
            while (views.length < count) {
                addView(this);
            }
            for (let i = 0; i < count; i++) {
                views[i].setLetter(letters[i]);
            }
            return { width: this._model.minWidth(), height: h };
        }
        _doRender(doc, width, height) {
            const views = this._letterViews;
            const count = views.length;
            if (count > 0) {
                let y = (height - count * this._hChar) / 2 >> 0;
                views.forEach(v => {
                    v.move((width - v.dom.offsetWidth) / 2 >> 0, y);
                    y += this._hChar;
                });
            }
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    IndexBarView.CLASS_NAME = 'dlist-index-bar';

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     *
     * View for DScrollBar.
     */
    class ScrollBarView extends ListControlElement {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(doc, model) {
            super(doc, model, false, ScrollBarView.CLASS_NAME);
            this._len = 0;
            this._page = 0;
            this._pos = 0;
            this._thumbSum = 0;
            this._thumbed = 0;
            this._vertical = true;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        setVertical(vertical) {
            this._vertical = vertical;
        }
        setScroll(len, page, pos, render) {
            this._len = len;
            this._page = page;
            this._pos = pos;
            Dom.setVisible(this._thumb, this._len > this._page);
            render && this.$_setScrollBar(this.width, this.height);
        }
        calcPosition(p) {
            let h = this.height;
            const hThumb = this.$_calcThumb(h);
            h -= hThumb;
            p = (p * this._len / h) >> 0;
            return p;
        }
        reset() {
            this._thumbSum = this._thumbed = 0;
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        isView(dom) {
            return dom === this._thumb;
        }
        _doInitDom(doc, dom) {
            this._thumb = this.appendSpan(doc, ScrollBarView.THUMB_CLASS);
            this._thumb.style.position = 'absolute';
        }
        _doMeasure(doc, hintWidth, hintHeight) {
            if (this._vertical) {
                return { width: this._model.barWidth(), height: hintHeight };
            }
            else {
                return { width: hintWidth, height: this._model.barWidth() };
            }
        }
        _doRender(doc, width, height) {
            this.$_setScrollBar(width, height);
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        $_calcThumb(sz) {
            let h = sz * this._page / this._len;
            this._thumbSum += h;
            this._thumbed++;
            h = this._thumbSum / this._thumbed;
            return Math.max(this._model.minThumbLength(), h) >> 0;
        }
        $_setScrollBar(width, height) {
            if (Dom.isVisible(this._thumb)) {
                const sz = this._vertical ? height : width;
                const szThumb = this.$_calcThumb(sz);
                const p = ((sz - szThumb) * this._pos / (this._len - this._page)) >> 0;
                const wThumb = this._model.thumbWidth();
                if (this._vertical) {
                    const x = ((width - wThumb) / 2) >> 0;
                    Dom.setBounds(this._thumb, x, p, wThumb, szThumb);
                }
                else {
                    const y = ((height - wThumb) / 2) >> 0;
                    Dom.setBounds(this._thumb, p, y, szThumb, wThumb);
                }
            }
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    ScrollBarView.CLASS_NAME = 'dlist-scroll-bar';
    ScrollBarView.THUMB_CLASS = 'dlist-scroll-bar-thumb';

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     *
     * Selection handle view.
     */
    class SelectionHandle extends DElement {
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(doc) {
            super(doc, false, SelectionHandle.CLASS_NAME, 'span');
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _getDisplayStyle() {
            return 'inline-block';
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    SelectionHandle.CLASS_NAME = 'dlist-selection-mask-handle';
    /**
     * @internal
     *
     * View for DSelectionMask.
     */
    class SelectionView extends DListElement {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(doc) {
            super(doc, false, SelectionView.CLASS_NAME);
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doInitDom(doc, dom) {
            this._handles = [];
            for (let i = 0; i < 2; i++) {
                this._handles.push(new SelectionHandle(doc));
            }
        }
        _doMeasure(doc, hintWidth, hintHeight) {
            return { width: hintWidth, height: hintHeight };
        }
        _doRender(doc, width, height) {
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    SelectionView.CLASS_NAME = 'dlist-selection-mask';

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     *
     * Command box cell button for RowCommand.
     */
    class CommandButton extends ButtonElement {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(doc) {
            super(doc, CommandButton.CLASS_NAME);
        }
        _doDestory() {
            this.model = null;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        setModel(control, model) {
            this._setModel(control, this.model = model);
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doInitDom(doc, dom) {
            super._doInitDom(doc, dom);
        }
        click(owner) {
            this.parent.runCommand(owner, this.model);
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    CommandButton.CLASS_NAME = 'dlist-command-cell';
    /**
     * @internal
     *
     * View for CommandBox.
     */
    class CommandBoxView extends DListElement {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(doc, model) {
            super(doc, false, CommandBoxView.CLASS_NAME);
            this._cellPool = [];
            this._cellViews = [];
            this._model = model;
        }
        _doDestory() {
            this._data = null;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        setCommands(data, row, commands) {
            this._data = data;
            this._row = row;
            this._commands = commands || [];
        }
        getCommand(dom) {
            for (let cell of this._cellViews) {
                if (cell.isDom(dom)) {
                    return cell.model;
                }
            }
        }
        runCommand(ctx, cmd) {
            cmd.run(ctx, this._data, this._row);
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doPrepareRender(doc, hint) {
            const pool = this._cellPool;
            const views = this._cellViews;
            const cmds = this._commands;
            while (views.length < cmds.length) {
                let v = pool.pop();
                if (!v) {
                    v = new CommandButton(doc);
                    this.addChild(v);
                    views.push(v);
                }
            }
            while (views.length > cmds.length) {
                const v = views.pop();
                this.removeChild(v);
                pool.push(v);
            }
        }
        _doMeasure(doc, hintWidth, hintHeight) {
            const control = this.control;
            const vertical = control.isVertical();
            const m = this._model;
            const views = this._cellViews;
            const cmds = this._commands;
            const wMin = vertical ? pickNum(m.minCellWidth(), 0) : 0;
            const hMin = vertical ? 0 : pickNum(m.minCellHeight(), 0);
            let w = 0;
            let h = 0;
            const sizes = this._sizes = [];
            views.forEach((v, i) => {
                // 동일한 button element를 재사용하므로 기존에 계산된 크기를 초기화 해야 한다.
                v.resize(NaN, NaN);
                v.setModel(control, cmds[i]);
                const sz = v.getOffsetSize();
                if (vertical) {
                    sizes.push(sz.width = Math.max(wMin, Math.ceil(sz.width)));
                    w += sz.width;
                    h = Math.max(h, Math.max(hMin || 0, sz.height));
                }
                else {
                    sizes.push(sz.height = Math.max(hMin, Math.ceil(sz.height)));
                    h += sz.height;
                    w = Math.max(w, Math.max(wMin || 0, sz.width));
                }
            });
            return { width: w, height: h };
        }
        _doRender(doc, width, height) {
            const control = this.control;
            const vertical = control.isVertical();
            const views = this._cellViews;
            let x = 0;
            let y = 0;
            views.forEach((v, i) => {
                v.move(x, y);
                if (vertical) {
                    v.resize(this._sizes[i], height);
                    x += v.width;
                }
                else {
                    v.resize(width, this._sizes[i]);
                    y += v.height;
                }
            });
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    CommandBoxView.CLASS_NAME = 'dlist-command-box';

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * 데이터행 {@link DListCommandBox 커맨드 상자}에 표시되는 셀들의 배치 방향.
     * <br>
     * {@link DListCommandBox.orientation} 속성으로 접근한다.
     *
     * @see concepts.command_box 커맨드 상자 개요
     */
    var DListCommandBoxOrientation;
    (function (DListCommandBoxOrientation) {
        /**
         * {@link DListControl 리스트 컨트롤}의 {@link DListControl.orientation 표시 방향}에 맞춰 셀들을 배치한다.
         * <br>
         */
        DListCommandBoxOrientation["AUTO"] = "auto";
        /**
         * 수평 방향으로 셀들을 배치한다.
         * <br>
         */
        DListCommandBoxOrientation["HORIZONTAL"] = "horizontal";
        /**
         * 수직 방향으로 셀들을 배치한다.
         * <br>
         */
        DListCommandBoxOrientation["VERTICA"] = "vertical";
    })(DListCommandBoxOrientation || (DListCommandBoxOrientation = {}));
    /**
     * @internal 미구현
     *
     * 커맨드 상자 표시 방식
     */
    var DListCommandBoxMode;
    (function (DListCommandBoxMode) {
        /**
         * shift
         */
        DListCommandBoxMode["SHIFT"] = "shift";
        /**
         * overlap
         */
        DListCommandBoxMode["OVERLAP"] = "overlap";
    })(DListCommandBoxMode || (DListCommandBoxMode = {}));
    /**
     * @internal
     *
     * Row command들이 표시되는 영역 관련 설정 객체.
     */
    class CommandBox extends ListControlObject {
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        _doInitDefaults() {
            super._doInitDefaults();
            this._minCellWidth = 70;
            this._minCellHeight = 24;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * Command 셀 배치 방향.
         */
        orientation() {
            return pickProp(this._orientation, this._defs && this._defs._orientation);
        }
        setOrientation(value) {
            this._orientation = value;
        }
        /**
         * 표시 방식. 데이터행을 밀어내거나, 겹쳐 표시한다.
         */
        mode() {
            return pickProp(this._mode, this._defs && this._defs._mode);
        }
        setMode(value) {
            this._mode = value;
        }
        /**
         * 최소 셀 너비.
         */
        minCellWidth() {
            return pickProp(this._minCellWidth, this._defs && this._defs._minCellWidth);
        }
        setMinCellWidth(value) {
            this._minCellWidth = value;
        }
        /**
         * 최소 셀 높이.
         */
        minCellHeight() {
            return pickProp(this._minCellHeight, this._defs && this._defs._minCellHeight);
        }
        setMinCellHeight(value) {
            this._minCellHeight = value;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doPrepareRender() {
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    class PanelButtonElement extends ButtonElement {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(doc) {
            super(doc, PanelButtonElement.CLASS_NAME);
        }
        _doDestory() {
            this.model = null;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        setModel(control, model) {
            this.model = model;
            this._setModel(control, model);
            return this;
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _getPositionStyle() {
            return '';
        }
        click(owner) {
            this.model.click(owner);
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    PanelButtonElement.CLASS_NAME = 'dlist-row-button dlist-panel-button';
    /**
     * @internal
     *
     * View for ListPanel.
     */
    class ListPanelView extends DListElement {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(doc, model, className) {
            super(doc, true, className + ' dlist-panel');
            this._model = model;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        model() {
            return this._model;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        refresh(manager, width, height) {
            const doc = this.doc;
            let x = 0;
            let y = 0;
            width = pickNum(width, this.width);
            height = pickNum(height, this.height);
            const sz = this.measure(doc, manager, width, height);
            this.resize(sz.width, sz.height);
            this.render(doc);
            this.move(x, y);
            this._manager = null;
        }
        // true를 리턴하면 panel이 닫힌다.
        click(dom, x, y) {
            return false;
        }
        // true를 리턴하면 panel이 닫힌다.
        clickButton(button, control) {
            button.enabled() && button.click(control);
            return true;
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doInitDom(doc, dom) {
            Object.assign(dom.style, {
                pointerEvents: 'auto',
                overflow: 'hidden',
            });
        }
        _doPrepareRender(doc, hint) {
            this._manager = hint;
        }
        measure(doc, hint, maxWidth, maxHeight) {
            const model = this._model;
            const p = model.getPosition();
            let border;
            switch (model.getPosition()) {
                case DListPanelPosition.CENTER:
                    border = 'center';
                    break;
                case DListPanelPosition.BOTTOM:
                    border = 'top';
                    break;
                case DListPanelPosition.LEFT:
                    border = 'right';
                    break;
                case DListPanelPosition.RIGHT:
                    border = 'left';
                    break;
                case DListPanelPosition.TOP:
                default:
                    border = 'bottom';
                    break;
            }
            this.dom.dataset.border = border;
            const sz = super.measure(doc, hint, maxWidth, maxHeight);
            if (model.isFullWidth()) {
                sz.width = maxWidth;
            }
            if (model.isFullHeight()) {
                sz.height = maxHeight;
            }
            if (p === DListPanelPosition.LEFT || p === DListPanelPosition.RIGHT || p === DListPanelPosition.CENTER) {
                sz.width = model.getSize(maxWidth, sz.width);
            }
            else {
                sz.height = model.getSize(maxHeight, sz.height);
            }
            this.mw = sz.width += 1;
            this.mh = sz.height += 1;
            return sz;
        }
        _doMeasure(doc, hintWidth, hintHeight) {
            const p = this._padding = this.getPadding();
            const w = hintWidth - p.left - p.right;
            const h = hintHeight - p.top - p.bottom;
            let sz = this._doMeasureContent(doc, w, h); //hintWidth, hintHeight);
            sz.width += p.left + p.right;
            sz.height += p.top + p.bottom;
            return sz;
        }
        _doAfterRender() {
            this._manager = null;
        }
        _createButton(doc, button) {
            const view = new PanelButtonElement(doc);
            view.setModel(this.control, button);
            return view;
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    ListPanelView.DURATION = 500;
    class DialogPanelView extends ListPanelView {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(doc, model, className) {
            super(doc, model, className);
            this._buttonViews = [];
            this._hButton = 0;
            this._wButton = 0;
            this._hBody = 0;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        getButton(model) {
            return this._buttonViews.find(v => v.model === model);
        }
        _getDefaultButtonPosition() {
            return DListPanelButtonPosition.BOTTOM;
        }
        getButtonPosition(model) {
            const p = model.buttonPosition();
            if (p === DListPanelButtonPosition.LEFT || p === DListPanelButtonPosition.RIGHT || p === DListPanelButtonPosition.BOTTOM) {
                return p;
            }
            return this._getDefaultButtonPosition();
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doInitDom(doc, dom) {
            dom.style.boxSizing = '';
        }
        _doInitContent(doc, div) {
            // content
            div.style.display = 'flex';
            div.style.flexDirection = 'column';
            div.style.height = '100%'; // 좌우 배치에서 필요하다.
            // body
            this.addChild(this._bodyContainer = new DElement(doc, false, 'dlist-dialog-panel-body'));
            this._bodyContainer.setStyles({
                position: '',
                flex: '1 1 auto',
                minHeight: '20px',
                // width: '100%',
                overflow: 'hidden scroll'
            });
            this._initBody(doc, this._bodyContainer);
            // buttons
            this.addChild(this._buttonContainer = new DElement(doc, false, 'dlist-dialog-panel-buttons'));
            this._buttonContainer.setStyles({
                position: '',
                flex: '0 0 auto',
                display: 'flex',
                flexWrap: 'wrap',
                alignItems: 'center',
                justifyContent: 'flex-end',
            });
        }
        _doPrepareRender(doc, manager) {
            super._doPrepareRender(doc, manager);
            const model = this.model();
            this._layoutManager = manager;
            // body
            this._prepareBody(doc, this._bodyContainer, manager, model);
            // buttons
            this.$_prepareButtons(doc, model);
            this._prepareButtons(this._buttonViews);
        }
        _doMeasureContent(doc, hintWidth, hintHeight) {
            const model = this.model();
            const p = model.getPosition();
            const bp = this.getButtonPosition(model);
            const horz = bp === DListPanelButtonPosition.LEFT || bp === DListPanelButtonPosition.RIGHT;
            let w = p === DListPanelPosition.LEFT || p === DListPanelPosition.RIGHT ?
                model.getSize(hintWidth, hintWidth) : hintWidth;
            if (horz) {
                this.content.style.flexDirection = bp === DListPanelButtonPosition.LEFT ? 'row-reverse' : 'row';
                this._buttonContainer.dom.style.flexDirection = 'column';
            }
            else {
                this.content.style.flexDirection = 'column';
                this._buttonContainer.dom.style.flexDirection = 'row';
            }
            // buttons
            this._buttonViews.forEach(bv => {
                bv.setEnabled(bv.model.isEnabled(this.control.wrapperOrThis()));
            });
            this._buttonContainer.dom.style.gap = model.buttonGap() + 'px';
            this._measureButtons(this._buttonViews);
            this._hButton = horz ? 0 : this._buttonContainer.dom.offsetHeight;
            this._wButton = horz ? this._buttonContainer.dom.offsetWidth : 0;
            // body
            w -= this._wButton;
            const szBody = this._measureBody(doc, this._layoutManager, this._bodyContainer, model, w, hintHeight);
            this._hBody = szBody.height;
            const h = horz ? Math.max(this._hBody, this._hButton) : this._hBody + this._hButton;
            return { width: this.content.offsetWidth, height: h };
        }
        _doRender(doc, width, height) {
            // buttons
            // this._buttonContainer.resize(width, this._hButton);
            // this._buttonContainer.move(0, height - this._hButton);
            // body
            // this._bodyContainer.move(0, 0);
            // this._bodyContainer.resize( width, height - this._hButton);
            this._renderBody(doc, this._bodyContainer, width - this._wButton, height - this._hButton);
        }
        _doAfterRender() {
            this._layoutManager = null;
        }
        clickButton(button, control) {
            super.clickButton(button, control);
            const t = button.model.type;
            if (t === DListButtonType.SUBMIT) {
                return this._submit();
            }
            else if (t === DListButtonType.CANCEL) {
                return true;
            }
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        _initBody(doc, container) {
        }
        _prepareBody(doc, container, manager, model) {
        }
        $_prepareButtons(doc, model) {
            const buttons = model.getButtons();
            const views = this._buttonViews;
            while (views.length < buttons.length) {
                const v = this._createButton(doc, buttons[views.length]);
                this._buttonContainer.addChild(v);
                this._buttonViews.push(v);
            }
            while (views.length > buttons.length) {
                this._buttonContainer.removeLast();
                this._buttonViews.pop();
            }
        }
        _prepareButtons(buttons) {
        }
        _measureButtons(buttons) {
        }
        _renderBody(doc, container, width, height) {
        }
        _submit() {
            return true;
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     *
     * View for FormPanel.
     * template으로 지정한 layout을 표시한다.
     * 상/하/좌/우 지정한 위치에 버튼 목록을 표시한다.
     * 내용은 한 방향으로 스크롤 가능하다.
     */
    class FormPanelView extends DialogPanelView {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(doc, model) {
            super(doc, model, FormPanelView.CLASS_NAME);
            this._layoutChanged = false;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        setLayout(layout) {
            // layout 객체 자체는 매번 새로 생성된다.
            // id는 템플릿 id이다.
            // param으로 설정된 속성들의 값이 매번 달라질 수 있다.
            this._layoutChanged = !this._layout || layout.tid !== this._layout.tid;
            this._layout = layout;
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _prepareBody(doc, container, manager, model) {
            const layout = model.getLayout();
            let lv = this._layoutView;
            this.setLayout(layout);
            if (this._layoutChanged && lv) {
                container.removeChild(lv);
                lv = null;
            }
            if (!lv) {
                container.addChild(lv = this._layoutView = manager.createLayoutView(doc, layout));
                lv.build(doc, manager);
            }
            else {
                // child들의 layout 모델을 갱신한다.
                lv.refreshModels(layout); // as any는 ListItemView 참조.
            }
            lv.prepareLayout(doc, manager);
        }
        _measureBody(doc, manager, container, model, width, height) {
            const sz = this._layoutView.measureLayout(doc, manager, width, Number.MIN_SAFE_INTEGER);
            return sz;
        }
        _renderBody(doc, container, width, height) {
            this._layoutView.move(0, 0);
            this._layoutView.resize(width, height);
            this._layoutView.render(doc);
            container.setHeight(height);
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    FormPanelView.CLASS_NAME = 'dlist-form-panel';

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     *
     * View for ButtonPanel.
     */
    class ButtonPanelView extends ListPanelView {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(doc, model) {
            super(doc, model, ButtonPanelView.CLASS_NAME);
            this._buttonViews = [];
        }
        //-------------------------------------------------------------------------
        // static members
        //-------------------------------------------------------------------------
        static createView(doc, panel, display) {
            switch (display) {
                case DListButtonArrange.VERTICAL:
                    return new ButtonPanelViewV(doc, panel);
                case DListButtonArrange.DEFAULT:
                default:
                    return new ButtonPanelView(doc, panel);
            }
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        display() {
            return DListButtonArrange.DEFAULT;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doInitContent(doc, div) {
            this.addChild(this._buttonContainer = new DElement(doc, false, 'dlist-button-panel-buttons').
                setStyles(this._containerStyle()));
        }
        _doPrepareRender(doc, hint) {
            super._doPrepareRender(doc, hint);
            this.$_prepareButtons(doc, this.model());
        }
        _doMeasureContent(doc, hintWidth, hintHeight) {
            if (this._buttonViews.length > 0) {
                const gap = (this.model().buttonGap() || 0) / 2 + 'px';
                this._layoutButtons(this._buttonViews, gap);
            }
            // render에서 설정할 수 있도록...
            this.content.style.width = '';
            this.content.style.height = '';
            this._buttonContainer.clearSize();
            const w = this._buttonContainer.dom.offsetWidth + this._buttonViews.length; // flexWrap이 'wrap'일 때 +1을 하지 않으면 wrap된다.
            const h = this._buttonContainer.dom.offsetHeight;
            return { width: w, height: h };
        }
        _doRender(doc, width, height) {
            const p = this.model().position();
            this._buttonContainer.dom.style.justifyContent = this.model().align();
            // 버튼들의 위치를 조정할 수 있도록...
            if (p === DListPanelPosition.LEFT || p === DListPanelPosition.RIGHT) {
                this.content.style.height = '100%';
                this._buttonContainer.dom.style.height = '100%';
            }
            else if (p === DListPanelPosition.TOP || p === DListPanelPosition.BOTTOM) {
                this.content.style.width = '100%';
                this._buttonContainer.dom.style.width = '100%';
            }
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        $_prepareButtons(doc, model) {
            const buttons = model.getButtons() || [];
            const views = this._buttonViews;
            const container = this._buttonContainer;
            while (views.length < buttons.length) {
                const v = this._createButton(doc, buttons[views.length]);
                container.addChild(v);
                views.push(v);
            }
            while (views.length > buttons.length) {
                container.removeLast();
                views.pop();
            }
        }
        _containerStyle() {
            return {
                position: 'relative',
                display: 'flex',
                justifyContent: 'center',
                alignItems: 'center',
                flexWrap: 'wrap'
            };
        }
        _layoutButtons(buttons, gap) {
            for (let i = 0, cnt = buttons.length; i < cnt; i++) {
                buttons[i].dom.style.marginLeft = gap;
                buttons[i].dom.style.marginRight = gap;
            }
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    ButtonPanelView.CLASS_NAME = 'dlist-button-panel';
    /**
     * @internal
     *
     * button panel view for DListButtonPanelDisplay.VERTICAL
     */
    class ButtonPanelViewV extends ButtonPanelView {
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        display() {
            return DListButtonArrange.VERTICAL;
        }
        _containerStyle() {
            const style = super._containerStyle();
            style.flexDirection = 'column';
            return style;
        }
        _layoutButtons(buttons, gap) {
            for (let i = 0, cnt = buttons.length; i < cnt; i++) {
                buttons[i].dom.style.marginTop = gap;
                buttons[i].dom.style.marginBottom = gap;
            }
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     *
     * 끝 행 효과.
     */
    class EndBalloon extends DShape {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(doc) {
            super(doc, EndBalloon.CLASS_NAME);
            this.dir = Direction.DOWN;
            this._svg.setStyle({
                position: 'absolute',
                width: '100%',
                height: '100%'
            });
        }
        _doDestory() {
            this._svg.detach();
            super._doDestory();
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        active() {
            return this._svg.svg.firstElementChild && (+new Date() - this._started) <= EndBalloon.DURATION;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        draw() {
            const svg = this._svg;
            const r = this.bounds;
            let path;
            let x;
            let y;
            let w;
            let h;
            switch (this.dir) {
                case 'up':
                    x = r.x;
                    y = r.y + r.height;
                    w = r.width;
                    path = svg.quadratic(x, y, x + w / 2, y, x + w, y);
                    svg._animateRevert(path, `M ${x} ${y} Q ${x + w / 2} ${y} ${x + w} ${y} z`, `M ${x} ${y} Q ${x + w / 2} ${y - EndBalloon.SIZE} ${x + w} ${y} z`, EndBalloon.DURATION);
                    break;
                case 'down':
                    x = r.x;
                    y = r.y;
                    w = r.width;
                    path = svg.quadratic(x, y, x + w / 2, r.y, x + w, y);
                    svg._animateRevert(path, `M ${x} ${y} Q ${x + w / 2} ${y} ${x + w} ${y} z`, `M ${x} ${y} Q ${x + w / 2} ${y + EndBalloon.SIZE} ${x + w} ${y} z`, EndBalloon.DURATION);
                    break;
                case 'left':
                    x = r.x;
                    y = r.y;
                    h = r.height;
                    path = svg.quadratic(x, y, x, y + h / 2, x, y + h);
                    svg._animateRevert(path, `M ${x} ${y} Q ${x} ${y + h / 2} ${x} ${y + h} z`, `M ${x} ${y} Q ${x + EndBalloon.SIZE} ${y + h / 2} ${x} ${y + h} z`, EndBalloon.DURATION);
                    break;
                case 'right':
                    x = r.x + r.width;
                    y = r.y;
                    h = r.height;
                    path = svg.quadratic(x, y, x, y + h / 2, x, y + h);
                    svg._animateRevert(path, `M ${x} ${y} Q ${x} ${y + h / 2} ${x} ${y + h} z`, `M ${x} ${y} Q ${x - EndBalloon.SIZE} ${y + h / 2} ${x} ${y + h} z`, EndBalloon.DURATION);
                    break;
            }
            this._started = +new Date();
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    EndBalloon.CLASS_NAME = 'dlist-end-balloon';
    EndBalloon.SIZE = 50;
    EndBalloon.DURATION = 300;
    class ListFeedback extends DElement {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        clearFeedbacks() {
            if (this._endBalloon && !this._endBalloon.active()) {
                this.removeEndBalloon();
            }
        }
        removeEndBalloon() {
            if (this._endBalloon) {
                this._endBalloon = this._endBalloon.destroy();
                this.setAnimating(false);
            }
        }
        showEndBalloon(bounds, dir) {
            if (this._clearTimer) {
                clearTimeout(this._clearTimer);
                this._clearTimer = undefined;
            }
            if (this._endBalloon) {
                if (this._endBalloon.active()) {
                    return;
                }
                this.removeEndBalloon();
            }
            const eb = this._endBalloon = new EndBalloon(this.doc);
            // console.log('NEW BALLOON');
            eb.bounds = Object.assign({}, bounds);
            eb.dir = dir;
            eb.draw();
            eb.appendTo(this);
            this.setAnimating(true);
            this._clearTimer = setTimeout(() => this.clearFeedbacks(), 1000);
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doInitDom(doc, dom) {
            Object.assign(dom.style, {
                pointerEvents: 'none'
            });
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     *
     * View of {@link StackLayout}.

     * 자식들 중 지정한 것만 표시하고 나머지는 감춘다.
     * layout의 크기가 지정되지 않으면 표시되는 자식의 크기에 맞춰진다.
     */
    class StackLayoutView extends PositionableLayoutView {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(doc, model) {
            super(doc, model);
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doPrepareRender(doc, manager) {
            super._doPrepareRender(doc, manager);
            // prepare children
            const id = this._model.getActiveChild(manager, this._model.row);
            let v = this._visibles.find(view => view.model().id() === id);
            if (!v) {
                v = this._visibles.length > 0 ? this._visibles[this._visibles.length - 1] : null;
            }
            this._visibles.forEach(view => view._internalVisible(view === v));
            if (v) {
                this._childView = v;
                v.prepareView(manager);
                v.setRelativePositions();
                this._visibles = [v];
            }
            else {
                this._visibles = [];
            }
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     *
     * View of {@link FormLayout}.

     * 자식들 중 지정한 것만 표시하고 나머지는 감춘다.
     * layout의 크기가 지정되지 않으면 표시되는 자식의 크기에 맞춰진다.
     */
    class FormLayoutView extends ListLayoutView {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(doc, model) {
            super(doc, model);
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        insertChild(at, child) {
            if (!child._label) {
                const span = child._label = this.doc.createElement('label');
                span.className = FormLayoutView.SPAN_CLASS;
                span.style.position = 'absolute';
                span.style.overflow = 'hidden';
                span.style.textOverflow = 'ellipsis';
                if (DElement.BOUNDING)
                    span.style.border = DElement.BOUNDING_BORDER;
            }
            super.insertChild(at, child);
        }
        _doPrepareRender(doc, manager) {
            super._doPrepareRender(doc, manager);
            // prepare children
            this._visibles.forEach((view, i) => {
                view.prepareView(manager);
            });
            this._labelStyled = false;
        }
        _defaultExplicitWidth(maxWidth) {
            return maxWidth;
        }
        _doMeasureLayout(doc, hint, maxWidth, maxHeight) {
            const visibles = this._visibles;
            this.$_calcLabelSize(visibles, pickNum(this._explicitWidth, maxWidth));
            if (!isNaN(this._szLabel)) {
                maxWidth = Math.max(0, maxWidth - this._szLabel - this.model().itemGap);
            }
            this._measureChildren(visibles, doc, hint, maxWidth, maxHeight, null);
            return this.$_measureContent(doc, maxWidth, maxHeight);
        }
        _doLayoutContent(doc, width, height) {
            const model = this._model;
            const visibles = this._visibles;
            // const spans = this._spans;
            const pts = this._pts;
            const heights = this._heights;
            const szLabel = this._szLabel;
            const wLabel = this._wLabel;
            let x2 = wLabel + model.labelGap;
            visibles.forEach((view, i) => {
                const span = view._label;
                isNaN(szLabel) && Dom.setWidth(span, wLabel); // 고정 크기이면 위 measure에서 미리 크기 지정.
                Dom.move(span, 0, pts[i] + (heights[i] - span.offsetHeight) / 2);
                view.mx = x2;
                view.my = pts[i];
                view.mh = heights[i];
                view.applyMeasuredBounds();
            });
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        $_calcLabelSize(views, expWidth) {
            if (expWidth > 0) {
                const model = this._model;
                const sync = model.syncLabelWidth;
                let { szLabel, szMin, szMax } = model.getLabelWidth(expWidth);
                this._szLabel = szLabel;
                // 각 행의 label 너비를 계산하고 나머지를 view에 고정시킨다.
                // syncLabelWidth가 true면 최대 너비로 모두 설정한다.
                // false면 행 별로 label 너비를 제외한 너비로 layout view들의 너비를 고정시킨다.
                if (isNaN(szLabel)) {
                    const labelStyle = model.labelStyle;
                    let wLabel = 0;
                    views.forEach((view, i) => {
                        const span = view._label;
                        labelStyle && Object.assign(span.style, labelStyle);
                        // span.style.whiteSpace = 'nowrap';
                        span.style.whiteSpace = 'pre';
                        span.textContent = view.model().getChildProp('label');
                        let wSpan = span.offsetWidth + 1; // +1: https://stackoverflow.com/questions/31719624/displaytable-div-with-percentage-width-1px-bug
                        if (sync) {
                            wLabel = Math.max(wLabel, wSpan);
                        }
                        else {
                            wSpan = Utils.clamp(wSpan, szMin, szMax);
                            view._explicitWidth = Math.max(0, expWidth - wSpan);
                        }
                    });
                    if (sync) {
                        this._szLabel = szLabel = wLabel;
                    }
                    this._labelStyled = true;
                }
                // label 너비가 고정이되면 layout view들의 너비를 나머지로 고정시킨다.
                if (!isNaN(szLabel)) {
                    this._szLabel = Utils.clamp(szLabel, szMin, szMax);
                }
            }
        }
        $_measureContent(doc, hintWidth, hintHeight) {
            const model = this._model;
            const visibles = this._visibles;
            // const spans = this._spans;
            const labelStyle = model.labelStyle;
            const gap = model.labelGap;
            const itemGap = model.itemGap;
            const szLabel = this._szLabel;
            const pts = this._pts = [0];
            const heights = this._heights = [];
            let wLabel = 0;
            let w = 0;
            let h = 0;
            // 자식들은 이미 measure된 상태이다.
            if (visibles.length > 0) {
                visibles.forEach((view, i) => {
                    const span = view._label;
                    if (!this._labelStyled) {
                        labelStyle && Object.assign(span.style, labelStyle);
                        // 고정 크기이면 wrap할 수 있도록 크기를 미리 지정한다.
                        if (!isNaN(szLabel)) {
                            Dom.setWidth(span, szLabel);
                            //span.style.whiteSpace = 'normal';
                            span.style.whiteSpace = 'pre-wrap';
                        }
                        else {
                            // span.style.whiteSpace = 'nowrap';
                            span.style.whiteSpace = 'pre';
                        }
                        span.textContent = view.model().getChildProp('label');
                    }
                    else if (!isNaN(szLabel)) {
                        Dom.setWidth(span, szLabel);
                        //span.style.whiteSpace = 'normal';
                        span.style.whiteSpace = 'pre-wrap';
                    }
                    //const hLine = Math.max(span.offsetHeight, pickNum(view._explicitHeight, view.dom.offsetHeight));
                    //const hLine = Math.max(span.offsetHeight, pickNum(view.mh, view.dom.offsetHeight));
                    const hLine = Math.max(span.offsetHeight, view.mh);
                    view._explicitHeight = hLine;
                    heights.push(hLine);
                    h += hLine;
                    if (isNaN(szLabel)) {
                        wLabel = Math.max(wLabel, span.offsetWidth);
                        w = Math.max(w, wLabel + gap + view.dom.offsetWidth);
                    }
                    else {
                        w = Math.max(w, szLabel + gap + view.dom.offsetWidth);
                    }
                    h += itemGap;
                    pts.push(h);
                });
                h -= itemGap;
            }
            this._wLabel = isNaN(szLabel) ? wLabel + 1 : szLabel;
            return { width: w, height: h };
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    FormLayoutView.SPAN_CLASS = 'dlist-form-label';

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     *
     * View for SearchPanel.
     */
    class SearchPanelView extends DialogPanelView {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(doc, model) {
            super(doc, model, SearchPanelView.CLASS_NAME);
        }
        //-------------------------------------------------------------------------
        // static members
        //-------------------------------------------------------------------------
        static createView(doc, panel, display) {
            switch (display) {
                case DListSearchPanelDisplay.LONG:
                    return new SearchPanelViewL(doc, panel);
                case DListSearchPanelDisplay.VERTICAL:
                    return new SearchPanelViewV(doc, panel);
                case DListSearchPanelDisplay.DEFAULT:
                default:
                    return new SearchPanelView(doc, panel);
            }
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        display() {
            return DListSearchPanelDisplay.DEFAULT;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        search() {
            if (this._input.value) {
                this.model().search(this._input.value, this._options);
                return true;
            }
        }
        canShowResult(sr) {
            return this._chkAll.checked && sr && (!sr.isEmpty() || this.model().alwaysResult());
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        // isDom(dom: Element): boolean {
        //     return this.dom.contains(dom) || super.isDom(dom);
        // }
        _initBody(doc, container) {
            this._createElements(doc);
            this._initForm(doc, container);
        }
        _prepareBody(doc, container, manager, model) {
            const options = this._options = this._manager.owner().searchOptions();
            this._spanCase.textContent = model.matchCaseLabel();
            this._chkCase.checked = options.matchCase;
            this._spanWhole.textContent = model.wholeWordLabel();
            this._chkWhole.checked = options.matchWholeWord;
            this._spanExp.textContent = model.regExpLabel();
            this._chkExp.checked = options.useRegExp;
            this._spanNext.textContent = model.searchNextLabel();
            this._chkNext.checked = !options.searchAll;
            this._spanAll.textContent = model.searchAllLabel();
            this._chkAll.checked = options.searchAll;
        }
        _measureBody(doc, manager, container, model, width, height) {
            let gap = model.lineGap();
            if (gap !== this._lineGap) {
                this._lineGap = gap;
                gap = (gap || 0) / 2 + 'px';
                // gap 을 지원하지 않는 이전 버전들이 있다(특히 ios).
                // this._lineContainer.style.gap = (this.model.lineGap() || 0) + 'px'
                this._lines.forEach(line => {
                    line.style.marginTop = gap;
                    line.style.marginBottom = gap;
                });
            }
            // return container.getOffsetSize();
            return { width: container.dom.scrollWidth, height: container.dom.scrollHeight };
        }
        _measureButtons(buttons) {
            this.$_checkOk();
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        $_checkOk() {
            const okBtn = this.getButton(this.model().okButton());
            if (okBtn) {
                okBtn.setEnabled(this._input.value.length > 0);
            }
        }
        _createElements(doc) {
            // input
            this._input = doc.createElement('input');
            this._input.type = 'search';
            this._input.tabIndex = 0;
            this._input.style.width = '100%';
            this._input.oninput = () => {
                this.$_checkOk();
            };
            // case
            this._chkCase = Dom.createCheckBox(doc, null);
            this._chkCase.onchange = () => {
                this._options.matchCase = this._chkCase.checked;
            };
            this._spanCase = doc.createElement('label');
            // whole word
            this._chkWhole = Dom.createCheckBox(doc, null);
            this._chkWhole.onchange = () => {
                this._options.matchWholeWord = this._chkWhole.checked;
            };
            this._spanWhole = doc.createElement('label');
            // regExp
            this._chkExp = Dom.createCheckBox(doc, null);
            this._chkExp.onchange = () => {
                this._options.useRegExp = this._chkExp.checked;
            };
            this._spanExp = doc.createElement('label');
            // next search
            this._chkNext = Dom.createRadio(doc, null);
            this._chkNext.onchange = () => {
                this._options.searchAll = this._chkAll.checked;
            };
            this._spanNext = doc.createElement('label');
            // search all
            this._chkAll = Dom.createRadio(doc, null);
            this._chkAll.onchange = () => {
                this._options.searchAll = this._chkAll.checked;
            };
            this._chkAll.style.marginLeft = '10px';
            this._spanAll = doc.createElement('label');
            this._chkAll.name = this._chkNext.name = 'dl-search';
        }
        _addLine(doc, box, label, div) {
            if (!div) {
                div = Dom.createElement(doc, 'div', {
                    display: 'flex'
                });
            }
            div.appendChild(box);
            box.style.marginRight = '4px';
            label.htmlFor = box.id = Dom.getDomId();
            label.style.whiteSpace = 'pre';
            div.appendChild(label);
            return div;
        }
        _initForm(doc, container) {
            const lines = this._lines = [this._input];
            let line;
            lines.push(this._addLine(doc, this._chkCase, this._spanCase));
            lines.push(this._addLine(doc, this._chkWhole, this._spanWhole));
            lines.push(this._addLine(doc, this._chkExp, this._spanExp));
            line = this._addLine(doc, this._chkNext, this._spanNext);
            lines.push(this._addLine(doc, this._chkAll, this._spanAll, line));
            lines.forEach(line => container.appendDom(line));
        }
        _submit() {
            return this.search();
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    SearchPanelView.CLASS_NAME = 'dlist-search-panel';
    /**
     * @internal
     *
     * 항목들을 최대한 수평으로 배치한다.
     * 버튼들이 우측에 수직으로 배치된다.
     * 수평 모드시 사용한다.
     */
    class SearchPanelViewL extends SearchPanelView {
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        display() {
            return DListSearchPanelDisplay.LONG;
        }
        _getDefaultButtonPosition() {
            return DListPanelButtonPosition.RIGHT;
        }
        _measureBody(doc, manager, container, model, width, height) {
            let gap = model.lineGap();
            this._input.style.marginBottom = gap + 'px';
            this._line.style.marginBottom = gap + 'px';
            return container.getOffsetSize();
        }
        _initForm(doc, container) {
            container.appendDom(this._input);
            let line = this._line = this._addLine(doc, this._chkCase, this._spanCase);
            this._spanCase.style.marginRight = '10px';
            this._addLine(doc, this._chkWhole, this._spanWhole, line);
            this._spanWhole.style.marginRight = '10px';
            this._addLine(doc, this._chkExp, this._spanExp, line);
            container.appendDom(line);
            line = this._addLine(doc, this._chkNext, this._spanNext);
            this._addLine(doc, this._chkAll, this._spanAll, line);
            container.appendDom(line);
        }
    }
    /**
     * @internal
     *
     * 버튼을 포함 모든 항목들을 수직으로 배치한다.
     */
    class SearchPanelViewV extends SearchPanelView {
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        display() {
            return DListSearchPanelDisplay.VERTICAL;
        }
        _measureBody(doc, manager, container, model, width, height) {
            const gap = pixel(model.lineGap() || 0);
            this._input.style.marginBottom = gap;
            this._lines.forEach(line => line.style.marginBottom = gap);
            return container.getOffsetSize();
        }
        _initForm(doc, container) {
            const lines = this._lines = [this._input];
            lines.push(this._addLine(doc, this._chkCase, this._spanCase));
            lines.push(this._addLine(doc, this._chkWhole, this._spanWhole));
            lines.push(this._addLine(doc, this._chkExp, this._spanExp));
            lines.push(this._addLine(doc, this._chkNext, this._spanNext));
            lines.push(this._addLine(doc, this._chkAll, this._spanAll));
            lines.forEach(line => container.appendDom(line));
            this._chkAll.style.marginLeft = '';
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     *
     * View for SearchBar.
     */
    class SearchBarView extends ListSectionView {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(doc, model) {
            super(doc, model, SearchBarView.CLASS_NAME);
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        canEnter() {
            return !this._search.disabled;
        }
        search() {
            if (this.canEnter()) {
                this._model.search(this._input.value);
            }
        }
        setResult(result) {
            this._result = result;
            this._reset.disabled = !result || result.isEmpty();
            this._search.disabled = !result && !this._input.value;
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        isDom(dom) {
            return this.dom.contains(dom) || super.isDom(dom);
        }
        clickable() {
            return true;
        }
        click(dom, x, y) {
            if (dom === this._search) {
                this.search();
            }
            else if (dom === this._reset) {
                this._result.clear();
                this.control.invalidateLayout();
            }
            else if (dom === this._menu) {
                this._model.clickMenu();
            }
        }
        _doInitContent(doc, div) {
            Object.assign(div.style, {
                display: 'flex',
                alignItems: 'center',
                gap: '5px'
            });
            // input
            div.appendChild(this._input = doc.createElement('input'));
            this._input.type = 'search';
            this._input.placeholder = '검색어를 입력하세요.';
            this._input.style.flex = '1 1 auto';
            this._input.oninput = () => {
                this._search.disabled = !this._result && this._input.value.length < 1;
            };
            // search
            div.appendChild(this._search = SvgButton.createButton(doc, SHAPES['@search'], 24, ListSection.BUTTON_CLASS));
            this._search.disabled = true;
            this._search.style.flex = '0 0 auto';
            // reset
            div.appendChild(this._reset = SvgButton.createButton(doc, SHAPES['@refresh'], 24, ListSection.BUTTON_CLASS));
            this._reset.disabled = true;
            this._reset.style.flex = '0 0 auto';
            // menu
            div.appendChild(this._menu = SvgButton.createButton(doc, SHAPES['@menu'], 24, ListSection.BUTTON_CLASS));
            this._menu.style.flex = '0 0 auto';
        }
        _doPrepareRender(doc, owner) {
            const model = this._model;
            this.$_prepareButtons(doc, model);
        }
        _doMeasureContent(doc, hintWidth, hintHeight) {
            const model = this._model;
            this._reset.style.display = model.resetVisible() ? '' : 'none';
            this._menu.style.display = model.optionsVisible() ? '' : 'none';
            return { width: hintWidth, height: this.content.offsetHeight };
        }
        _doRenderContent(doc, width, height) {
            this._model;
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        $_prepareButtons(doc, model) {
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    SearchBarView.CLASS_NAME = 'dlist-search-bar';

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     *
     * View for SearchResultBar.
     */
    class SearchResultView extends ListSectionView {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(doc, model) {
            super(doc, model, SearchResultView.CLASS_NAME);
            this._closed = false;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        setResult(result) {
            this._result = result;
            this._closed = false;
            this.control.invalidateLayout();
            this.refreshView();
        }
        refreshView() {
            const result = this._result;
            if (result) {
                const buttons = this._buttons;
                const empty = result.isEmpty();
                const curr = result.current();
                buttons[SearchResultView.PREV].disabled = buttons[SearchResultView.FIRST].disabled = empty || curr == 0;
                buttons[SearchResultView.NEXT].disabled = buttons[SearchResultView.LAST].disabled = empty || curr === result.count() - 1;
            }
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        isDom(dom) {
            return this.dom.contains(dom) || super.isDom(dom);
        }
        setVisible(value) {
            return super.setVisible(value && !this._closed);
        }
        clickable() {
            return true;
        }
        click(dom, x, y) {
            if (dom === this._close) {
                // alert('Close');
                if (this._model.clearWhenClose()) {
                    this._result.clear();
                }
                this._closed = true;
                this.control.invalidateLayout();
            }
            else {
                for (const p in this._buttons) {
                    if (dom === this._buttons[p]) {
                        // alert(this._buttons[p].value);
                        switch (this._buttons[p].value) {
                            case SearchResultView.FIRST:
                                this._result.moveFirst();
                                break;
                            case SearchResultView.PREV:
                                this._result.movePrev();
                                break;
                            case SearchResultView.NEXT:
                                this._result.moveNext();
                                break;
                            case SearchResultView.LAST:
                                this._result.moveLast();
                                break;
                        }
                        break;
                    }
                }
            }
        }
        _doInitContent(doc, div) {
            Object.assign(div.style, {
                display: 'flex',
                alignItems: 'center',
                gap: '5px'
            });
            // title
            div.appendChild(this._title = doc.createElement('span'));
            Object.assign(this._title.style, {
                flex: '0 1 auto',
                whiteSpace: 'pre',
                overflow: 'hidden',
                textOverflow: 'ellipsis'
            });
            this._title.textContent = '검색 결과:';
            // counts
            div.appendChild(this._counts = doc.createElement('span'));
            Object.assign(this._counts.style, {
                flex: '0 0 auto',
                textAlign: 'center',
                minWidth: '50px'
            });
            this._counts.textContent = '0 / 0';
            // button container
            div.appendChild(this._container = doc.createElement('div'));
            Object.assign(this._container.style, {
                display: 'flex',
                justifyContent: 'center',
                flex: '1 0 auto'
            });
            this.$_prepareButtons(doc, this._container, this._model);
            // close
            div.appendChild(this._close = SvgButton.createButton(doc, SHAPES['@close'], 24, ListSection.BUTTON_CLASS));
            this._close.style.flex = '0 0 auto';
        }
        _doPrepareRender(doc, hint) {
        }
        _doMeasureContent(doc, hintWidth, hintHeight) {
            this.model;
            const r = this._result;
            if (r) {
                this._counts.textContent = (r.current() + 1) + ' / ' + r.count();
            }
            return { width: hintWidth, height: this.content.offsetHeight };
        }
        _doRenderContent(doc, width, height) {
            this.model;
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        $_prepareButton(doc, shape) {
            const button = doc.createElement('button');
            const s = SHAPES[shape];
            const svg = new DSvg(doc);
            svg.setViewSize(s.width);
            svg.path(s.path);
            svg.makeBackground().fillSize();
            button.appendChild(svg.svg);
            button.className = ListSection.BUTTON_CLASS;
            return button;
        }
        $_prepareButtons(doc, container, model) {
            const buttons = this._buttons = {};
            [SearchResultView.FIRST, SearchResultView.PREV, SearchResultView.NEXT, SearchResultView.LAST].forEach((m) => {
                const button = this.$_prepareButton(doc, m);
                button.value = m;
                Dom.resize(button, 24, 24);
                container.appendChild(button);
                buttons[m] = button;
            });
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    SearchResultView.CLASS_NAME = 'dlist-search-result';
    SearchResultView.FIRST = '@first';
    SearchResultView.PREV = '@prev';
    SearchResultView.NEXT = '@next';
    SearchResultView.LAST = '@last';

    ////////////////////////////////////////////////////////////////////////////////
    var DListMenuItemType;
    (function (DListMenuItemType) {
        DListMenuItemType["NORMAL"] = "norml";
        DListMenuItemType["HEADER"] = "header";
        DListMenuItemType["SEPARATOR"] = "separator";
        DListMenuItemType["SUBMENU"] = "submenu";
        DListMenuItemType["CHECK"] = "check";
        DListMenuItemType["RADIO"] = "radio";
    })(DListMenuItemType || (DListMenuItemType = {}));
    /**
     * @internal
     */
    class ListMenuItem extends DObject {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(parent, menu) {
            super();
            //-------------------------------------------------------------------------
            // property fields
            //-------------------------------------------------------------------------
            this.type = DListMenuItemType.NORMAL;
            this._checked = false;
            this._parent = parent;
            Object.assign(this, menu);
            // if (Array.isArray(menu.items) && menu.items.length > 0) {
            //     this.items = menu.items.map(i => new ListMenuItem(i));
            // } else {
            //     this.items = null;
            // }
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        parent() {
            return this._parent;
        }
        get items() {
            return this._items ? this._items.slice(0) : [];
        }
        set items(value) {
            this._items = value ? value.slice(0) : [];
        }
        /** checked */
        get checked() {
            return this._checked;
        }
        set checked(value) {
            if (value !== this._checked) {
                this._checked = value;
                value && this._parent && ListMenu.checkItem(this, this._parent.items);
            }
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        checkable() {
            return this.type === DListMenuItemType.CHECK || this.type === DListMenuItemType.RADIO;
        }
        $_click(control) {
            switch (this.type) {
                case DListMenuItemType.HEADER:
                    break;
                case DListMenuItemType.SEPARATOR:
                    break;
                case DListMenuItemType.CHECK:
                case DListMenuItemType.RADIO:
                    return this.onClick && this.onClick(control, this) === true;
                default:
                    return this.onClick && this.onClick(control, this) === true;
            }
        }
    }
    /**
     * {@link concepts.menu 메뉴}가 animation으로 표시될 때, 드러나는 시작 위치.
     *
     * @see concepts.menu 메뉴 개요
     * @see IListMenu
     */
    var DListMenuOrigin;
    (function (DListMenuOrigin) {
        /**
         * 리스트 위 끝에서 시작한다.
         */
        DListMenuOrigin["TOP"] = "top";
        /**
         * 리스트 아래쪽 끝에서 시작한다.
         */
        DListMenuOrigin["BOTTOM"] = "bottom";
        /**
         * 리스트 왼쪽 끝에서 시작한다.
         */
        DListMenuOrigin["LEFT"] = "left";
        /**
         * 리스트 오른쪽 끝에서 시작한다.
         */
        DListMenuOrigin["RIGHT"] = "right";
        /**
         * 리스트 헤더 아래에서 시작한다.
         */
        DListMenuOrigin["HEADER"] = "header";
        /**
         * 리스트 푸터 위에서 시작한다.
         */
        DListMenuOrigin["FOOTER"] = "footer";
        /**
         * 중앙에 표시한다.
         */
        DListMenuOrigin["CENTER"] = "center";
    })(DListMenuOrigin || (DListMenuOrigin = {}));
    /**
     * @internal
     */
    class ListMenu extends DControlObject {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(owner, source) {
            super(owner);
            this._checkSize = 20;
            this.separator = true;
            this.autoCheck = true;
            this.autoHide = true;
            this.fillWidth = false;
            this.fillHeight = true;
            this.origin = DListMenuOrigin.RIGHT;
            const items = source.items;
            delete source.items;
            try {
                const map = this._itemMap = {};
                Object.assign(this, source);
                if (items) {
                    this._items = items.map(s => new ListMenuItem(this, s));
                    for (let i = this._items.length - 1; i >= 0; i--) {
                        const item = this._items[i];
                        if (item.id) {
                            map[item.id] = item;
                        }
                        if (item.checked && item.checkable()) {
                            this.checkItem(item);
                            break;
                        }
                    }
                }
                else {
                    this._items = [];
                }
            }
            finally {
                items && (source.items = items);
            }
        }
        //-------------------------------------------------------------------------
        // consts
        //-------------------------------------------------------------------------
        static checkItem(item, items) {
            if (item.type === DListMenuItemType.RADIO && items) {
                const group = item.group;
                for (const it of items) {
                    if (it !== item && it.type === DListMenuItemType.RADIO && (it.group === group || !it.group && !group)) {
                        it.checked = false;
                    }
                }
            }
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        get checkSize() {
            return this._checkSize;
        }
        set checkSize(value) {
            if (value !== this._checkSize) {
                this._checkSize = value;
            }
        }
        get items() {
            return this._items ? this._items.slice(0) : [];
        }
        set items(value) {
            this._items = value ? value.slice(0) : [];
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        getItem(id) {
            return this._itemMap[id];
        }
        show(control) {
            this.onShow && this.onShow(control, this);
            this._items.forEach(item => item.onShow && item.onShow(control, item));
        }
        close(control) {
            this.onClose && this.onClose(control, this);
        }
        // NOTE: true를 리턴하면 메뉴가 닫힌다. DefaultTool 참조.
        clickItem(control, item) {
            const checkable = item.checkable();
            if (this.autoCheck && checkable) {
                item.checked = !item.checked;
            }
            if (item.$_click(control)) {
                return this.alwaysHide || !checkable;
            }
            if (this.onClick) {
                this.onClick(control, this, item);
            }
            return this.alwaysHide || !checkable;
        }
        checkItem(item) {
            ListMenu.checkItem(item, this._items);
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    class ListMenuItemView extends DElement {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(doc) {
            super(doc, false, 'dlist-menu-item');
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        model() {
            return this._model;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        setModel(model, bottomLine) {
            this._model = model;
            this._spanLabel.textContent = model.label;
            this._divMenu.style.borderBottom = bottomLine ? '1px solid #ccc' : '';
            if (model.type === DListMenuItemType.CHECK || model.type === DListMenuItemType.RADIO) {
                if (!this._shape || this._shape.name() !== 'check') {
                    if (this._shape) {
                        this._shape.remove();
                    }
                    this._shape = this.control.shapes().createShape(this.doc, '@check');
                    this._shape.appendTo(this._divMenu);
                    this._shape.resize(ListMenuItemView.CHECK_SIZE);
                    this.$_resetCheck(this._shape.dom());
                }
            }
            else if (this._shape) {
                this._shape.setVisible(false);
            }
        }
        refresh() {
            this._shape && this.$_resetCheck(this._shape.dom());
        }
        touched() {
            this.dom.dataset.touched = '1';
        }
        clearTouched() {
            delete this.dom.dataset.touched;
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        isDom(dom) {
            return this.containsDom(dom);
        }
        _doInitDom(doc, dom) {
            Object.assign(dom.style, {
                position: 'relative',
                display: 'flex',
                alignItems: 'center',
                pointerEvents: 'auto'
            });
            this._divImage = doc.createElement('div');
            this._divImage.style.flex = '0 0 24px';
            dom.appendChild(this._divImage);
            this._divMenu = doc.createElement('div');
            Object.assign(this._divMenu.style, {
                display: 'flex',
                alignItems: 'center',
                flex: '1 1 auto',
                boxSizing: 'content-box',
                padding: '10px 5px'
            });
            this._spanLabel = doc.createElement('span');
            Object.assign(this._spanLabel.style, {
                flex: '1 1 auto',
                whiteSpace: 'pre',
                overflow: 'hidden',
                textOverflow: 'ellipsis'
            });
            this._divMenu.appendChild(this._spanLabel);
            dom.appendChild(this._divMenu);
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        $_resetCheck(svg) {
            svg.style.stroke = this._model.checked ? '#333' : '#ccc';
            svg.style.fill = this._model.checked ? '#333' : '#ccc';
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    ListMenuItemView.CHECK_SIZE = 24;
    /**
     * @internal
     *
     * View for ListMenu.
     * 지정한 기준 위치로 부터 반대쪽으로 sliding 시킨다.
     * 컨트롤 전체 바탕을 modal로 처리한다.
     */
    class ListMenuView extends DListElement {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(doc) {
            super(doc, true, 'dlist-menu');
            this._itemPool = [];
            this._itemViews = [];
            this._lineGap = 8;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /** model */
        get model() {
            return this._model;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        show(menu, width, height, animate) {
            if (!this.visible) {
                const c = this._itemContainer;
                this.setVisible(true);
                if (menu.origin === DListMenuOrigin.CENTER) {
                    this.$_refresh(this.doc, menu, width, height, false);
                    c.center(width, height);
                    this.dom.style.backgroundColor = '#00000040';
                    c.dom.style.border = '1px solid #777';
                }
                else {
                    // NOTE: refresh 후에 frame을 생셩해야 itemContainer.width가 계산된다.
                    this.$_refresh(this.doc, menu, width, height);
                    c.dom.style.border = '';
                    if (animate) {
                        const dom = c.dom;
                        let frames;
                        switch (menu.origin) {
                            case DListMenuOrigin.LEFT:
                                frames = [
                                    { left: -c.width + 'px' },
                                    { left: '0px' }
                                ];
                                break;
                            default:
                                frames = [
                                    { left: width + 'px' },
                                    { left: (width - c.width) + 'px' }
                                ];
                                break;
                        }
                        if (frames) {
                            const ani = dom.animate(frames, {
                                delay: 100,
                                duration: 150,
                                fill: 'both'
                            });
                            // Dom.setAnimating(dom, true);
                            ani.addEventListener('finish', () => {
                                // Dom.setAnimating(dom, false);
                            });
                            this.dom.animate([
                                { backgroundColor: '#00000000' },
                                { backgroundColor: '#00000040' }
                            ], {
                                duration: 500,
                                fill: 'both'
                            });
                        }
                    }
                    else {
                        switch (menu.origin) {
                            case DListMenuOrigin.LEFT:
                                this.moveX(0);
                                break;
                            default:
                                this.moveX(width - this._itemContainer.width);
                                break;
                        }
                    }
                }
            }
        }
        hide(animate) {
            if (this.visible) {
                if (animate && this._model.origin !== DListMenuOrigin.CENTER) {
                    const c = this._itemContainer;
                    const dom = c.dom;
                    let frames;
                    switch (this._model.origin) {
                        case DListMenuOrigin.LEFT:
                            frames = [
                                { left: '0px' },
                                { left: -c.width + 'px' }
                            ];
                            break;
                        default:
                            frames = [
                                { left: c.x + 'px' },
                                { left: (c.x + c.width) + 'px' }
                            ];
                            break;
                    }
                    const ani = dom.animate(frames, {
                        duration: 150,
                        fill: 'none' // 중요. 아니면 panel의 padding 스타일이 재적용 되지 않는다.
                    });
                    // Dom.setAnimating(mv.dom, false);
                    ani.addEventListener('finish', () => {
                        this.setVisible(false);
                        const control = this.control.wrapperOrThis();
                        this.remove();
                        this._model.close(control);
                        this._model = null;
                        // Dom.setAnimating(mv.dom, false);
                    });
                    this.dom.animate([
                        { backgroundColor: '#00000040' },
                        { backgroundColor: '#00000000' },
                    ], {
                        duration: 500,
                        fill: 'both'
                    });
                }
                else {
                    this.setVisible(false);
                    this.remove();
                    this._model = null;
                }
                return true;
            }
        }
        $_refresh(doc, menu, width, height, fill = true) {
            const sz = this.measure(doc, this._model = menu, width, height);
            //const w = Math.max(sz.width, width * 0.7 >> 0)
            const w = width * 0.7 >> 0;
            this.resize(width, height);
            this._itemContainer.resize(w, fill ? height : sz.height);
            // this._itemContainer.moveX(width - w);
            this.render(doc);
        }
        resetRadios() {
            this._itemViews.forEach(iv => iv.model().type === DListMenuItemType.RADIO && iv.refresh());
        }
        isMenuView(dom) {
            return this.containsDom(dom);
        }
        setTouched(view) {
            this._touched = view;
            view.touched();
        }
        clearTouched() {
            this._touched && this._touched.clearTouched();
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doInitDom(doc, dom) {
            dom.style.pointerEvents = 'all';
        }
        _doInitContent(doc, div) {
            this._itemContainer = new DElement(doc);
            this._itemContainer.setStyles({
                position: 'absolute',
                display: 'flex',
                flexDirection: 'column',
                padding: '5px 0px',
                backgroundColor: '#efefef'
            });
            this.addChild(this._itemContainer);
        }
        _doPrepareRender(doc, menu) {
            const items = menu.items;
            const pool = this._itemPool;
            const views = this._itemViews;
            while (views.length < items.length) {
                let v = pool.pop();
                if (!v) {
                    v = this.$_createItemView(doc);
                }
                views.push(v);
                this._itemContainer.addChild(v);
            }
            this._model = menu;
        }
        _doMeasure(doc, hintWidth, hintHeight) {
            const model = this._model;
            const views = this._itemViews;
            this._itemContainer.getPadding();
            model.items.forEach((m, i, n) => {
                const v = views[i];
                v.setModel(m, model.separator && i < n.length - 1);
            });
            const sz = this._itemContainer.getOffsetSize();
            return sz;
        }
        _doRender(doc, width, height) {
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        $_createItemView(doc) {
            const v = new ListMenuItemView(doc);
            return v;
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    class FilterItemView extends DElement {
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        isDirty() {
            return this._item.filter.enabled != this._check.checked;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        setItem(item, index, exclusive) {
            const id = FilterItemView.CLASS_NAME + '-' + index;
            if (exclusive)
                debugger;
            this._item = item;
            this._check.id = id;
            this._check.checked = item.filter.enabled;
            this._label.htmlFor = id;
            this._label.textContent = item.label;
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doInitDom(doc, dom) {
            dom.className = FilterItemView.CLASS_NAME;
            Dom.setStyle(dom, {
                position: 'relative',
                display: 'flex',
                flexDirection: 'row',
                padding: '4px 4px'
            });
            dom.appendChild(this._check = Dom.createCheckBox(doc, {
                marginRight: '8px',
                flex: '0 0 auto'
            }));
            dom.appendChild(this._label = Dom.createElement(doc, 'label', {
                flex: '1 1 auto',
                whiteSpace: 'pre'
            }));
        }
    }
    //-------------------------------------------------------------------------
    // static members
    //-------------------------------------------------------------------------
    FilterItemView.CLASS_NAME = 'dlist-filter-panel-item';
    /**
     * @internal
     *
     * View for FilterPanel.
     */
    class FilterPanelView extends DialogPanelView {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(doc, model) {
            super(doc, model, FilterPanelView.CLASS_NAME);
            //-------------------------------------------------------------------------
            // static members
            //-------------------------------------------------------------------------
            //-------------------------------------------------------------------------
            // property fields
            //-------------------------------------------------------------------------
            //-------------------------------------------------------------------------
            // fields
            //-------------------------------------------------------------------------
            this._itemViews = [];
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        // isDom(dom: Element): boolean {
        //     return this.dom.contains(dom) || super.isDom(dom);
        // }
        _prepareBody(doc, container, manager, model) {
            this._dv = manager.data();
            model.prepare(this._dv);
        }
        _prepareButtons(buttons) {
        }
        _measureBody(doc, manager, container, model, width, height) {
            this.$_buildFilters(doc, container, model);
            return container.getOffsetSize();
        }
        _measureButtons(buttons) {
            this.$_checkOk();
        }
        _doAfterRender() {
            this.model().unprepare();
            super._doAfterRender();
        }
        click(dom, x, y) {
            for (let v of this._itemViews) {
                if (v.isView(dom)) {
                    if (this.model().autoApply()) {
                        this._dv.toggleFilter(v._item.filter, true);
                        // panel을 닫는다.
                        return true;
                    }
                    else {
                        setTimeout(() => {
                            this.$_checkOk();
                        }, 0);
                    }
                }
            }
            return false;
        }
        _submit() {
            const filters = this._itemViews.filter(v => v.isDirty()).map(v => v._item.filter);
            this._dv.toggleFilters(filters, true);
            return true;
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        $_buildFilters(doc, container, model) {
            const filters = model.getItems();
            const views = this._itemViews;
            while (views.length < filters.length) {
                const v = new FilterItemView(doc);
                container.addChild(v);
                views.push(v);
            }
            while (views.length > filters.length) {
                views.pop().remove();
            }
            const exclusive = false; //model.model().exclusive;
            views.forEach((v, i) => v.setItem(filters[i], i, exclusive));
            this.$_checkOk();
        }
        $_checkOk() {
            const okBtn = this.getButton(this.model().okButton());
            if (okBtn) {
                for (let v of this._itemViews) {
                    if (v.isDirty()) {
                        okBtn.setEnabled(true);
                        return;
                    }
                }
                okBtn.setEnabled(false);
            }
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    FilterPanelView.CLASS_NAME = 'dlist-filter-panel';

    ////////////////////////////////////////////////////////////////////////////////
    const ONE$1 = '①'.charCodeAt(0);
    class FieldBarItemView extends DElement {
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        setField(field, sort) {
            this._field = field;
            this._span.textContent = field.displayText();
            if (!sort) {
                this._mark.style.display = 'none';
                this._order.style.display = 'none';
            }
            else {
                this._mark.style.display = '';
                this._mark.textContent = sort.dir === DListSortDirection.ASCENDING ? '↓' : '↑'; //'⇅';//'↓';//'↑';//'↕';// '↑';
                this._order.style.display = '';
                this._order.textContent = String.fromCharCode(ONE$1 + sort.order);
            }
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doInitDom(doc, dom) {
            dom.className = FieldBarItemView.CLASS_NAME;
            dom.style.display = 'inline-flex';
            dom.style.alignItems = 'center';
            // label
            dom.appendChild(this._span = Dom.createSpan(doc, {
                whiteSpace: 'pre',
            }));
            // sort dir
            dom.appendChild(this._mark = Dom.createSpan(doc, {
                fontFamily: 'Helvetica',
                fontWeight: 'bold',
                color: '#111',
                marginLeft: '2px'
            }));
            // sort order
            dom.appendChild(this._order = Dom.createSpan(doc, {
                color: '#111',
                fontWeight: 'bold',
                marginLeft: '2px'
            }));
        }
        _getPositionStyle() {
            return '';
        }
    }
    //-------------------------------------------------------------------------
    // static members
    //-------------------------------------------------------------------------
    FieldBarItemView.CLASS_NAME = 'dlist-field-bar-item';
    /**
     * @internal
     *
     * View for FieldBar.
     */
    class FieldBarView extends ListSectionView {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(doc, model) {
            super(doc, model, FieldBarView.CLASS_NAME);
            //-------------------------------------------------------------------------
            // static members
            //-------------------------------------------------------------------------
            //-------------------------------------------------------------------------
            // property fields
            //-------------------------------------------------------------------------
            //-------------------------------------------------------------------------
            // fields
            //-------------------------------------------------------------------------
            this._itemViews = [];
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doInitContent(doc, div) {
            Object.assign(div.style, {
                display: 'flex',
                flexDirection: 'row',
                alignItems: 'center',
                flexWrap: 'wrap',
            });
        }
        _doMeasureContent(doc, hintWidth, hintHeight) {
            this.content.style.width = hintWidth + 'px'; // 이렇게 해줘야 flexWrap인 content의 너비가 결정되고, 처음 표시될 때 높이가 제대로 계산된다.
            this.$_buildItems(doc, this._model);
            return { width: hintWidth, height: this.content.offsetHeight };
        }
        _doRenderContent(doc, width, height) {
            this.content.style.width = '100%';
        }
        clickable() {
            return true;
        }
        isDom(dom) {
            for (let v of this._itemViews) {
                if (v.isView(dom)) {
                    return true;
                }
            }
        }
        click(dom, x, y) {
            for (let v of this._itemViews) {
                if (v.isView(dom)) {
                    this._model.sortField(v._field);
                    break;
                }
            }
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        $_buildItems(doc, model) {
            const fields = model.getFields();
            const views = this._itemViews;
            while (views.length < fields.length) {
                const v = new FieldBarItemView(doc);
                this.addChild(v);
                views.push(v);
            }
            while (views.length > fields.length) {
                this.removeChild(views.pop());
            }
            views.forEach((v, i) => {
                const sort = model.getSort(fields[i]);
                v.setField(fields[i], sort);
            });
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    FieldBarView.CLASS_NAME = 'dlist-field-bar';

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     *
     * View for {@link FieldHeader} model.
     */
    class FieldHeaderView extends LayoutedSectionView {
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(doc, model) {
            super(doc, model, FieldHeaderView.CLASS_NAME);
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        click(dom, _x, _y) {
            const fv = this._layoutView instanceof ListLayoutView && this._layoutView.simpleByDom(dom, true);
            const rd = fv && fv.model().renderer;
            if (rd instanceof FieldRenderer) {
                this.model().sortField(rd.field || fv.model().field());
            }
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    FieldHeaderView.CLASS_NAME = 'dlist-field-header';

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     *
     * View of DHtmlLayout.
     */
    class HtmlLayoutView extends DListElement {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(doc, model) {
            super(doc, false);
            if (!model) {
                throwError(locale.layoutMustSet);
            }
            this._model = model;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        /**
         * 처음 생성될 때,
         * item view의 measure 직전 {@link ListItemView._doPrepareLayout}에서 호출한다.
         */
        build(doc, manager) {
            const view = this._view = this._model.clone();
            // view.style.width = '100%';
            // view.style.height = '100%';
            this.appendDom(view);
        }
        refreshModels(layout) {
        }
        prepareLayout(doc, hint) {
            const css = this.dom.style;
            this._doPrepareRender(doc, hint);
            this._doApplyStyles(css);
            this._doApplyImportantStyles(css);
            this._prevMax = { width: NaN, height: NaN };
            this.mw = this.mh = NaN;
            const p = this._padding = this.getPadding2();
            p.horz = p.left + p.right + p.borderLeft + p.borderRight;
            p.vert = p.top + p.bottom + p.borderTop + p.borderBottom;
        }
        measureLayout(doc, hint, maxWidth, maxHeight) {
            const p = this._padding;
            maxWidth -= p.horz;
            maxHeight -= p.vert;
            const sz = this._doMeasure(doc, maxWidth, maxHeight);
            this.mw = sz.width += p.horz;
            this.mh = sz.height += p.vert;
            return sz;
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doInitContent(doc, div) {
            if (DElement.BOUNDING) {
                div.style.boxSizing = 'border-box';
                div.style.border = DElement.BOUNDING_BORDER_2;
            }
        }
        prepareView(manager) {
        }
        _doPrepareRender(doc, manager) {
            this._manager = manager;
        }
        _doApplyStyles(css) {
            // const styles = this.model().style;
            // if (styles) {
            //     Object.assign(css, styles);
            // } 
        }
        _doApplyImportantStyles(css) {
            this.setImportantStyle(css, 'position', 'absolute');
            this.setImportantStyle(this._view.style, 'position', 'absolute');
        }
        _doMeasure(doc, maxWidth, maxHeight) {
            this._manager;
            const widthExplicited = !isNaN(this._explicitWidth);
            !isNaN(this._explicitHeight);
            if (widthExplicited) {
                maxWidth = this._explicitWidth;
            }
            // if (this._model.style) {
            //     p = this._padding = this.getPadding();
            //     maxWidth -= p.left + p.right;
            //     maxHeight -= p.top + p.bottom;
            // } else {
            //     this._padding = null;
            // }
            // if (this._visibles.length > 0) {
            //     this._setExplicits(this._visibles, maxWidth, maxHeight);
            //     this._checkRelatives(doc, manager, this._visibles, maxWidth, maxHeight);
            //     this._visibles.forEach((child: LayoutChildView<T>) => {
            //         // 이전에 measure한 적이 없는 경우라면
            //         if (isNaN(child.mw) && isNaN(child.mh)) {
            //             child.measure(doc, manager, maxWidth, maxHeight); 
            //         }
            //     });
            // }
            this._view.style.width = maxWidth + 'px';
            this._model.apply(this._view);
            const w = maxWidth;
            const h = this._view.offsetHeight;
            // if (p) {
            //     sz.width += p.left + p.right;
            //     sz.height += p.top + p.bottom;
            // }
            // if (widthExplicited) {
            //     sz.width = this._explicitWidth;
            // }
            // if (heightExplicited) {
            //     // 지정된 크기를 넘칠 수 있다. 스크롤하게 한다.
            //     if (sz.height > this._explicitHeight && manager.owner().isSingleRow() && this.isRoot()) {
            //     } else {
            //         sz.height = this._explicitHeight;
            //     }
            // }
            // return sz;
            return { width: w, height: h };
        }
        _doRender(doc, width, height) {
            // const visibles = this._visibles;
            // const p = this._padding;
            // if (p) {
            //     width -= p.left + p.right;
            //     height -= p.top + p.bottom;
            // }
            // this.resizeContent(width, height);
            // this._doLayoutContent(doc, width, height);         
            // visibles.forEach((child: DListElement) => {
            //     child.render(doc); 
            // });
            // // layout에 포함된 simple들의 renderer 재생성 순서가 일치되도록 거꾸로 push되게한다.
            // for (let i = visibles.length - 1; i >= 0; i--) {
            //     if (visibles[i] instanceof SimpleLayoutView) {
            //         (visibles[i] as  SimpleLayoutView<any>).freeRenderer();
            //     }
            // }
            Dom.resize(this.dom, width, height);
        }
        _doAfterRender() {
            super._doAfterRender();
            this._manager = null;
        }
        _doMeasureContent(doc, hintWidth, hintHeight) {
            return;
        }
        _doLayoutContent(doc, width, height) {
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * Toast message 표시 위치.
     * <br>
     * {@link IListToast.position} 속성 값으로 사용된다.
     *
     * @see concepts.toast Toast 메시지 개요
     */
    var DListToastPosition;
    (function (DListToastPosition) {
        /**
         * 컨트롤 상단에 표시.
         */
        DListToastPosition["TOP"] = "top";
        /**
         * 컨트롤 하단에 표시.
         */
        DListToastPosition["BOTTOM"] = "bottom";
        /**
         * 컨트롤 중앙에 표시.
         */
        DListToastPosition["CENTER"] = "center";
    })(DListToastPosition || (DListToastPosition = {}));
    /**
     * @internal
     *
     * {@link DListControl} 페이징 모델.<br>
     * 그룹핑과 배타적이다. 즉, 둘 중 하나만 적용될 수 있다.
     *
     * 연결된 data 행 수가 변경되면 바로 반영된다.
     * 즉, 동적으로 페이징을 구현할 수 있다.
     */
    class ListToast extends DEventProvider {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(source) {
            super();
            this.duration = 3000;
            this.position = DListToastPosition.BOTTOM;
            this.margin = 50;
            if (source) {
                this.message = source.message;
                this.html = source.html;
                if (source.duration > 0) {
                    this.duration = source.duration;
                }
                if (source.position) {
                    this.position = source.position;
                }
                if (!isNaN(source.margin)) {
                    this.margin = source.margin;
                }
                this.style = source.style;
            }
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     *
     * View for toast.
     */
    class ToastView extends DElement {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(doc) {
            super(doc, false, 'dlist-toast');
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        show(parent, model) {
            const dom = this.dom;
            const width = parent.width;
            const height = parent.height;
            // 기존에 표시 중이면 감춘다.
            this.$_hide();
            if (typeof model.style === 'string') {
                this.setClassName(model.style);
            }
            else if (model.style) {
                this.setStyles(model.style);
            }
            parent.addChild(this);
            this.setVisible(true);
            if (model.html) {
                dom.innerHTML = model.html;
            }
            else {
                dom.textContent = model.message;
            }
            const h = dom.offsetHeight;
            const margin = model.margin;
            let y;
            switch (model.position) {
                case DListToastPosition.TOP:
                    y = margin;
                    break;
                case DListToastPosition.CENTER:
                    y = (height - h) / 2 + margin;
                    break;
                default:
                    y = height - h - margin;
                    break;
            }
            y = Math.max(0, Math.min(height - h, y));
            this.move((width - dom.offsetWidth) / 2, y);
            this.$_show(model);
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        $_hide() {
            this.setVisible(false);
            this.remove();
        }
        $_show(model) {
            this.dom.animate([
                { opacity: '0' },
                { opacity: '1' }
            ], {
                duration: ToastView.EFFECT_DURATION,
                fill: 'forwards'
            });
            const ani = this.dom.animate([
                { opacity: '1' },
                { opacity: '0' }
            ], {
                delay: model.duration,
                duration: ToastView.EFFECT_DURATION * 2,
                fill: 'forwards'
            });
            ani.addEventListener('finish', () => {
                this.$_hide();
            });
        }
    }
    //-------------------------------------------------------------------------
    // static members
    //-------------------------------------------------------------------------
    ToastView.EFFECT_DURATION = 500;

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     *
     * View of {@link ScrollLayout}.

     * 자식들의 위치를 left|right|top|bottom 고정값 혹은 %값으로 지정된다.
     * 위치를 지정하지 않으면 상하/좌우 중앙에 표시된다.
     */
    class ScrollLayoutView extends ListLayoutView {
        //-------------------------------------------------------------------------
        // consts
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // static members
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // property fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(doc, model) {
            super(doc, model);
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        scrollable() {
            return true;
        }
        _doInitContent(doc, div) {
            super._doInitContent(doc, div);
            div.style.overflow = 'auto';
        }
        _doPrepareRender(doc, manager) {
            super._doPrepareRender(doc, manager);
            if (this._visibles.length > 0) {
                this._visibles[0].prepareView(manager);
            }
        }
        _doLayoutContent(doc, width, height) {
            if (this._visibles.length > 0) {
                this._visibles[0].applyMeasuredBounds();
            }
        }
        _doMeasureLayout(doc, hint, maxWidth, maxHeight) {
            this._measureChildren(this._visibles, doc, hint, maxWidth, maxHeight, null);
            return { width: maxWidth, height: maxHeight };
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    const DEF_LETTERS = '가-하,A-Z';
    /**
     * @internal
     *
     * Alphabetic scroll index bar.
     * 한글 영문 알파벳들로 표시되는 스크롤 인덱스 바
     * 문자를 클릭하면 문자에 해당하는 최초의 데이터행 혹은 해당하는 그룹 헤더가 표시되도록 스크롤한다.
     * 컨트롤 생성 시 기본적으로 표시되지 않는다.
     */
    class IndexBar extends ListControlObject {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        _doInitDefaults() {
            super._doInitDefaults();
            this.setVisible(false);
            this.setLength(IndexBar.LENGTH);
            this._floating = false;
            this._minWidth = IndexBar.MIN_WIDTH;
            this._spaceCharacter = '•';
            this._caseSensitive = false;
            this._autoScroll = true;
            this._groups = this._defGroups = this.$_buildGroups(DEF_LETTERS);
        }
        //-------------------------------------------------------------------------
        // events
        //-------------------------------------------------------------------------
        /**
         * 문자 클릭 시 호출된다.
         * undefined가 아닌 값을 리턴하면 해당 값의 위치로 스크롤한다.
         */
        onLetterClick() {
            return pickProp(this._onLetterClick, this._defs && this._defs._onLetterClick);
        }
        setOnLetterClick(value) {
            this._onLetterClick = value;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * 인덱스바 전체 길이(높이 혹은 너비).
         * 최대 길이이다. 표시할 문자 수 등에 따라 실제 표시 길이는 이 속성 값보다 작을 수 있다.
         * 숫자나 컨트롤 길이에 대한 상대값을 '%'로 지정할 수 있다.
         * 잘못된 값으로 지정하면 '85%'로 계산된다.
         */
        length() {
            return pickProp(this._length, this._defs && this._defs._length);
        }
        setLength(value) {
            if (!isValidSizeValue(value)) {
                value = IndexBar.LENGTH;
            }
            if (value !== this._length) {
                this._length = value;
                this._changed();
            }
        }
        /**
         * true면 {@link width}로 지정한 자체 영역을 차지 않고 내용 위에 중첩돼서 표시된다.
         */
        floating() {
            return pickProp(this._floating, this._defs && this._defs._floating);
        }
        setFloating(value) {
            if (value !== this._floating) {
                this._floating = value;
                this._changed();
            }
        }
        /**
         * 이 속성을 NaN이 아닌 값으로 지정하면 내용과 상관없이 이 속성값의 폭으로 표시된다.
         * 단, {@link minWidth}와 {@link maxWidth} 사이의 값으로 조정된다.
         */
        width() {
            return pickProp(this._width, this._defs && this._defs._width);
        }
        setWidth(value) {
            value = pickNum(value, NaN);
            if (value !== this._width) {
                this._width = value;
                this._changed();
            }
        }
        /**
         * 최소 폭 크기.
         * 타당한 값으로 지정되면 내용이나 width, maxWidth 값과 관계없이
         * 항상 이 속성값 이상의 폭으로 표시된다.
         */
        minWidth() {
            return pickProp(this._minWidth, this._defs && this._defs._minWidth);
        }
        setMinWidth(value) {
            value = pickNum(value, NaN);
            if (value !== this._minWidth) {
                this._minWidth = value;
                this._changed();
            }
        }
        /**
         * 최대 폭 크기.
         * 타당한 값으로 지정되면 내용이나 width 값과 관계없이
         * 항상 이 속성값 이하의 폭으로 표시된다.
         */
        maxWidth() {
            return pickProp(this._maxWidth, this._defs && this._defs._maxWidth);
        }
        setMaxWidth(value) {
            value = pickNum(value, NaN);
            if (value !== this._maxWidth) {
                this._maxWidth = value;
                this._changed();
            }
        }
        /**
         * 이 속성을 지정하면 문자 사이에 이 속성 글자를 표시해서 문자 간격을 유지시킨다.
         * 이 속성이 지정되면 {@link letterGap}은 무시된다.
         */
        spaceCharacter() {
            return pickProp(this._spaceCharacter, this._defs && this._defs._spaceCharacter);
        }
        setSpaceCharacter(value) {
            if (value !== this._spaceCharacter) {
                this._spaceCharacter = value;
                this._changed();
            }
        }
        /**
         * true면 {@link autoScroll} 시 대소문자 구분하여 데이터행을 찾는다.
         */
        caseSensitive() {
            return pickProp(this._caseSensitive, this._defs && this._defs._caseSensitive);
        }
        setCaseSensitive(value) {
            this._caseSensitive = value;
        }
        /**
         * 표시할 문자들. 두 문자 이상 지정해도 첫 문자만 표시한다.
         * 인덱스 바의 크기에 따라 지정한 문자들이 모두 표시되지 못할 수 있다.
         * 문자들은 '-'을 이용하여 범위로 설정할 수 있고, ','을 이용하여 그룹으로 분할할 수 있다.
         * 적어도 각 그룹의 한 문자는 표시되도록 구성한다.
         * 이 속성을 지정하지 않으면 기본 문자셋 '가-하,A-Z'으로 표시 문자들을 구성한다.
         * 한글의 경우 항상 초성 낱자로 표시된다.
         * 즉, '가'로 지정해도 'ㄱ'로 표시된다.
         */
        letters() {
            return pickProp(this._letters, this._defs && this._defs._letters);
        }
        setLetters(value) {
            value = value ? value.trim() : value;
            if (value !== this._letters) {
                this._letters = value;
                this._groups = this.$_buildGroups(value);
                this._changed();
            }
        }
        /**
         * letter 클릭 시 행 이동 기준이 되는 데이터 필드 이름.
         */
        indexField() {
            return pickProp(this._indexField, this._defs && this._defs._indexField);
        }
        setIndexField(value) {
            this._indexField = value;
        }
        /**
         * 문자 클릭 시 해당 문자와 관련된 최초의 데이터행이 표시되도록 스크롤한다.
         * 단, {@link onLetterClick} 콜백에서 true를 리턴하면 자동 스크롤하지 않는다.
         */
        autoScroll() {
            return pickProp(this._autoScroll, this._defs && this._defs._autoScroll);
        }
        setAutoScroll(value) {
            this._autoScroll = value;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        /** bar 길이 */
        getLength(domain) {
            return calcPercent(this._len, domain);
        }
        getLetters(maxCount) {
            function extractLetters(group, count) {
                if (count === 1) {
                    letters.push(group[0]);
                }
                else {
                    const step = group.length / count;
                    let p = 0;
                    let i = 1;
                    letters.push(group[0]);
                    while (i < group.length) {
                        if (i - p >= step) {
                            letters.push(group[i >> 0]);
                        }
                        p = i;
                        i += step;
                    }
                }
            }
            let groups = this._groups;
            if (!groups) {
                if (this._defs) {
                    groups = this._defs._groups || this._defs._defGroups;
                }
                else {
                    groups = this._defGroups;
                }
            }
            let letters = [];
            for (let i = 0, n = Math.min(maxCount, groups.length); i < n; i++) {
                letters.push(groups[i][0]);
            }
            let remains = maxCount - letters.length;
            if (remains > 0) {
                const groups2 = groups.slice(0).sort((g1, g2) => g2.length - g1.length);
                const nGroup = groups2.length;
                const remains2 = remains;
                const counts = [];
                let sum = 0;
                letters = [];
                for (let g of groups2) {
                    sum += g.length - 1;
                }
                if (sum <= maxCount) {
                    for (let g of groups2) {
                        for (let c of g) {
                            letters.push(c);
                        }
                    }
                }
                else {
                    remains = maxCount;
                    for (let i = 0; i < nGroup && remains > 0; i++) {
                        const n = Math.floor(groups2[i].length * remains2 / sum);
                        counts.push(n);
                        remains -= n;
                    }
                    if (remains > 0) {
                        for (let i = 0; i < nGroup && remains > 0; i++) {
                            const n = groups2[i].length * remains2 / sum;
                            if (Math.round(n) > n) {
                                counts[i]++;
                                remains--;
                            }
                        }
                    }
                    if (remains > 0) {
                        for (let i = 0; i < nGroup && remains > 0; i++) {
                            counts[i]++;
                            remains--;
                        }
                    }
                    for (let i = 0; i < nGroup; i++) {
                        const group = groups[i];
                        const n = counts[groups2.indexOf(group)];
                        extractLetters(group, n);
                    }
                }
            }
            return letters;
        }
        clickLetter(letter) {
            const cb = this.onLetterClick();
            if (cb) {
                return cb(letter);
            }
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doPrepareRender() {
            this._len = parsePercentSize(this.length(), false);
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        $_extractChars(group) {
            const arr = group.trim().split('');
            const chars = [];
            if (arr.length > 0) {
                for (let i = 0; i < arr.length; i++) {
                    const c = arr[i];
                    for (let j = 0; j < KR_LETTERS.length - 1; j++) {
                        if (c >= KR_LETTERS[j] && c < KR_LETTERS[j + 1]) {
                            arr[i] = KR_LETTERS[j];
                        }
                    }
                }
                if (arr.length > 2 && arr[1] === '-') {
                    let c = arr[0];
                    const c2 = arr[2];
                    do {
                        chars.push(c);
                        if (c >= KR_LETTERS[0] && c <= KR_LETTERS[KR_LETTERS.length - 1]) {
                            c = KR_LETTERS[KR_LETTERS.indexOf(c) + 1];
                        }
                        else {
                            c = String.fromCharCode(c.charCodeAt(0) + 1);
                        }
                    } while (c <= c2);
                }
                else {
                    for (let i = 0; i < arr.length; i++) {
                        chars.push(arr[i]);
                    }
                }
            }
            return chars.length > 0 ? chars : null;
        }
        $_buildGroups(letters) {
            const groups = letters.split(',').map(g => this.$_extractChars(g)).filter(g => !!g);
            return groups.length > 0 ? groups : null;
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    IndexBar.LENGTH = '85%';
    IndexBar.MIN_WIDTH = 20;
    IndexBar.LETTER_GAP = 2;

    ////////////////////////////////////////////////////////////////////////////////
    var DPageNavigatorAction;
    (function (DPageNavigatorAction) {
        DPageNavigatorAction["FIRST"] = "first";
        DPageNavigatorAction["PREV"] = "prev";
        DPageNavigatorAction["NEXT"] = "next";
        DPageNavigatorAction["LAST"] = "last";
    })(DPageNavigatorAction || (DPageNavigatorAction = {}));
    class PageNavigatorItem extends DWrappableObject {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(owner, action, label, defs) {
            super();
            this._disabled = false;
            this._owner = owner;
            this._action = action;
            this._label = label;
            this._defs = defs;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        owner() {
            return this._owner;
        }
        action() {
            return this._action;
        }
        label() {
            return this._label;
        }
        /**
         * 기본 스타일외에 추가로 설정할 css selector.
         */
        className() {
            return pickProp(this._className, this._defs && this._defs._className);
        }
        setClassName(value) {
            if (value !== this._className) {
                this._className = value;
                this._changed();
            }
        }
        /**
         * 기본 스타일외에 disabled일 때 추가로 설정할 css selector.
         */
        disabledClass() {
            return pickProp(this._disabledClass, this._defs && this._defs._disabledClass);
        }
        setDisabledClass(value) {
            if (value !== this._disabledClass) {
                this._disabledClass = value;
                this._changed();
            }
        }
        /**
         * [접근성] 정보.
         * 아이템 element의 title로 사용된다.
         * 지정하지 않으면 다음과 같은 기본값이 적용된다.
         *
         * 페이지 이동이 아나라 표시할 데이터를 바꾸는 것이다?
         * first: '시작 페이지 데이타 표시', //'시작 페이지로 이동',
         * last: '마지막 페이지 데이타 표시', //'마지막 페이지로 이동',
         * prev: '이전 페이지 데이타 표시', //'이전 페이지로 이동',
         * next: '다음 페이지 데이타 표시', //'다음 페이지로 이동'
         */
        hint() {
            return pickProp(this._hint, this._defs && this._defs._hint);
        }
        setHint(value) {
            if (value !== this._hint) {
                this._hint = value;
                this._changed();
            }
        }
        /**
         * 비활성 상태 여부.
         */
        disabled() {
            // property가 아니라 status이다.
            //return pickProp(this._disabled, this._defs && (this._defs as PageNavigatorItem)._disabled);
            return this._disabled;
        }
        $_setDisabled(value) {
            if (value !== this._disabled) {
                this._disabled = value;
                this._changed();
            }
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        run() {
            const pm = this._owner.owner().pageModel();
            switch (this._action) {
                case DPageNavigatorAction.FIRST:
                    pm.setPage(0);
                    break;
                case DPageNavigatorAction.PREV:
                    pm.incPage(-1);
                    break;
                case DPageNavigatorAction.NEXT:
                    pm.incPage(1);
                    break;
                case DPageNavigatorAction.LAST:
                    pm.setPage(pm.pageCount() - 1);
                    break;
            }
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        _changed() {
            var _a;
            (_a = this._owner) === null || _a === void 0 ? void 0 : _a['_itemChanged'](this);
        }
    }
    class PageNavigatorIndex extends DWrappableObject {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(owner, defaults) {
            super();
            this._owner = owner;
            this._defs = defaults;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * 기본 스타일외에 추가로 설정할 css selector.
         */
        className() {
            return pickProp(this._className, this._defs && this._defs._className);
        }
        setClassName(value) {
            if (value !== this._className) {
                this._className = value;
                this._changed();
            }
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        _changed() {
            var _a;
            (_a = this._owner) === null || _a === void 0 ? void 0 : _a['_itemChanged'](this);
        }
    }
    /**
     * @internal
     *
     * 시작,끝,이전,다음 페이지 버튼 표시.
     * 중앙에 현재/전체 페이지 번호 표시.
     * 컨트롤이 paging 상태일 때만 표시될 수 있다.
     */
    class PageNavigator extends PositionableControlObject {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(control, owner, defaults) {
            super(control, defaults);
            this._owner = owner;
            this._first = new PageNavigatorItem(this, DPageNavigatorAction.FIRST, '<<', defaults && defaults._first);
            this._prev = new PageNavigatorItem(this, DPageNavigatorAction.PREV, '<', defaults && defaults._prev);
            this._next = new PageNavigatorItem(this, DPageNavigatorAction.NEXT, '>', defaults && defaults._next);
            this._last = new PageNavigatorItem(this, DPageNavigatorAction.LAST, '>>', defaults && defaults._last);
            this._page = new PageNavigatorIndex(this, defaults && defaults._page);
            this._total = new PageNavigatorIndex(this, defaults && defaults._total);
        }
        _doInitDefaults() {
            super._doInitDefaults();
            // this._orientation = DOrientation.HORIZONTAL;
            this._width = 60;
            this._height = 60;
            this._itemGap = 10;
            this._buttonSize = 36;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        owner() {
            return this._owner;
        }
        // /**
        //  * 항목 배치 방향.
        //  */
        // get orientation(): DOrientation {
        //     return this._orientation;
        // }
        // set orientation(value: DOrientation) {
        //     if (value !== this._orientation) {
        //         this._orientation = value;
        //         this._changed('orientation');
        //     }
        // }
        first() {
            return this._first;
        }
        prev() {
            return this._prev;
        }
        next() {
            return this._next;
        }
        last() {
            return this._last;
        }
        /**
         * {@link orientation}이 {@link DOrientation.VERTICAL}일 때 내비게이터 너비.
         */
        width() {
            return pickProp(this._width, this._defs && this._defs._width);
        }
        setWidth(value) {
            if (value !== this._width) {
                this._width = value;
                this._changed();
            }
        }
        /**
         * {@link orientation}이 {@link DOrientation.HORIZONTAL}일 때 내비게이터 높이.
         */
        height() {
            return pickProp(this._height, this._defs && this._defs._height);
        }
        setHeight(value) {
            if (value !== this._height) {
                this._height = value;
                this._changed();
            }
        }
        /**
         * 아이템 사아의 간격.
         * 중앙 배치되는 페이지 번호/전체 항목을 기준으로 좌우 배치하는 간격.
         * 숫자값으로 지정하지 않으면 남아 있는 공간을 골고루 배분한다.
         */
        itemGap() {
            return pickProp(this._itemGap, this._defs && this._defs._itemGap);
        }
        setItemGap(value) {
            if (value !== this._itemGap) {
                this._itemGap = value;
                this._changed();
            }
        }
        /**
         * 컨트롤이 landscape이고, navigator가 수직으로 배치될 때 아이템들 사이의 간격.
         * 지정하지 않고 itemGap이 설정된 상태면 itemGap의 반으로 계산된다.
         * itemGap도 설정되지 않으면 남아 있는 공간으로 골고루 배분한다.
         */
        itemGap2() {
            return pickProp(this._itemGap2, this._defs && this._defs._itemGap2);
        }
        setItemGap2(value) {
            if (value !== this._itemGap2) {
                this._itemGap2 = value;
                this._changed();
            }
        }
        /**
         * button 기본 스타일에 padding이 적용되어 있으므로,
         * padding으로 고려해서 크기를 지정해야 한다.
         * 버튼 크기를 지정하지 않으면 button svg의 기본 크기(16px)에 의해 버튼 크기가 결정된다.
         */
        buttonSize() {
            return pickProp(this._buttonSize, this._defs && this._defs._buttonSize);
        }
        setButtonSize(value) {
            value = toNumProp(value);
            if (value !== this._buttonSize) {
                this._buttonSize = value;
                this._changed();
            }
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doPrepareRender() {
            const pm = this._owner.pageModel();
            const page = pm.page();
            const count = pm.pageCount();
            this._first.$_setDisabled(page === 0);
            this._prev.$_setDisabled(this._first.disabled());
            this._last.$_setDisabled(page >= count - 1);
            this._next.$_setDisabled(this._last.disabled());
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        _itemChanged(item) {
            this._changed();
        }
    }
    /**
     * @internal
     *
     * Page scroller index 모델.
     * 각 index는 한 페이지를 의마한다.
     */
    class PageScrollerIndex extends DWrappableObject {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(owner, defaults) {
            super();
            this._owner = owner;
            this._defs = defaults || void 0; // null로 설정하면 안된다. pickNum3() 등에서 void 0으로 간주한다.
            !defaults && this._doInitDefaults();
        }
        _doInitDefaults() {
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * 기본 스타일외에 추가로 설정할 css selector.
         */
        className() {
            return pickProp(this._className, this._defs && this._defs._className);
        }
        setClassName(value) {
            if (value !== this._className) {
                this._className = value;
                this._changed();
            }
        }
        /**
         * [접근성] 정보.
         * 인덱스 element의 title로 사용된다.
         * 지정하지 않으면 다음과 같은 기본값이 적용된다.
         *
         * first: '시작 페이지로 이동',
         * last: '마지막 페이지로 이동',
         * current: '현재 페이지',
         * page index: 'n페이지로 이동'
         *
         * 페이지 인덱스의 hint에는 '${page}'를 포함할 수 있는데,
         * 인덱스에 해당하는 페이지 번호로 대체된다.
         */
        hint() {
            return pickProp(this._hint, this._defs && this._defs._hint);
        }
        setHint(value) {
            if (value !== this._hint) {
                this._hint = value;
            }
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        _changed() {
            var _a;
            (_a = this._owner) === null || _a === void 0 ? void 0 : _a['_indexChanged'](this);
        }
    }
    class PageScrollerEndIndex extends PageScrollerIndex {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        _doInitDefaults() {
            super._doInitDefaults();
            this._visible = true;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * visible
         */
        visible() {
            return pickProp(this._visible, this._defs && this._defs._visible);
        }
        setVisible(value) {
            if (value !== this._visible) {
                this._visible = value;
                this._changed();
            }
        }
    }
    var DPageScrollerPosition;
    (function (DPageScrollerPosition) {
        DPageScrollerPosition["NEAR"] = "near";
        DPageScrollerPosition["FAR"] = "far";
    })(DPageScrollerPosition || (DPageScrollerPosition = {}));
    /**
     * @internal
     *
     * 페이지 번호를 연속적으로 표시하고 드래그로 스크롤링한다.
     * 양끝에 시작 번호, 끝 번호를 표시한다.
     * 번호를 클릭해서 페이지로 이동한다.
     * 컨트롤이 paging 상태일 때만 표시될 수 있다.
     * page navigator와 동시에 표시될 경우 navigator 바깥에 표시된다.
     */
    class PageScroller extends ListControlObject {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(owner, defaults) {
            super(owner, defaults);
            this._first = new PageScrollerEndIndex(this, defaults && defaults._first);
            this._last = new PageScrollerEndIndex(this, defaults && defaults._last);
            this._index = new PageScrollerIndex(this, defaults && defaults._index);
            this._current = new PageScrollerIndex(this, defaults && defaults._current);
        }
        _doInitDefaults() {
            super._doInitDefaults();
            this.setVisible(false);
            this._position = DPageScrollerPosition.FAR;
            // this._orientation = DOrientation.HORIZONTAL;
            this._itemGap = 7;
            this._autoScroll = true;
            this._width = 50;
            this._height = 50;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * {@link PageScroller 페이지 스크롤러} 표시 위치.
         * 화면이 portrait일 때 'far'이면 bottom에, 'near'이면 top에 표시.
         * landscape일 때 'far'이면 right, 'near'이면 left에 표시.
         */
        position() {
            return pickProp(this._position, this._defs && this._defs._position);
        }
        setPosition(value) {
            if (value !== this._position) {
                this._position = value;
                this._changed('position');
            }
        }
        // /**
        //  * 항목 배치 방향.
        //  */
        // get orientation(): DOrientation {
        //     return pickProp(this._orientation, this._defs && this._defs._orientation);
        // }
        // set orientation(value: DOrientation) {
        //     if (value !== this._orientation) {
        //         this._orientation = value;
        //         this._changed('orientation');
        //     }
        // }
        /**
         * 페이지 인덱스 아이템들 사이의 간격.
         */
        itemGap() {
            return pickProp(this._itemGap, this._defs && this._defs._itemGap);
        }
        setItemGap(value) {
            value = Utils.toNumber(value, 0);
            if (value !== this._itemGap) {
                this._itemGap = value;
                this._changed('itemGap');
            }
        }
        /**
         * 컨트롤 페이지 인덱스가 변경됐을 때,
         * 현재 페이지 인덱스가 표시되지 않은 상태라면.
         * 표시되도록 자동 스크롤한다.
         */
        autoScroll() {
            return this._autoScroll;
        }
        setAutoScroll(value) {
            this._autoScroll = value;
        }
        /**
         * 시작 번호에 대한 설정.
         */
        first() {
            return this._first;
        }
        /**
         * 끝 번호에 대한 설정.
         */
        last() {
            return this._last;
        }
        /**
         * 페이지 번호들에 대한 설정.
         */
        index() {
            return this._index;
        }
        /**
         * 현재 페이지에 대한 설정.
         */
        current() {
            return this._current;
        }
        /**
         * {@link orientation}이 {@link DOrientation.VERTICAL}일 때 내비게이터 너비.
         */
        width() {
            return pickProp(this._width, this._defs && this._defs._width);
        }
        setWidth(value) {
            value = toNumProp(value);
            if (value !== this._width) {
                this._width = value;
                this._changed();
            }
        }
        /**
         * {@link orientation}이 {@link DOrientation.HORIZONTAL}일 때 내비게이터 높이.
         */
        height() {
            return pickProp(this._height, this._defs && this._defs._height);
        }
        setHeight(value) {
            value = toNumProp(value);
            if (value !== this._height) {
                this._height = value;
                this._changed();
            }
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doPrepareRender() {
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        _indexChanged(index) {
            this._changed();
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     *
     * 컨트롤 우측이나 아래쪽에 표시되는 스크롤바.
     * Thumb을 드래그하여 행 단위로 스크롤한다.
     * 컨트롤 생성 시 기본적으로 표시되지 않는다.
     */
    class ScrollBar extends ListControlObject {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        _doInitDefaults() {
            super._doInitDefaults();
            this.setVisible(false);
            this._floating = true;
            this._barWidth = ScrollBar.BAR_WIDTH;
            this._thumbWidth = ScrollBar.THUMB_WIDTH;
            this._minThumbLength = ScrollBar.MIN_THUMB_LENGTH;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * true면 행들 위에 중첩되어 표시된다.
         */
        floating() {
            return pickProp(this._floating, this._defs && this._defs._floating);
        }
        setFloating(value) {
            if (value !== this._floating) {
                this._floating = value;
                this._changed();
            }
        }
        /**
         * 스크롤바 전체 폭.
         * 숫자로 변환될 수 없는 값을 지정하면 기본 너비로 지정된다.
         */
        barWidth() {
            return pickProp(this._barWidth, this._defs && this._defs._barWidth);
        }
        setBarWidth(value) {
            value = pickNum(value, void 0);
            if (!isNaN(value))
                value = Math.max(0, value);
            if (value !== this._barWidth) {
                this._barWidth = value;
                this._changed();
            }
        }
        /**
         * 스크롤바 thumb 폭.
         * 숫자로 변환될 수 없는 값을 지정하면 기본 너비로 지정된다.
         */
        thumbWidth() {
            return pickProp(this._thumbWidth, this._defs && this._defs._thumbWidth);
        }
        setThumbWidth(value) {
            value = pickNum(value, void 0);
            if (!isNaN(value))
                value = Math.max(0, value);
            if (value !== this._thumbWidth) {
                this._thumbWidth = value;
                this._changed();
            }
        }
        /**
         * 스크롤바의 최소 길이.
         */
        minThumbLength() {
            return pickProp(this._minThumbLength, this._defs && this._defs._minThumbLength);
        }
        setMinThumbLength(value) {
            value = pickNum(value, void 0);
            if (!isNaN(value))
                value = Math.max(0, value);
            if (value !== this._minThumbLength) {
                this._minThumbLength = value;
                this._changed();
            }
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doPrepareRender() {
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    ScrollBar.BAR_WIDTH = 6;
    ScrollBar.THUMB_WIDTH = 4;
    ScrollBar.PIXELS_PER_ROW = 1;
    ScrollBar.MIN_THUMB_LENGTH = 30;

    ////////////////////////////////////////////////////////////////////////////////
    class SelectionMask extends ListControlObject {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        _doInitDefaults() {
            super._doInitDefaults();
            this._showHandle = true;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * 핸들 표시 여부.
         */
        showHandle() {
            return pickProp(this._showHandle, this._defs && this._defs._showHandle);
        }
        setShowHandle(value) {
            if (value !== this._showHandle) {
                this._showHandle = value;
                this._changed();
            }
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doPrepareRender() {
        }
    }
    /**
     * @internal
     *
     * 행 선택 모델.
     * 그룹핑 상태면 item.index(vindex가 아니다), 아니면 데이터행 번호를 기준으로 설정한다.
     * data 변경을 바로 반영하지 않고 기존 선택 영역을 유지한다.
     * 사용자 ui 에서는 row 기준으로 선택하게 한다.
     */
    class DSelection extends DObject {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(dataOrGroup, start, end) {
            super();
            this._group = dataOrGroup instanceof GroupModel ? dataOrGroup : null;
            this._data = dataOrGroup instanceof GroupModel ? dataOrGroup.data() : dataOrGroup;
            this._start = start;
            this._end = end;
        }
        _doDestory() {
            this._group = null;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        get start() {
            return this._start;
        }
        get end() {
            return this._end;
        }
        get min() {
            return Math.min(this._start, this._end);
        }
        get max() {
            return Math.max(this._start, this._end);
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        resize(newEnd) {
            if (newEnd >= 0) {
                newEnd = Math.min(newEnd, this.$_getMax());
                if (newEnd !== this._end) {
                    this._end = newEnd;
                    return true;
                }
            }
            return false;
        }
        contains(index) {
            return index >= this.min && index <= this.max;
        }
        /**
         * O(n) - 데이터행 수.
         */
        isRowSelected(row) {
            if (this._group) {
                const item = this._group.itemOfRow(row, false);
                return item && this.contains(item.index);
            }
            else {
                return this.contains(row);
            }
        }
        getSelectedRows() {
            if (this._group) {
                const rows = [];
                for (let i = this.min, max = this.max; i <= max; i++) {
                    const item = this._group.getItem(i);
                    if (item instanceof GroupRow) {
                        rows.push(item.row());
                    }
                }
                return rows;
            }
            else {
                return Utils.makeIntArray(this.min, this.max + 1);
            }
        }
        getSelectedItems() {
            return Utils.makeIntArray(this.min, this.max + 1);
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        $_getMax() {
            return this._group ? this._group.itemCount() - 1 : this._data.rowCount() - 1;
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    class DataRowInfo {
        constructor() {
            //-------------------------------------------------------------------------
            // fields
            //-------------------------------------------------------------------------
            this.template = undefined;
            this.indent = undefined;
            this.rowBar = undefined;
            this.editBar = undefined;
            this.style = undefined;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        assign(source) {
            return Utils.assignProps(this, source);
        }
        copy() {
            return Object.assign({}, this);
        }
    }
    class DataRowInfoCollection extends DWrappableObject {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(owner, defaults) {
            super();
            this._infos = {};
            this._owner = owner;
            this._defs = defaults || void 0;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        master() {
            const info = this._master || this._defs && this._defs._master;
            return info && info.copy();
        }
        setMaster(value) {
            if (value !== this._master) {
                if (value) {
                    if (!this._master)
                        this._master = new DataRowInfo();
                    this._master.assign(value);
                }
                else {
                    this._master = undefined;
                }
                this._owner.invalidateLayout();
            }
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        prepareRender() {
            this.dv = this._owner.data();
        }
        getInfo(dataName) {
            const info = this._infos[dataName];
            return info && info.copy();
        }
        setInfo(dataName, info, redraw = true) {
            const di = this._infos[dataName] || new DataRowInfo();
            const changed = di.assign(info);
            this._infos[dataName] = di;
            // if (redraw && changed && this._owner.data() instanceof ListDataSet) {
            //     this._owner.invalidateLayout();
            // }
            return changed;
        }
        setInfos(infos) {
            for (const d in infos) {
                if (this.setInfo(d, infos[d], false)) ;
            }
            // if (changed && this._owner.data() instanceof ListDataSet) {
            //     this._owner.invalidateLayout();
            // }
        }
        getRowTemplate(dataName) {
            const info = this._infos[dataName];
            let template = pickProp(info && info.template, this._defs && this._defs.getRowTemplate(dataName));
            // if (template === void 0 && this.dg && this.dg.isMaster(dataName)) {
            //     template = this._master && this._master.rowTemplate;
            // }
            return template;
        }
        getIndent(dataName) {
            const info = this._infos[dataName];
            return pickProp(info && info.indent, this._defs && this._defs.getIndent(dataName));
        }
        getRowBar(dataName) {
            const info = this._infos[dataName];
            return pickProp(info && info.rowBar, this._defs && this._defs.getRowBar(dataName));
        }
        getEditBar(dataName) {
            const info = this._infos[dataName];
            return pickProp(info && info.editBar, this._defs && this._defs.getEditBar(dataName));
        }
        getStyle(dataName) {
            const info = this._infos[dataName];
            return pickProp(info && info.style, this._defs && this._defs.getStyle(dataName));
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    class RowPageHeader extends ListHeader {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        _doInitDefaults() {
            super._doInitDefaults();
            this.setVisible(true);
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        caption() {
            return pickProp(this._model && this._model.caption, super.caption());
        }
        style() {
            return pickProp(this._model && this._model.style, super.style());
        }
        showCheck() {
            return pickProp(this._model && this._model.showCheck, super.showCheck());
        }
        autoCheck() {
            return pickProp(this._model && this._model.autoCheck, super.autoCheck());
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        setModel(model) {
            this._model = model || void 0;
        }
    }
    const TEMPLATE = function (callback) {
        const t = {
            template: {
                layout: 'vlinear',
                itemsAlign: 'left',
                children: []
            },
            rowStyle: {
                padding: '11px 9px'
            }
        };
        callback && callback(t);
        return t;
    };
    const FORM_TEMPLATE = function (callback) {
        const t = {
            template: {
                layout: 'form',
                maxLabelWidth: '40%',
                labelStyle: { fontWeight: 'bold', textAlign: 'right' },
                children: []
            },
            rowStyle: {
                padding: '11px 9px'
            }
        };
        callback && callback(t);
        return t;
    };
    /**
     * @internal
     *
     * RowList view 관련 설정 객체.
     * RowList template을 지정하지 않으면 지정한 data의 필드 구성을 기준으로 템플릿을 자동 생성한다.
     * RowList view의 param inflater이다.
     */
    class RowPage extends DWrappableOptions {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(owner, defaults) {
            super(owner, defaults);
            this._allFields = true;
            this._args = {
                context: this,
                control: void 0,
                row: -1,
                field: void 0,
                values: void 0
            };
            this._header = this._createHeader(owner, defaults);
        }
        _doInitDefaults() {
            this._effectDuration = 0.2;
            this._showDirection = DListSlideDirection.UP;
            this._hideDirection = DListSlideDirection.DEFAULT; // showDirection의 반대 방향.
        }
        inflateParam(target, field, param) {
            const params = this.templateParams2();
            if (params) {
                const p = param.name;
                const v = params[p];
                if (typeof v === 'function') {
                    const args = this._args;
                    args.control = this.owner().wrapperOrThis();
                    args.row = this._row;
                    args.field = field;
                    args.values = this._rowValues;
                    return v(args);
                }
                else if (v !== void 0) {
                    return v;
                }
            }
        }
        inflateStock(target, field, param) {
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        data() {
            return this.owner().data();
        }
        /** header */
        header() {
            return this._header;
        }
        /**
         * true로 지정되면, layout 계산 크기가 list 본체 영역보다 작을 때 본체 영역 크기에 맞춘다.
         * 계산 크기가 넘치면 이 속성과 상관 없이 스크롤 시킨다.
         */
        fitSize() {
            return pickProp(this._fitSize, this._defs && this._defs._fitSize);
        }
        setFitSize(value) {
            this._fitSize = value;
        }
        /**
         * Row page view 스타일셋 혹은 className.
         */
        style() {
            return pickProp(this._style, this._defs && this._defs._style);
        }
        setStyle(value) {
            this._style = value;
        }
        /** animation effect duration */
        effectDuration() {
            return pickProp(this._effectDuration, this._defs && this._defs._effectDuration);
        }
        setEffectDuration(value) {
            this._effectDuration = value;
        }
        /** Row page template */
        template() {
            return pickProp3(this._model && this._model.template, this._template, this._defs && this._defs._template);
        }
        setTemplate(value) {
            this._template = value;
        }
        /**
         * 페이지가 애니메이션으로 표시될 때 드러나는 방향.
         */
        showDirection() {
            return pickProp(this._showDirection, this._defs && this._defs._showDirection);
        }
        setShowDirection(value) {
            this._showDirection = value;
        }
        /**
         * 페이지가 애니메이션으로 숨겨질 때 감춰지는 방향.
         */
        hideDirection() {
            return pickProp(this._hideDirection, this._defs && this._defs._hideDirection);
        }
        setHideDirection(value) {
            this._hideDirection = value;
        }
        /**
         * 자동 생성 템플릿에 모든 필드를 포함시킨다.
         */
        allFields() {
            return pickProp3(this._model && this._model.allFields, this._allFields, this._defs && this._defs._allFields);
        }
        setAllFields(value) {
            this._allFields = value;
        }
        /**
         * 자동 생성 템플릿에 포함될 필드 목록.
         * 각 필드에는 표시 설정 정보들이 포함된다.
         * 이 목록에 포함되지 않은 필드들은 {@link allFields} 설정에 따라 표시 여부가 결정된다.
         */
        fields() {
            return pickProp3(this._model && this._model.fields, this._fields, this._defs && this._defs._fields);
        }
        setFields(value) {
            this._fields = Object.assign({}, value);
        }
        /**
         * 자동 생성 템플릿의 **vars**로 설정된다.
         * 즉, 여기에 설정된 값들은 {@link fields}에 추가되는 필드들의 style, renderer 설정에
         * **'--'** prefix를 추가해서 사용할 수 있다.
         */
        templateVars() {
            return pickProp3(this._model && this._model.templateVars, this._templateVars, this._defs && this._defs._templateVars);
        }
        setTemplateVars(value) {
            this._templateVars = value;
        }
        /**
         * NOTE: inflate 시점에 LayoutFactory가 templateParams를 설정하므로 이름 변경.
         */
        templateParams2() {
            return pickProp3(this._model && this._model.templateParams, this._templateParams, this._defs && this._defs._templateParams);
        }
        setTemplateParams2(value) {
            this._templateParams = value;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        setModel(model) {
            this._model = model || void 0; // null인 경우 undefined로 만든다. pickProp()를 위해
            this._header.setModel(model && model.header);
        }
        getLayout(dv, row) {
            const t = this.owner().getTemplate(this.template()) || this._getDefaultTemplate(dv, this.templateVars(), row);
            this._rowInflater = this.owner().getRowInflater(row);
            this._row = row;
            this._rowValues = this._getRowValues();
            return {
                layout: LayoutFactory.Instance.layoutFromTemplate(this.wrapperOrThis(), this, false, false, t, this),
                rowStyle: t.rowStyle,
                rowProps: t.rowProps
            };
        }
        getShowDirection() {
            let dir = this.showDirection();
            if (dir === DListSlideDirection.RANDOM) {
                dir = this.$_getRandomDir();
            }
            return dir;
        }
        getHideDirection(showDirection) {
            let dir = this.hideDirection();
            if (dir === DListSlideDirection.RANDOM) {
                dir = this.$_getRandomDir();
            }
            else if (dir === DListSlideDirection.DEFAULT) {
                switch (showDirection) {
                    case DListSlideDirection.LEFT:
                        dir = DListSlideDirection.RIGHT;
                        break;
                    case DListSlideDirection.RIGHT:
                        dir = DListSlideDirection.LEFT;
                        break;
                    case DListSlideDirection.DOWN:
                        dir = DListSlideDirection.UP;
                        break;
                    default:
                        dir = DListSlideDirection.DOWN;
                        break;
                }
            }
            return dir;
        }
        $_getRandomDir() {
            while (true) {
                const d = Utils.erandom(DListSlideDirection);
                if (d !== DListSlideDirection.RANDOM && d !== DListSlideDirection.DOWN) { // TODO: 'down'은 다소 어색하다.
                    return d;
                }
            }
        }
        _getLabelRenderer(fld) {
            return 'text';
        }
        _getDefRenderer(fld) {
            return 'text';
        }
        _prepareFields(dv) {
            const empty = {};
            const fields = this.fields() || {};
            const runs = [];
            const allFields = this.allFields();
            dv.fields().forEach(fld => {
                const field = fields[fld.name] || empty;
                if (allFields || field !== empty) {
                    runs.push({
                        field: fld.name,
                        label: pickProp(field.label, fld.displayText()),
                        unit: field.unit,
                        default: field.default,
                        required: field.required,
                        renderer: pickProp(field.renderer, this._getDefRenderer(fld)),
                        style: field.style,
                        labelRenderer: this._getLabelRenderer(fld),
                        validator: field.validator
                    });
                }
            });
            return runs;
        }
        _isImageRenderer(renderer) {
            if (renderer) {
                const t = typeof renderer === 'string' ? renderer : renderer.type;
                return t === 'image';
            }
        }
        /**
         * templateVar가 존재하고 '--value' 형식으로 지정한 경우,
         * template으로 넘기지 않고 미리 확장해서 기본 스타일에 적용한다.
         */
        _extendStyle(style, field, templateVars) {
            const st = field.style;
            if (!style || !templateVars) {
                return st;
            }
            else {
                if (typeof st === 'string' && templateVars && templateVars[st.substring(2)]) {
                    const obj = templateVars[st.substring(2)];
                    obj && Object.assign(style, obj);
                }
                else if (Utils.isObject(st)) {
                    Object.assign(style, st);
                }
                return style;
            }
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     *
     * Row edit page 헤더 설정 모델.
     */
    class RowEditPageHeader extends RowPageHeader {
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doInitDefaults() {
            super._doInitDefaults();
            this.setButtons([{
                    name: 'back',
                    label: '〈',
                    position: DListSectionButtonPosition.HEAD,
                    style: { fontSize: '20px', fontWeight: 'bold' },
                    onClick: (args) => {
                        args.control.closeEditPage();
                    }
                }, {
                    name: 'cancel',
                    label: "취소",
                    onClick: (args) => {
                        args.control.closeEditPage(false);
                    }
                }, {
                    name: 'commit',
                    label: "완료",
                    onClick: (args) => {
                        args.control.closeEditPage(true);
                    }
                }]);
        }
    }
    /**
     * 편집 페이지 뷰 템플릿 종류.
     * <br>
     * {@link DListRowEditPage.viewType} 속성으로 사용된다.
     *
     * @see concepts.edit_page Row 편집 페이지
     */
    var DListEditPageType;
    (function (DListEditPageType) {
        /**
         * 기본 템플릿.
         * <br>
         */
        DListEditPageType["DEFAULT"] = "default";
        /**
         * Label + Input 으로 구성되는 폼 형식 템플릿
         * <br>
         */
        DListEditPageType["FORM"] = "form";
        DListEditPageType["A"] = "A";
    })(DListEditPageType || (DListEditPageType = {}));
    const LINE$1 = {
        left: 20,
        right: 10,
        height: 20,
        renderer: 'line'
    };
    const BUTTONS = function (callback) {
        const t = {
            layout: 'hlinear',
            width: '100%',
            itemsArrange: 'end',
            style: { paddingRight: '10px', paddingTop: '10px' },
            children: [{
                    renderer: {
                        type: 'button',
                        label: '취소',
                        buttonWidth: 80,
                        onClick: (args) => {
                            args.control.closeEditPage(false);
                        },
                        style: {}
                    }
                }, {
                    renderer: {
                        type: 'button',
                        label: '완료',
                        buttonWidth: 80,
                        onClick: (args) => {
                            args.control.closeEditPage(true);
                        },
                        style: {}
                    }
                }]
        };
        callback && callback(t);
        return t;
    };
    /**
     * @internal
     *
     * Row edit page 관련 설정 객체.
     */
    class RowEditPage extends RowPage {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(owner, defaults) {
            super(owner, defaults);
            this._defaultTemplate = (dv, templateVars, row) => {
                const t = TEMPLATE();
                const childs = t.template.children;
                dv.fields().forEach(fld => {
                    const label = [{
                            value: fld.displayText()
                        }];
                    if (fld.required) {
                        label.push({
                            value: '*',
                            style: {
                                color: '#a00',
                                fontSize: '20px'
                            }
                        });
                    }
                    childs.push({
                        layout: 'hlinear',
                        children: label
                    });
                    childs.push({
                        id: fld.name,
                        left: 20,
                        right: 10,
                        field: fld.name,
                        renderer: this._getDefRendderer(fld)
                    });
                    childs.push({
                        space: 10
                    });
                });
                childs.push(LINE$1, BUTTONS());
                t.vars = templateVars;
                return new DListTemplate(null, t);
            };
            this._formTemplate = (dv, templateVars, row) => {
                const t = FORM_TEMPLATE();
                const childs = t.template.children;
                dv.fields().forEach(fld => {
                    childs.push({
                        id: fld.name,
                        label: fld.displayText(),
                        field: fld.name,
                        renderer: this._getDefRendderer(fld)
                    });
                });
                childs.push(LINE$1, BUTTONS(t => t.style.paddingRight = '0px'));
                t.vars = templateVars;
                return new DListTemplate(null, t);
            };
            this._ATemplate = (dv, templateVars, row) => {
                return;
            };
            this._templates = {
                defafult: this._defaultTemplate,
                form: this._formTemplate,
                A: this._ATemplate,
            };
        }
        //-------------------------------------------------------------------------
        // fields
        //-----------------------------------------------------  --------------------
        _getDefRendderer(fld) {
            switch (fld.type) {
                case DListDataType.NUMBER:
                    return 'number';
                case DListDataType.DATE:
                    return 'datetime';
                case DListDataType.BOOL:
                    return 'switch';
                default:
                    return 'input';
            }
        }
        _doInitDefaults() {
            super._doInitDefaults();
            this._viewType = DListEditPageType.DEFAULT;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /** viewType */
        viewType() {
            return pickProp(this._viewType, this._defs && this._defs._viewType);
        }
        setViewType(value) {
            this._viewType = value;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        // edit view에서 호출한다.
        valueChanged(ctx, field, newValue, oldValue) {
            const cb = this.owner().onEditFieldChange;
            cb && cb({ ctx, row: this._row, field, newValue, oldValue });
        }
        // list control에서 호출한다.
        commit(ctx, values) {
            const cb = this.owner().onEditCommit;
            if (cb) {
                const args = {
                    ctx,
                    row: this._row,
                    values,
                    cancel: false,
                    message: void 0
                };
                cb(args);
                if (args.cancel) {
                    if (args.message) {
                        throw args.message;
                    }
                    return false;
                }
            }
            if (this._row >= 0) {
                this.data().updateRow(this._row, values, false);
            }
            else {
                this.data().appendRow(values);
            }
            return true;
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _getRowValues() {
            return {};
        }
        _createHeader(owner, defaults) {
            return new RowEditPageHeader(owner, defaults && defaults.header());
        }
        _getDefaultTemplate(dv, templateVars, row) {
            return (this._templates[this.viewType()] || this._defaultTemplate)(dv, templateVars, row);
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    var DListSingleRowChangeEffect;
    (function (DListSingleRowChangeEffect) {
        DListSingleRowChangeEffect["SLIDE"] = "slide";
        DListSingleRowChangeEffect["FLIP"] = "flip";
    })(DListSingleRowChangeEffect || (DListSingleRowChangeEffect = {}));
    class SingleRowScroll extends AutoScroll {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        _doInitDefaults() {
            super._doInitDefaults();
            this.setDuration(10 * 1000);
            this.setChangeDuration(500);
            this._changeEffect = DListSingleRowChangeEffect.SLIDE;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /** change effect */
        changeEffect() {
            return pickProp(this._changeEffect, this._defs && this._defs._changeEffect);
        }
        setChangeEffect(value) {
            this._changeEffect = value;
        }
    }
    /**
     * @internal
     *
     * 리스트 컨트롤 전체를 데이터행 하나로 채우는 표시 방식.
     * 데이터행 내용이 컨트를 크기 범위를 벗어나면 스크롤된다.
     * full 모드에서는 데이터행 내용에 맞게 높이가 조정된다.
     */
    class SingleRow extends DWrappableOptions {
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(owner, defaults) {
            super(owner, defaults);
            this._autoScroll = new SingleRowScroll(owner, defaults && defaults._autoScroll);
        }
        _doInitDefaults() {
            this._visible = false;
            this._noShrink = true;
            this._maskEffect = true;
            this._showPrev = false;
            this._showNext = false;
            this._rowChangeDir = DRowChangeDirection.DEFAULT;
            this._rowBorderVisible = false;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * Single Row 표시 여부.
         * <br>
         *
         * @default false
         */
        visible() {
            return pickProp(this._visible, this._defs && this._defs._visible);
        }
        setVisible(value) {
            if (value !== this._visible) {
                this._visible = value;
                this._changed();
            }
        }
        /**
         * 데이터행 레이아웃 자식들의 크기 합이 레이아웃 크기보다 클 때에도 shrink하지 않는다.
         * <br>
         * 데이터행 내용이 화면을 넘치면 스크롤되게 한다.
         *
         * @default true
         */
        noShrink() {
            return pickProp(this._noShrink, this._defs && this._defs._noShrink);
        }
        setNoShrink(value) {
            this._noShrink = value;
        }
        /**
         * 데이터행 변경 시 숨겨진 행 mask 효과.
         *
         * @default true
         */
        maskEffect() {
            return pickProp(this._maskEffect, this._defs && this._defs._maskEffect);
        }
        setMaskEffect(value) {
            this._maskEffect = value;
        }
        /**
         * @noimpl
         *
         * true이고 rowTemplate의 brief 템플릿이 설정되면 상단에 표시.
         * <br>
         * 이 행을 클릭하면 이 행으로 이동.
         *
         * @default false
         */
        showPrev() {
            return pickProp(this._showPrev, this._defs && this._defs._showPrev);
        }
        setShowPrev(value) {
            if (value !== this._showPrev) {
                this._showPrev = value;
                this._changed();
            }
        }
        /**
         * @noimpl
         *
         * true이고 rowTemplate의 brief 템플릿이 설정되면 하단에 표시.
         * <br>
         * 이 행을 클릭하면 이 행으로 이동.
         *
         * @default false
         */
        showNext() {
            return pickProp(this._showNext, this._defs && this._defs._showNext);
        }
        setShowNext(value) {
            if (value !== this._showNext) {
                this._showNext = value;
                this._changed();
            }
        }
        /**
         * swipe 제스처로 행 이동 시 방향.
         * <br>
         *
         * @default DRowChangeDirection.DEFAULT
         */
        rowChangeDir() {
            return pickProp(this._rowChangeDir, this._defs && this._defs._rowChangeDir);
        }
        setRowChangeDir(value) {
            value = value || DRowChangeDirection.DEFAULT;
            if (value !== this._rowChangeDir) {
                this._rowChangeDir = value;
                this._changed();
            }
        }
        /**
         * @noimpl
         *
         * 행 이동 navigator. 필요한가?
         */
        rowNavigator() {
            return pickProp(this._rowNavigator, this._defs && this._defs._rowNavigator);
        }
        setRowNavigator(value) {
            if (value !== this._rowNavigator) {
                this._rowNavigator = value;
                this._changed();
            }
        }
        /**
         * 이 속성이 true가 아니면 리스트 rowBorder.visible이 true이어도
         * single row 모드일 때 행 bottom/right 라인이 표시되지 않는다.
         */
        rowBorderVisible() {
            return pickProp(this._rowBorderVisible, this._defs && this._defs._rowBorderVisible);
        }
        setRowBorderVisible(value) {
            if (value !== this._rowBorderVisible) {
                this._rowBorderVisible = value;
                this._changed();
            }
        }
        autoScroll() {
            return this._autoScroll;
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     *
     * Search Bar.
     */
    class SearchBar extends ListSection {
        constructor() {
            super(...arguments);
            //-------------------------------------------------------------------------
            // fields
            //-------------------------------------------------------------------------
            this._menu = {
                items: [{
                        id: 'case',
                        type: DListMenuItemType.CHECK,
                        label: '대소문자 구분',
                        onShow: (control, item) => {
                            item.checked = this._options.matchCase;
                        },
                        onClick: (control, item) => {
                            this._options.matchCase = item.checked;
                            return true;
                        }
                    }, {
                        id: 'whole',
                        type: DListMenuItemType.CHECK,
                        label: '전체 단어 일치',
                        onShow: (control, item) => {
                            item.checked = this._options.matchWholeWord;
                        },
                        onClick: (control, item) => {
                            this._options.matchWholeWord = item.checked;
                            return true;
                        }
                    }, {
                        id: 'regExp',
                        type: DListMenuItemType.CHECK,
                        label: '정규식 사용',
                        onShow: (control, item) => {
                            item.checked = this._options.useRegExp;
                        },
                        onClick: (control, item) => {
                            this._options.useRegExp = item.checked;
                            return true;
                        }
                    }],
                onShow: (control, menu) => {
                }
            };
            this._options = {
                matchCase: false,
                matchWholeWord: false,
                useRegExp: false
            };
            //-------------------------------------------------------------------------
            // internal members
            //-------------------------------------------------------------------------
        }
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        _doInitDefaults() {
            super._doInitDefaults();
            this.setVisible(false);
            this._position = DListBarPosition.AFTER;
            this._resetVisible = true;
            this._optionsVisible = true;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * 표시 위치
         */
        position() {
            return pickProp(this._position, this._defs && this._defs._position);
        }
        setPosition(value) {
            this._position = value;
        }
        /**
         * reset 버튼 표시 여부
         */
        resetVisible() {
            return pickProp(this._resetVisible, this._defs && this._defs._resetVisible);
        }
        setResetVisible(value) {
            this._resetVisible = value;
        }
        /**
         * options 버튼 표시 여부
         */
        optionsVisible() {
            return pickProp(this._optionsVisible, this._defs && this._defs._optionsVisible);
        }
        setOptionsVisible(value) {
            this._optionsVisible = value;
        }
        /**
         * 검색 결과가 0건이어도 결과 view를 표시한다.
         *
         * @default false
         */
        alwaysResult() {
            return this._alwaysResult;
        }
        setAlwaysResult(value) {
            this._alwaysResult = value;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        search(key) {
            this.owner().search(this._options, key);
        }
        clickMenu() {
            this.owner().toggleMenu(this._menu, true);
        }
        canShowResult(sr) {
            return this.visible() && sr && (!sr.isEmpty() || this.alwaysResult());
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doPrepareRender() {
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    SearchBar.TYPE = 'search';
    var DSearchResultPosition;
    (function (DSearchResultPosition) {
        /**
         * List footer 이전에 표시.
         */
        DSearchResultPosition["BEFORE"] = "before";
        /**
         * List footer 이후에 표시.
         */
        DSearchResultPosition["AFTER"] = "after";
        /**
         * List footer를 감추고 그 자리에 표시.
         */
        DSearchResultPosition["REPLACE"] = "replate";
    })(DSearchResultPosition || (DSearchResultPosition = {}));
    /**
     * @internal
     *
     * Search Result Bar.
     * 검색 결과가 설정되지 않으면 visible이 true이어도 표시되지 않는다.
     */
    class SearchResultBar extends ListSection {
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        _doInitDefaults() {
            super._doInitDefaults();
            this._position = DSearchResultPosition.BEFORE;
            this._clearWhenClose = true;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * 표시 위치.
         */
        position() {
            return pickProp(this._position, this._defs && this._defs._position);
        }
        setPosition(value) {
            this._position = value;
        }
        /**
         * close 버튼 클릭 시 검색 결과 clear.
         */
        clearWhenClose() {
            return pickProp(this._clearWhenClose, this._defs && this._defs._clearWhenClose);
        }
        setClearWhenClose(value) {
            this._clearWhenClose = value;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doPrepareRender() {
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    SearchResultBar.TYPE = 'searchresult';

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     *
     * Field Bar.
     * 필드 목록을 표시한다.
     * 필드별 정렬 상태 등을 표시한다.
     */
    class FieldBar extends ListSection {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        _doInitDefaults() {
            super._doInitDefaults();
            this.setVisible(false);
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * field 목록. 이 속성을 지정하지 않으면 리스트컨트롤에 연결된 data의 모든 필드들을 표시한다.
         */
        fields() {
            const fields = pickProp(this._fields, this._defs && this._defs._fields);
            return Array.isArray(fields) ? fields.slice(0) : fields ? fields : null;
        }
        setFields(value) {
            if (value !== this._fields) {
                this._fields = Array.isArray(value) ? value.slice(0) : value ? value : null;
                this._changed();
            }
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        _setRowTemplate(template) {
            this._rowTemplate = template;
        }
        getFields() {
            const dv = this.data();
            const fields = this.fields();
            if (fields === 'template') {
                const flds = this._owner.getDefaultRowTemplate().getFields() || [];
                return flds.map(f => dv.fieldByName(f)).filter(f => !!f);
            }
            else if (fields === 'sortables') {
                return dv.fields().filter(fld => fld.sortable);
            }
            else if (Array.isArray(fields)) {
                return fields.map(f => dv.fieldByName(f)).filter(f => !!f);
            }
            return dv.fields();
        }
        getSort(field) {
            return this.data().isSorted(field);
        }
        sortField(field) {
            const dv = this.data();
            if (dv instanceof ListDataView) {
                dv.toggleSort(field, true);
            }
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     *
     * Field Header.
     * 필드 목록을 표시한다.
     * FieldRenderer를 이용해 필드별 정렬 상태 등을 표시한다.
     */
    class FieldHeader extends LayoutedSection {
        constructor() {
            super(...arguments);
            //-------------------------------------------------------------------------
            // fields
            //-------------------------------------------------------------------------
            this.defRenderer = 'field'; // renderer 타입을 지정하지 않으면 fieldRenderer가 생성된다.
            //-------------------------------------------------------------------------
            // internal members
            //-------------------------------------------------------------------------
        }
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        _doInitDefaults() {
            super._doInitDefaults();
            this.setVisible(false);
            this._showOrder = true;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * 정렬 순서 표시 여부.
         */
        showOrder() {
            return pickProp(this._showOrder, this._defs && this._defs._showOrder);
        }
        setShowOrder(value) {
            if (value !== this._showOrder) {
                this._showOrder = value;
                this._changed();
            }
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        isFieldOrderVisible() {
            return this.showOrder();
        }
        sortField(field) {
            const dv = this.data();
            if (dv instanceof ListDataView) {
                dv.toggleSort(field, true);
            }
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        defTemplate() {
            return;
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     *
     * 리스트 컨트롤이 paging 상태가 아닐 때,
     * 마지막 데이터행 다음에 추가되는 첨부 행 영역에 대한 설정 모음.
     */
    class AttachedRow extends DWrappableOptions {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(owner, defaults) {
            super(owner, defaults);
            this._inflater = new ListSectionInflater(owner);
        }
        _doInitDefaults() {
            this._visible = false;
            this._endSpace = 0;
            this._indicatorVisible = true;
            this._indicatorType = DListSpinnerType.DEFAULT;
            this._indicatorSize = 28;
            this._indicatorMargin = 2;
        }
        //-------------------------------------------------------------------------
        // IParamInflater
        //-------------------------------------------------------------------------
        inflateParam(target, field, param) {
            const n = param.name;
            if (this.templateParams) {
                const v = this.templateParams[n];
                if (v !== void 0)
                    return v;
            }
            const pv = this.layoutParams();
            return pv && pv[n];
        }
        inflateStock(target, field, param) {
            return this._inflater.inflateStock(param);
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * 행 표시 여부.
         */
        visible() {
            return pickProp(this._visible, this._defs && this._defs._visible);
        }
        setVisible(value) {
            if (value !== this._visible) {
                this._visible = value;
                this._changed();
            }
        }
        /**
         * 행 다음(아래쪽이나 오른쪽)에 추가되는 여분의 공간.
         */
        endSpace() {
            return pickNum3(this._endSpace, this._defs && this._defs._endSpace, 0);
        }
        setEndSpace(value) {
            if (value !== this._endSpace) {
                this._endSpace = value;
                this._changed();
            }
        }
        /**
         * 표시할 행 템플릿.
         */
        rowTemplate() {
            return pickProp(this._rowTemplate, this._defs && this._defs._rowTemplate);
        }
        setRowTemplate(value) {
            if (value !== this._rowTemplate) {
                this._rowTemplate = value;
                this._changed();
            }
        }
        /**
         * 리스트컨트롤이 setDataAppending을 통해 행 추가 모드로 설정될 때 표시되는 인디케이터 표시 여부.
         */
        indicatorVisible() {
            return pickProp(this._indicatorVisible, this._defs && this._defs._indicatorVisible);
        }
        setIndicatorVisible(value) {
            if (value !== this._indicatorVisible) {
                this._indicatorVisible = value;
                this._changed();
            }
        }
        /**
         * 인디케이터 모양.
         */
        indicatorType() {
            return pickProp(this._indicatorType, this._defs && this._defs._indicatorType);
        }
        setIndicatorType(value) {
            if (value !== this._indicatorType) {
                this._indicatorType = value;
                this._changed();
            }
        }
        /**
         * 인디케이터 지름.
         */
        indicatorSize() {
            return pickNum3(this._indicatorSize, this._defs && this._defs._indicatorSize, 24);
        }
        setIndicatorSize(value) {
            if (value !== this._indicatorSize) {
                this._indicatorSize = value;
                this._changed();
            }
        }
        /**
         * 인디케이터 경계 여백 크기.
         */
        indicatorMargin() {
            return pickNum3(this._indicatorMargin, this._defs && this._defs._indicatorMargin, 0);
        }
        setIndicatorMargin(value) {
            if (value !== this._indicatorMargin) {
                this._indicatorMargin = value;
                this._changed();
            }
        }
        /**
         * template으로 부터 layout이 생성될 때 template param 들의 값 목록.
         * {@link paramCallback}으로 전달되는 값이 더 우선한다.
         */
        layoutParams() {
            return pickProp(this._layoutParams, this._defs && this._defs._layoutParams);
        }
        setLayoutParams(value) {
            let changed = false;
            if (!value) {
                if (this._layoutParams) {
                    this._layoutParams = value;
                    changed = true;
                }
            }
            else if (!Utils.equalObjects(value, this._layoutParams)) {
                this._layoutParams = Object.assign({}, value);
                changed = true;
            }
            if (changed) {
                this._changed();
            }
        }
        layout() {
            const t = this.rowTemplate();
            if (t) {
                const template = this.owner().getTemplate(t);
                const layout = LayoutFactory.Instance.layoutFromTemplate(this.wrapperOrThis(), this, false, false, template, this);
                const rowStyle = template.rowStyle;
                return { layout, rowStyle };
            }
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     *
     * Row info page 헤더 설정 모델.
     */
    class RowInfoPageHeader extends RowPageHeader {
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doInitDefaults() {
            super._doInitDefaults();
            this.setButtons([{
                    name: 'back',
                    position: DListSectionButtonPosition.HEAD,
                    // label: 'HOME이전',
                    // labelPosition: DButtonLabelPosition.LEFT,
                    // style: { fontSize: '20px', fontWeight: 'bold' },
                    shape: '@prev',
                    shapeWidth: 16,
                    // imageUrl: '/asset/images/slack.png',
                    // imageWidth: 22,
                    style: { fill: 'blue' },
                    onClick: (args) => {
                        args.control.closeInfoPage();
                    }
                }, {
                    name: 'close',
                    label: "닫기",
                    onClick: (args) => {
                        args.control.closeInfoPage();
                    }
                }]);
        }
    }
    var DRowInfoPageType;
    (function (DRowInfoPageType) {
        DRowInfoPageType["DEFAULT"] = "default";
        DRowInfoPageType["FORM"] = "form";
    })(DRowInfoPageType || (DRowInfoPageType = {}));
    const LINE = {
        left: 10,
        right: 5,
        height: 10,
        renderer: 'line'
    };
    const BUTTON = {
        right: 5,
        style: { paddingTop: '5px' },
        renderer: {
            type: 'button',
            label: '닫기',
            buttonWidth: 80,
            onClick: (args) => {
                args.control.closeInfoPage();
            },
            style: {}
        }
    };
    const TEXT_BUTTON = {
        right: 5,
        // style: { paddingTop: '5px' },
        renderer: {
            type: 'button',
            label: '닫기',
            onClick: (args) => {
                args.control.closeInfoPage();
            },
            style: {
                fontSize: '17px',
                border: 'none',
                backgroundColor: 'transparent',
                color: '#0088ff',
                padding: '7px 0px'
            }
        }
    };
    /**
     * @internal
     *
     * Row info page 관련 설정 객체.
     */
    class RowInfoPage extends RowPage {
        constructor() {
            super(...arguments);
            this._defaultTemplate = (fields, templateVars, row) => {
                const t = TEMPLATE();
                const childs = t.template.children;
                const defRenderer = {
                    wrap: true,
                    style: { fontSize: '18px' }
                };
                fields.forEach(fld => {
                    childs.push({
                        value: fld.label,
                        renderer: fld.labelRenderer,
                        style: { fontSize: '0.8em', fontWeight: 'bold' }
                    });
                    childs.push({
                        field: fld.field,
                        left: 20,
                        right: 5,
                        renderer: fld.renderer || defRenderer,
                        style: { color: '#555' }
                    });
                    childs.push({
                        space: 10
                    });
                });
                childs.push({
                    space: 20
                });
                childs.push(LINE);
                childs.push(TEXT_BUTTON);
                t.vars = templateVars;
                return new DListTemplate(null, t);
            };
            this._formTemplate = (fields, templateVars, row) => {
                const t = FORM_TEMPLATE();
                const childs = t.template.children;
                const defRenderer = {
                    wrap: true,
                    style: { fontSize: '18px' }
                };
                fields.forEach(fld => {
                    childs.push({
                        label: fld.label,
                        field: fld.field,
                        renderer: fld.renderer || defRenderer
                    });
                });
                childs.push(LINE);
                childs.push(TEXT_BUTTON);
                t.vars = templateVars;
                return new DListTemplate(null, t);
            };
            this._ATemplate = (fields, templateVars, row) => {
                const t = TEMPLATE((obj) => {
                    obj.rowStyle.backgroundColor = '#e8e8ea';
                });
                const childs = t.template.children;
                const defRenderer = {
                    wrap: true,
                    style: {
                        border: '1px inset #fff',
                        padding: '3px 5px',
                        borderRadius: '5px',
                        backgroundColor: '#fffff8',
                        fontSize: '17px'
                    }
                };
                fields.forEach(fld => {
                    childs.push({
                        value: fld.label,
                        style: { fontWeight: 'bold', fontSize: '0.8em' }
                    });
                    childs.push({
                        field: fld.field,
                        left: 10,
                        right: 5,
                        renderer: fld.renderer || defRenderer
                    });
                    childs.push({
                        space: 10
                    });
                });
                childs.push(LINE);
                childs.push(BUTTON);
                t.vars = templateVars;
                return new DListTemplate(null, t);
            };
            this._BTemplate = (fields, templateVars, row) => {
                const t = TEMPLATE(obj => {
                    obj.rowStyle.backgroundColor = '#e8e8ea';
                });
                const childs = t.template.children;
                const defRenderer = {
                    wrap: true
                };
                fields.forEach(fld => {
                    childs.push({
                        value: fld.label,
                        style: { fontWeight: 'bold', fontSize: '16px' }
                    });
                    childs.push({
                        field: fld.field,
                        left: 10,
                        right: this._isImageRenderer(fld.renderer) ? void 0 : 5,
                        style: {
                            border: '1px inset #fff',
                            padding: '3px 5px',
                            borderRadius: '5px',
                            backgroundColor: '#fffff8',
                            fontSize: '17px'
                        },
                        renderer: fld.renderer || defRenderer
                    });
                    childs.push({
                        space: 10
                    });
                });
                childs.push(LINE);
                childs.push(BUTTON);
                t.vars = templateVars;
                return new DListTemplate(null, t);
            };
            this._CTemplate = (fields, templateVars, row) => {
                return;
            };
            this._FTemplate = (fields, templateVars, row) => {
                const t = FORM_TEMPLATE(obj => {
                    obj.rowStyle.backgroundColor = '#e8e8ea';
                });
                const childs = t.template.children;
                const defRenderer = {
                    wrap: true,
                    style: {
                        border: '1px inset #fff',
                        padding: '3px 5px',
                        borderRadius: '5px',
                        backgroundColor: '#fffff8',
                        fontSize: '17px'
                    }
                };
                fields.forEach(fld => {
                    childs.push({
                        label: fld.label,
                        field: fld.field,
                        renderer: fld.renderer || defRenderer
                    });
                });
                childs.push(LINE);
                childs.push(BUTTON);
                t.vars = templateVars;
                return new DListTemplate(null, t);
            };
            this._GTemplate = (fields, templateVars, row) => {
                const t = FORM_TEMPLATE(obj => {
                    obj.rowStyle.backgroundColor = '#e8e8ea';
                });
                const childs = t.template.children;
                const defRenderer = {
                    wrap: true
                };
                fields.forEach(fld => {
                    const renderer = fld.renderer || defRenderer;
                    const style = this._isImageRenderer(renderer) ? {} : {
                        border: '1px inset #fff',
                        padding: '3px 5px',
                        borderRadius: '5px',
                        backgroundColor: '#fffff8',
                        fontSize: '17px'
                    };
                    const children = [{
                            grow: 1,
                            field: fld.field,
                            style: this._extendStyle(style, fld, templateVars),
                            renderer: renderer
                        }];
                    if (fld.unit) {
                        children.push({
                            bottom: 1,
                            value: fld.unit,
                        });
                    }
                    childs.push({
                        layout: 'hlinear',
                        itemGap: 6,
                        label: fld.label,
                        children
                    });
                });
                childs.push(LINE);
                childs.push(BUTTON);
                t.vars = templateVars;
                return new DListTemplate(null, t);
            };
            this._templates = {
                defafult: this._defaultTemplate,
                form: this._formTemplate,
                A: this._ATemplate,
                B: this._BTemplate,
                C: this._CTemplate,
                F: this._FTemplate,
                G: this._GTemplate,
            };
        }
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        _getDefRenderer(fld) {
            return;
        }
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        _doInitDefaults() {
            super._doInitDefaults();
            this._viewType = DRowInfoPageType.DEFAULT;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /** viewType */
        viewType() {
            return pickProp(this._viewType, this._defs && this._defs._viewType);
        }
        setViewType(value) {
            this._viewType = value;
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _getRowValues() {
            return this.data().internalRowValues(this._row);
        }
        inflateParam(target, field, param) {
            const v = super.inflateParam(target, field, param);
            if (v !== void 0)
                return v;
            switch (param.name) {
                default:
                    return this._rowInflater.inflateParam(target, field, param);
            }
        }
        inflateStock(target, field, param) {
            const v = super.inflateStock(target, field, param);
            if (v !== void 0)
                return v;
            switch (param.name) {
                default:
                    return this._rowInflater.inflateStock(target, field, param);
            }
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        _createHeader(owner, defaults) {
            return new RowInfoPageHeader(owner, defaults && defaults.header());
        }
        _getDefaultTemplate(dv, templateVars, row) {
            const fields = this._prepareFields(dv);
            return (this._templates[this.viewType()] || this._defaultTemplate)(fields, templateVars, row);
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    class DataGroupTheme extends DObject {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(options) {
            super();
            this._options = options;
        }
        //-------------------------------------------------------------------------
        // static members
        //-------------------------------------------------------------------------
        static createTheme(theme, options) {
            switch (theme) {
                case ClassicTheme$1.TYPE:
                    return new ClassicTheme$1(options);
                default:
                    return new DefaultTheme$1(options);
            }
        }
        bodyIndented() {
            return this._bodyMode;
        }
        getBodyIndent(item) {
            if (this._bodyMode) {
                switch (this._options.rowIndents()) {
                    case DListRowIndents.PARENT:
                        return (item.group.level() - 1) * this._indent;
                    case DListRowIndents.INNER:
                        return (item.group.level() - 1) * this._indent + this._indent;
                    default:
                        return 0;
                }
            }
            else if (item instanceof DataGroupRow) {
                return 0;
            }
        }
        getBodyMargin(item) {
            return 0;
        }
        getItemIndent(item) {
            if (this._bodyMode) {
                return 0;
            }
            else if (item instanceof DataGroupRow) {
                switch (this._options.rowIndents()) {
                    case DListRowIndents.PARENT:
                        return (item.group.level() - 1) * this._indent;
                    case DListRowIndents.INNER:
                        return (item.group.level() - 1) * this._indent + this._indent;
                    default:
                        return 0;
                }
            }
        }
        prepareRender() {
            this._bodyMode = this.indentsMode() === GroupIndentMode.BODY;
            this._indent = this._options.indent();
            this._endMargin = this._options.endMargin();
            return this;
        }
    }
    /**
     * @internal
     */
    class DefaultTheme$1 extends DataGroupTheme {
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        type() {
            return DefaultTheme$1.TYPE;
        }
        indentsMode() {
            return GroupIndentMode.ROW;
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    DefaultTheme$1.TYPE = 'default';
    /**
     * @internal
     */
    class ClassicTheme$1 extends DataGroupTheme {
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        type() {
            return ClassicTheme$1.TYPE;
        }
        indentsMode() {
            return GroupIndentMode.BODY;
        }
        getBodyMargin(item) {
            if (item.isLeaf()) {
                return this._endMargin;
            }
            return 0;
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    ClassicTheme$1.TYPE = 'classic';

    ////////////////////////////////////////////////////////////////////////////////
    class RowGroupTheme extends DObject {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(options) {
            super();
            this._options = options;
        }
        //-------------------------------------------------------------------------
        // static members
        //-------------------------------------------------------------------------
        static createTheme(theme, options) {
            switch (theme) {
                case ClassicTheme.TYPE:
                    return new ClassicTheme(options);
                default:
                    return new DefaultTheme(options);
            }
        }
        bodyIndented() {
            return this._bodyMode;
        }
        getBodyIndent(item) {
            if (this._bodyMode) {
                if (item instanceof GroupRow) {
                    switch (this._options.rowIndents()) {
                        case DListRowIndents.PARENT:
                            return item.group.level() * this._gindent;
                        case DListRowIndents.INNER:
                            return item.group.level() * this._gindent + this._indent;
                        default:
                            return 0;
                    }
                }
                else {
                    return item.group.level() * this._gindent;
                }
            }
            else {
                return 0;
            }
        }
        getBodyMargin(item) {
            return 0;
        }
        getItemIndent(item) {
            if (this._bodyMode) {
                return 0;
            }
            else if (item instanceof GroupRow) {
                switch (this._options.rowIndents()) {
                    case DListRowIndents.PARENT:
                        return item.group.level() * this._gindent;
                    case DListRowIndents.INNER:
                        return item.group.level() * this._gindent + this._indent;
                    default:
                        return 0;
                }
            }
            else {
                return item.group.level() * this._gindent;
            }
        }
        prepareRender() {
            this._bodyMode = this.indentsMode() === GroupIndentMode.BODY;
            this._indent = this._options.indent();
            this._gindent = this._options.groupIndent();
            this._endMargin = this._options.endMargin();
            return this;
        }
    }
    /**
     * @internal
     */
    class DefaultTheme extends RowGroupTheme {
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        type() {
            return DefaultTheme.TYPE;
        }
        indentsMode() {
            return GroupIndentMode.ROW;
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    DefaultTheme.TYPE = 'default';
    /**
     * @internal
     */
    class ClassicTheme extends RowGroupTheme {
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        type() {
            return ClassicTheme.TYPE;
        }
        indentsMode() {
            return GroupIndentMode.BODY;
        }
        getBodyIndent(item) {
            if (this._bodyMode && item instanceof GroupFooter) {
                return (item.group.level() + 1) * this._gindent;
            }
            return super.getBodyIndent(item);
        }
        getBodyMargin(item) {
            return this._endMargin;
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    ClassicTheme.TYPE = 'classic';

    ////////////////////////////////////////////////////////////////////////////////
    class GroupOptions extends DWrappableOptions {
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        _doInitDefaults() {
            this._rowIndents = DListRowIndents.INNER;
            this._indent = GroupOptions.INDENT;
            this._endMargin = RowGroupOptions.END_MARGIN;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * 테마.
         */
        theme() {
            return pickProp(this._theme, this._defs && this._defs._theme);
        }
        setTheme(value) {
            this._theme = value;
        }
        /**
         * 데이터행을 들여쓰기 하는 방식.
         *
         * @default DListRowIndents.GROUP
         */
        rowIndents() {
            return pickProp(this._rowIndents, this._defs && this._defs._rowIndents);
        }
        setRowIndents(value) {
            this._rowIndents = value;
        }
        /**
         * rowIndents가 'inner'일 때 들여쓰기 픽셀 크기.
         */
        indent() {
            return pickProp(this._indent, this._defs && this._defs._indent);
        }
        setIndent(value) {
            this._indent = value;
        }
        /**
         * row end margin
         */
        endMargin() {
            return pickProp(this._endMargin, this._defs && this._defs._endMargin);
        }
        setEndMargin(value) {
            this._endMargin = value;
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    GroupOptions.INDENT = 12;
    class RowGroupOptions extends GroupOptions {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(owner, groupOwner, defaults) {
            super(owner, defaults);
            this._header = new RowGroupHeader(groupOwner, defaults && defaults._header);
            this._footer = new RowGroupFooter(groupOwner, defaults && defaults._footer);
            this._expander = new RowExpander(groupOwner, defaults && defaults._expander);
        }
        _doInitDefaults() {
            super._doInitDefaults();
            this._groupIndent = RowGroupOptions.GROUP_INDENT;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        header() {
            return this._header;
        }
        footer() {
            return this._footer;
        }
        expander() {
            return this._expander;
        }
        /**
         * group header/footer indent size.
         */
        groupIndent() {
            return pickProp(this._groupIndent, this._defs && this._defs._groupIndent);
        }
        setGroupIndent(value) {
            this._groupIndent = value;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        getTheme() {
            const t = this.theme();
            if (!this._themeImpl) {
                this._themeImpl = RowGroupTheme.createTheme(t, this);
            }
            else if (t !== this._themeImpl.type()) {
                this._themeImpl = RowGroupTheme.createTheme(t, this);
            }
            return this._themeImpl;
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    RowGroupOptions.GROUP_INDENT = 12;
    RowGroupOptions.END_MARGIN = 4;
    class DataGroupOptions extends GroupOptions {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(owner, groupOwner, defaults) {
            super(owner, defaults);
            this._expander = new RowExpander(groupOwner, defaults && defaults._expander);
        }
        _doInitDefaults() {
            super._doInitDefaults();
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        expander() {
            return this._expander;
        }
        /**
         * 그룹핑 기준 level. 지정하지 않으면 모든 level에 대해 그룹핑.
         */
        groupLevel() {
            return pickProp(this._groupLevel, this._defs && this._defs._groupLevel);
        }
        setGroupLevel(value) {
            this._groupLevel = value;
        }
        addMasterHeader() {
            return this._addMasterHeader;
        }
        addMasterFooter() {
            return this._addMasterFooter;
        }
        addEmptyMasterHeader() {
            return this._addEmptyMasterHeader;
        }
        addEmptyMasterFooter() {
            return this._addEmptyMasterFooter;
        }
        addDetailHeader() {
            return this._addDetailHeader;
        }
        addDetailFooter() {
            return this._addDetailFooter;
        }
        addSingleDetailHeader() {
            return this._addSingleDetailHeader;
        }
        addSingleDetailFooter() {
            return this._addSingleDetailFooter;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        getTheme() {
            const t = this.theme();
            if (!this._themeImpl) {
                this._themeImpl = DataGroupTheme.createTheme(t, this);
            }
            else if (t !== this._themeImpl.type()) {
                this._themeImpl = DataGroupTheme.createTheme(t, this);
            }
            return this._themeImpl;
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    class DataLinkRow {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(master, dv, dataRow) {
            this.master = master;
            this.dv = dv;
            this.dataRow = dataRow;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        id() {
            return this.dataRow.id;
        }
        values() {
            return this.dataRow.values;
        }
        level() {
            return this.master ? this.master.level() + 1 : 0;
        }
        detailCount() {
            return this.details ? this.details.length : 0;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        getDescendants() {
            function getDetails(row) {
                const details = row.details;
                if (details) {
                    for (let i = 0, n = details.length; i < n; i++) {
                        rows.push(details[i]);
                        getDetails(details[i]);
                    }
                }
            }
            const rows = [];
            getDetails(this);
            return rows;
        }
    }
    const ALREADY_ERROR = 'A data is already linked: ';
    class DataLinkInfo extends DObject {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(data, details, dvs) {
            super();
            if (!(data instanceof ListDataOjbject)) {
                throw new Error('데이터객체가 지정돼야 합니다.');
            }
            if (data instanceof ListDataLinkView) {
                throw new Error('데이터링크는 다른 데이터링크의 데이터로 지정될 수 없습니다.');
            }
            if (dvs.indexOf(data) >= 0) {
                throw new DListDataError(data, ALREADY_ERROR + data.name());
            }
            dvs.push(this.data = data);
        }
        _initDetails(details, dvs, infoMap) {
            if (details) {
                const childs = Utils.makeArray(details);
                if (childs.length > 0) {
                    this.details = childs.map(c => new DetailDataInfo(this, c, dvs, infoMap));
                }
            }
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        level() {
            return this.parent.level() + 1;
        }
        detailCount() {
            return this.details ? this.details.length : 0;
        }
    }
    class DetailDataInfo extends DataLinkInfo {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(parent, info, dvs, infoMap) {
            super(info.data, info.details, dvs);
            infoMap[info.data.hash] = this;
            this.parent = parent;
            this.$_setParentLevel(this.level() + 1);
            this.keyFields = checkFields(info.data, info.keyFields);
            if (Array.isArray(info.masterFields) && info.masterFields.length > 0) {
                this.masterFields = checkFields(parent.data, info.masterFields);
            }
            else {
                this.masterFields = checkFields(parent.data, info.keyFields);
            }
            if (this.keyFields.length !== this.masterFields.length) {
                throw new Error('key fields와 master fields의 개수가 동일해야 합니다.');
            }
            this._initDetails(info.details, dvs, infoMap);
        }
        $_setParentLevel(levels) {
            if (this.parent instanceof MasterDataInfo) {
                this.parent._levels = Math.max(this.parent._levels, levels);
            }
            else if (this.parent instanceof DetailDataInfo) {
                this.parent.$_setParentLevel(levels);
            }
        }
        _doDestory() {
            this.data = null;
            if (this.details) {
                this.details.forEach(c => c.destroy());
                this.details = null;
            }
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        findData(name) {
            if (this.data.name() === name) {
                return this.data;
            }
            if (this.details) {
                for (let child of this.details) {
                    const dv = child.findData(name);
                    if (dv)
                        return dv;
                }
            }
        }
    }
    class MasterDataInfo extends DataLinkInfo {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(data, details, dvs, infoMap) {
            super(data, details, dvs);
            //-------------------------------------------------------------------------
            // fields
            //-------------------------------------------------------------------------
            this._levels = 1;
            infoMap[data.hash] = this;
            this._initDetails(details, dvs, infoMap);
        }
        _doDestory() {
            this.data = null;
            this.details.forEach(d => d.destroy());
            this.details = null;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        findData(name) {
            if (name === this.data.name()) {
                return this.data;
            }
            if (this.details) {
                for (let d of this.details) {
                    const dv = d.findData(name);
                    if (dv)
                        return dv;
                }
            }
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        level() {
            return 0;
        }
    }
    /**
     * @internal
     *
     * 데이터 결합 view.
     *
     * 1. 포함된 모든 data의 행들은 최대 한번씩만 표시된다.
     *    즉, 같은 key값들의 master행이 두 개 있으면 두 번째 마스트행에는 detail 행이 표시되지 않는다.
     *    master 행은 unique해야 한다.
     * 2. 마스터와 연결되지 않은 행은 표시되지 않는다.
     * 3. 디테일 행은 다시 마스터행이 될 수 있다.
     * 4. 적어도 한 쌍의 master/detail 관계는 존재한다고 전제한다.
     * 5. 디테일이 masterFields나 keyFields 기준으로 정렬될 필요는 없다.
     */
    class ListDataLinkView extends ListDataOjbject {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(name, data, details, wrapper) {
            super(name);
            this._wrapper = wrapper;
            this._info = new MasterDataInfo(data, details, this._dvs = [], this._infoMap = {});
            this._dvMap = {};
            this._dvs.forEach(dv => {
                this._dvMap[dv.name()] = dv;
                dv.addListener(this);
            });
            this._root = this._info.data;
            this._rows = this.$_buildRows();
        }
        _doDestory() {
            this._dvs.forEach(dv => dv.removeListener(this));
            this._dvs = this._root = this._info = null;
        }
        //-------------------------------------------------------------------------
        // IListDataView
        //-------------------------------------------------------------------------
        source() {
            return this._root.source();
        }
        wrapper() {
            return this._wrapper;
        }
        wrapperOrThis() {
            return this._wrapper || this;
        }
        readOnly() {
            return this._root.readOnly();
        }
        fields() {
            return this._root.fields();
        }
        fieldByName(name) {
            return this._root.fieldByName(name);
        }
        rowCount() {
            return this._rows.length;
        }
        visRowCount() {
            return this._rows.length;
        }
        getSource(row) {
            return this._rows[row].dv;
        }
        getSourceRow(row) {
            const dv = this._rows[row].dv;
            row = dv.rowOfDataRow(this._rows[row].dataRow);
            return { dv, row };
        }
        canSort() {
            return this._root.canSort();
        }
        canMove() {
            return false;
        }
        getRowId(row) {
            return this._rows[row].id();
        }
        levelRowOfRow(row) {
            return this._rows[row].no;
        }
        getRowValues(row) {
            ListData.checkRow(this, row);
            const drow = this._rows[row];
            // TODO: derived values
            return drow && Object.assign({}, drow.dataRow.values);
        }
        getValues(row, fields, fieldCheck) {
            if (Array.isArray(fields)) {
                ListDataOjbject.checkRow(this, row);
                const ret = {};
                const drow = this._rows[row];
                const vals = drow.values();
                const dv = drow.dv.source();
                fields.forEach(f => {
                    fieldCheck && dv.checkField(f);
                    ret[f] = vals[f];
                });
                return ret;
            }
            else {
                return this.getRowValues(row);
            }
        }
        internalRowValues(row) {
            // TODO: derived values
            return Object.assign({}, this._rows[row].dataRow.values);
        }
        getValue(row, field, fieldCheck) {
            ListDataOjbject.checkRow(this, row);
            const drow = this._rows[row];
            const dv = drow.dv;
            fieldCheck && dv.checkField(field);
            return drow.dataRow.values[field];
        }
        getProp(row, field, prop, fieldCheck) {
            ListDataOjbject.checkRow(this, row);
            const drow = this._rows[row];
            const dv = drow.dv;
            fieldCheck && dv.checkField(field);
            return drow.dataRow.getProp(field, prop);
        }
        getFieldValues(field, from, to) {
            return;
        }
        getSummary(field, start, end) {
            return this._root.getSummary(field, start, end);
        }
        updateValue(row, field, value) {
            const drow = this._rows[row];
            const dv = drow.dv;
            return dv.updateValue(-1, field, value);
        }
        findRow(values, from = 0, to = -1) {
            return this._root.findRow(values, from, to);
        }
        findRows(values, from = 0, to = -1) {
            return this._root.findRows(values, from, to);
        }
        findDistinctRows(fields, from, to) {
            return this._root.findDistinctRows(fields, from, to);
        }
        deleteRow(row, force) {
            ListData.checkRow(this, row);
            const drow = this._rows[row];
            const dv = drow.dv;
            dv.deleteRow(dv.rowOfDataRow(drow.dataRow), force);
        }
        /**
         * TODO: 다중 dv 삭제 시 컨트롤 쪽 animation 확인.
         */
        deleteRows(rows, force) {
            if (Array.isArray(rows) && rows.length > 0) {
                rows.forEach(row => ListDataOjbject.checkRow(this, row));
                const map = this.$_getRowsMap(rows);
                for (const n in map) {
                    const dv = this._dvMap[n];
                    if (dv) {
                        rows = map[n].map(dataRow => dv.rowOfDataRow(dataRow));
                        dv.deleteRows(rows, force);
                    }
                }
            }
        }
        updateRow(row, values, forceEmpty = false) {
            ListData.checkRow(this, row);
            const drow = this._rows[row];
            const dv = drow.dv;
            const r = dv.rowOfDataRow(drow.dataRow); // O(n)
            return dv.updateRow(r, values, forceEmpty);
        }
        appendRow(values) {
            return this._root.appendRow(values);
        }
        getRowState(row) {
            ListData.checkRow(this, row);
            return this.internalRowState(row);
        }
        internalRowState(row) {
            return this._rows[row].dataRow.state;
        }
        $_getRowsMap(rows) {
            const map = {};
            rows.forEach(row => {
                const drow = this._rows[row];
                const dv = drow.dv.name();
                if (map[dv]) {
                    map[dv].push(drow.dataRow);
                }
                else {
                    map[dv] = [drow.dataRow];
                }
            });
            return map;
        }
        //-------------------------------------------------------------------------
        // IListDataListener
        //-------------------------------------------------------------------------
        $_handler() {
            const oldCount = this._rows.length;
            this.$_reset();
            this._fireEvent('onDataReset');
            if (this._rows.length !== oldCount) {
                this._fireEvent('onDataCountChanged', this._rows.length, oldCount);
            }
            this._fireEvent('onDataChanged');
        }
        onDataValueUpdated(dv, row, field, value, oldValue) {
            this.$_handler();
        }
        onDataRowUpdated(dv, row, oldValues) {
            this.$_handler();
        }
        onDataRowsUpdated(dv, rows) {
            this.$_handler();
        }
        onDataRangeUpdated(dv, row, count) {
            this.$_handler();
        }
        onDataRowAdded(dv, row) {
            this.$_handler();
        }
        onDataRowsAdded(dv, row, count) {
            this.$_handler();
        }
        onDataCleared(dv, oldCount) {
            this.$_handler();
        }
        onDataRowDeleted(dv, row, rowid) {
            const r = this.getRowOfId(rowid); // O(n)
            if (r < 0)
                return;
            const drow = this._rows[r];
            const oldCount = this._rows.length;
            let rows;
            // this._rows.splice(r, 1);
            if (drow.details) {
                rows = drow.getDescendants();
                rows.unshift(drow);
            }
            this.$_reset();
            this._fireEvent('onDataReset');
            if (rows) {
                this._fireEvent('onDataRowsDeleted', rows, this.$_getRowIds(rows));
            }
            else {
                this._fireEvent('onDataRowDeleted', r, drow.id());
            }
            //if (this._rows.length !== oldCount) {
            if (rows) {
                this._flags._rowsDeleted(Utils.sortNum(this.$_getRowIds(rows)));
            }
            else {
                this._flags._rowDeleted(r);
            }
            this._fireEvent('onDataCountChanged', this._rows.length, oldCount);
            //}
            this._fireEvent('onDataChanged');
        }
        onDataRowsDeleted(dv, rows, ids) {
            rows = this.getRowsOfIds(dv, ids);
            if (rows.length > 0) {
                const oldCount = this._rows.length;
                let list = [];
                rows.forEach(r => {
                    const drow = this._rows[r];
                    const ids2 = this.$_getRowIds(drow.getDescendants());
                    list.push(r);
                    if (ids2.length > 0) {
                        list = list.concat(this.getRowsOfIds(dv, ids2));
                        ids = ids.concat(ids2);
                    }
                });
                list = Utils.dedupe(list);
                ids = Utils.dedupe(ids);
                // rows = rows.sort((r1, r2) => r1 - r2);
                // for (let i = rows.length - 1; i >= 0; i--) {
                //     this._rows.splice(rows[i], 1);
                // }
                this.$_reset();
                this._fireEvent('onDataRowsDeleted', list, ids);
                this._fireEvent('onDataReset');
                // if (this._rows.length !== oldCount) {
                this._flags._rowsDeleted(Utils.sortNum(list));
                this._fireEvent('onDataCountChanged', this._rows.length, oldCount);
                // }
                this._fireEvent('onDataChanged');
            }
        }
        onDataRangeDeleted(dv, row, count) {
            const rows = Utils.makeIntArray(row, row + count);
            const ids = rows.map(r => dv.getRowId(r));
            this.onDataRowsDeleted(dv, rows, ids);
        }
        onDataRowMoved(data, from, to) {
        }
        onDataRowsMoved(data, from, count, to) {
        }
        //-------------------------------------------------------------------------
        // events
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        info() {
            return this._info;
        }
        root() {
            return this._root;
        }
        levels() {
            return this._info._levels;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        setDataTags(rows, tag) {
            for (const r of this._rows)
                r.tag = void 0;
            for (const r of rows)
                this._rows[r].tag = tag;
        }
        getDataTag(row) {
            return this._rows[row].tag;
        }
        isDataTag(row, tag) {
            return this._rows[row].tag === tag;
        }
        getDataViews() {
            return this._dvs.slice(0);
        }
        getLevel(row) {
            return this._rows[row].level();
        }
        getLinkInfo(dv) {
            return this._infoMap[dv.hash];
        }
        getLinkRows() {
            return this._rows.slice(0);
        }
        getRows() {
            return this._rows.map(r => r.dataRow);
        }
        getDetailCount(row, detailName) {
            if (detailName) ;
            else {
                return this._rows[row].detailCount();
            }
            return 1;
        }
        // 마지막 level의 detail 행에 표함된 데이터행들이 leaf이다.
        isLeaf(row) {
            ListData.checkRow(this, row);
            return this._rows[row].level() === this._info._levels - 1;
        }
        _internalLeaf(row) {
            return this._rows[row].level() === this._info._levels - 1;
        }
        isLast(row) {
            return row === this._rows.length - 1;
        }
        isMaster(row) {
            ListData.checkRow(this, row);
            return this._rows[row].level() < this._info._levels - 1;
        }
        getRowOf(dv, row) {
            for (let r = 0, n = this._rows.length; r < n; r++) {
                const drow = this._rows[r];
                if (drow.dv === dv && dv.getDataRow(row) === drow.dataRow) {
                    return r;
                }
            }
            return -1;
        }
        getRowsOf(dv, rows) {
            const list = [];
            const cnt = rows.length;
            for (let r = 0, n = this._rows.length; r < n; r++) {
                const drow = this._rows[r];
                if (drow.dv === dv) {
                    for (let i = 0; i < cnt; i++) {
                        if (drow.dataRow == dv.getDataRow(rows[i])) {
                            list.push(r);
                            break;
                        }
                    }
                }
                if (list.length === cnt) {
                    break;
                }
            }
            return list;
        }
        // O(n)
        getRowOfId(id) {
            for (let r = 0, n = this._rows.length; r < n; r++) {
                if (this._rows[r].id() === id) {
                    return r;
                }
            }
            return -1;
        }
        // O(n)
        getRowsOfIds(dv, ids) {
            const list = [];
            const cnt = ids.length;
            for (let r = 0, n = this._rows.length; r < n; r++) {
                const drow = this._rows[r];
                if (drow.dv === dv) {
                    for (let i = 0; i < cnt; i++) {
                        if (drow.id() == ids[i]) {
                            list.push(r);
                            break;
                        }
                    }
                }
                if (list.length === cnt) {
                    break;
                }
            }
            return list;
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        $_collectDetails(master, masterRow, dinfos, target) {
            function getValues(drow, flds) {
                const vals = [];
                for (let i = 0, n = flds.length; i < n; i++) {
                    vals.push(drow.values[flds[i]]);
                }
                return vals;
            }
            function compareVals(vals1, vals2) {
                for (let i = 0, n = vals1.length; i < n; i++) {
                    if (vals1[i] !== vals2[i])
                        return false;
                }
                return true;
            }
            function selectRows(m, dv, drows, masterRow, keyFlds, masterFlds) {
                const rows = [];
                const masterVals = getValues(masterRow.dataRow, masterFlds);
                // 마스터행마다 detail 전체 행을 검색하지 말고, 이미 master에 연결된 행들은 제외시키면서 검색해야 한다.
                for (let r = 0, cnt = dv.rowCount(); r < cnt; r++) {
                    if (drows[r]) {
                        const vals = getValues(dv.getDataRow(r), keyFlds);
                        if (compareVals(vals, masterVals)) {
                            const lrow = new DataLinkRow(masterRow, dv, drows[r]);
                            rows.push(lrow);
                            detailRows.push(lrow);
                            drows[r] = null; // 다른 master 행에서 검색되지 않도록...
                        }
                    }
                }
                return rows;
            }
            const detailRows = [];
            dinfos.forEach(dinfo => {
                const keyFlds = dinfo.keyFields.map(f => f.name);
                const masterFlds = dinfo.masterFields.map(f => f.name);
                const rows = selectRows(master, dinfo.data, dinfo['drows'], masterRow, keyFlds, masterFlds);
                if (rows.length > 0) {
                    rows.forEach(row => {
                        target.push(row);
                        row.no = dinfo.no++;
                        if (Array.isArray(dinfo.details)) {
                            row.details = this.$_collectDetails(dinfo.data, row, dinfo.details, target);
                        }
                    });
                }
            });
            return detailRows;
        }
        $_buildRows() {
            // 마스터행마다 detail 전체 행을 검색하지 말고, 이미 master에 연결된 행들은 제외시키면서 검색해야 한다.
            function prepare(d) {
                d['drows'] = d.data.getRows().slice(0);
                d.no = 0;
                if (Array.isArray(d.details)) {
                    d.details.forEach(d2 => prepare(d2));
                }
            }
            function unprepare(d) {
                delete d['drows'];
                if (Array.isArray(d.details)) {
                    d.details.forEach(d2 => unprepare(d2));
                }
            }
            const t = +new Date();
            const info = this._info;
            const dinfos = info.details;
            const dv = this._root;
            const mrows = dv.getRows();
            const rows = [];
            if (dinfos) {
                dinfos.forEach(d => prepare(d));
            }
            for (let i = 0, n = mrows.length; i < n; i++) {
                const row = new DataLinkRow(null, dv, mrows[i]);
                row.no = i;
                rows.push(row);
                if (dinfos) {
                    row.details = this.$_collectDetails(dv, row, dinfos, rows);
                }
            }
            // rows.forEach((r, i) => r.row = i);
            if (dinfos) {
                dinfos.forEach(d => unprepare(d));
            }
            console.log('DATA LINK BUILD: ' + (+new Date() - t) + 'ms.');
            return rows;
        }
        $_reset() {
            this._rows = this.$_buildRows();
            this._fireEvent('onDataReset');
        }
        $_getRowIds(rows) {
            return rows.map(r => r.id());
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     *
     * 컨트롤 설정 객체 기반 클래스
     */
    class ListOptionsBase extends DWrappableObject {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(owner, defaults) {
            super();
            this._owner = owner;
            this._defs = defaults;
            this._row = new ListRow(owner, defaults && defaults._row);
            !defaults && this._doInitDefaults();
        }
        _doInitDefaults() {
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        owner() {
            return this._owner;
        }
        /**
         * @readonly
         *
         * 데이터행 관련 설정 모델.
         * <br>
         */
        row() {
            return this._row;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        load(config) {
            return this.assignProps(config);
        }
        //-------------------------------------------------------------------------
        // internal methods
        //-------------------------------------------------------------------------
        _changed() {
            this._owner.invalidateLayout();
        }
    }
    const ALL_ROWS = [];
    /**
     * @internal 미구현
     *
     * HeadRowPosition.
     */
    var DHeadRowPosition;
    (function (DHeadRowPosition) {
        /**
         * 컨트롤 헤더 이 후에 표시.
         */
        DHeadRowPosition["AFTER"] = "after";
        /**
         * 컨트롤 헤더 이 전에 표시.
         */
        DHeadRowPosition["BEFORE"] = "before";
    })(DHeadRowPosition || (DHeadRowPosition = {}));
    /**
     * @internal
     *
     * 컨트롤 상단에 별도의 행들을 표시할 수 있다.
     * 별도의 data view를 지정할 수 있다. data view가 지정된 경우 그 행들을 표시한다.
     * data view를 지정하지 않은 경우, rows 속성으로 컨트롤 data의 행들 중에서 표시할 행들을 지정할 수 있다.
     * 스크롤하지 않고 고정 높이를 유지한다.
     */
    class HeadRows extends ListOptionsBase {
        constructor() {
            super(...arguments);
            this._drows = [];
        }
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        _doInitDefaults() {
            this._visible = true;
            this._position = DHeadRowPosition.AFTER;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * visible
         */
        visible() {
            return pickProp(this._visible, this._defs && this._defs._visible);
        }
        setVisible(value) {
            if (value !== this._visible) {
                this._visible = value;
                this._changed();
            }
        }
        /**
         * position.
         */
        position() {
            return pickProp(this._position, this._defs && this._defs._position);
        }
        setPosition(value) {
            if (value !== this._position) {
                this._position = value;
                this._changed();
            }
        }
        /**
         * data view.
         */
        data() {
            return pickProp(this._data, this._defs && this._defs._data);
        }
        setData(value) {
            if (value !== this._data) {
                if (this._data) {
                    this._data.removeListener(this);
                }
                this._data = value;
                if (this._data) {
                    this._data.addListener(this);
                }
                this._changed();
            }
        }
        /**
         * rows
         */
        rows() {
            var _a;
            return (_a = pickProp(this._rows, this._defs && this._defs._rows)) === null || _a === void 0 ? void 0 : _a.slice(0);
        }
        setRows(value) {
            if (value != this._rows) {
                this._rows = value && value.slice(0);
                this._changed();
            }
        }
        rowCount() {
            return this._drows === ALL_ROWS ? this._data.rowCount() : this._drows.length;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        prepareRender(dv) {
            if (this.visible) {
                let rows = this._rows;
                if (rows === void 0 && this._defs)
                    rows = this._defs._rows;
                if (rows && rows.length > 0) {
                    this._drows = [];
                    dv = this._dv = this._data || dv;
                    if (dv) {
                        const n = dv.rowCount();
                        rows.forEach(r => {
                            if (r >= 0 && r < n) {
                                this._drows.push(r);
                            }
                        });
                    }
                }
                else if (this._data) {
                    this._dv = this._data;
                    this._drows = ALL_ROWS;
                }
                return this.rowCount() > 0;
            }
        }
        getRow(r) {
            if (this._drows === ALL_ROWS) {
                return r;
            }
            else {
                return this._drows[r];
            }
        }
        getValue(row, field) {
            return this._dv.getValue(this.getRow(row), field, true);
        }
    }
    /**
     * @internal
     *
     * 컨트롤 options.
     * template이 적용되는 영역은 portrait/landscape로 별도 지정할 수 있다.
     */
    class ListOptions extends ListOptionsBase {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(control, owner, defaults, landscape) {
            super(owner, defaults);
            this._landscape = landscape;
            this._rowBar = new RowBar(control, owner, defaults && defaults._rowBar);
            this._editBar = new EditBar(control, owner, defaults && defaults._editBar);
            this._scrollIndicator = new ScrollIndicator(control, defaults && defaults._scrollIndicator);
            this._indexBar = new IndexBar(control, defaults && defaults._indexBar);
            this._scrollBar = new ScrollBar(control, defaults && defaults._scrollBar);
            this._pageNavigator = new PageNavigator(control, owner, defaults && defaults._pageNavigator);
            this._pageScroller = new PageScroller(control, defaults && defaults._pageScroller);
            this._commandBox = new CommandBox(control, defaults && defaults._commandBox);
            this._selectionMask = new SelectionMask(control, defaults && defaults._selectionMask);
            this._headRows = new HeadRows(owner, defaults && defaults._headRows);
            this._header = new ListHeader(owner, defaults && defaults._header);
            this._footer = new ListFooter(owner, defaults && defaults._footer);
            this._searchBar = new SearchBar(owner, defaults && defaults._searchBar);
            this._searchResultBar = new SearchResultBar(owner, defaults && defaults._searchResultBar);
            this._fieldBar = new FieldBar(owner, defaults && defaults._fieldBar);
            this._fieldHeader = new FieldHeader(owner, defaults && defaults._fieldHeader);
            this._rowGroup = new RowGroupOptions(owner, this, defaults && defaults._rowGroup);
            this._dataGroup = new DataGroupOptions(owner, this, defaults && defaults._dataGroup);
            this._dataRowInfos = new DataRowInfoCollection(owner, defaults && defaults._dataRowInfos);
            this._infoPage = new RowInfoPage(owner, defaults && defaults._infoPage);
            this._editPage = new RowEditPage(owner, defaults && defaults._editPage);
            this._addPage = new RowEditPage(owner, defaults && defaults._addPage);
            this._singleRow = new SingleRow(owner, defaults && defaults._singleRow);
            this._attachedRow = new AttachedRow(owner, defaults && defaults._attachedRow);
            this._formPanel = new FormPanel(control, defaults && defaults._formPanel);
            this._buttonPanel = new ButtonPanel(control, defaults && defaults._buttonPanel);
            this._searchPanel = new SearchPanel(control, defaults && defaults._searchPanel);
            this._filterPanel = new FilterPanel(control, defaults && defaults._filterPanel);
            this._emptyPage = new EmptyPage(owner, defaults && defaults._emptyPage);
            this._loadingPage = new LoadingPage(owner, defaults && defaults._loadingPage);
            // args
            this._rowTemplateArgs = { control: control.wrapperOrThis(), large: false, row: -1 };
        }
        _doDestory() {
            super._doDestory();
            this._dataLink = this._dv = null;
        }
        _doInitDefaults() {
            super._doInitDefaults();
            this._orientation = DListOrientation.VERTICAL;
            this._largeSize = ListOptions.LARGE_SIZE;
            this._rowsPerLine = 1;
            this._levelIndent = 8;
            this._overScrollEffect = DListOverScrollEffect.BALLOON;
        }
        //-------------------------------------------------------------------------
        // IListGroupSectionOwner
        //-------------------------------------------------------------------------
        groupSectionChanged(section) {
            this._changed();
        }
        //-------------------------------------------------------------------------
        // IRowCellObjectOwner
        //-------------------------------------------------------------------------
        rowCellObjectChanged(cell) {
            this._changed();
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        isLandscape() {
            return this._landscape;
        }
        /**
         * row 배치 방향.
         * {@link DListOrientation.VERTICAL}이면 행들을 위에서 아래로 수직 배치하고,
         * {@link DListOrientation.HORIZONTAL}이면 왼쪽에서 오른쪽으로 수평 배치한다.
         *
         * 수직 모드일 때는 모든 행의 최대 너비가 컨트롤의 너비로 고정되고,
         * 수평 모드일 때는 모든 행의 최대 높이가 컨트롤의 높이로 고정된다.
         * 즉, 수직 모드일 때는 좌우로 스크롤되지 않고,
         * 수평 모드일 때는 상하로 스크롤 되지 않는다.
         *
         * @default DOrientation.VERTICAL
         */
        orientation() {
            return pickProp(this._orientation, this._defs && this._defs._orientation);
        }
        setOrientation(value) {
            if (value !== this._orientation) {
                if (value === DListOrientation.HORIZONTAL && this._owner.isGrouped()) {
                    throwError(locale.canNotHorzInGrouping);
                }
                this._orientation = value;
                this._changed();
            }
        }
        /**
         * 큰 화면으로 판단하는 기준 크기.
         * <br>
         * portrait일 때는 너비, landscape일 때는 높이에 대한 기준값이다.
         */
        largeSize() {
            return pickNum(this._largeSize, this._defs && this._defs._largeSize);
        }
        setLargeSize(value) {
            if (value !== this._largeSize) {
                this._largeSize = value;
                this._changed();
            }
        }
        /**
         * 수평모드일 때 한 행의 너비.
         *
         * @default undefined
         */
        rowWidth() {
            return pickNum(this._rowWidth, this._defs && this._defs._rowWidth);
        }
        setRowWidth(value) {
            if (value !== this._rowWidth) {
                this._rowWidth = value;
                this._changed();
            }
        }
        /**
         * 수평모드일 때 한 행의 최소 너비.
         *
         * @default undefined
         */
        minRowWidth() {
            return pickNum(this._minRowWidth, this._defs && this._defs._minRowWidth);
        }
        setMinRowWidth(value) {
            if (value !== this._minRowWidth) {
                this._minRowWidth = value;
                this._changed();
            }
        }
        /**
         * 수평모드일 때 한 행의 최대 너비.
         *
         * @default undefined
         */
        maxRowWidth() {
            return pickNum(this._maxRowWidth, this._defs && this._defs._maxRowWidth);
        }
        setMaxRowWidth(value) {
            if (value !== this._maxRowWidth) {
                this._maxRowWidth = value;
                this._changed();
            }
        }
        /**
         * 보여지는 화면에 표시할 최대 데이터행 개수.
         * 0보다 큰 값일 때만 적용된다.
         * 표시할 수 있는 데이터행이 지정한 값보다 작은 경우 의미가 없지만,
         * {@link rowCount}가 설정되면 나머지 높이를 고려해서 행의 높이를 적절히 표시한다.
         * 이 속성이 타당한 값으로 설정되면 {@link minRowHeight}, {@link maxRowHeight} 속성은 무시된다.
         * 대신, {@link rowHeight}가 명시적으로 설정되면 이 속성이 무시된다.
         * 계산된 행들의 높이가 합이 전체 높이보다 작은 경우 균등 배분한다.
         *
         * @default NaN
         */
        rowCount() {
            return pickNum(this._rowCount, this._defs ? this._defs._rowCount : NaN);
        }
        setRowCount(value) {
            value = Utils.toNumber(value) >>> 0;
            if (value !== this._rowCount) {
                this._rowCount = value;
                this._changed();
            }
        }
        /** levelIndent */
        levelIndent() {
            return pickNum(this._levelIndent, this._defs ? this._defs._levelIndent : NaN);
        }
        setLevelIndent(value) {
            value = pickNum(value, 0);
            if (value !== this._levelIndent) {
                this._levelIndent = value;
                this._changed();
            }
        }
        /** menu */
        menu() {
            return pickProp(this._menu, this._defs && this._defs._menu);
        }
        setMenu(value) {
            this._menu = value;
        }
        /** overScrollEffect */
        overScrollEffect() {
            return pickProp(this._overScrollEffect, this._defs && this._defs._overScrollEffect);
        }
        setOverScrollEffect(value) {
            this._overScrollEffect = value;
        }
        /**
         * Head rows options.
         */
        headRows() {
            return this._headRows;
        }
        /**
         * 컨트롤 header model.
         */
        header() {
            return this._header;
        }
        /**
         * 컨트롤 footer model.
         */
        footer() {
            return this._footer;
        }
        /**
         * 검색 bar.
         * 헤더 아래 표시된다.
         */
        searchBar() {
            return this._searchBar;
        }
        /**
         * 검색 결과 bar.
         * Footer 위에 표시된다.
         */
        searchResultBar() {
            return this._searchResultBar;
        }
        /**
         * 필드 목록.
         */
        fieldBar() {
            return this._fieldBar;
        }
        /**
         * 필드 헤더.
         */
        fieldHeader() {
            return this._fieldHeader;
        }
        /**
         * Row group options.
         */
        rowGroup() {
            return this._rowGroup;
        }
        /**
         * Data group options.
         */
        dataGroup() {
            return this._dataGroup;
        }
        dataRowInfos() {
            return this._dataRowInfos;
        }
        editBar() {
            return this._editBar;
        }
        scrollIndicator() {
            return this._scrollIndicator;
        }
        indexBar() {
            return this._indexBar;
        }
        scrollBar() {
            return this._scrollBar;
        }
        pageNavigator() {
            return this._pageNavigator;
        }
        pageScroller() {
            return this._pageScroller;
        }
        commandBox() {
            return this._commandBox;
        }
        selectionMask() {
            return this._selectionMask;
        }
        infoPage() {
            return this._infoPage;
        }
        editPage() {
            return this._editPage;
        }
        addPage() {
            return this._addPage;
        }
        singleRow() {
            return this._singleRow;
        }
        attachedRow() {
            return this._attachedRow;
        }
        formPanel() {
            return this._formPanel;
        }
        buttonPanel() {
            return this._buttonPanel;
        }
        searchPanel() {
            return this._searchPanel;
        }
        filterPanel() {
            return this._filterPanel;
        }
        emptyPage() {
            return this._emptyPage;
        }
        loadingPage() {
            return this._loadingPage;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        load(config) {
            return super.load(config);
        }
        isLarge() {
            if (this.isLandscape()) {
                return this._owner.height() >= this.largeSize();
            }
            else {
                return this._owner.width() >= this.largeSize();
            }
        }
        getDefaultRowTemplate() {
            return this._runRowTemplate;
        }
        getRowTemplate(row) {
            const cb = this._runRowTemplateCallback;
            let template;
            if (cb) {
                this._rowTemplateArgs.row = row;
                this._rowTemplateArgs.large = this.isLarge();
                template = cb(this._rowTemplateArgs);
            }
            if (!template) {
                let name;
                if (this._dataLink) {
                    name = this._dataLink.getSource(row).name();
                }
                else {
                    name = this._dv.name();
                }
                template = name && this.dataRowInfos().getRowTemplate(name);
            }
            return template || this._runRowTemplate;
        }
        getRowParams() {
            return this._runRowParams;
        }
        getRowStyle() {
            return this._runRowStyle;
        }
        getRowCommands() {
            const runner = this._owner.rowCommands();
            const cmds = [];
            Utils.makeArray(this.row().commands(), true).forEach(s => {
                const cmd = runner.get(s);
                cmd && cmds.push(cmd);
            });
            return cmds;
        }
        prepareRender() {
            this.$_prepareRunnings();
            this._dv = this.owner().data();
            this._dataLink = this._dv instanceof ListDataLinkView ? this._dv : null;
            this._rowBar.visible() && this._rowBar.prepareRender();
            this._editBar.visible() && this._editBar.prepareRender();
            this._scrollIndicator.visible() && this._scrollIndicator.prepareRender();
            this._indexBar.visible() && this._indexBar.prepareRender();
            this._scrollBar.visible() && this._scrollBar.prepareRender();
            this._owner.isPaging() && this._pageNavigator.visible() && this._pageNavigator.prepareRender();
            this._owner.isPaging() && this._pageScroller.visible() && this._pageScroller.prepareRender();
            this._commandBox.visible() && this._commandBox.prepareRender();
            this._selectionMask.visible() && this._selectionMask.prepareRender();
            // this._headRows.visible() && this._headRows.prepareRender();
            // this._header.visible() && this._header.prepareRender();
            // this._footer.visible() && this._footer.prepareRender();
            this._fieldBar.visible() && this._fieldBar._setRowTemplate(this._row.template());
            // this._formPanel.prepareRender();
            // this._buttonPanel.prepareRender();
            // this._rowGroup.prepareRender();
            // this._dataGroup.prepareRender();
            this._dataRowInfos.prepareRender();
            this._rowBar.visible() && this._rowBar.prepareRender();
            // this._editPageView.prepareRender();
        }
        unprepareRender() {
            this._rowBar.visible() && this._rowBar.unprepareRender();
            this._editBar.visible() && this._editBar.unprepareRender();
        }
        //-------------------------------------------------------------------------
        // internal methods
        //-------------------------------------------------------------------------
        $_getPanel(type) {
            switch (type) {
                case FormPanel.TYPE:
                    return this._formPanel;
                case ButtonPanel.TYPE:
                    return this._buttonPanel;
                case SearchPanel.TYPE:
                    return this._searchPanel;
                case FilterPanel.TYPE:
                    return this._filterPanel;
            }
        }
        $_prepareRunnings() {
            const row = this._row;
            this._runRowTemplateCallback = row.templateCallback();
            this._runRowTemplate = this.isLarge() ? (row.largeTemplate() || row.template()) : row.template();
            this._runRowParams = row.$_internalParams();
            this._runRowStyle = row.style();
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    ListOptions.LARGE_SIZE = 600;

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     *
     * Focus View.
     */
    class FocusView extends DListElement {
        //-------------------------------------------------------------------------
        // static members
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // property fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(doc) {
            super(doc, false, FocusView.CLASS_NAME);
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doInitDom(doc, dom) {
        }
        _doMeasure(doc, hintWidth, hintHeight) {
            return { width: hintWidth, height: hintHeight };
        }
        _doRender(doc, width, height) {
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    FocusView.CLASS_NAME = 'dlist-focus-mask';

    ////////////////////////////////////////////////////////////////////////////////
    class ListRowAnimation extends DObject {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(bodyView) {
            super();
            this._bodyView = bodyView;
        }
        _doDestory() {
            this.stop();
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        start() {
            if (!this._doStart()) {
                this.stop();
            }
            return this;
        }
        stop() {
            this._doStop();
        }
    }
    /**
     * @internal
     *
     * ListControl의 행들과 header/footer를 표시하는 content view.
     * 현재, list control의 전체 영역을 차지한다.
     */
    class ListView extends DListElement {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(doc, owner) {
            super(doc, false, ListView.CLASS_NAME);
            this._panelViews = [];
            this.pageMoving = false;
            this.orderWidth = NaN;
            this.rightMargin = 0;
            this._owner = owner;
            this.addChild(this._bodyView = this._bodyView = this._createBodyView(doc, owner.noCache(), false));
            this._bodyView['_listView'] = this;
            this.addChild(this._sectionContainer = new DElement(doc, false, 'dlist-sections'));
            this.addChild(this._panelContainer = new LayerElement(doc, false, 'dlist-panels'));
            this._panelContainer.dom.style.overflow = 'hidden'; // show/hide animation을 위해 필요.
            this.addChild(this._toolContainer = new LayerElement(doc, false, 'dlist-tools'));
        }
        _doDestory() {
            super._doDestory();
            this.rowBar = this.editBar = this._renderInfo = this._owner = null;
            this._panelViews.length = 0;
        }
        isSkeleton() {
            return false;
        }
        createLayoutView(doc, layout) {
            if (layout instanceof DListLayout) {
                return new LayoutViews[layout.type](doc, layout);
            }
            else {
                return new HtmlLayoutView(doc, layout);
            }
        }
        borrowRenderer(renderer) {
            return this._owner.borrowRenderer(renderer);
        }
        freeRenderer(renderer) {
            this._owner.freeRenderer(renderer);
        }
        useImage(src) {
            this._owner.useImage(src);
        }
        getImageSize(src) {
            return this._owner.getImageSize(src);
        }
        getIcon(iconSet, iconName) {
            return this._owner.getIcon(iconSet, iconName);
        }
        rowBorderVisible(rv) {
            if (rv._last && this._owner.rowBorder.skipLast)
                return false;
            return true;
        }
        //-------------------------------------------------------------------------
        // IFieldPanelOwner
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        owner() {
            return this._owner;
        }
        data() {
            return this._owner.data();
        }
        isVertical() {
            return this._vertical;
        }
        isLandscape() {
            return this._owner.isLandscape();
        }
        itemCount() {
            return this._bodyView.itemViewCount();
        }
        headRowsView() {
            return this._headRowsView;
        }
        formPanelView() {
            return this._formPanelView;
        }
        buttonPanelView() {
            return this._buttonPanelView;
        }
        bodyView() {
            return this._bodyView;
        }
        headerView() {
            return this._headerView;
        }
        footerView() {
            return this._footerView;
        }
        searchBarView() {
            return this._searchBarView;
        }
        fieldBarView() {
            return this._fieldBarView;
        }
        fieldHeaderView() {
            return this._fieldHeaderView;
        }
        scrollIndicatorView() {
            return this._scrollIndicatorView;
        }
        indexBarView() {
            return this._indexBarView;
        }
        scrollBarView() {
            return this._scrollBarView;
        }
        pageNavigatorView() {
            return this._pageNavigatorView;
        }
        pageScrollerView() {
            return this._pageScrollerView;
        }
        menuView() {
            return this._menuView;
        }
        renderInfo() {
            return this._renderInfo;
        }
        scrollPos() {
            return this._bodyView.scrollPos();
        }
        scrollOff() {
            return this._bodyView.scrollOff();
        }
        topRow() {
            return this._bodyView.topRow();
        }
        activePanel() {
            return this._activePanel;
        }
        menu() {
            return this._menu;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        getExpander(index) {
            return this._bodyView.getExpander(index);
        }
        _resetScrollStates() {
            const pos = this.scrollPos();
            const off = this.scrollOff();
            this.$_setScrollRate(this._scrollIndicatorView, pos, off, true);
            this.$_setScrollBar(this._scrollBarView, true);
        }
        scrollBy(delta) {
            const r = this._bodyView.scrollBy(delta);
            this._resetScrollStates();
            // TODO: 주석 처리할 것.
            this._bodyView.checkItemViewOrders();
            this._bodyView.resetFocusedView();
            return r;
        }
        scrollToEnd(row) {
            this._bodyView.scrollToEnd(row);
            this._resetScrollStates();
            // TODO: 주석 처리할 것.
            this._bodyView.checkItemViewOrders();
            this._bodyView.resetFocusedView();
        }
        pageChanged(page) {
            const view = this._pageScrollerView;
            if (view && view.visible) {
                view.makeVisible(page);
            }
        }
        closePanel(animate) {
            if (this._activePanel) {
                const w = this._panelContainer.width;
                const h = this._panelContainer.height;
                const v = this.$_getPanelView(this._activePanel);
                if (animate) {
                    v && this.$_hidePanel(v, w, h, null);
                }
                else {
                    this._activePanel = null;
                    if (v) {
                        this._panelContainer.dom.style.pointerEvents = 'none';
                        this._panelContainer.removeChild(v);
                        v.setVisible(false);
                    }
                }
            }
        }
        showPanel(panel, animate) {
            const w = this._panelContainer.width;
            const h = this._panelContainer.height;
            if (animate) {
                if (panel && panel !== this._activePanel) {
                    if (this._activePanel) {
                        this.$_hidePanel(this.$_getPanelView(this._activePanel), w, h, () => {
                            this.$_showPanel(this.$_getPanelView(panel), w, h, null);
                        });
                    }
                    else {
                        this.$_showPanel(this.$_getPanelView(panel), w, h, null);
                    }
                }
            }
            else if (panel && panel !== this._activePanel) {
                const v = this.$_getPanelView(this._activePanel = panel);
                if (v) {
                    this._panelContainer.dom.style.pointerEvents = 'auto';
                    v.setVisible(true);
                    this._panelContainer.addChild(v);
                }
                else {
                    this._panelContainer.removeChild(v);
                }
            }
        }
        togglePanel(panel, animate) {
            // animate = false;
            if (panel) {
                const w = this._panelContainer.width;
                const h = this._panelContainer.height;
                const wasActive = panel === this._activePanel;
                const pv = this.$_getPanelView(panel);
                if (pv) {
                    if (animate) {
                        if (wasActive) {
                            this.$_hidePanel(pv, w, h, null);
                        }
                        else {
                            this.$_showPanel(pv, w, h, null);
                        }
                    }
                    else {
                        this._activePanel = wasActive ? null : panel;
                        if (pv.setVisible(!wasActive)) {
                            this._panelContainer.addChild(pv);
                        }
                        else {
                            this._panelContainer.removeChild(pv);
                        }
                    }
                }
            }
        }
        getPanel(dom) {
            const v = this._activePanel && this.$_getPanelView(this._activePanel);
            return v && v.containsDom(dom) ? v : null;
        }
        isInPanel(dom) {
            const pv = this.getPanel(dom);
            return pv && pv.containsDom(dom);
        }
        isMenuView(dom) {
            return this._menuView && this._menuView.isMenuView(dom);
        }
        showMenu(menu, animate) {
            checkNull(!!menu, 'menu object is required.');
            this.closePanel(false);
            this.hideMenu(false);
            menu.onShow && menu.show(this.control.wrapperOrThis());
            let mv = this._menuView;
            if (!mv) {
                mv = this._menuView = new ListMenuView(this.doc);
                mv.setVisible(false);
            }
            this._panelContainer.addChild(mv);
            mv.show(this._menu = menu, this.width, this.height, this.canAnimate());
        }
        hideMenu(animate) {
            return this._menuView && this._menuView.hide(this.canAnimate());
        }
        canMovePage(dx, endEffect) {
            const owner = this._owner;
            if (owner.isPaging()) {
                if (dx > 0) {
                    if (owner.page() > 0)
                        return true;
                    else if (endEffect) {
                        this._bodyView.$_showOverEffect(Direction.LEFT);
                    }
                }
                else if (dx < 0) {
                    if (owner.page() < owner.pageCount() - 1)
                        return true;
                    else if (endEffect) {
                        this._bodyView.$_showOverEffect(Direction.RIGHT);
                    }
                }
            }
        }
        canMoveSingle(dx, endEffect) {
            return false;
        }
        getSpareBody() {
            if (!this._spareBodyView) {
                this._spareBodyView = this._createBodyView(this.doc, this._owner.noCache(), true);
                this._spareBodyView['_listView'] = this;
            }
            return this._spareBodyView;
        }
        // 이미지가 load됐을 때 호출된다.
        refreshPanel() {
            // buttonPanel에 이미지가 표시될 수 있다.
            if (this._buttonPanelView && this._buttonPanelView.visible) {
                this._buttonPanelView.refresh(this, this.width, this.height);
            }
        }
        focusedRowChanged(focus, old) {
            this._bodyView.focusedRowChanged(focus, old);
        }
        getLayoutView(dom) {
            for (const v of this._layoutViews) {
                if (v && v.visible && v.isView(dom)) {
                    return v;
                }
            }
        }
        addTooltipView(view) {
            this.control.lock(() => {
                this._toolContainer.addChild(view);
            });
        }
        removeTooltipView(view) {
            this.control.lock(() => {
                this._toolContainer.removeChild(view);
            });
        }
        addFeedback(dom) {
            this._toolContainer.appendDom(dom);
        }
        showToast(toast) {
            const tv = new ToastView(this.doc);
            const m = new ListToast(toast);
            tv.show(this._toolContainer, m);
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doPrepareRender(doc, hint) {
            if (this.pageMoving)
                debugger;
            const owner = this._owner;
            const empty = owner.isEmpty();
            const data = owner.data();
            const fullMode = owner.fullMode();
            const single = owner.isSingleRow();
            const hasRow = owner.getRowCount() > 0;
            const options = owner.current();
            const sectionContainer = this._sectionContainer;
            const headRows = options.headRows();
            let vis;
            this._vertical = owner.isVertical();
            this._renderInfo = hint;
            this.rowBar = options._rowBar.visible() ? options._rowBar : null;
            this.editBar = options._editBar.visible() ? options._editBar : null;
            this.borderLine = (!single || options.singleRow().rowBorderVisible) && options.row().borderLine().visible() ? options.row().borderLine() : null;
            this.focusMask = !single && options.row().focusMask().visible() ? options.row().focusMask() : null;
            this.textFormatter = owner.getTextFormatter();
            this.boolFormatter = owner.getBoolFormatter();
            this.numberFormatter = owner.getNumberFormatter();
            this.dateFormatter = owner.getDateFormatter();
            // head rows
            if (headRows.prepareRender(owner.data())) {
                sectionContainer.addChild(this._headRowsView = new HeadRowsView(doc, headRows));
            }
            else if (this._headRowsView) {
                this._headRowsView.setVisible(false);
            }
            // scroll indicator
            vis = options._scrollIndicator.visible() && !empty;
            if (!fullMode && vis && !this._scrollIndicatorView) {
                sectionContainer.addChild(this._scrollIndicatorView = new ScrollIndicatorView(doc, options.scrollIndicator()));
            }
            else if (this._scrollIndicatorView) {
                if (this._scrollIndicatorView.setVisible(hasRow && vis)) {
                    this._scrollIndicatorView.setModel(options.scrollIndicator());
                }
            }
            // header
            vis = options.header().visible();
            if (vis && !this._headerView) {
                sectionContainer.addChild(this._headerView = new ListHeaderView(doc, options.header()));
            }
            else if (this._headerView) {
                if (this._headerView.setVisible(vis)) {
                    this._headerView.setModel(options.header());
                }
            }
            // search bar
            vis = options.searchBar().visible();
            if (vis && !this._searchBarView) {
                sectionContainer.addChild(this._searchBarView = new SearchBarView(doc, options.searchBar()));
            }
            else if (this._searchBarView) {
                if (this._searchBarView.setVisible(vis)) {
                    this._searchBarView.setModel(options.searchBar());
                }
            }
            // search result
            vis = options.searchResultBar().visible() && (this._searchPanelView &&
                this._searchPanelView.canShowResult(owner.searchResult()) || options.searchBar().canShowResult(owner.searchResult()));
            if (vis && !this._searchResultView) {
                sectionContainer.addChild(this._searchResultView = new SearchResultView(doc, options.searchResultBar()));
            }
            else if (this._searchResultView) {
                if (this._searchResultView.setVisible(vis)) {
                    this._searchResultView.setModel(options.searchResultBar());
                }
            }
            // field bar
            vis = options.fieldBar().visible() && data && data.canSort();
            if (vis && !this._fieldBarView) {
                sectionContainer.addChild(this._fieldBarView = new FieldBarView(doc, options.fieldBar()));
            }
            else if (this._fieldBarView) {
                if (this._fieldBarView.setVisible(vis)) {
                    this._fieldBarView.setModel(options.fieldBar());
                }
            }
            // field header
            vis = options.fieldHeader().visible();
            if (vis && !this._fieldHeaderView) {
                sectionContainer.addChild(this._fieldHeaderView = new FieldHeaderView(doc, options.fieldHeader()));
            }
            else if (this._fieldHeaderView) {
                if (this._fieldHeaderView.setVisible(vis)) {
                    this._fieldHeaderView.setModel(options.fieldHeader());
                }
            }
            // footer
            vis = options.footer().visible();
            if (vis && !this._footerView) {
                sectionContainer.addChild(this._footerView = new ListFooterView(doc, options.footer()));
            }
            else if (this._footerView) {
                if (this._footerView.setVisible(vis)) {
                    this._footerView.setModel(options.footer());
                }
            }
            // index bar
            vis = hasRow && owner.indexBar().visible() && !empty;
            if (!fullMode && vis && !this._indexBarView) {
                sectionContainer.addChild(this._indexBarView = new IndexBarView(doc, options.indexBar()));
            }
            else if (this._indexBarView) {
                if (this._indexBarView.setVisible(hasRow && vis)) {
                    this._indexBarView.setModel(options.indexBar());
                }
            }
            // scroll bar
            let sv = this._scrollBarView;
            vis = owner.scrollBar().visible() && !empty;
            if (!fullMode && hasRow && vis && !sv) {
                sectionContainer.addChild(sv = this._scrollBarView = new ScrollBarView(doc, options.scrollBar()));
            }
            else if (sv) {
                if (sv.setVisible(hasRow && vis)) {
                    sv.setModel(options.scrollBar());
                }
            }
            vis && sv && sv.setVertical(this._vertical);
            // paging
            if (owner.isPaging()) {
                // page navigator
                vis = owner.pageNavigator().visible();
                if (vis && !this._pageNavigatorView) {
                    sectionContainer.addChild(this._pageNavigatorView = new PageNavigatorView(doc, owner, options.pageNavigator()));
                }
                else if (this._pageNavigatorView) {
                    if (this._pageNavigatorView.setVisible(vis)) {
                        this._pageNavigatorView.setModel(options.pageNavigator());
                    }
                }
                // page scroller
                vis = owner.pageScroller().visible();
                if (vis && !this._pageScrollerView) {
                    sectionContainer.addChild(this._pageScrollerView = new PageScrollerView(doc, owner, options.pageScroller()));
                }
                else if (this._pageScrollerView) {
                    if (this._pageScrollerView.setVisible(vis)) {
                        this._pageScrollerView.setModel(options.pageScroller());
                    }
                }
            }
            // panel
            const pv = this.$_getPanelView(this._activePanel);
            pv && pv.setVisible(true);
            this._panelViews.forEach(v => {
                v !== pv && !v.animating() && v.setVisible(false);
            });
            this._runScrollIndicator = this._scrollIndicatorView && this._scrollIndicatorView.visible ? this._scrollIndicatorView : null;
            this._runPageNavigator = this._pageNavigatorView && this._pageNavigatorView.visible ? this._pageNavigatorView : null;
            this._headerViews = [this._headerView, this._searchBarView, this._fieldBarView, this._fieldHeaderView];
            this._layoutViews = [this._headerView, this._footerView, this._fieldHeaderView];
        }
        $_measureFull(owner, doc, w, h) {
            let height = 0;
            this.rightMargin = 0;
            // head rows
            if (this._headRowsView && this._headRowsView.visible) {
                height += this._headRowsView.measure(doc, null, w, h).height;
            }
            // header
            if (this._headerView && this._headerView.visible) {
                this._headerView.setLayout(this._headerView.model().layout());
                height += this._headerView.measure(doc, this, w, h).height;
            }
            // search bar
            if (this._searchBarView && this._searchBarView.visible) {
                height += this._searchBarView.measure(doc, owner, w, h).height;
            }
            // field bar
            if (this._fieldBarView && this._fieldBarView.visible) {
                height += this._fieldBarView.measure(doc, owner, w, h).height;
            }
            // field header
            if (this._fieldHeaderView && this._fieldHeaderView.visible) {
                height += this._fieldHeaderView.measure(doc, owner, w, h).height;
            }
            // footer
            if (this._footerView && this._footerView.visible) {
                this._footerView.setLayout(this._footerView.model().layout());
                height += this._footerView.measure(doc, this, w, h).height;
            }
            // body
            height += this._bodyView.measure(doc, owner, w, h).height;
            // page navigator
            if (this._runPageNavigator) {
                height += this._runPageNavigator.measure(doc, this, w, h).height;
            }
            // page scroller
            if (this._pageScrollerView && this._pageScrollerView.visible) {
                height += this._pageScrollerView.measure(doc, this, w, h).height;
            }
            // panel
            const pv = this.$_getPanelView(this._activePanel);
            if (pv && !pv.animating()) {
                pv.measure(doc, this, w, h);
            }
            return { width: w, height };
        }
        _doMeasure(doc, hintWidth, hintHeight) {
            // TODO: control.orientation === horizontal
            const owner = this._owner;
            if (owner.fullMode()) {
                return this.$_measureFull(owner, doc, hintWidth, Number.MAX_SAFE_INTEGER);
            }
            if (!this._vertical) {
                return this._doMeasureHorz(doc, hintWidth, hintHeight);
            }
            const landscape = owner.isLandscape();
            const searchResult = owner.searchResult();
            let h = hintHeight;
            let w = hintWidth;
            let hHeader = 0;
            let hSearchBar = 0;
            let hFieldBar = 0;
            let hFieldHeader = 0;
            let hSearchResult = 0;
            let hFooter = 0;
            let sz;
            // page navigator
            const pnv = this._runPageNavigator;
            if (pnv) {
                pnv.setPosition(landscape);
                sz = pnv.measure(doc, this, w, h);
                if (pnv.vertical) {
                    w -= sz.width;
                }
                else {
                    h -= sz.height;
                }
            }
            // scroll indicator
            const siv = this._runScrollIndicator;
            if (siv) {
                siv.setPosition(landscape);
                sz = siv.measure(doc, this, w, h);
                if (siv.vertical) {
                    w -= sz.width;
                }
                else {
                    h -= sz.height;
                }
            }
            // head rows
            if (this._headRowsView && this._headRowsView.visible) {
                sz = this._headRowsView.measure(doc, null, w, h);
                h -= sz.height;
            }
            // page scroller
            if (this._pageScrollerView && this._pageScrollerView.visible) {
                sz = this._pageScrollerView.measure(doc, this, w, h);
                h -= sz.height;
            }
            // header
            if (this._headerView && this._headerView.visible) {
                this._headerView.setLayout(this._headerView.model().layout());
                hHeader = this._headerView.measure(doc, this, w, h).height;
            }
            // search bar
            if (this._searchBarView && this._searchBarView.visible) {
                this._searchBarView.setResult(searchResult);
                hSearchBar = this._searchBarView.measure(doc, owner, w, h).height;
            }
            // field bar
            if (this._fieldBarView && this._fieldBarView.visible) {
                hFieldBar = this._fieldBarView.measure(doc, owner, w, h).height;
            }
            // field header
            if (this._fieldHeaderView && this._fieldHeaderView.visible) {
                this._fieldHeaderView.setLayout(this._fieldHeaderView.model().layout());
                hFieldHeader = this._fieldHeaderView.measure(doc, this, w, h).height;
            }
            // search result
            if (this._searchResultView) {
                // reuslt 유무에 따라 visible이 달라진다.
                this._searchResultView.setResult(searchResult);
                if (this._searchResultView.visible) {
                    hSearchResult = this._searchResultView.measure(doc, this, w, h).height;
                }
            }
            // footer
            if (this._footerView && this._footerView.visible) {
                this._footerView.setLayout(this._footerView.model().layout());
                hFooter = this._footerView.measure(doc, this, w, h).height;
            }
            h -= hHeader + hSearchBar + hFieldBar + hFieldHeader + hSearchResult + hFooter;
            this.rightMargin = 0;
            // scroll bar
            if (this._scrollBarView && this._scrollBarView.visible) {
                sz = this._scrollBarView.measure(doc, this, w, h);
                if (!this._scrollBarView.model().floating()) {
                    this.rightMargin += sz.width;
                }
            }
            // index bar
            if (this._indexBarView && this._indexBarView.visible) {
                sz = this._indexBarView.measure(doc, this, w, h);
                if (!this._indexBarView.model().floating()) {
                    this.rightMargin += sz.width;
                }
            }
            // panel
            const pv = this.$_getPanelView(this._activePanel);
            if (pv && !pv.animating()) {
                pv.measure(doc, this, hintWidth, h);
            }
            // body
            this._bodyView._searchResult = searchResult;
            this._bodyView.measure(doc, owner, w, h);
            return { width: hintWidth, height: hintHeight };
        }
        _doRender(doc, width, height) {
            if (!this._vertical) {
                this._doRenderHorz(doc, width, height);
                return;
            }
            function renderHeadRows() {
                const h = headRowsView.mh;
                headRowsView.resize(width, h).move(x, y);
                height = -h;
                y += h;
                headRowsView.render(doc);
            }
            const scrollPos = this.scrollPos();
            const scrollOff = this.scrollOff();
            const headRowsView = this._headRowsView && this._headRowsView.visible ? this._headRowsView : null;
            const pnv = this._runPageNavigator;
            const siv = this._runScrollIndicator;
            let scrollBarView = this._scrollBarView && this._scrollBarView.visible ? this._scrollBarView : null;
            let wSave = width;
            let hSave = height;
            let x = 0;
            let y = 0;
            let y2 = height;
            let view;
            // page navigator
            if (pnv && pnv.vertical) {
                const w = pnv.mw;
                if (pnv.position === DListControlObjectPosition.LEFT) {
                    pnv.resize(w, height).move(x, y);
                    x += w;
                }
                else {
                    pnv.resize(w, height).move(wSave - w, y);
                }
                width -= w;
                wSave -= w;
                pnv.render(doc);
            }
            // scroll indicator
            if (siv) {
                if (siv.vertical) {
                    const w = siv.mw;
                    siv.resize(w, height);
                    if (siv.position === DListControlObjectPosition.LEFT) {
                        siv.move(x, y);
                        x += w;
                    }
                    else {
                        siv.move(wSave - w, y);
                    }
                    width -= w;
                    wSave -= w;
                }
                else {
                    const h = siv.mh;
                    siv.resize(width, h);
                    if (siv.position === DListControlObjectPosition.TOP) {
                        siv.move(x, y);
                        y += h;
                    }
                    else {
                        siv.move(x, hSave - h);
                        y2 -= h;
                    }
                    height -= h;
                    hSave -= h;
                }
                siv.render(doc);
            }
            // head rows view
            if (headRowsView && headRowsView.model.position() === DHeadRowPosition.BEFORE) {
                renderHeadRows();
            }
            // page scroller - 제일 바닥 혹은 scroll indicator 아래
            view = this._pageScrollerView;
            if (view && view.visible) {
                const h = view.mh;
                view.resize(width, h).move(x, hSave - h);
                height -= h;
                hSave -= h;
                view.render(doc);
            }
            // page navigator - page scroller 위 혹은 아래
            if (pnv && !pnv.vertical) {
                const h = pnv.mh;
                if (pnv.position === DListControlObjectPosition.TOP) {
                    pnv.resize(width, h).move(x, y);
                    y += h;
                }
                else {
                    pnv.resize(width, h).move(x, hSave - h);
                    y2 -= h;
                }
                height -= h;
                hSave -= h;
                pnv.render(doc);
            }
            // footer - page navigator 위
            view = this._footerView;
            if (view && view.visible) {
                const h = view.mh;
                y2 -= h;
                view.resize(width, h).move(x, y2);
                height -= h;
                hSave -= h;
                view.render(doc);
            }
            // saerch result - footer 위
            view = this._searchResultView;
            if (view && view.visible) {
                const h = view.mh;
                y2 -= h;
                view.resize(width, h).move(x, y2);
                height -= h;
                hSave -= h;
                view.render(doc);
            }
            // header, searchBar, fieldBar
            for (const view of this._headerViews) {
                if (view && view.visible) {
                    const h = view.mh;
                    view.resize(width, h).move(x, y);
                    height -= h;
                    y += h;
                    view.render(doc);
                }
            }
            // head rows view
            if (headRowsView && headRowsView.model.position() === DHeadRowPosition.AFTER) {
                renderHeadRows();
            }
            let wRight = 0;
            // scroll bar
            view = scrollBarView;
            if (view) {
                const w = view.mw;
                // const h = view.mh;
                view.resize(w, height).move(width - w, y);
                if (!this._scrollBarView.model().floating()) {
                    wRight += w;
                }
            }
            // index bar
            view = this._indexBarView;
            if (view && view.visible) {
                const w = view.mw;
                const h = view.mh;
                view.resize(w, h).move(width - wRight - w, (height - h) / 2);
                view.render(doc);
                if (!this._indexBarView.model().floating()) {
                    wRight += w;
                }
            }
            // panel container
            this._panelContainer.setBounds(0, y, width, height); //hSave - y);
            const pv = this.$_getPanelView(this._activePanel);
            if (pv && !pv.animating()) {
                const w = pv.mw;
                const h = pv.mh;
                pv.resize(w, h);
                this.$_movePanel(pv);
                pv.render(doc);
            }
            // body
            const body = this._bodyView;
            body.resize(width, Math.max(0, height)).move(x, y);
            body.render(doc);
            // scroll views, bodyView가 결정되야 내용을 그릴 수 있다.
            if (body.isEmpty()) {
                if (scrollBarView) {
                    scrollBarView.setVisible(false);
                    scrollBarView = null;
                }
            }
            if (siv) {
                this.$_setScrollRate(siv, scrollPos, scrollOff, false);
                siv.render(doc);
            }
            if (scrollBarView) {
                this.$_setScrollBar(scrollBarView, false);
                scrollBarView.render(doc);
            }
            // tool container
            this._toolContainer.setBounds(0, 0, width, hSave);
        }
        _doMeasureHorz(doc, hintWidth, hintHeight) {
            const owner = this._owner;
            const searchResult = owner.searchResult();
            let h = hintHeight;
            let w = hintWidth;
            let hHeader = 0;
            let hSearchBar = 0;
            let hSearchResult = 0;
            let hFooter = 0;
            let sz;
            this.rightMargin = 0;
            // scroll indicator
            const sv = this._scrollIndicatorView;
            if (sv && sv.visible) {
                sz = sv.measure(doc, this, w, h);
                h -= sz.height;
            }
            const pnv = this._runPageNavigator;
            if (pnv) {
                if (pnv.vertical) ;
            }
            // header
            const hv = this._headerView;
            if (hv && hv.visible) {
                hv.setLayout(hv.model().layout());
                hHeader = hv.measure(doc, this, w, h).height;
            }
            // search bar
            if (this._searchBarView && this._searchBarView.visible) {
                this._searchBarView.setResult(searchResult);
                hSearchBar = this._searchBarView.measure(doc, this, w, h).height;
            }
            // search result
            if (this._searchResultView) {
                // reuslt 유무에 따라 visible이 달라진다.
                this._searchResultView.setResult(searchResult);
                if (this._searchResultView.visible) {
                    hSearchResult = this._searchResultView.measure(doc, this, w, h).height;
                }
            }
            // footer
            const fv = this._footerView;
            if (fv && fv.visible) {
                fv.setLayout(fv.model().layout());
                hFooter = fv.measure(doc, this, w, h).height;
            }
            h -= hHeader + hSearchBar + hSearchResult + hFooter;
            // scroll bar
            if (this._scrollBarView && this._scrollBarView.visible) {
                sz = this._scrollBarView.measure(doc, this, w, h);
                if (!this._scrollBarView.model().floating()) ;
            }
            // panel
            // TODO: 좌/우측에서 표시되도록...
            const pv = this.$_getPanelView(this._activePanel);
            if (pv && !pv.animating()) {
                pv.measure(doc, this, hintWidth, h);
            }
            // body
            this._bodyView._searchResult = searchResult;
            this._bodyView.measure(doc, owner, w, h);
            return { width: hintWidth, height: hintHeight };
        }
        _doRenderHorz(doc, width, height) {
            const scrollPos = this.scrollPos();
            const scrollOff = this.scrollOff();
            let scrollIndicatorView = this._scrollIndicatorView && this._scrollIndicatorView.visible ? this._scrollIndicatorView : null;
            let scrollBarView = this._scrollBarView && this._scrollBarView.visible ? this._scrollBarView : null;
            let hSave = height;
            let x = 0;
            let y = 0;
            let view;
            // scroll indicator
            view = scrollIndicatorView;
            if (view) {
                const h = view.mh;
                view.resize(width, h).move(x, y);
                height -= h;
                y += h;
            }
            // footer - page navigator 위
            view = this._footerView;
            if (view && view.visible) {
                const h = view.mh;
                view.resize(width, h).move(x, hSave - h);
                height -= h;
                hSave -= h;
                view.render(doc);
            }
            // saerch result - footer 위
            view = this._searchResultView;
            if (view && view.visible) {
                const h = view.mh;
                view.resize(width, h).move(x, hSave - h);
                height -= h;
                hSave -= h;
                view.render(doc);
            }
            // header
            view = this._headerView;
            if (view && view.visible) {
                const h = view.mh;
                view.resize(width, h).move(x, y);
                height -= h;
                y += h;
                view.render(doc);
            }
            // search bar
            view = this._searchBarView;
            if (view && view.visible) {
                const h = view.mh;
                view.resize(width, h).move(x, y);
                height -= h;
                y += h;
                view.render(doc);
            }
            // scroll bar
            view = scrollBarView;
            if (view) {
                const h = view.mh;
                view.resize(width, h).move(x, hSave - h);
                if (!this._scrollBarView.model().floating()) ;
            }
            // body
            const body = this._bodyView;
            body.resize(width, Math.max(0, height)).move(x, y);
            body.render(doc);
            // scroll views, bodyView가 결정되야 내용을 그릴 수 있다.
            if (body.isEmpty()) {
                if (scrollIndicatorView) {
                    scrollIndicatorView.setVisible(false);
                    scrollIndicatorView = null;
                }
                if (scrollBarView) {
                    scrollBarView.setVisible(false);
                    scrollBarView = null;
                }
            }
            if (scrollIndicatorView) {
                this.$_setScrollRate(scrollIndicatorView, scrollPos, scrollOff, false);
                scrollIndicatorView.render(doc);
            }
            if (scrollBarView) {
                this.$_setScrollBar(scrollBarView, false);
                scrollBarView.render(doc);
            }
            // panel container
            this._panelContainer.move(0, y);
            this._panelContainer.setHeight(hSave - y);
            const pv = this.$_getPanelView(this._activePanel);
            if (pv && !pv.animating()) {
                const w = pv.mw;
                const h = pv.mh;
                pv.resize(w, h).move(0, 0);
                pv.render(doc);
            }
        }
        _doAfterRender() {
            this._runPageNavigator = null;
            // TODO: 주석 처리할 것.
            this._bodyView.checkItemViewOrders();
        }
        $_destroyPanel(view) {
            if (view) {
                this._panelViews.splice(this._panelViews.indexOf(view), 1);
                return view.destroy();
            }
        }
        $_getButtonPanel(panel) {
            const views = this._panelViews;
            const d = panel.getDisplay(this.isLandscape());
            let view = this._buttonPanelView;
            if (!view || view.display() != d) {
                this.$_destroyPanel(view);
                view = ButtonPanelView.createView(this.doc, panel, d);
                views.push(this._buttonPanelView = view);
            }
            return view;
        }
        $_getFormPanel(panel) {
            const views = this._panelViews;
            if (!this._formPanelView) {
                views.push(this._formPanelView = new FormPanelView(this.doc, panel));
            }
            return this._formPanelView;
        }
        $_getSearchPanel(panel) {
            const views = this._panelViews;
            const d = panel.getDisplay(this.isLandscape());
            let view = this._searchPanelView;
            if (!view || view.display() != d) {
                this.$_destroyPanel(view);
                view = SearchPanelView.createView(this.doc, panel, d);
                views.push(this._searchPanelView = view);
            }
            return view;
        }
        $_getFilterPanel(panel) {
            const views = this._panelViews;
            if (!this._filterPanelView) {
                views.push(this._filterPanelView = new FilterPanelView(this.doc, panel));
            }
            return this._filterPanelView;
        }
        /**
         * 마지막에 표시된 행의 위치를 기준으로 계산한다.
         */
        $_setScrollRate(view, pos, off, render) {
            if (view) {
                const owner = this._owner;
                const body = this._bodyView;
                const vertical = this._vertical;
                if (owner.isSingleRow()) {
                    view.updateRate(this._owner, pos, 1, 1, render);
                }
                else if (owner.preMode()) {
                    const len = body.getPreLength();
                    const off = body.itemLayerOff() + (vertical ? body.height : body.width);
                    view.setRate(off / len, render);
                }
                else {
                    const lv = body.lastItemView();
                    if (lv) {
                        const h = this._vertical ? lv.height : lv.width;
                        const off = this._vertical ? body.height - lv.y : body.width - lv.x;
                        view.updateRate(owner, pos + body.itemViewCount() - 1, h, off, render);
                    }
                }
            }
        }
        $_getPageLen(body) {
            const pts = this._bodyView._itemPoints();
            let n = pts.length - 1;
            if (n > 0) {
                // 앞쪽 잘린 부분 제외
                let len = n - body.scrollOff() / (pts[1] - pts[0]);
                // 끝쪽 잘린 부분 제외
                len -= ((pts[n]) - (this._vertical ? body.height : body.width)) / (pts[n] - pts[n - 1]);
                return len;
            }
            return 0;
        }
        $_setScrollBar(view, render) {
            if (view && view.visible) {
                const body = this._bodyView;
                const scrollPos = body.scrollPos();
                if (body._preMode) {
                    const len = body.getPreLength();
                    const pos = body.getPrePos(scrollPos, body.scrollOff());
                    view.setScroll(len, this._vertical ? body.height : body.width, pos, render);
                }
                else {
                    const owner = this._owner;
                    const len = owner.isPaging() ? owner.pageSize() : owner.isGrouped() ? owner.groupModel().visItemCount() : owner.data().rowCount();
                    const szItem = this._vertical ? body.getItemView(0).height : body.getItemView(0).width;
                    const pos = scrollPos + (body.itemViewCount() > 0 ? body.scrollOff() / szItem : 0);
                    const page = this.$_getPageLen(body);
                    view.setScroll(len, page, pos, render);
                }
            }
        }
        $_getPanelView(panel) {
            this._panelViews;
            if (panel instanceof ButtonPanel) {
                return this.$_getButtonPanel(panel);
            }
            else if (panel instanceof FormPanel) {
                return this.$_getFormPanel(panel);
            }
            else if (panel instanceof SearchPanel) {
                return this.$_getSearchPanel(panel);
            }
            else if (panel instanceof FilterPanel) {
                return this.$_getFilterPanel(panel);
            }
        }
        $_movePanel(pv) {
            const w = this._panelContainer.width;
            const h = this._panelContainer.height;
            let x = 0;
            let y = 0;
            switch (pv.model().getPosition()) {
                case DListPanelPosition.RIGHT:
                    x = w - pv.mw;
                    break;
                case DListPanelPosition.BOTTOM:
                    y = h - pv.mh;
                    break;
                case DListPanelPosition.CENTER:
                    x += (w - pv.mw) / 2;
                    y += (h - pv.mh) / 2;
                    break;
                case DListPanelPosition.LEFT:
                case DListPanelPosition.TOP:
            }
            pv.move(x, y);
        }
        /**
         * TODO: padding을 줄여가면서 0 크기로 끝내는,
         *       최소 크기를 유지해서 끝내는 것이 좋은 지 검토 필요.
         */
        $_hidePanel(pv, width, height, callback) {
            function finish(self) {
                pv.setVisible(false);
                self._panelContainer.removeChild(pv);
                self._activePanel = null;
                callback && callback();
            }
            // function getFrames(): Keyframe[] {
            //     // const pad = Dom.getPadding2(pv.dom);
            //     const cs = pv.getComputedStyle();
            //     switch (pv.model().getPosition()) {
            //         case DListPanelPosition.CENTER:
            //             return [
            //             ];
            //         case DListPanelPosition.LEFT:
            //             return [
            //                 // [주의]padding: cs.padding 으로 시작하면 anroid에서 'Partial keyframes...' 에러가 발생한다!
            //                 { width: pixel(pv.width), paddingLeft: cs.paddingLeft, paddingRight: cs.paddingRight },
            //                 { width: ZERO_PX, paddingLeft: ZERO_PX, paddingRight: ZERO_PX }
            //             ];
            //         case DListPanelPosition.RIGHT:
            //             return [
            //                 { left: pixel(width - pv.width), width: pixel(pv.width), paddingLeft: cs.paddingLeft, paddingRight: cs.paddingRight },
            //                 { left: pixel(width), width: ZERO_PX, paddingLeft: ZERO_PX, paddingRight: ZERO_PX }
            //             ];
            //         case DListPanelPosition.BOTTOM:
            //             return [
            //                 { top: pixel(height - pv.height), height: pixel(pv.height), paddingTop: cs.paddingTop, paddingBottom: cs.paddingBottom },
            //                 { top: pixel(height), height: ZERO_PX, paddingTop: ZERO_PX, paddingBottom: ZERO_PX }
            //             ];
            //         case DListPanelPosition.TOP:
            //         default:
            //             return [
            //                 { height: pixel(pv.height), paddingTop: cs.paddingTop, paddingBottom: cs.paddingBottom },
            //                 { height: ZERO_PX, paddingTop: ZERO_PX, paddingBottom: ZERO_PX }
            //             ];
            //     }
            // }
            function getFrames() {
                switch (pv.model().getPosition()) {
                    case DListPanelPosition.CENTER:
                        return [
                            { opacity: '1' },
                            { opacity: '0' }
                        ];
                    case DListPanelPosition.LEFT:
                        return [
                            { left: ZERO_PX },
                            { left: pixel(-pv.width) }
                        ];
                    case DListPanelPosition.RIGHT:
                        return [
                            { left: pixel(width - pv.width) },
                            { left: pixel(width) }
                        ];
                    case DListPanelPosition.BOTTOM:
                        return [
                            { top: pixel(height - pv.height) },
                            { top: pixel(height) }
                        ];
                    case DListPanelPosition.TOP:
                    default:
                        return [
                            { top: ZERO_PX },
                            { top: pixel(-pv.height) }
                        ];
                }
            }
            this._panelContainer.dom.style.pointerEvents = 'none';
            if (this.canAnimate()) {
                const frames = getFrames();
                const ani = pv.dom.animate(frames, {
                    duration: ListView.PANEL_DURATION,
                    fill: 'backwards' // 중요. 아니면 panel의 padding 스타일이 재적용 되지 않는다.
                });
                pv.setAnimating(true);
                ani.addEventListener('finish', () => {
                    pv.setAnimating(false);
                    finish(this);
                });
            }
            else {
                finish(this);
            }
        }
        $_showPanel(pv, width, height, callback) {
            function finish(self) {
                callback && callback();
            }
            // function getFrames(): Keyframe[] {
            //     // const pad = Dom.getPadding2(pv.dom);
            //     const cs = pv.getComputedStyle();
            //     switch (pv.model().getPosition()) {
            //         case DListPanelPosition.CENTER:
            //             return [
            //             ];
            //         case DListPanelPosition.LEFT:
            //             return [
            //                 // box-sizing: border-box는
            //                 // The content box can't be negative and is floored to 0, making it impossible to use border-box to make the element disappear.
            //                 // 즉, width 설정과 상관없이 최소 border + padding 크기를 갖게 된다.
            //                 { width: ZERO_PX, paddingLeft: ZERO_PX, paddingRight: ZERO_PX},
            //                 { width: pixel(pv.width), paddingLeft: cs.paddingLeft, paddingRight: cs.paddingRight }
            //             ];
            //         case DListPanelPosition.RIGHT:
            //             return [
            //                 { left: pixel(width), width: ZERO_PX, paddingLeft: ZERO_PX, paddingRight: ZERO_PX},
            //                 { left: pixel(width - pv.width), width: pixel(pv.width), paddingLeft: cs.paddingLeft, paddingRight: cs.paddingRight }
            //             ];
            //         case DListPanelPosition.BOTTOM:
            //             return [
            //                 { top: pixel(height), height: ZERO_PX, paddingTop: ZERO_PX, paddingBottom: ZERO_PX},
            //                 { top: pixel(height - pv.height), height: pixel(pv.height), paddingTop: cs.paddingTop, paddingBottom: cs.paddingBottom }
            //             ];
            //         case DListPanelPosition.TOP:
            //         default:
            //             return [
            //                 { height: ZERO_PX, paddingTop: ZERO_PX, paddingBottom: ZERO_PX},
            //                 { height: pixel(pv.height), paddingTop: cs.paddingTop, paddingBottom: cs.paddingBottom }
            //             ];
            //     }
            // }
            function getFrames() {
                switch (pv.model().getPosition()) {
                    case DListPanelPosition.CENTER:
                        return [
                            { opacity: '0' },
                            { opacity: '1' }
                        ];
                    case DListPanelPosition.LEFT:
                        return [
                            { left: pixel(-pv.width) },
                            { left: ZERO_PX }
                        ];
                    case DListPanelPosition.RIGHT:
                        return [
                            { left: pixel(width) },
                            { left: pixel(width - pv.width) }
                        ];
                    case DListPanelPosition.BOTTOM:
                        return [
                            { top: pixel(height) },
                            { top: pixel(height - pv.height) }
                        ];
                    case DListPanelPosition.TOP:
                    default:
                        return [
                            { top: pixel(-pv.height) },
                            { top: ZERO_PX }
                        ];
                }
            }
            this._activePanel = pv.model();
            this._panelContainer.dom.style.pointerEvents = 'auto';
            this._panelContainer.addChild(pv);
            pv.setVisible(true);
            pv.refresh(this, width, height);
            this.$_movePanel(pv);
            if (this.canAnimate()) {
                const frames = getFrames();
                const ani = pv.dom.animate(frames, {
                    duration: ListView.PANEL_DURATION,
                    fill: 'backwards' // 'none'으로 하지 않는다. 
                    // animation 실행 중 image가 load 되어 refresh가 호출되어 
                    // measure 크기가 animation 시작점 크기와 달라질 수 있다.
                });
                pv.setAnimating(true);
                ani.addEventListener('finish', () => {
                    pv.setAnimating(false);
                    finish();
                });
            }
            else {
                finish();
            }
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    ListView.CLASS_NAME = 'dlist-list-view';
    ListView.PANEL_DURATION = 250;
    class LoadingPageView extends DLayoutedElement {
    }
    class EmptyPageView extends DLayoutedElement {
    }
    const LayoutViews = {
        'vlinear': VLinearLayoutView,
        'hlinear': HLinearLayoutView,
        'frame': FrameLayoutView,
        'stack': StackLayoutView,
        'scroll': ScrollLayoutView,
        'form': FormLayoutView,
        'grid': GridLayoutView,
    };
    /**
     * @internal
     *
     * 현재 검색 결과 필드를 꾸민다.
     */
    class SearchFieldView extends DElement {
        //-------------------------------------------------------------------------
        // constrctor
        //-------------------------------------------------------------------------
        constructor(doc) {
            super(doc, false, 'dlist-search-field');
            this.setVisible(false);
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doInitDom(doc, dom) {
            ['tl', 'tr', 'bl', 'br'].forEach(borders => {
                const span = doc.createElement('span');
                const styles = {
                    position: 'absolute',
                    width: '5px',
                    height: '5px',
                    borderStyle: 'solid',
                };
                const b1 = borders.charAt(0);
                const b2 = borders.charAt(1);
                styles[BORDER_SIDES[b1] + 'Width'] = '2px';
                styles[BORDER_SIDES[b2] + 'Width'] = '2px';
                if (b1 === 'b') {
                    styles['bottom'] = '0';
                }
                if (b2 === 'r') {
                    styles['right'] = '0';
                }
                Object.assign(span.style, styles);
                dom.appendChild(span);
            });
        }
    }
    /**
     * @internal
     *
     * 마지막 데어터행 다음에 추가되는 첨부 행 영역 view.
     */
    class AttachedRowView extends DListElement {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(doc, body) {
            super(doc, true, AttachedRowView.CLASS_NAME);
            this._layoutChanged = false;
            this._body = body;
            this.setVisible(false);
        }
        _doDestory() {
            this._body = null;
            super._doDestory();
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        // protected _createBack(doc: Document): HTMLElement {
        //     const back = this._layoutBack = doc.createElement('div');
        //     back.className = AttachedRowView.LAYOUT_CLASS;
        //     back.style.position = 'absolute';
        //     return back;
        // }
        _doInitDom(doc, dom) {
            // dom.style.backgroundColor = 'green';
        }
        _getContentPosition() {
            return 'absolute';
        }
        _doPrepareRender(doc, hint) {
            const owner = hint;
            const model = this._model = owner.current().attachedRow();
            const layout = model.layout();
            const dom = this.content;
            this._vertical = owner.isVertical();
            this.dom.dataset.dir = this._vertical ? 'v' : 'h';
            if (layout) {
                this._layoutChanged = !this._layout || layout.layout.tid !== this._layout.tid;
                this._layout = layout.layout;
                this._rowStyle = layout.rowStyle;
                // this._layoutBack.style.display = 'block';
                if (this._layoutChanged && this._layoutView) {
                    // this._layoutBack.removeChild(this._layoutView.dom);
                    dom.removeChild(this._layoutView.dom);
                    this._layoutView = null;
                }
                if (!this._layoutView) {
                    const manager = this._body.listView();
                    this._layoutView = manager.createLayoutView(doc, this._layout);
                    this._layoutView.build(doc, manager);
                    // this._layoutBack.appendChild(this._layoutView.dom);
                    dom.appendChild(this._layoutView.dom);
                }
                else if (this._layoutView) {
                    // child들의 layout 모델을 갱신한다.
                    this._layoutView.refreshModels(this._layout); // as any는 ListItemView 참조.
                }
            }
            else {
                if (this._layoutView) {
                    // this._layoutBack.removeChild(this._layoutView.dom);
                    dom.removeChild(this._layoutView.dom);
                    this._layoutView = null;
                }
                // this._layoutBack.style.display = 'none';
            }
            if (owner.isDataAppending() && model.indicatorVisible()) {
                if (this._indicator && (this._indiSize !== model.indicatorSize() || this._indiType !== model.indicatorType())) {
                    Dom.hide(this._indicator);
                    Dom.clearChildren(this._indicator);
                }
                if (!this._indicator) {
                    this._indicator = DSvg.create(doc);
                    this._indicator.style.position = 'absolute';
                    this.appendDom(this._indicator);
                }
                const rd = this._indiSize = model.indicatorSize();
                Dom.show(this._indicator);
                Dom.resize(this._indicator, rd, rd);
                DSpinner.render(doc, this._indicator, {
                    type: this._indiType = model.indicatorType(),
                    itemCount: 10,
                    width: rd,
                    height: rd
                });
            }
            else if (this._indicator) {
                Dom.hide(this._indicator);
                this._indiSize = 0;
            }
        }
        _doApplyStyles(css) {
            if (this._rowStyle) {
                // css = this._layoutBack.style;
                css = this.content.style;
                Object.assign(css, this._rowStyle.default);
            }
        }
        _doMeasure(doc, hintWidth, hintHeight) {
            const model = this._model;
            const p = this._padding = Dom.getPadding(this.dom);
            const wSave = hintWidth;
            const hSave = hintHeight;
            const wPad = p.left + p.right;
            const hPad = p.top + p.bottom;
            let szIndi = 0;
            hintWidth -= wPad;
            hintHeight -= hPad;
            if (this._indiSize > 0) {
                szIndi = this._indiSize + model.indicatorMargin() * 2;
            }
            this._space = Math.max(0, pickNum(model.endSpace(), 0));
            if (this._vertical) {
                let h = 0;
                if (this._layoutView) {
                    const manager = this._body.listView();
                    this._layoutView.prepareLayout(doc, manager);
                    this._layoutView._explicitWidth = hintWidth;
                    h += this._layoutView.measureLayout(doc, manager, hintWidth, hintHeight).height + hPad;
                    hintWidth += wPad;
                }
                h += szIndi + this._space;
                return { width: wSave, height: h };
            }
            else {
                let w = 0;
                if (this._layoutView) {
                    const manager = this._body.listView();
                    this._layoutView.prepareLayout(doc, manager);
                    this._layoutView._explicitHeight = hintHeight;
                    w += this._layoutView.measureLayout(doc, manager, hintWidth, hintHeight).width + wPad;
                    hintHeight += hPad;
                }
                w += szIndi + this._space;
                return { width: w, height: hSave };
            }
        }
        _doRender(doc, width, height) {
            const p = this._padding;
            const lv = this._layoutView;
            width -= p.left + p.right;
            height -= p.top + p.bottom;
            this.setContentBounds(p.left, p.top, width, height);
            if (this._vertical) {
                let y = 0;
                if (lv) {
                    //Dom.resize(this._layoutBack, width - p.left - p.right, lv.mh); 
                    // Dom.resize(lv.dom, width, lv.mh); 
                    lv.resizeByMeasure().render(doc);
                    y += lv.height + p.top + p.bottom;
                }
                if (this._indiSize > 0) {
                    this._indicator && Dom.move(this._indicator, (width - this._indiSize) / 2, y + this._model.indicatorMargin());
                }
            }
            else {
                let x = 0;
                if (lv) {
                    // Dom.resize(this._layoutBack, lv.mw, height - p.top - p.bottom); 
                    // Dom.resize(lv.dom, lv.mw, height); 
                    lv.resizeByMeasure().render(doc);
                    x += lv.width + p.left + p.right;
                }
                if (this._indiSize > 0) {
                    this._indicator && Dom.move(this._indicator, x + this._model.indicatorMargin(), (height - this._indiSize) / 2);
                }
            }
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    AttachedRowView.CLASS_NAME = 'dlist-attached-row';
    class FocusLayer extends DElement {
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doInitDom(doc, dom) {
            Object.assign(dom.style, {
                width: '100%',
                height: '100%',
                overflow: 'hidden',
                pointerEvents: 'none'
            });
        }
    }
    /**
     * @internal
     *
     * ListView에서 고정 행들과 header와 footer를 제외한 영역.
     * Item view들을 표시한다.
     * Grouping 상태에 따라 다른 종류의 body view가 표시된다.
     *
     * [no cache mode]
     * 1. item view 개수가 0이고 표시할 item들이 있는 경우에만 전체 item view 빌드.
     * 2. 이 후에는 개별적으로 변경 요청되므로 measure에서 item view들을 재구성하지 않는다.
     */
    class ListBodyView extends DListElement {
        //-------------------------------------------------------------------------
        // constrctor
        //-------------------------------------------------------------------------
        constructor(doc) {
            super(doc, false, ListBodyView.CLASS_NAME);
            this._vertical = true;
            this._rowViewPool = [];
            this._rowViewMap = {};
            this._touchedRow = -1;
            this._commandRow = -1;
            this._noCache = false;
            this._positionsDirty = false;
            this._arVis = false;
            this._scrollPos = 0;
            this._scrollOff = 0;
            this._topRow = 0;
            this._focusedRow = -1;
            this._rowEnded = false;
            this._scrollEnded = false;
            this._deletingRowIds = [];
            this.addChild(this._loadingView = new LoadingPageView(doc));
            this.addChild(this._emptyView = new EmptyPageView(doc));
            this.addChild(this._indentLayer = new DElement(doc, false, 'dlist-indent-layer'));
            this.addChild(this._deletingLayer = new DElement(doc, false, 'dlist-deleting-layer'));
            this.addChild(this._itemLayer = new DElement(doc, false, 'dlist-item-layer'));
            this.addChild(this._itemSubLayer = new DElement(doc, false, 'dlist-items-sub'));
            this._itemSubLayer.addChild(this._attachedView = new AttachedRowView(doc, this));
            this._itemSubLayer.addChild(this._searchFieldView = new SearchFieldView(doc));
            this.addChild(this._maskLayer = new FocusLayer(doc, false, 'dlist-mask-layer'));
            this.addChild(this._feedback = new ListFeedback(doc));
            this.addChild(this._toolLayer = new LayerElement(doc, false, 'dlist-tools'));
            // _itemLayer.y 값을 다른 곳에서 사용한다.
            this._itemLayer.moveY(0);
            this._itemSubLayer.moveY(0);
        }
        _doDestory() {
            this._focusView = this._focusView && this._focusView.destroy();
            this._selectionView = this._selectionView && this._selectionView.destroy();
            this._commandsView = this._commandsView && this._commandsView.destroy();
            super._doDestory();
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        listView() {
            return this._listView;
        }
        owner() {
            return this._owner;
        }
        isVertical() {
            return this._vertical;
        }
        data() {
            return this._listView.data();
        }
        scrollPos() {
            return this._scrollPos;
        }
        scrollOff() {
            return this._scrollOff;
        }
        topRow() {
            return this._topRow;
        }
        commandRow() {
            return this._commandRow;
        }
        animating() {
            return !!this._rowAnimation;
        }
        isRowEnded() {
            return this._rowEnded;
        }
        isScrollEnded() {
            return this._scrollEnded;
        }
        itemLayerOff() {
            return -this._itemLayer[this.POS];
        }
        length() {
            return this[this.SIZE];
        }
        isEmpty() {
            return this.itemViewCount() < 1;
        }
        addFeedback(dom) {
            this._toolLayer.appendDom(dom);
        }
        indexOfRow(row) {
            for (let i = 0, n = this.itemViewCount(); i < n; i++) {
                if (this.getItemView(i).row() === row) {
                    return i;
                }
            }
            return -1;
        }
        getRowView(row) {
            return this._rowViewMap[this._dv.getRowId(row)];
        }
        getRenderer(row, dom) {
            let fv;
            if (this._emptyView.visible) {
                fv = this._emptyView.simpleViewByDom(dom, true);
            }
            else if (this._loadingView.visible) {
                fv = this._loadingView.simpleViewByDom(dom, true);
            }
            else if (row >= 0) {
                const rv = this.getRowView(row);
                fv = rv.simpleViewByDom(dom, true);
            }
            return fv && fv.renderer();
        }
        findSimpleLayoutView(row, tag) {
            var _a;
            return (_a = this.getRowView(row)) === null || _a === void 0 ? void 0 : _a.simpleViewByTag(tag, true);
        }
        findDom(row, id) {
            return this.doc.getElementById(DListRendererImpl.getDomId(row, NaN, id));
        }
        getRow(dom) {
            let p = dom;
            while (p) {
                if (p instanceof HTMLDivElement && ListRowView.isRowView(p)) {
                    const rv = this._rowViewOfDom(p);
                    if (rv) {
                        return rv.row();
                    }
                    break;
                }
                p = p.parentElement;
            }
        }
        setTouchedRow(row) {
            if (row !== this._touchedRow) {
                if (this._touchedRow >= 0) {
                    const rv = this.getRowView(this._touchedRow);
                    rv && rv.setTouched(false);
                }
                this._touchedRow = row;
                if (this._touchedRow >= 0) {
                    const rv = this.getRowView(this._touchedRow);
                    rv && rv.setTouched(true);
                }
            }
        }
        scrollBy(delta) {
            const doc = this.doc;
            const vertical = this._vertical;
            const w = this.width;
            const h = this.height;
            let result;
            //DLog.log('SCROLL BY', delta);
            delta = delta >> 0;
            // 아래/오른쪽으로 스크를, scrollPos 감소.
            if (delta < 0) {
                if (this._scrollPos === 0 && this._scrollOff === 0) {
                    this.$_scrollEnded(false);
                    // console.log('ROW VIEW POOL3: ', this._rowViewPool.length)
                    return 'near';
                }
                if (vertical) {
                    delta = Math.min(h, -delta); // 높이보다 큰 스크롤은 무시한다.
                }
                else {
                    delta = Math.min(w, -delta); // 너비보다 큰 스크롤은 무시한다.
                }
                result = this._doScrollNear(doc, this._scrollPos, this._scrollOff, delta, w, h);
                if (result.pos <= 0 && result.off <= 0) {
                    this.$_scrollEnded(false);
                }
                else {
                    this.$_removeEndEffect();
                }
            }
            // 위/왼쪽으로 스크를, scrollPos 증가.
            else if (delta > 0) {
                if (this.isScrollEnded()) {
                    this.$_scrollEnded(true);
                    // console.log('ROW VIEW POOL3: ', this._rowViewPool.length)
                    return 'far';
                }
                if (vertical) {
                    delta = Math.min(h, delta); // 높이보다 큰 스크롤은 무시한다.
                }
                else {
                    delta = Math.min(w, delta); // 너비보다 큰 스크롤은 무시한다.
                }
                result = this._doScrollFar(doc, this._scrollPos, this._scrollOff, delta, w, h);
                if (this._scrollEnded) {
                    this.$_scrollEnded(true);
                }
                else {
                    this.$_removeEndEffect();
                }
            }
            // console.log('ROW VIEW POOL2: ', this._rowViewPool.length)
            if (result) {
                this._scrollPos = result.pos;
                this._scrollOff = result.off;
                this._topRow = result.row;
                this._searchResult && this.$_renderSearchField(this._searchResult);
                return true;
            }
        }
        /**
         * 현재 표시 중인 데이터행에만 설정할 수 있다.
         */
        setCommands(row, commands, animate) {
            this.control.lock(() => {
                const rv = this.getRowView(row);
                if (rv) {
                    const doc = this.doc;
                    const owner = this._owner;
                    const vertical = owner.isVertical();
                    const r = rv.getOffsetBounds(); // rv.getBounds();
                    const shift = owner.commandBox().mode() === DListCommandBoxMode.SHIFT;
                    let view = this._commandsView;
                    this._commandRow = row;
                    if (!view) {
                        view = this._commandsView = new CommandBoxView(doc, owner.commandBox());
                        this.addChild(this._commandsView);
                    }
                    view.visible = true;
                    view.setCommands(owner.data(), row, commands);
                    view.measure(doc, null, this.width, this.height);
                    if (vertical) {
                        view.resize(view.mw, Math.max(r.height, view.mh));
                    }
                    else {
                        view.resize(Math.max(r.width, view.mw), view.mh);
                    }
                    view.render(doc);
                    if (vertical) {
                        const yView = r.y + (this._itemLayer.y || 0);
                        const xView = r.x + r.width - view.mw + 1;
                        const xRow = r.x - view.mw;
                        view.move(xView, yView);
                        this._commandPos = rv.x;
                        shift && rv.move(xRow, yView);
                        if (animate && this.canAnimate()) {
                            this._commandsView.dom.animate([
                                { left: (r.x + r.width) + 'px' },
                                { left: xView + 'px' }
                            ], {
                                duration: 150,
                                fill: 'none'
                            });
                            if (shift) {
                                rv.dom.animate([
                                    { left: r.x + 'px' },
                                    { left: xRow + 'px' }
                                ], {
                                    duration: 150,
                                    fill: 'none'
                                });
                            }
                        }
                    }
                    else {
                        const xView = r.x + (this._itemLayer.x || 0);
                        const yView = r.y + r.height - view.mh + 1;
                        const yRow = r.y - view.mh;
                        view.move(xView, yView);
                        this._commandPos = rv.y;
                        shift && rv.move(xView, yRow);
                        if (animate && this.canAnimate()) {
                            this._commandsView.dom.animate([
                                { top: (r.y + r.height) + 'px' },
                                { top: yView + 'px' }
                            ], {
                                duration: 150,
                                fill: 'none'
                            });
                            if (shift) {
                                rv.dom.animate([
                                    { top: r.y + 'px' },
                                    { top: yRow + 'px' }
                                ], {
                                    duration: 150,
                                    fill: 'none'
                                });
                            }
                        }
                    }
                }
            });
        }
        clearCommands(animate) {
            if (this._commandRow >= 0) {
                const rv = this.getRowView(this._commandRow);
                this._commandsView.visible = false;
                this._commandRow = -1;
                if (rv) {
                    if (this._owner.isVertical()) {
                        rv.moveX(this._commandPos);
                    }
                    else {
                        rv.moveY(this._commandPos);
                    }
                }
            }
        }
        focusedRowChanged(focus, old) {
            this._focusedRow = focus;
        }
        canMoveTo(row, target) {
            return true;
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doInitDom(doc, dom) {
            dom.style.overflow = 'hidden';
        }
        _doPrepareRender(doc, owner) {
            // testing 중에 owner가 null일 수 있다.
            if (owner) {
                const loading = owner.isDataLoading();
                const vertical = this._vertical = owner.isSingleRow() || owner.isVertical();
                this._preMode = owner.preMode();
                this._noCache = owner.noCache();
                this._owner = owner;
                this._dv = owner.data();
                this.SIZE = vertical ? 'height' : 'width';
                this.MEASURE_SIZE = vertical ? 'mh' : 'mw';
                this.POS = vertical ? 'y' : 'x';
                this._arVis = owner.current().attachedRow().visible();
                this._positionsDirty = owner.isDataChanged();
                this._loadingView.setVisible(loading && !owner.skeletonVisible);
                this._emptyView.setVisible(!loading && owner.shouldShowEmptyPage());
            }
        }
        _measureLayoutView(doc, view, template, stockTemplate, inflater, hintWidth, hintHeight) {
            if (view.visible) {
                const owner = this._owner;
                const t = (template && (owner.getTemplate(template))) || StockTemplates.get(stockTemplate);
                const layout = LayoutFactory.Instance.layoutFromTemplate(owner.wrapperOrThis(), -1, false, false, t, inflater || {
                    inflateParam: function (target, field, param) { },
                    inflateStock: function (target, field, param) { }
                });
                view.setLayout(layout);
                view.measure(doc, this._listView, hintWidth, hintHeight);
                return { width: hintWidth, height: hintHeight };
            }
        }
        _renderLayoutedView(doc, view, width, height) {
            if (view.visible) {
                view.resize(width, height);
                view.render(doc);
                return true;
            }
        }
        _createRowAnimation() {
            let ani;
            if (this._deletingRowIds.length > 0) {
                const ids = this._deletingRowIds.sort((r1, r2) => r1 - r2);
                ani = this._createRowsDeleingAnimation(ids);
                this._deletingRowIds = [];
            }
            else if (this._detailingRow >= 0) {
                if (this._owner.isRowDetailed(this._detailingRow)) {
                    ani = new ShowRowDetailAni(this, this._detailingRow);
                }
                else {
                    ani = new HideRowDetailAni(this, this._detailingRow);
                }
                this._detailingRow = -1;
            }
            return ani;
        }
        _doMeasure(doc, hintWidth, hintHeight) {
            if (this._rowAnimation) {
                this._rowAnimation.stop();
                this._rowAnimation = null;
            }
            const opts = this._owner.current();
            let sz = this._measureLayoutView(doc, this._loadingView, opts.loadingPage().template(), '@it_loading_page', opts.loadingPage(), hintWidth, hintHeight) ||
                this._measureLayoutView(doc, this._emptyView, opts.emptyPage().template(), '@it_empty_page', opts.emptyPage(), hintWidth, hintHeight);
            if (!sz) {
                // NOTE: 예를들어, 삭제된 행의 view들이 제거되기 전에 미리 animation을 준비해야 한다.
                //       animation 시작은 afterRender()에서.
                this._rowAnimation = this._createRowAnimation();
                // this.$_refreshDeletingRows();
                // // delete row 애니메이션 중에 measure가 호출되면 안된다.
                // if (this._deleteingRowAni) {
                //     debugger;
                // }
                this._searchFieldView.setVisible(!!this._searchResult);
                if (this._vertical) {
                    sz = this._doMeasureVert(doc, hintWidth, hintHeight);
                }
                else {
                    sz = this._doMeasureHorz(doc, hintWidth, hintHeight);
                }
            }
            return sz;
        }
        $_renderSelection(doc, width, height) {
            const selection = this._owner.getSelection();
            let view = this._selectionView;
            if (selection) {
                if (!view) {
                    view = this._selectionView = new SelectionView(doc);
                    this.addChild(view);
                }
                view.visible = true;
                this._doRenderSelection(doc, this._vertical, selection, view, width, height);
            }
            else if (view) {
                view.visible = false;
            }
        }
        $_renderSearchField(sr) {
            const v = this._searchFieldView;
            if (sr.isEmpty()) {
                v.setVisible(false);
            }
            else {
                const f = sr.getCurrrentField();
                const rv = this.getRowView(f.row);
                if (rv) {
                    const fv = rv.simpleViewByModel(f.layout, true);
                    if (fv) {
                        const r1 = this.getClientRect();
                        const r2 = fv.getClientRect();
                        v.setVisible(true);
                        v.setBounds(r2.x - r1.x - 4, r2.y - r1.y - 2, fv.width + 8, fv.height + 4);
                    }
                    else {
                        v.setVisible(false);
                    }
                }
                else {
                    v.setVisible(false);
                }
            }
        }
        _doRender(doc, width, height) {
            if (!this._renderLayoutedView(doc, this._loadingView, width, height) &&
                !this._renderLayoutedView(doc, this._emptyView, width, height)) {
                this._feedback.resize(width, height);
                if (this._vertical) {
                    this._doRenderVert(doc, width, height);
                }
                else {
                    this._doRenderHorz(doc, width, height);
                }
                this.$_renderSelection(doc, width, height);
                this._searchResult && this.$_renderSearchField(this._searchResult);
                this.setFocusedRow(this._focusedRow);
            }
            this._toolLayer.setBounds(0, 0, width, height);
        }
        setFocusedRow(row) {
            const rv = row >= 0 ? this.getRowView(row) : void 0;
            if (rv) {
                if (!this._focusView) {
                    this._focusView = new FocusView(this.doc);
                }
                this._maskLayer.addChild(this._focusView);
                const mask = this._listView.focusMask;
                const r = rv.getBounds();
                const x = rv.getNearIndent(mask.nearIndent());
                r.x += x;
                r.width -= x + rv.getFarIndent(mask.farIndent());
                this._focusView.setRect(r);
            }
            else if (this._focusView) {
                this._focusView.remove();
            }
        }
        resetFocusedView() {
            this.setFocusedRow(this._focusedRow);
        }
        _doAfterRender() {
            this._rowAnimation && this._rowAnimation.start();
            DLog.log('ROW VIEW POOL: ', this._rowViewPool.length);
        }
        _moveItemLayer(p) {
            if (this._vertical) {
                this._itemLayer.moveY(p);
                this._itemSubLayer.moveY(p);
                this._deletingLayer.moveY(p);
            }
            else {
                this._itemLayer.moveX(p);
                this._itemSubLayer.moveX(p);
                this._deletingLayer.moveX(p);
            }
        }
        _canShowAttached(owner) {
            return !owner.isPaging() && owner.current().attachedRow().visible();
        }
        _measureAttached(doc, owner, vertical, w, h) {
            const arv = this._attachedView;
            if (this._canShowAttached(owner)) {
                arv.setVisible(true);
                if (arv.measure(doc, owner, w, h).height > 0) {
                    return arv;
                }
            }
            arv.setVisible(false);
        }
        _getRowIndent(v) {
            return 0;
        }
        _getBodyIndent(v) {
            return 0;
        }
        _getBodyMargin(v) {
            return 0;
        }
        _prepareRowView(v, row, owner) {
            var _a;
            const layout = owner.getRowLayout(row);
            v.setData('state', void 0);
            v.setLayout(layout);
            v.indent = this._getRowIndent(v);
            v.bodyIndent = this._getBodyIndent(v);
            v.bodyMargin = this._getBodyMargin(v);
            v.alternate = (row % 2) === 1;
            v.rowState = owner.data().internalRowState(row);
            v.detailed = owner.isRowDetailed(row);
            v.checked = owner.isRowChecked(row);
            v.selected = (_a = owner.getSelection()) === null || _a === void 0 ? void 0 : _a.isRowSelected(row);
            v.searched = owner.isRowSearched(row);
            // v.focused = this._focusedRow >= 0 && this._focusedRow === row;
        }
        _getRowView(doc, row, model, before) {
            const owner = this._owner;
            const map = this._rowViewMap;
            const id = this._dv.getRowId(row);
            let v = map[id];
            if (v) {
                delete map[id];
            }
            else {
                const pool = this._rowViewPool;
                const cnt = pool.length;
                if (cnt > 0) {
                    for (let i = pool.length - 1; i > 0; i--) {
                        if (pool[i]._rowid === id) {
                            v = pool.splice(i, 1)[0];
                            break;
                        }
                    }
                    if (!v) {
                        //v = pool.shift(); // 왜 이렇게 했지?
                        v = pool.pop();
                        v.$_borrowed();
                    }
                }
                if (!v) {
                    v = this._createItemView(doc);
                }
                if (before) {
                    this._itemLayer.insertBefore(v, before);
                }
                else {
                    this._itemLayer.addChild(v);
                }
            }
            v.setRow(this._dv, row, id, model);
            this._prepareRowView(v, row, owner);
            return v;
        }
        _returnRowView(view) {
            this._itemLayer.removeChild(view);
            delete this._rowViewMap[view._rowid];
            this._rowViewPool.push(view);
        }
        _returnRowViews(views, from) {
            for (let i = views.length - 1; i >= from; i--) {
                this._returnRowView(views[i]);
            }
        }
        /**
         * Item view map에 남아 있는 view들을 pool로 이동시키고, view map을 다시 구성한다.
         */
        _resetRowViews(views) {
            let map = this._rowViewMap;
            for (const id in map) {
                const v = map[id];
                this._returnRowView(v);
            }
            map = this._rowViewMap = {};
            for (const v of views) {
                if (v instanceof ListRowView) {
                    map[v._rowid] = v;
                }
            }
        }
        _addRowView(doc, row, model, before, vertical, width, height) {
            const v = this._getRowView(doc, row, model, before);
            // v.mx = v.my = NaN;
            const sz = v.measure(doc, this._listView, width - v.bodyIndent - v.bodyMargin, height);
            if (vertical) {
                v.resize(width - v.bodyIndent - v.bodyMargin, sz.height);
            }
            else {
                v.resize(sz.width, height - v.bodyIndent - v.bodyMargin);
            }
            v.render(doc);
            this._rowViewMap[v._rowid] = v;
            return v;
        }
        _createItemView(doc) {
            return new ListRowView(doc);
        }
        _setScrollPos(pos, off, row) {
            this._scrollPos = pos;
            this._scrollOff = off;
            this._topRow = row;
        }
        $_addDeletingRows(ids) {
            if (this.canAnimate()) {
                if (Array.isArray(ids)) {
                    this._deletingRowIds = this._deletingRowIds.concat(ids);
                }
                else {
                    this._deletingRowIds.push(ids);
                }
            }
        }
        $_setDetailingRow(row) {
            this._detailingRow = row;
        }
        $_scrollEnded(end) {
            this.$_showOverEffect(end ?
                (this._vertical ? Direction.UP : Direction.RIGHT) :
                (this._vertical ? Direction.DOWN : Direction.LEFT));
        }
        $_showOverEffect(dir) {
            switch (this._owner.current().overScrollEffect()) {
                default:
                    this._feedback.showEndBalloon(createRect(0, 0, this.width, this.height), dir);
                    break;
            }
        }
        $_removeEndEffect() {
            switch (this._owner.current().overScrollEffect()) {
                default:
                    this._feedback.removeEndBalloon();
                    break;
            }
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    ListBodyView.CLASS_NAME = 'dlist-body';
    ListBodyView.DELETE_DURATION = 300;
    ListBodyView.DETAIL_DURATION = 300;
    /**
     * @internal
     *
     * 삭제될 행들을 삭제 후 아래에서 올라오거나 위에서 내려올 행들 내의 적절한 위치에 배치한다.
     * 현재 화면 밖에 있는 것들은 제외한다.
     * 리스트의 bodyView가 measure 직전에 이 객체를 생성하고, render 완료 후 시작시킨다.
     * 생성 시점에 삭제될 행들의 view를 미리 준비해야 한다.
     */
    class RowsDeletingAni extends ListRowAnimation {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(bodyView, rowIds) {
            super(bodyView);
            const vertical = bodyView.isVertical();
            const ids = rowIds.sort((r1, r2) => r1 - r2);
            this.SIZE = vertical ? 'height' : 'width';
            this.POS = vertical ? 'y' : 'x';
            this.MOVE = vertical ? 'moveY' : 'moveX';
            this._allViews = bodyView.itemViews();
            this.$_collectDeleted(ids);
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doStart() {
            this._doPrepare();
            this._rowAni = DAnimation.create((step) => {
                this._doRun(step);
            }, (step, canceled) => {
                // this._bodyView.control.invalidateLayout();
            }, ListBodyView.DELETE_DURATION);
            return true;
        }
        _doStop() {
            this.$_clear();
        }
        _doPrepare() {
            const body = this._bodyView;
            const POS = this.POS;
            const SIZE = this.SIZE;
            // 삭제된 행들의 view. bodyView에 포함되지 않은 것들이다.
            const drvs = this._deletedViews;
            const views = this._views = this._getItemViews();
            const allViews = views.slice(0);
            const off = views.length > 0 ? views[0][POS] : 0;
            let p = off;
            let h = 0;
            drvs.forEach(v => v.rv.newPos = v.rv[POS]);
            views.forEach(v => v.newPos = v[POS]);
            drvs.forEach(drv => {
                const r = drv.rv.vindex();
                const i = allViews.findIndex(v => v.vindex() === r);
                if (i >= 0) {
                    allViews.splice(i, 0, drv.rv);
                }
                else if (r > allViews[allViews.length - 1].vindex()) {
                    allViews.push(drv.rv);
                }
            });
            allViews.forEach(v => {
                v.oldPos = p;
                p += v[SIZE];
                h += v[SIZE];
            });
            if (body.isScrollEnded() && h > body[SIZE]) {
                p = h - body[SIZE] + off;
                views.forEach(v => {
                    v.oldPos -= p;
                });
            }
        }
        _preparePre() {
            const POS = this.POS;
            const allViews = this._allViews;
            // 삭제된 행들의 view. bodyView에 포함되지 않은 것들이다.
            const drvs = this._deletedViews;
            const views = this._views = this._getItemViews();
            let p = 0;
            allViews.forEach(v => {
                v.oldPos = p;
                p += v.height;
            });
            drvs.forEach(v => {
                v.rv.newPos = v[POS];
            });
            views.forEach(v => {
                v.newPos = v[POS];
            });
        }
        _doRun(step) {
            const MOVE = this.MOVE;
            this._views.forEach(v => {
                v[MOVE](v.oldPos + (v.newPos - v.oldPos) * step);
            });
        }
        // 삭제될 행들 중 기존에 표시 중이었던 행들의 view를 저장한다.
        $_collectDeleted(ids) {
            const vertical = this._bodyView.isVertical();
            const map = this._bodyView._rowViewMap;
            const layer = this._bodyView._deletingLayer;
            const views = this._deletedViews = [];
            const len = vertical ? this._bodyView.width : this._bodyView.height;
            for (const id of ids) {
                const rv = map[id];
                if (rv) {
                    const frames = {};
                    frames[vertical ? 'left' : 'top'] = [ZERO_PX, pixel(-len)];
                    frames[vertical ? 'height' : 'width'] = [pixel(vertical ? rv.height : rv.width), ZERO_PX];
                    const ani = rv.dom.animate(frames, {
                        duration: ListBodyView.DELETE_DURATION,
                        fill: 'none'
                    });
                    const drv = { rv, ani };
                    ani.addEventListener('finish', () => {
                        // 여기서 제거하지 않으면 이 이벤트와 다음 measure 사이에 rv가 애니메이션 이전 원래 위치에 잠시 표시될 수 있다.
                        layer.removeChild(rv);
                    });
                    ani.addEventListener('cancel', () => {
                        layer.removeChild(rv);
                    });
                    // rv.dom.style.background = 'red';
                    views.push(drv);
                    drv.rv.aniTag = vertical ? drv.rv.height : drv.rv.width;
                    layer.addChild(drv.rv);
                    delete map[id];
                }
            }
            views.sort((v1, v2) => v1.rv.row() - v2.rv.row());
        }
        $_clear() {
            const pool = this._bodyView._rowViewPool;
            const layer = this._bodyView._deletingLayer;
            const views = this._deletedViews;
            if (views) {
                for (let i = views.length - 1; i >= 0; i--) {
                    const v = views[i];
                    v.ani = Dom.stopAnimation(v.ani);
                    // if (!v.ani || v.ani.playState === 'finished') {
                    layer.removeChild(v.rv);
                    pool.push(v.rv);
                    views.splice(i, 1);
                    // }
                }
            }
            this._rowAni = DObject.destroy(this._rowAni);
        }
    }
    class RowDetailAni extends ListRowAnimation {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(bodyView, row) {
            super(bodyView);
            this._rowView = bodyView.getRowView(row);
            // 새로 measure하기 전에 기존 높이를 보관한다.
            this._oldHeight = this._rowView.height;
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doStart() {
            const dy = this._rowView.bottom() - this._bodyView.height;
            this._ani = this._createAnimation();
            this._moveOthers(this.$_collectOtherViews(), this._rowView.height - this._oldHeight);
            if (dy > 0) {
                this._bodyView['_owner'].scrollBy(dy);
            }
            return true;
        }
        _doStop() {
            this._ani = Dom.stopAnimation(this._ani);
            this._rowView = null;
        }
        $_collectOtherViews() {
            const vertical = this._bodyView.isVertical();
            const views = [];
            const row = this._rowView.row();
            const body = this._bodyView;
            const cnt = body.itemViewCount();
            const p = body.indexOfRow(row);
            if (p >= 0 && p + 1 < cnt) {
                for (let i = p + 1; i < cnt; i++) {
                    const v = body.getItemView(i);
                    views.push(v);
                    v.aniTag = vertical ? v.y : v.x;
                }
            }
            return views;
        }
    }
    class ShowRowDetailAni extends RowDetailAni {
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _createAnimation() {
            const h = this._rowView.height;
            const ani = this._rowView.dom.animate([
                { height: this._oldHeight + 'px' },
                { height: h + 'px' }
            ], {
                duration: ListBodyView.DETAIL_DURATION,
                fill: 'none'
            });
            return ani;
        }
        _moveOthers(views, delta) {
            this._moveAni = DAnimation.create((step) => {
                views.forEach(v => this._doStep(v, delta, step));
            }, (step, canceled) => {
                this._bodyView.control.invalidateLayout();
            }, ListBodyView.DETAIL_DURATION);
        }
        _doStep(view, delta, step) {
            view.moveY(view.aniTag - delta + delta * step);
        }
        _doStop() {
            this._moveAni = DObject.destroy(this._moveAni);
            super._doStop();
        }
    }
    class HideRowDetailAni extends ShowRowDetailAni {
    }

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     *
     * Data 행들만 표시하는 ListView.
     */
    class DefaultListView extends ListView {
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        canMoveSingle(dx, endEffect) {
            return this._bodyView.canMoveSingle(dx, endEffect);
        }
        _createBodyView(doc, noCache, spare) {
            if (noCache) {
                return spare ? new DefaultSpareBodyView(doc) : new DefaultPreBodyView(doc);
            }
            else {
                return spare ? new DefaultSpareBodyView(doc) : new DefaultListBodyView(doc);
            }
        }
        _doMeasure(doc, hintWidth, hintHeight) {
            const headerView = this.headerView();
            const footerView = this.footerView();
            const owner = this._owner;
            const dv = owner.data();
            const info = this.renderInfo();
            this.reqScrollPos = (info && dv) ? Math.max(0, Math.min(owner.getRowCount() - 1, info.scrollPos)) : 0; // control에서 요청한 scroll pos.
            this.reqScrollOff = info ? info.scrollOff : 0;
            if (owner.isSingleRow() && dv) {
                // header나 footer의 param에서 topRow를 참조할 수 있도록...
                headerView && (headerView.model().setTopRow(this.reqScrollPos));
                footerView && (footerView.model().setTopRow(this.reqScrollPos));
            }
            else {
                headerView && (headerView.model().setTopRow(NaN));
                footerView && (footerView.model().setTopRow(NaN));
            }
            this._bodyView._expander = owner.groupExpander();
            return super._doMeasure(doc, hintWidth, hintHeight);
        }
    }
    class RowsDeletingAniImpl$1 extends RowsDeletingAni {
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        _getItemViews() {
            return this._bodyView._internalRowViews();
        }
    }
    /**
     * @internal
     *
     * Data 행들만 표시하는 body view.
     *
     * [pre mode]
     * 1. itemLayer를 이동시켜서 스크롤한다.
     */
    class DefaultListBodyView extends ListBodyView {
        constructor() {
            super(...arguments);
            //-------------------------------------------------------------------------
            // fields
            //-------------------------------------------------------------------------
            this._rowViews = [];
            this._rowPts = [0];
            this._singleMode = false;
            this.singleMoving = false;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        _internalRowPoints() {
            return this._rowPts;
        }
        singleView() {
            return this._singleView;
        }
        spareSingleView() {
            if (!this._spareSingleView) {
                this._spareSingleView = this.$_createSingleView(this.doc, true);
            }
            return this._spareSingleView;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        canMoveSingle(dx, endEffect) {
            if (this._singleMode) {
                const owner = this.owner();
                const row = this._singleView.row();
                const rowCount = owner.getRowCount();
                if (dx > 0) {
                    if (row > 0) {
                        return true;
                    }
                    else if (endEffect) {
                        this.$_showOverEffect(Direction.LEFT);
                    }
                }
                else if (dx < 0) {
                    if (row < rowCount - 1) {
                        return true;
                    }
                    else if (endEffect) {
                        this.$_showOverEffect(Direction.RIGHT);
                    }
                }
            }
        }
        rowViewAt(index) {
            return this._rowViews[index];
        }
        _internalRowViews() {
            return this._rowViews;
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        // footerView(): ListFooterView {
        //     return this._fv;
        // }
        bottomRow() {
            return this._topRow + this._rowPts.length - 1;
        }
        isEmpty() {
            return !this._singleMode && this._rowPts.length < 2;
        }
        itemViewCount() {
            return this._rowPts.length - 1;
        }
        _itemPoints() {
            return this._rowPts;
        }
        rowViewCount() {
            return this._rowPts.length - 1;
        }
        lastItemView() {
            return this._rowViews[this._rowViews.length - 1];
        }
        getItemViewPoints() {
            return this._rowPts.slice(0);
        }
        itemViews() {
            return this._rowViews.slice(0);
        }
        getItemView(index) {
            return this._rowViews[index];
        }
        itemViewAt(x, y) {
            const p = this._vertical ? y : x;
            const pts = this._rowPts;
            for (let i = 0, n = pts.length - 1; i < n; i++) {
                if (p >= pts[i] && p < pts[i + 1]) {
                    return this._rowViews[i];
                }
            }
        }
        getRowView(row) {
            if (this._singleMode) {
                return row === this._singleView.row() ? this._singleView.rowView() : null;
            }
            else {
                return super.getRowView(row);
            }
        }
        getPreLength() {
            return this._rowPts[this._rowPts.length - 1] + (this._attachedView.visible ? this._attachedView[this.SIZE] : 0);
        }
        getPrePos(pos, off) {
            return this._rowPts[pos] + off;
        }
        getExpander(row) {
            return this._expander;
        }
        _rowViewOfDom(dom) {
            if (this._singleMode) {
                return this._singleView.rowView().isDom(dom) ? this._singleView.rowView() : null;
            }
            else {
                for (const v of this._rowViews) {
                    if (v.isDom(dom)) {
                        return v;
                    }
                }
            }
        }
        validateViews() {
            const owner = this._listView.owner();
            const h = this.height;
            const views = this._rowViews;
            const map = this._rowViewMap;
            const pts = this._rowPts;
            const len = pts.length;
            if (pts.length !== views.length + 1) {
                throw `Invalid length: ${pts.length}, ${views.length}`;
            }
            if (views.length === 0)
                return;
            if (views[0].row() !== owner.getRowAt(this.scrollPos())) {
                throw `Invalid top index: ${this.scrollPos()}, ${views[0].row()}`;
            }
            // views와 map이 일치하는 지 확인한다.
            views.forEach(v => {
                if (!map[v._rowid]) {
                    throw `Invalid map: ${v.row()} is not in view map.`;
                }
            });
            for (let row in map) {
                if (!views.find(v => v._rowid === +row)) {
                    throw `Invalid map: ${row} is not in view array.`;
                }
            }
            // check points
            if (-pts[0] !== this.scrollOff()) {
                throw `Invalid start: ${pts[0]}, ${this.scrollOff()}`;
            }
            for (let i = 1; i < len; i++) {
                if (pts[i] < 0 || pts[i] <= pts[i - 1]) {
                    throw `Invalid pos: ${i}, ${pts[i]}`;
                }
            }
            for (let i = 1; i < len - 1; i++) {
                if (pts[i] > h) {
                    throw `Invalid end pos: ${i}, ${pts[i]}`;
                }
            }
            if (pts[len - 1] < h) {
                if (pts[0] !== 0) {
                    throw `Invalid first pos: ${pts[0]}`;
                }
            }
            // check heights
            pts[0];
            for (let i = 0; i < len - 1; i++) {
                const h = pts[i + 1] - pts[i];
                if (h !== views[i].height) {
                    throw `Invalid height: ${i}, ${h}, ${views[i].height}`;
                }
            }
        }
        $_createSingleView(doc, spare) {
            return new SingleView(doc, this, this._owner.current().singleRow(), spare);
        }
        _doPrepareRender(doc, owner) {
            super._doPrepareRender(doc, owner);
            this._indentLayer.setVisible(false);
            this._singleMode = owner && owner.isSingleRow();
            if (owner) {
                if (this._singleMode) {
                    if (!this._singleView) {
                        this.insertBefore(this._singleView = this.$_createSingleView(doc, false), this._feedback);
                        this._singleView['_doPrepareRender'](doc, owner);
                    }
                    this._singleView.setVisible(true);
                }
                else if (this._singleView) {
                    this._singleView.setVisible(false);
                    this._spareSingleView && this._spareSingleView.setVisible(false);
                }
            }
        }
        $_clearRowViews() {
            this._itemLayer.clear();
            this._returnRowViews(this._rowViews, 0);
            this._rowViews = [];
            this._rowViewMap = {};
        }
        _measureSingle(doc, hintWidth, hintHeight) {
            const listView = this._listView;
            const scrollPos = listView.reqScrollPos;
            const scrollOff = listView.reqScrollOff;
            this.$_clearRowViews();
            this._setScrollPos(scrollPos, scrollOff, scrollPos);
            const sz = this._singleView['_doMeasureVert'](doc, hintWidth, hintHeight);
            this._singleView.mh = sz.height;
            return sz;
        }
        _doMeasureVert(doc, hintWidth, hintHeight) {
            if (this._singleMode) {
                return this._measureSingle(doc, hintWidth, hintHeight);
            }
            const listView = this._listView;
            const owner = listView.owner();
            const rowCount = owner.getRowCount();
            const views = this._rowViews = [];
            let scrollPos = listView.reqScrollPos;
            let scrollOff = listView.reqScrollOff;
            let i = scrollPos;
            let h = hintHeight + scrollOff;
            let w = 0;
            let arv;
            while (h > 0 && i < rowCount) {
                const row = owner.getRowAt(i);
                const v = this._getRowView(doc, row, null, null);
                const sz = v.measure(doc, listView, hintWidth, hintHeight);
                views.push(v);
                h -= sz.height;
                w = Math.max(w, sz.width);
                i++;
            }
            // 마지막 행이 표시되고 attachedRow.visible이 true라면
            if (i === rowCount && h > 0) {
                if (arv = this._measureAttached(doc, owner, true, hintWidth, h)) {
                    h -= arv.mh;
                }
            }
            // 아래가 남아 있으면 아래로 내린다.
            if (h > 0) {
                if (scrollOff > 0) {
                    if (h > scrollOff) {
                        h -= scrollOff;
                        scrollOff = 0;
                    }
                    else {
                        scrollOff -= h;
                        h = 0;
                    }
                }
                while (scrollPos > 0 && h > 0) {
                    const v = this._getRowView(doc, owner.getRowAt(scrollPos - 1), null, null);
                    const sz = v.measure(doc, listView, hintWidth, hintHeight);
                    views.unshift(v);
                    if (h >= sz.height) {
                        h -= sz.height;
                    }
                    else {
                        scrollOff = sz.height - h;
                        h = 0;
                    }
                    w = Math.max(w, sz.width);
                    scrollPos--;
                }
            }
            if (views.length > 0) {
                this._setScrollPos(scrollPos, scrollOff, views[0].row());
                !owner.isPaging() && assert(views[0].row() === this.scrollPos(), 'row === scrollPos');
            }
            else {
                // TODO: 다소 불필요하다. 위 로직으로 해결되야 하지 않나? 아니면 미리 체크하던지...
                this._setScrollPos(0, 0, -1);
            }
            return { width: w, height: hintHeight - h };
        }
        _doMeasureHorz(doc, hintWidth, hintHeight) {
            if (this._singleMode) {
                return this._measureSingle(doc, hintWidth, hintHeight);
            }
            const listView = this._listView;
            const owner = listView.owner();
            let scrollPos = listView.reqScrollPos;
            let scrollOff = listView.reqScrollOff;
            const rowCount = owner.getRowCount();
            // const footer = owner.current().footer();
            const views = this._rowViews = [];
            let i = scrollPos;
            let w = hintWidth + scrollOff;
            let h = 0;
            while (w > 0 && i < rowCount) {
                const row = owner.getRowAt(i);
                const v = this._getRowView(doc, row, null, null);
                const sz = v.measure(doc, listView, hintWidth, hintHeight);
                views.push(v);
                w -= sz.width;
                h = Math.max(h, sz.height);
                i++;
            }
            // TODO: 마지막 행 다음에 spinner 표시.
            if (owner.isDataAppending()) ;
            // 오른쪽이 남아 있으면 오른쪽으로 민다.
            if (w > 0) {
                if (scrollOff > 0) {
                    if (w > scrollOff) {
                        w -= scrollOff;
                        scrollOff = 0;
                    }
                    else {
                        scrollOff -= w;
                        w = 0;
                    }
                }
                while (scrollPos > 0 && w > 0) {
                    const v = this._getRowView(doc, owner.getRowAt(scrollPos - 1), null, null);
                    const sz = v.measure(doc, listView, hintWidth, hintHeight);
                    views.unshift(v);
                    if (w >= sz.width) {
                        w -= sz.width;
                    }
                    else {
                        scrollOff = sz.width - w;
                        w = 0;
                    }
                    h = Math.max(h, sz.height);
                    scrollPos--;
                }
            }
            if (views.length > 0) {
                this._setScrollPos(scrollPos, scrollOff, views[0].row());
                !owner.isPaging() && views.length > 0 && assert(views[0].row() === this.scrollPos(), 'row === scrollPos');
            }
            else {
                this._setScrollPos(0, 0, -1);
            }
            return { width: hintWidth - w, height: h };
        }
        _doRenderVert(doc, width, height) {
            if (this._singleMode) {
                const h = Math.max(height, this._singleView.mh);
                this._singleView.resize(width, h);
                this._singleView.move(0, -this._scrollOff);
                this._singleView['_doRenderVert'](doc, width, h);
            }
            else {
                this._renderVert(doc, this.scrollOff(), width, height);
                this._resetRowViews(this._rowViews);
            }
        }
        _doRenderHorz(doc, width, height) {
            if (this._singleMode) {
                const w = Math.max(width, this._singleView.mw);
                this._singleView.resize(w, height);
                this._singleView.move(-this._scrollOff, 0);
                this._singleView['_doRenderHorz'](doc, w, height);
            }
            else {
                this._renderHorz(doc, this.scrollOff(), width, height);
                this._resetRowViews(this._rowViews);
            }
        }
        _doAfterRender() {
            if (this._singleMode) {
                this._singleView['_doAfterRender']();
            }
            else {
                super._doAfterRender();
            }
        }
        _doRenderSelection(doc, vertical, sel, view, w, h) {
            let r1 = sel.min;
            let r2 = sel.max;
            const top = this.topRow();
            const count = this.rowViewCount();
            if (view.visible = r1 < top + count && r2 >= top) {
                r1 = Math.max(top, r1) - top;
                r2 = Math.min(top + count, r2) - top;
                const y = this._rowPts[r1];
                const h = this._rowPts[r2 + 1] - y;
                view.measure(doc, sel, w, h);
                view.move(0, y).resize(w, h);
                view.render(doc);
            }
        }
        // 화면을 아래(오른쪽)로 드래그한다. scrollPos가 작아진다.
        _doScrollNear(doc, oldPos, oldOff, delta, width, height) {
            const owner = this._listView.owner();
            const vertical = this._vertical;
            const views = this._rowViews;
            let pos = oldPos;
            let off = oldOff;
            let v;
            // 위에 걸친 부분 - off 만큼 위로 넘어가 있다.
            if (off > 0) {
                if (delta > off) {
                    delta -= off;
                    off = 0;
                }
                else {
                    off -= delta;
                    delta = 0;
                }
            }
            while (delta > 0 && pos > 0) {
                const before = views.length > 0 ? views[0] : null;
                v = this._addRowView(doc, owner.getRowAt(--pos), null, before, vertical, width, height);
                views.unshift(v);
                delta -= vertical ? v.height : v.width;
                if (delta <= 0) {
                    off = -delta;
                }
            }
            if (vertical) {
                this._renderVert(doc, off, width, height, false, false);
            }
            else {
                this._renderHorz(doc, off, width, height, false, false);
            }
            // this._resetRowViews(this._rowViews); TODO: 이 건 아니더라도 아래 사라진 view는 return 시켜야...
            while (views.length > 1) {
                const v = views[views.length - 1];
                if (v.y >= height) {
                    debugger;
                    this._returnRowView(v);
                    views.pop();
                    this._rowPts.pop();
                }
                else {
                    break;
                }
            }
            if (views.length > 0) {
                return { pos, off, row: views[0].row() };
            }
            else {
                return { pos: 0, off: 0, row: -1 };
            }
        }
        $_scrollSingle(delta) {
            const h = this._singleView.height - this.height;
            let off = this._scrollOff;
            delta = delta >> 0;
            off = Math.min(h, Math.max(0, off + delta));
            this._singleView.moveY(-off);
            this._scrollOff = off;
            if (off <= 0 && delta < 0) {
                this.$_scrollEnded(false);
                return "near";
            }
            else if (off >= h && delta > 0) {
                this.$_scrollEnded(true);
                return "far";
            }
            return delta !== 0;
        }
        scrollBy(delta) {
            if (this._singleMode) {
                return this.$_scrollSingle(delta);
            }
            else {
                return super.scrollBy(delta);
            }
        }
        // 화면을 위(왼쪽)로 드래그한다. scrollPos가 커진다.
        _doScrollFar(doc, oldPos, oldOff, delta, width, height) {
            function resetPts(start) {
                pts[0] = start;
                views.forEach((v, i) => pts[i + 1] = pts[i] + v[self.SIZE]);
                pts[pts.length - 1] + szArv;
            }
            function removeTop() {
                const v = views[0];
                self._returnRowView(v);
                views.splice(0, 1);
                pts.pop();
                resetPts(0);
            }
            function addArv() {
                if (ar && !arv.visible) {
                    arv.setVisible(true);
                    szArv = arv.measure(doc, owner, width, height)[self.SIZE];
                    // measure해야만 render할 수 있다(afterRender에서 layoutView들의 renderer가 null로 설정되므로).
                    needRenderArv = true;
                    return true;
                }
            }
            // 아래쪽에 공간이 있고 마지막 행이 표시된 상태가 아니면 끝에 행들을 추가.
            function fillEnd() {
                let p2 = pts[pts.length - 1] + szArv;
                while (p2 < len) {
                    let diff = len - p2;
                    const row = views.length > 0 ? views[views.length - 1].row() : endRow;
                    if (row === endRow) {
                        // attached row가 추가된 상태가 아니면 먼저 추가한다.
                        if (addArv()) {
                            p2 += szArv;
                            diff -= szArv;
                            if (diff <= 0) {
                                break;
                            }
                        }
                        if (off >= diff) {
                            off -= diff;
                            resetPts(-off);
                            break;
                        }
                        diff -= off;
                        off = 0;
                        // 아래가 남으면 끌어 내린다.
                        while (diff > 0 && pos > 0) {
                            pos--;
                            const v = self._addRowView(doc, pos, null, null, vertical, width, height);
                            const h = v[self.SIZE];
                            views.unshift(v);
                            p2 += h;
                            if (h > diff) {
                                off = h - diff;
                                diff = 0;
                            }
                            else {
                                diff -= h;
                                off = 0;
                            }
                        }
                        resetPts(-off);
                    }
                    else if (row < endRow) {
                        const v = self._addRowView(doc, row + 1, null, null, vertical, width, height);
                        const h = v[self.SIZE];
                        views.push(v);
                        pts.push(pts[pts.length - 1] + h);
                        p2 += h;
                    }
                    else if (addArv()) {
                        p2 += szArv;
                    }
                    else {
                        break;
                    }
                }
            }
            const self = this;
            const listView = this._listView;
            const owner = listView.owner();
            const endRow = owner.getEndRow();
            const vertical = this._vertical;
            const views = this._rowViews;
            const ar = this._arVis;
            const arv = this._attachedView;
            let szArv = arv.visible ? (vertical ? arv.height : arv.width) : 0;
            const pts = this._rowPts;
            const len = vertical ? height : width;
            pts[pts.length - 1] + szArv;
            let pos = oldPos;
            let off = oldOff;
            const d = pts[1] - pts[0];
            let needRenderArv = false;
            assert(off === -pts[0], '-off가 pts[0]과 동일해야 한다.');
            // 최상위 행을 끌어 올린다.
            if (off > 0) {
                if (delta >= d - off) {
                    delta -= d - off;
                    off = 0;
                    pos++;
                    removeTop();
                }
                else {
                    off += delta;
                    delta = 0;
                    resetPts(-off);
                }
            }
            while (delta > 0) {
                const i = pos - oldPos;
                const d = pts[i + 1] - pts[i];
                delta -= d;
                if (delta < 0) {
                    off = d + delta;
                    resetPts(-off);
                }
                else if (views.length > 0 && views[views.length - 1].row() < endRow) {
                    pos++;
                    removeTop();
                }
                else {
                    resetPts(-off);
                    delta = 0;
                }
            }
            fillEnd();
            assert(off === -pts[0], 'off가 pts[0]과 동일해야 한다 2.');
            if (vertical) {
                this._renderVert(doc, off, width, height, false, needRenderArv);
            }
            else {
                this._renderHorz(doc, off, width, height, false, needRenderArv);
            }
            // this._resetRowViews(this._rowViews);
            return { pos, off, row: views.length > 0 ? views[0].row() : -1 };
        }
        _createRowsDeleingAnimation(rowIds) {
            return new RowsDeletingAniImpl$1(this, rowIds);
        }
        isRowVisible(row, full) {
            // TODO: full 구현할 것!
            return row >= this._scrollPos && row < this._scrollPos + this._rowViews.length;
        }
        makeRowVisible(row) {
            if (this._singleMode) {
                return;
            }
            let pos = this._scrollPos;
            let off = this._scrollOff;
            if (row === pos) {
                if (off > 0) {
                    return { pos: row, off: 0 };
                }
            }
            else if (row < pos) {
                return { pos: row, off: 0 };
            }
            else if (row === pos + this._rowViews.length - 1) { // 마지막 표시 행
                const h = this.height;
                const pts = this._rowPts;
                const len = row - pos + 1;
                let d = pts[len] - h;
                if (d > 0) {
                    let i = 0;
                    while (i < len && d > 0) {
                        const h2 = pts[i + 1] - pts[i];
                        if (h2 > d) {
                            off += d;
                            break;
                        }
                        else if (h2 >= d) {
                            pos++;
                            off = 0;
                            d -= h2;
                        }
                        i++;
                    }
                }
                return { pos: pos, off: pos === row ? 0 : off };
            }
            else if (row >= pos + this._rowViews.length) {
                if (this._vertical) {
                    return this.$_pullUpVert(row);
                }
                else {
                    return this.$_pullUpHorz(row);
                }
            }
        }
        // 아래쪽에 숨겨진 행을 최소한 위로 끌어 올린다.
        $_pullUpVert(row) {
            let h = this.height;
            const doc = this.doc;
            const listView = this._listView;
            const owner = listView.owner();
            const dv = owner.data();
            const width = this.width;
            const height = this.height;
            const v = new ListRowView(doc);
            let r = row;
            this._itemLayer.addChild(v);
            while (r >= 0) {
                v.setRow(dv, r, dv.getRowId(r), null);
                this._prepareRowView(v, r, owner);
                const sz = v.measure(doc, listView, height, width);
                h -= sz.height;
                if (h <= 0) {
                    r = Math.min(row, r + 1);
                    break;
                }
                r--;
            }
            this._itemLayer.removeChild(v);
            return { pos: r, off: 0 };
        }
        // 오른쪽에 숨겨진 행을 최소한 위로 끌어 올린다.
        $_pullUpHorz(row) {
            let w = this.width;
            const doc = this.doc;
            const listView = this._listView;
            const owner = listView.owner();
            const dv = owner.data();
            const width = this.width;
            const height = this.height;
            const v = new ListRowView(doc);
            let r = row;
            this._itemLayer.addChild(v);
            while (r >= 0) {
                v.setRow(dv, r, dv.getRowId(r), null);
                this._prepareRowView(v, r, owner);
                const sz = v.measure(doc, listView, height, width);
                w -= sz.width;
                if (w <= 0) {
                    r = Math.min(row, r + 1);
                    break;
                }
                r--;
            }
            this._itemLayer.removeChild(v);
            return { pos: r, off: 0 };
        }
        // row 행이 마지막에 표시되도록 scroll. 0보다 작으면 attached row.
        scrollToEnd(row) {
            // TODO: 이미 scroll된 상태면 리턴.
            // TODO: 끝 행이 가까운 위치에 있으면 scrollBy() 호출.
            const listView = this._listView;
            const owner = listView.owner();
            const doc = this.doc;
            const vertical = this._vertical;
            const views = this._rowViews = [];
            const width = this.width;
            const height = this.height;
            let t = vertical ? height : width;
            let off = 0;
            const arv = row < 0 && this._measureAttached(doc, owner, vertical, width, height);
            if (arv) {
                t -= vertical ? arv.mh : arv.mw;
            }
            row = row < 0 ? owner.getEndRow() : row;
            while (row >= 0) {
                const v = this._getRowView(doc, row, null, null);
                const sz = v.measure(doc, listView, width, height);
                views.unshift(v);
                t -= sz[this.SIZE];
                if (t <= 0) {
                    off = -t;
                    break;
                }
                row--;
            }
            this._setScrollPos(row, off, row);
            if (vertical) {
                this._renderVert(doc, off, width, height, true, !!arv);
            }
            else {
                this._renderHorz(doc, off, width, height, true, !!arv);
            }
            this._resetRowViews(this._rowViews);
        }
        /**
         * For Testing Only.
         * 행 순서대로 row view들이 배치되었는 지 검사한다.
         */
        checkItemViewOrders() {
            const elts = Array.from(this._itemLayer.dom.children);
            if (elts.length > 1) {
                for (let i = 1; i < elts.length; i++) {
                    // assert(elts[i][T_ROW] === elts[i - 1][T_ROW] + 1, `${elts[i][T_ROW]} === ${elts[i - 1][T_ROW] + 1}`);
                }
            }
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        /**
         * [접근성] row순서와 rowView의 순서가 일치하도록 정렬
         */
        $_checkPositions() {
            if (this._positionsDirty) {
                const views = this._rowViews;
                // 1. 순서가 틀어졌는 지 검사.
                views[0].row();
                this._positionsDirty = false;
            }
        }
        _renderVert(doc, scrollOff, width, height, render = true, renderArv = true) {
            const ar = this._arVis;
            const arv = this._attachedView;
            const views = this._rowViews;
            const cmdRow = this._commandRow;
            const cnt = views.length;
            const pts = this._rowPts = [-scrollOff];
            const x = 0;
            let y = pts[0];
            let i = 0;
            // [접근성] row순서와 rowView의 순서가 일치하도록 정렬
            this.$_checkPositions();
            // 배치
            while (i < cnt && y < height) {
                const v = views[i++];
                const h = v.mh;
                if (v.isRow(cmdRow)) {
                    v.moveY(y);
                }
                else {
                    v.move(x, y);
                }
                render && v.resize(v.mw, h).render(doc);
                y += h;
                pts.push(y);
            }
            this._returnRowViews(views, i);
            views.length = i;
            if (arv.visible) {
                if (y >= height) {
                    arv.setVisible(false);
                }
                else {
                    arv.move(x, y);
                    renderArv && arv.resize(width, arv.mh).render(doc);
                    y += arv.mh;
                }
            }
            else if (ar) {
                if (y < height) {
                    debugger;
                }
                else {
                    // 아래 scrollended가 false가 되도록.
                    y++;
                }
            }
            // 마지막 행이 표시된 상태인 지 확인.
            this._rowEnded = views.length === 0 || views[views.length - 1].row() === this.owner().getRowCount() - 1;
            // 끝까지 표시된 상태인 지 확인.
            this._scrollEnded = this._rowEnded && y <= height;
        }
        _renderHorz(doc, scrollOff, width, height, render = true, renderArv = true) {
            const ar = this._arVis;
            const arv = this._attachedView;
            const views = this._rowViews;
            const cmdRow = this._commandRow;
            const cnt = views.length;
            const pts = this._rowPts = [-scrollOff];
            const y = 0;
            let x = pts[0];
            let i = 0;
            // [접근성] row순서와 rowView의 순서가 일치하도록 정렬
            this.$_checkPositions();
            while (i < cnt && x < width) {
                const v = views[i++];
                const w = v.mw;
                if (v.isRow(cmdRow)) {
                    v.moveX(x);
                }
                else {
                    v.move(x, y);
                }
                render && v.resize(w, height).render(doc);
                x += w;
                pts.push(x);
            }
            this._returnRowViews(views, i);
            views.length = i;
            if (arv.visible) {
                if (x >= width) {
                    arv.setVisible(false);
                }
                else {
                    arv.move(x, y);
                    renderArv && arv.resize(arv.mw, height).render(doc);
                    x += arv.mw;
                }
            }
            else if (ar) {
                if (x < width) {
                    debugger;
                }
                else {
                    // 아래 scrollended가 false가 되도록.
                    x++;
                }
            }
            // 마지막 행이 표시된 상태인 지 확인.
            this._rowEnded = views.length === 0 || views[views.length - 1].row() === this.owner().getRowCount() - 1;
            // 끝까지 표시된 상태인 지 확인.
            this._scrollEnded = this._rowEnded && x <= width;
        }
    }
    class DefaultSpareBodyView extends DefaultListBodyView {
        constructor() {
            super(...arguments);
            //-------------------------------------------------------------------------
            // fields
            //-------------------------------------------------------------------------
            this._page = -1;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        get page() {
            return this._page;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        setPage(value, view, force) {
            if (force || value !== this._page) {
                const doc = this.doc;
                this._page = value;
                if (value >= 0) {
                    this.measure(doc, view.owner(), view.width, view.height);
                    this.move(view.x, view.y).resize(view.width, view.height);
                    this.render(doc);
                }
            }
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        scrollPos() {
            return 0;
        }
        scrollOff() {
            return 0;
        }
        _doMeasureVert(doc, hintWidth, hintHeight) {
            const listView = this._listView;
            const owner = listView.owner();
            const page = this._page;
            const rows = owner.getPageRows(page);
            const rowCount = rows.length;
            const views = this._rowViews = [];
            let i = 0;
            let h = hintHeight;
            let w = 0;
            while (h > 0 && i < rowCount) {
                const row = rows[i];
                const v = this._getRowView(doc, row, null, null);
                const sz = v.measure(doc, listView, hintWidth, hintHeight);
                views.push(v);
                h -= sz.height;
                w = Math.max(w, sz.width);
                i++;
            }
            return { width: w, height: hintHeight - h };
        }
    }
    class SingleRowView extends ListRowView {
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        isFixedHeight() {
            return true;
        }
    }
    /**
     * @internal
     *
     * 데이터행 하나만 채워서 표시한다.
     * 설정에 showPrev이면 상단에 'template.brief'으로 설정된 layout으로 이전 행을 표시한다. 'template.brief' layout이 없으면 표시하지 않는다.
     * 설정에 showNext이면 상단에 'template.brief'으로 설정된 layout으로 다음 행을 표시한다. 'template.brief' layout이 없으면 표시하지 않는다.
     *
     * [접근성] 표시되지 않는 '이전', '이후' 버튼을 추가한다.
     */
    class SingleView extends DListElement {
        //-------------------------------------------------------------------------
        // constrctor
        //-------------------------------------------------------------------------
        constructor(doc, bodyView, model, spare) {
            super(doc, false, SingleView.CLASS_NAME);
            this._requestRow = -1;
            this._row = -1;
            this._dimmed = 0;
            this._model = model;
            this._bodyView = bodyView;
            this._spare = spare;
            // spare && (this.dom.style.background = 'yellow');
            this.addChild(this._rowView = new SingleRowView(doc));
            this._prevView = new ListRowView(doc);
            this._nextView = new ListRowView(doc);
            this.appendDom(this._mask = doc.createElement('div'));
            Object.assign(this._mask.style, {
                width: '100%',
                height: '100%',
                background: '#333',
                opacity: '0',
                pointerEvents: 'none'
            });
        }
        _doDestory() {
            super._doDestory();
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        isSpare() {
            return this._spare;
        }
        row() {
            return this._row;
        }
        setRow(value, view) {
            if (value !== this._row) {
                if (value >= 0) {
                    const doc = this.doc;
                    view = view || this;
                    this._requestRow = value;
                    this.measure(doc, view._bodyView.owner(), view.width, view.height);
                    this.move(view.x, view.y).resize(view.width, view.height);
                    this.render(doc);
                }
            }
        }
        rowView() {
            return this._rowView;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        getRow(dom) {
            const rv = this._rowView;
            if (rv && rv.containsDom(dom)) {
                return { dv: rv._dv, row: rv.row() };
            }
        }
        isRowEnded() {
            return !this._rowView || this._rowView.row() === this._bodyView.owner().getRowCount() - 1;
        }
        scrollBy(delta) {
            if (delta > 0) {
                return 'near';
            }
            else if (delta < 0) {
                return 'far';
            }
        }
        setDimmed(rate) {
            if (this._model.maskEffect() && rate !== this._dimmed) {
                this._dimmed = rate;
                this.dom.style.opacity = rate > 0 ? Math.max(0.3, 1 - rate) + '' : '';
                this._mask.style.opacity = rate > 0 ? rate + '' : '0';
            }
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doPrepareRender(doc, owner) {
            // row view
            const row = this._row = this._requestRow >= 0 ? this._requestRow : this._bodyView.listView().reqScrollPos;
            const dv = owner.data();
            const layout = owner.getRowLayout(row);
            const v = this._rowView;
            v.setRow(dv, row, dv.getRowId(row), null);
            if (layout.layout instanceof DListLayout) {
                layout.layout.setNoShrink(owner.current().singleRow().noShrink());
            }
            v.setLayout(layout);
            // v.indent = 0;
            // v.alternate = (row % 2) === 1;
            // v.detailed = owner.isRowDetailed(row);
            // v.checked = owner.isRowChecked(row);
            // v.selected = owner.getSelection()?.isRowSelected(dv, row);
            // v.expanderPosition = owner.getRowExpanderPosition();
            this._requestRow = -1;
        }
        _doMeasure(doc, hintWidth, hintHeight) {
            // defaultBodyView에서는 _doMeasureVert, _doMeasureHorz 를 직접 호출한다.
            if (this._bodyView.owner().isVertical()) {
                return this._doMeasureVert(doc, hintWidth, hintHeight);
            }
            else {
                return this._doMeasureHorz(doc, hintWidth, hintHeight);
            }
        }
        _doRender(doc, width, height) {
            // defaultBodyView에서는 _doRenderHorz, _doRenderVert를 직접 호출한다.
            if (this._bodyView.owner().isVertical()) {
                return this._doRenderVert(doc, width, height);
            }
            else {
                return this._doRenderHorz(doc, width, height);
            }
        }
        _doAfterRender() {
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        _doMeasureVert(doc, hintWidth, hintHeight) {
            return this._rowView.measure(doc, this._bodyView.listView(), hintWidth, hintHeight);
        }
        _doMeasureHorz(doc, hintWidth, hintHeight) {
            return this._doMeasureVert(doc, hintWidth, hintHeight);
        }
        _doRenderVert(doc, width, height) {
            this._rowView.resize(width, height);
            this._rowView.render(doc);
        }
        _doRenderHorz(doc, width, height) {
            this._doRenderVert(doc, width, height);
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    SingleView.CLASS_NAME = 'dlist-single-body';
    class RowsDeletingAniPre$1 extends RowsDeletingAniImpl$1 {
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doPrepare() {
            const body = this._bodyView;
            this._preparePre();
            // // points of itemLayer
            this._pLayer = body.itemLayerOff();
            this._oldLayer = body._prevPos; // 삭제 전 위치
        }
        _doRun(step) {
            super._doRun(step);
            const body = this._bodyView;
            // itemLayer
            body._moveItemLayer(-(this._oldLayer + (this._pLayer - this._oldLayer) * step));
        }
    }
    /**
     * @internal
     *
     * default body view for no-cache mode.
     * rowView들의 y를 0부터 유지하고, _moveItemLayer로 스크롤시킨다.
     * attachedRow와 appending spinner를 미리 생성한다.
     * [점근성]을 위해 구현되는 모드이므로 항상 모든 행을 생성하고 순서대로 표시한다.
     */
    class DefaultPreBodyView extends DefaultListBodyView {
        constructor() {
            super(...arguments);
            //-------------------------------------------------------------------------
            // fields
            //-------------------------------------------------------------------------
            this._prevPos = 0; // itemLayer 이전 위치.
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doMeasureVert(doc, hintWidth, hintHeight) {
            if (this._singleMode) {
                return this._measureSingle(doc, hintWidth, hintHeight);
            }
            const listView = this._listView;
            const owner = listView.owner();
            const rowCount = owner.getRowCount();
            const views = this._rowViews = [];
            const pts = this._rowPts = [0];
            let scrollPos = listView.reqScrollPos;
            let scrollOff = listView.reqScrollOff;
            let i = 0;
            let h = 0;
            let w = 0;
            let arv;
            while (i < rowCount) {
                const row = owner.getRowAt(i);
                const v = this._getRowView(doc, row, null, null);
                const sz = v.measure(doc, listView, hintWidth, hintHeight);
                views.push(v);
                h += sz.height;
                pts.push(h);
                w = Math.max(w, sz.width);
                i++;
            }
            if (arv = this._measureAttached(doc, owner, true, hintWidth, h)) {
                h += arv.mh;
            }
            if (views.length > 0) {
                // fullMode가 아니고, 아래가 남아 있으면 아래로 내린다.
                if (this._preMode) {
                    const si = this.$_scrollTo(this.$_scrollOff(scrollPos, scrollOff), hintHeight);
                    this._setScrollPos(si.pos, si.off, views[si.pos].row());
                }
            }
            else {
                this.$_scrollTo(0, hintHeight);
                this._setScrollPos(0, 0, -1);
            }
            return { width: w, height: h };
        }
        _doMeasureHorz(doc, hintWidth, hintHeight) {
            if (this._singleMode) {
                return this._measureSingle(doc, hintWidth, hintHeight);
            }
            const listView = this._listView;
            const owner = listView.owner();
            const rowCount = owner.getRowCount();
            const views = this._rowViews = [];
            const pts = this._rowPts = [0];
            let scrollPos = listView.reqScrollPos;
            let scrollOff = listView.reqScrollOff;
            let i = 0;
            let w = 0;
            let h = 0;
            let arv;
            while (i < rowCount) {
                const row = owner.getRowAt(i);
                const v = this._getRowView(doc, row, null, null);
                const sz = v.measure(doc, listView, hintWidth, hintHeight);
                views.push(v);
                w += sz.width;
                pts.push(w);
                h = Math.max(h, sz.height);
                i++;
            }
            if (arv = this._measureAttached(doc, owner, false, hintWidth, hintHeight)) {
                w += arv.mw;
            }
            if (views.length > 0) {
                // fullMode가 아니고, 아래가 남아 있으면 아래로 내린다.
                if (this._preMode) {
                    const si = this.$_scrollTo(this.$_scrollOff(scrollPos, scrollOff), hintWidth);
                    this._setScrollPos(si.pos, si.off, views[si.pos].row());
                }
            }
            else {
                this.$_scrollTo(0, hintWidth);
                this._setScrollPos(0, 0, -1);
            }
            return { width: w, height: h };
        }
        // 화면을 아래(오른쪽)로 드래그한다. scrollPos가 작아진다.
        _doScrollNear(doc, oldPos, oldOff, delta, width, height) {
            const si = this.$_scrollBy(-delta);
            return { pos: si.pos, off: si.off, row: si.row };
        }
        // 화면을 위(왼쪽)로 드래그한다. scrollPos가 커진다.
        _doScrollFar(doc, oldPos, oldOff, delta, width, height) {
            const si = this.$_scrollBy(delta);
            return { pos: si.pos, off: si.off, row: si.row };
        }
        scrollToEnd(row) {
            if (row < 0) {
                const listView = this._listView;
                const owner = listView.owner();
                const doc = this.doc;
                const vertical = this._vertical;
                const width = this.width;
                const height = this.height;
                const arv = this._measureAttached(doc, owner, vertical, width, height);
                arv.resize(vertical ? width : arv.mw, vertical ? arv.mh : height);
                arv.render(doc);
            }
            this.$_scrollTo(Number.MAX_SAFE_INTEGER, this[this.SIZE]);
        }
        _renderVert(doc, scrollOff, width, height, render = true, renderArv = true) {
            const arv = this._attachedView;
            const views = this._rowViews;
            const cmdRow = this._commandRow;
            const cnt = views.length;
            const x = 0;
            let y = 0;
            let i = 0;
            // 배치
            while (i < cnt) {
                const v = views[i++];
                if (v.isRow(cmdRow)) {
                    v.moveY(y);
                }
                else {
                    v.move(x, y);
                }
                render && v.resizeByMeasure().render(doc);
                y += v.mh;
            }
            if (arv.visible) {
                arv.move(x, y);
                renderArv && arv.resize(width, arv.mh).render(doc);
                y += arv.mh;
            }
            this.$_checkEnded();
        }
        _renderHorz(doc, scrollOff, width, height, render = true, renderArv = true) {
            const arv = this._attachedView;
            const views = this._rowViews;
            const cmdRow = this._commandRow;
            const cnt = views.length;
            const y = 0;
            let x = 0;
            let i = 0;
            width = Number.MAX_SAFE_INTEGER;
            // [접근성] row순서와 rowView의 순서가 일치하도록 정렬
            // this.$_checkPositions();
            while (i < cnt && x < width) {
                const v = views[i++];
                if (v.isRow(cmdRow)) {
                    v.moveX(x);
                }
                else {
                    v.move(x, y);
                }
                render && v.resizeByMeasure().render(doc);
                x += v.mw;
            }
            if (arv.visible) {
                arv.move(x, y);
                renderArv && arv.resize(arv.mw, height).render(doc);
                x += arv.mw;
            }
            this.$_checkEnded();
        }
        _createRowsDeleingAnimation(rowIds) {
            return new RowsDeletingAniPre$1(this, rowIds);
        }
        _moveItemLayer(p) {
            this._prevPos = this.itemLayerOff();
            super._moveItemLayer(p);
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        $_scrollOff(pos, off) {
            const views = this._rowViews;
            const msz = this.MEASURE_SIZE;
            let p = 0;
            for (let i = 0; i < pos; i++) {
                p += views[i][msz];
            }
            p += off;
            return p;
        }
        $_scrollBy(delta) {
            return this.$_scrollTo(-this._itemLayer[this.POS] + delta, this[this.SIZE]);
        }
        $_scrollTo(p, sz) {
            const views = this._rowViews;
            const msz = this.MEASURE_SIZE;
            const cnt = views.length;
            if (cnt > 0) {
                const szArv = this._arVis ? this._attachedView[this.MEASURE_SIZE] : 0;
                const pts = this._rowPts;
                const pLast = pts[cnt] + szArv;
                sz = pickNum(sz, this[this.SIZE]);
                p = Math.max(0, Math.min(p, pLast - sz));
                let pos = cnt - 1;
                let off = 0;
                let y = p;
                let h = 0;
                let i = 0;
                while (i < cnt) {
                    const h2 = views[i][msz];
                    if (h2 > y) {
                        pos = i;
                        off = y;
                        h += off;
                        break;
                    }
                    y -= h2;
                    h += h2;
                    i++;
                }
                y = pLast - pts[pos] - off;
                if (y < sz) {
                    y = sz - y;
                    if (off >= y) {
                        off -= y;
                        h -= y;
                    }
                    else {
                        while (pos > 0 && y > 0) {
                            const h2 = views[--pos][msz];
                            if (y > h2) {
                                y -= h2;
                                h -= h2;
                                off = 0;
                            }
                            else {
                                off = y;
                                h -= y;
                                y = 0;
                            }
                        }
                    }
                }
                this._moveItemLayer(-h);
                this.$_checkEnded();
                return { pos, off, row: views[pos].row() };
            }
            else {
                this._moveItemLayer(0);
                this.$_checkEnded();
                return { pos: 0, off: 0, row: -1 };
            }
        }
        $_checkEnded() {
            const pts = this._rowPts;
            const cnt = pts.length - 1;
            if (cnt > 0) {
                const sz = this[this.SIZE];
                const szArv = this._arVis ? this._attachedView[this.MEASURE_SIZE] : 0;
                const pLast = pts[cnt] + szArv;
                const p = -this._itemLayer[this.POS];
                this._rowEnded = pts[cnt - 1] - p <= sz;
                this._scrollEnded = pLast - p <= sz;
            }
            else {
                this._rowEnded = this._scrollEnded = true;
            }
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     *
     * Group 행들과 Data 행들을 모두 표시하는 ListView.
     */
    class GroupedListView extends ListView {
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        clickItem(item) {
            this._bodyView.$_clickItem(item);
        }
        makeItemVisible(item) {
            return this._bodyView.makeItemVisible(item.index);
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _createBodyView(doc, noCache, spare) {
            return noCache ? new GroupedPreBodyView(doc) : new GroupedListBodyView(doc);
        }
        _doPrepareRender(doc, hint) {
            super._doPrepareRender(doc, hint);
            this._bodyView._expander = this._owner.dataExpander();
        }
        rowBorderVisible(rv) {
            if (super.rowBorderVisible(rv)) {
                if (rv._groupLast && this._owner.rowBorder.skipGroupLast)
                    return false;
                return true;
            }
        }
    }
    class RowsDeletingAniImpl extends RowsDeletingAni {
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _getItemViews() {
            return this._bodyView._internalItemViews();
        }
    }
    class GroupRowView extends ListRowView {
    }
    /**
     * @internal
     *
     * Body view for {@link GroupedListView}.
     */
    class GroupedListBodyView extends ListBodyView {
        constructor() {
            super(...arguments);
            //-------------------------------------------------------------------------
            // fields
            //-------------------------------------------------------------------------
            this._headerPool = [];
            this._headerPoolMap = {};
            this._headerMap = {};
            this._footerPool = [];
            this._footerPoolMap = {};
            this._footerMap = {};
            this._itemViews = [];
            this._itemPts = [0];
            this._rowCount = 0;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        _internalItemViews() {
            return this._itemViews;
        }
        _internalItemPoints() {
            return this._itemPts;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        getGroupItem(dom) {
            const headers = this._headerMap;
            for (const i in headers) {
                if (headers[i].isView(dom)) {
                    return headers[i].model();
                }
            }
            const footers = this._footerMap;
            for (const i in footers) {
                if (footers[i].isView(dom)) {
                    return footers[i].model();
                }
            }
        }
        $_clickItem(item) {
            if (item instanceof GroupHeader) {
                this.$_clickHeader(item);
            }
        }
        $_clickHeader(header) {
            if (header) {
                const action = this.owner().current().rowGroup().header().clickAction();
                switch (action) {
                    case DListGroupClickAction.EXPAND:
                        this.owner().groupModel().toggle(header.group, false);
                        break;
                    case DListGroupClickAction.COMMAND:
                        break;
                }
                return true;
            }
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        // footerView(): ListFooterView {
        //     return this._fv;
        // }
        bottomRow() {
            return this._topRow + this._rowCount - 1;
        }
        itemViewCount() {
            return this._itemPts.length - 1;
        }
        _itemPoints() {
            return this._itemPts;
        }
        rowViewCount() {
            return this._rowCount;
        }
        getItemViewPoints() {
            return this._itemPts.slice(0);
        }
        itemViews() {
            return this._itemViews.slice(0);
        }
        getItemView(index) {
            return this._itemViews[index];
        }
        itemViewAt(x, y) {
            const pts = this._itemPts;
            for (let i = 0, n = pts.length - 1; i < n; i++) {
                if (y >= pts[i] && y < pts[i + 1]) {
                    return this._itemViews[i];
                }
            }
        }
        lastItemView() {
            return this._itemViews[this._itemViews.length - 1];
        }
        getPreLength() {
            return this._itemPts[this._itemPts.length - 1];
        }
        getPrePos(pos, off) {
            return this._itemPts[pos] + off;
        }
        getExpander(index) {
            return this._expander;
        }
        _rowViewOfDom(dom) {
            for (const v of this._itemViews) {
                if (v instanceof ListRowView && v.isDom(dom)) {
                    return v;
                }
            }
        }
        validateViews() {
            this.height;
            const views = this._itemViews;
            this._rowViewMap;
            this._headerMap;
            this._footerMap;
            const pts = this._itemPts;
            pts.length;
            if (pts.length !== views.length + 1) {
                throw `Invalid length: ${pts.length}, ${views.length}`;
            }
        }
        $_itemCount(group) {
            return this._pageItems ? this._pageItems.length : group.visItemCount();
        }
        $_getItem(group, index) {
            return this._pageItems ? this._pageItems[index] : group.getVisItem(index);
        }
        _createItemView(doc) {
            return new GroupRowView(doc);
        }
        _getGroupOptions(owner) {
            return owner.current().rowGroup();
        }
        _getRowIndent(v) {
            return this._theme.getItemIndent(v._model);
        }
        _getBodyIndent(v) {
            return this._theme.getBodyIndent(v._model);
        }
        _getBodyMargin(v) {
            return this._theme.getBodyMargin(v._model);
        }
        _doPrepareRender(doc, owner) {
            super._doPrepareRender(doc, owner);
            this._options = this._getGroupOptions(owner);
            this._theme = this._options.getTheme().prepareRender();
            this._indented = this._theme.bodyIndented();
            this._indentLayer.setVisible(this._indented);
            this._indentLayer.setData('theme', this._theme.type());
            this._pageItems = owner.isPaging() ? owner.pageModel().getGroupItems() : null;
        }
        _doMeasure(doc, hintWidth, hintHeight) {
            // this._itemViews.forEach(iv => this.$_returnItemView(iv));
            this._itemViews = [];
            const listView = this._listView;
            const info = listView.renderInfo();
            const owner = listView.owner();
            const gm = owner.groupModel();
            const itemCount = this.$_itemCount(gm);
            listView.reqScrollPos = info ? Math.max(0, Math.min(itemCount - 1, info.scrollPos)) : 0; // control에서 요청한 scroll pos.
            listView.reqScrollOff = info ? info.scrollOff : 0;
            return super._doMeasure(doc, hintWidth, hintHeight);
        }
        _doMeasureVert(doc, hintWidth, hintHeight) {
            const listView = this._listView;
            const owner = listView.owner();
            owner.current().rowGroup();
            const gm = owner.groupModel();
            const itemCount = this.$_itemCount(gm);
            const views = this._itemViews;
            let scrollPos = listView.reqScrollPos;
            let scrollOff = listView.reqScrollOff;
            let i = scrollPos;
            let h = hintHeight + scrollOff;
            let w = 0;
            let arv;
            while (h > 0 && i < itemCount) {
                const item = this.$_getItem(gm, i);
                let v = this.$_getItemView(doc, item, null);
                const sz = v.measure(doc, listView, hintWidth - v.bodyIndent - v.bodyMargin, hintHeight);
                views.push(v);
                h -= sz.height;
                w = Math.max(w, sz.width);
                i++;
            }
            // 마지막 행이 표시되고 attachedRow.visible이 true라면
            if (i === itemCount && h > 0) {
                if (arv = this._measureAttached(doc, owner, true, hintWidth, h)) {
                    h -= arv.mh;
                }
            }
            // 아래가 남아 있으면 위로 올린다.
            if (h > 0) {
                if (scrollOff > 0) {
                    if (h > scrollOff) {
                        h -= scrollOff;
                        scrollOff = 0;
                    }
                    else {
                        scrollOff -= h;
                        h = 0;
                    }
                }
                while (scrollPos > 0 && h > 0) {
                    const item = this.$_getItem(gm, scrollPos - 1);
                    const v = this.$_getItemView(doc, item, null);
                    const sz = v.measure(doc, listView, hintWidth - v.bodyIndent - v.bodyMargin, hintHeight);
                    views.unshift(v);
                    if (h >= sz.height) {
                        h -= sz.height;
                    }
                    else {
                        scrollOff = sz.height - h;
                        h = 0;
                    }
                    w = Math.max(w, sz.width);
                    scrollPos--;
                }
            }
            if (views.length > 0) {
                this._setScrollPos(scrollPos, scrollOff, this.$_getTopRow());
            }
            else {
                // TODO: 다소 불필요하다. 위 로직으로 해결되야 하지 않나? 아니면 미리 체크하던지...
                this._setScrollPos(0, 0, -1);
            }
            return { width: w, height: hintHeight - h };
        }
        // TODO: 현재 수평 모드일 때 그룹핑할 수 없다.
        _doMeasureHorz(doc, hintWidth, hintHeight) {
            const listView = this._listView;
            const owner = listView.owner();
            owner.groupModel();
            this._itemViews;
            let w = hintWidth;
            let h = 0;
            return { width: w, height: hintHeight - h };
        }
        _doRender(doc, width, height) {
            if (this._indentLayer.visible) {
                this._indentLayer.setBounds(0, 0, width, height);
            }
            super._doRender(doc, width, height);
        }
        _doRenderVert(doc, width, height) {
            this._renderVert(doc, this.scrollOff(), width, height);
            this._resetRowViews(this._itemViews);
            this.$_resetGroupViews(this._itemViews);
        }
        _doRenderHorz(doc, width, height) {
            // TODO: 현재 수평 모드일 때 그룹핑할 수 없다.
        }
        _doRenderSelection(doc, vertical, sel, view, w, h) {
            let r1 = sel.min;
            let r2 = sel.max;
            const top = this.scrollPos();
            const count = this.itemViewCount();
            if (view.visible = r1 < top + count && r2 >= top) {
                r1 = Math.max(top, r1) - top;
                r2 = Math.min(top + count, r2) - top;
                const y = this._itemPts[r1];
                const h = this._itemPts[r2 + 1] - y;
                view.measure(doc, sel, w, h);
                view.move(0, y).resize(w, h);
                view.render(doc);
            }
        }
        // 화면을 아래(오른쪽)로 드래그한다. scrollPos가 작아진다.
        _doScrollNear(doc, oldPos, oldOff, delta, width, height) {
            const listView = this._listView;
            const owner = listView.owner();
            const vertical = owner.isVertical();
            const group = owner.groupModel();
            const views = this._itemViews;
            let pos = oldPos;
            let off = oldOff;
            let item;
            let v;
            // 위에 걸친 부분 - off 만큼 위로 넘어가 있다.
            if (off > 0) {
                if (delta > off) {
                    delta -= off;
                    off = 0;
                }
                else {
                    off -= delta;
                    delta = 0;
                }
            }
            while (delta > 0 && pos > 0) {
                const before = views.length > 0 ? views[0] : null;
                item = this.$_getItem(group, --pos);
                v = this.$_addItemView(doc, vertical, item, before, width, height);
                views.unshift(v);
                delta -= v.height;
                if (delta <= 0) {
                    off = -delta;
                }
            }
            this._renderVert(doc, off, width, height, false, false);
            if (views.length > 0) {
                return { pos, off, row: this.$_getTopRow() };
            }
            else {
                return { pos: 0, off: 0, row: -1 };
            }
        }
        // 화면을 위(왼쪽)로 드래그한다. scrollPos가 커진다.
        _doScrollFar(doc, oldPos, oldOff, delta, width, height) {
            function resetPts(start) {
                pts[0] = start;
                views.forEach((v, i) => pts[i + 1] = pts[i] + v.height);
                pts[pts.length - 1] + hArv;
            }
            function removeTop() {
                const v = views[0];
                self.$_returnItemView(v);
                views.splice(0, 1);
                pts.pop();
                resetPts(0);
            }
            function addArv() {
                if (ar && !arv.visible) {
                    arv.setVisible(true);
                    hArv = arv.measure(doc, owner, width, height).height;
                    // measure해야만 render할 수 있다(afterRender에서 layoutView들의 renderer가 null로 설정되므로).
                    needRenderArv = true;
                    return true;
                }
            }
            function fillEnd() {
                let p2 = pts[pts.length - 1] + hArv;
                while (p2 < len) {
                    const i = views[views.length - 1].model().vindex + 1 - pageOff;
                    let diff = len - p2;
                    if (i === endIdx) {
                        // attached row가 추가된 상태가 아니면 먼저 추가한다.
                        if (addArv()) {
                            p2 += hArv;
                            diff -= hArv;
                            if (diff <= 0) {
                                break;
                            }
                        }
                        if (off >= diff) {
                            off -= diff;
                            resetPts(-off);
                            break;
                        }
                        diff -= off;
                        off = 0;
                        // 아래가 남으면 끌어 내린다.
                        while (diff > 0 && pos > 0) {
                            pos--;
                            const v = self.$_addItemView(doc, vertical, self.$_getItem(gm, pos), null, width, height);
                            const h = vertical ? v.height : v.width;
                            views.unshift(v);
                            p2 += h;
                            if (h > diff) {
                                off = h - diff;
                                diff = 0;
                            }
                            else {
                                diff -= h;
                                off = 0;
                            }
                        }
                        resetPts(-off);
                    }
                    else if (i < endIdx) {
                        const v = self.$_addItemView(doc, vertical, self.$_getItem(gm, i), null, width, height);
                        const h = vertical ? v.height : v.width;
                        views.push(v);
                        pts.push(pts[pts.length - 1] + h);
                        p2 += h;
                    }
                    else if (addArv()) {
                        p2 += hArv;
                    }
                    else {
                        break;
                    }
                }
            }
            const self = this;
            const listView = this._listView;
            const owner = listView.owner();
            const gm = owner.groupModel();
            const paging = owner.isPaging();
            const pageOff = paging ? self._pageItems[0].vindex : 0;
            const endIdx = this.$_itemCount(gm);
            const vertical = owner.isVertical();
            const views = this._itemViews;
            const ar = this._arVis;
            const arv = this._attachedView;
            let hArv = arv.visible ? arv.height : 0;
            const pts = this._itemPts;
            const len = vertical ? height : width;
            pts[pts.length - 1] + hArv;
            let pos = oldPos;
            let off = oldOff;
            const d = pts[1] - pts[0];
            let needRenderArv = false;
            assert(off === -pts[0], '-off가 pts[0]과 동일해야 한다.');
            // 최상위 행을 끌어 올린다.
            if (off > 0) {
                if (delta >= d - off) {
                    delta -= d - off;
                    off = 0;
                    pos++;
                    removeTop();
                }
                else {
                    off += delta;
                    delta = 0;
                    resetPts(-off);
                }
            }
            while (delta > 0) {
                const i = pos - oldPos;
                const d = pts[i + 1] - pts[i];
                delta -= d;
                if (delta < 0) {
                    off = d + delta;
                    resetPts(-off);
                }
                else if (views.length > 0 && views[views.length - 1].model().vindex - pageOff < endIdx) {
                    pos++;
                    removeTop();
                }
                else {
                    resetPts(-off);
                    delta = 0;
                }
            }
            fillEnd();
            assert(off === -pts[0], 'off가 pts[0]과 동일해야 한다 2.');
            this._renderVert(doc, off, width, height, false, needRenderArv);
            return { pos, off, row: views.length > 0 ? this.$_getTopRow() : -1 };
        }
        _createRowsDeleingAnimation(rowIds) {
            return new RowsDeletingAniImpl(this, rowIds);
        }
        scrollToEnd(row) {
            // TODO: 이미 scroll된 상태면 리턴.
            // TODO: 끝 행이 가까운 위치에 있으면 scrollBy() 호출.
            this._itemViews.forEach(iv => this.$_returnItemView(iv));
            const views = this._itemViews = [];
            const listView = this._listView;
            const owner = listView.owner();
            const vertical = owner.isVertical();
            const gm = owner.groupModel();
            const doc = this.doc;
            const width = this.width;
            const height = this.height;
            let h = height;
            let off = 0;
            const arv = row < 0 && this._measureAttached(doc, owner, vertical, width, height);
            if (arv) {
                h -= arv.mh;
            }
            row = row < 0 ? owner.getEndRow() : row;
            let i = gm.visIndexOfRow(row);
            while (i >= 0) {
                const item = this.$_getItem(gm, i);
                let v = this.$_getItemView(doc, item, null);
                const sz = v.measure(doc, listView, width, height);
                views.unshift(v);
                h -= sz.height;
                if (h <= 0) {
                    off = -h;
                    break;
                }
                i--;
            }
            this._setScrollPos(row, off, this.$_getTopRow());
            if (vertical) {
                this._renderVert(doc, off, width, height, true);
            }
            else {
                this._renderHorz(doc, off, width, height, true);
            }
        }
        _getRowView(doc, row, model, before) {
            const rv = super._getRowView(doc, row, model, before);
            rv.setData('theme', this._theme.type());
            rv.setData('no', model.no);
            return rv;
        }
        canMoveTo(row, target) {
            const source = this.getRowView(row);
            if (source) {
                console.log(source.group().hash, target.group().hash);
                return target instanceof ListRowView && source.group() === target.group();
            }
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        $_getItemView(doc, item, before) {
            var _a;
            let v;
            if (item instanceof DataGroupRow) {
                v = this._getRowView(doc, item.row(), item, before);
                v._gindex = item.vindex;
            }
            else if (item instanceof GroupRow) {
                v = this._getRowView(doc, item.row(), item, before);
                v._gindex = item.vindex;
            }
            else if (item instanceof GroupHeader) {
                v = this._headerMap[item.index];
                if (v) {
                    delete this._headerMap[item.index];
                }
                else {
                    const i = this._headerPoolMap[item.index];
                    if (i >= 0) {
                        v = this._headerPool[i];
                        this._headerPool.splice(i, 1);
                        delete this._headerPoolMap[item.index];
                    }
                    else {
                        v = this._headerPool.pop();
                    }
                    if (!v) {
                        v = new GroupHeaderView(doc);
                    }
                    v.indent = this.$_getItemIndent(item);
                    if (before) {
                        this._itemLayer.insertBefore(v, before);
                    }
                    else {
                        this._itemLayer.addChild(v);
                    }
                    v.setModel(item);
                }
                v.setTheme(this._theme.type());
                v.setItemData('exp', item.group.expanded() ? '1' : '0');
            }
            else if (item instanceof GroupFooter) {
                v = this._footerMap[item.index];
                if (v) {
                    delete this._footerMap[item.index];
                }
                else {
                    const i = this._footerPoolMap[item.index];
                    if (i >= 0) {
                        v = this._footerPool[i];
                        this._footerPool.splice(i, 1);
                        delete this._footerPoolMap[item.index];
                    }
                    else {
                        v = this._footerPool.pop();
                    }
                    if (!v) {
                        v = new GroupFooterView(doc);
                    }
                    v.indent = this.$_getItemIndent(item);
                    if (before) {
                        this._itemLayer.insertBefore(v, before);
                    }
                    else {
                        this._itemLayer.addChild(v);
                    }
                    v.setModel(item);
                }
                v.bodyIndent = this._getBodyIndent(v);
                v.bodyMargin = this._getBodyMargin(v);
                v.setTheme(this._theme.type());
            }
            const owner = this._listView.owner();
            if (v instanceof GroupItemView) {
                v.setLayout(owner.getGroupItemLayout(v.model()));
            }
            else if (item instanceof GroupRow) {
                const row = item.row();
                v.alternate = (item.vindex % 2) === 1;
                v.detailed = owner.isRowDetailed(row);
                v.checked = owner.isRowChecked(row);
                v.selected = (_a = owner.getSelection()) === null || _a === void 0 ? void 0 : _a.isRowSelected(row);
            }
            v.dom[T_IDX] = item.vindex;
            !v.hasData('state') && v.setData('state', 'g');
            return v;
        }
        // group header/footer view indent
        $_getItemIndent(item) {
            return item.group.level() * this._options.groupIndent();
        }
        $_addItemView(doc, vertical, item, before, width, height) {
            if (!item)
                debugger;
            if (item instanceof GroupRow) {
                const v = this._addRowView(doc, item.row(), item, before, vertical, width, height);
                !v.hasData('state') && v.setData('state', 'g');
                v.dom[T_IDX] = item.vindex;
                return v;
            }
            else {
                const v = this.$_getItemView(doc, item, before);
                const sz = v.measure(doc, this._listView, width - v.bodyIndent - v.bodyMargin, height);
                v.resize(width - v.bodyIndent - v.bodyMargin, sz.height);
                v.render(doc);
                if (v instanceof GroupHeaderView) {
                    this._headerMap[item.index] = v;
                }
                else {
                    this._footerMap[item.index] = v;
                }
                return v;
            }
        }
        $_resetGroupViews(views) {
            // header views
            for (const index in this._headerMap) {
                const v = this._headerMap[index];
                this.$_returnItemView(v);
            }
            this._headerMap = {};
            for (const v of views) {
                if (v instanceof GroupHeaderView) {
                    this._headerMap[v.model().index] = v;
                }
            }
            // footer views
            for (const index in this._footerMap) {
                const v = this._footerMap[index];
                this.$_returnItemView(v);
            }
            this._footerMap = {};
            for (const v of views) {
                if (v instanceof GroupFooterView) {
                    this._footerMap[v.model().index] = v;
                }
            }
        }
        $_returnItemView(view) {
            if (view instanceof ListRowView) {
                this._returnRowView(view);
            }
            else {
                this._itemLayer.removeChild(view);
                if (view instanceof GroupHeaderView) {
                    const index = view.model().index;
                    delete this._headerMap[index];
                    this._headerPool.push(view);
                    this._headerPoolMap[index] = this._headerPool.length - 1;
                }
                else if (view instanceof GroupFooterView) {
                    const index = view.model().index;
                    delete this._footerMap[index];
                    this._footerPool.push(view);
                    this._footerPoolMap[index] = this._footerPool.length - 1;
                }
                else {
                    throwFormat(locale.unknownItemViewType, view);
                }
            }
        }
        _renderVert(doc, scrollOff, width, height, render = true, renderArv = true) {
            const ar = this._arVis;
            const arv = this._attachedView;
            const views = this._itemViews;
            const cnt = views.length;
            const pts = this._itemPts = [-scrollOff];
            let x = 0;
            let y = pts[0];
            let i = 0;
            let rv;
            this._rowCount = 0;
            while (i < cnt && y < height) {
                const v = views[i++];
                const h = v.mh;
                v.move(x + v.bodyIndent, y);
                render && v.resize(v.mw, h).render(doc);
                y += h;
                pts.push(y);
                if (v instanceof ListRowView) {
                    rv = v;
                    this._rowCount++;
                }
            }
            for (let j = i; j < cnt; j++) {
                this.$_returnItemView(views[j]);
            }
            views.length = i;
            if (arv.visible) {
                if (y > height) {
                    arv.setVisible(false);
                }
                else {
                    arv.move(x, y);
                    renderArv && arv.resize(width, arv.mh).render(doc);
                    y += arv.mh;
                }
            }
            else if (ar) {
                if (y < height) {
                    debugger;
                }
                else {
                    // 아래 scrollended가 false가 되도록.
                    y++;
                }
            }
            // 마지막 데이터행이 일부라도 표시된 상태인 지 확인.
            this._rowEnded = views.length === 0 || rv && rv.row() === this.owner().getEndRow();
            // 끝까지 표시된 상태인 지 확인.
            this._scrollEnded = this._rowEnded && y <= height; // y <= height 가 아니다!
        }
        _renderHorz(doc, scrollOff, width, height, render = true) {
            // TODO: 현재 수평 모드일 때 그룹핑할 수 없다.
        }
        $_getTopRow() {
            for (const v of this._itemViews) {
                if (v instanceof ListRowView) {
                    return v.row();
                }
            }
            return -1;
        }
        checkItemViewOrders() {
            const elts = Array.from(this._itemLayer.dom.children);
            if (elts.length > 1) {
                for (let i = 1; i < elts.length; i++) {
                    // assert(elts[i][T_IDX] === elts[i - 1][T_IDX] + 1, `${elts[i][T_IDX]} === ${elts[i - 1][T_IDX] + 1}`);
                }
            }
        }
        isRowVisible(row, full) {
            return this.isItemVisible(this.indexOfRow(row), full);
        }
        isItemVisible(index, full) {
            // TODO: full 구현할 것!
            if (this._itemViews.length > 0) {
                return index >= this._itemViews[0].gindex() && index <= this._itemViews[this._itemViews.length - 1].gindex();
            }
        }
        makeRowVisible(row) {
            const listView = this._listView;
            const owner = listView.owner();
            const gm = owner.groupModel();
            const i = gm.visIndexOfRow(row);
            return i >= 0 ? this.makeItemVisible(i) : null;
        }
        makeItemVisible(index) {
            const listView = this._listView;
            const owner = listView.owner();
            // const vertical = owner.isVertical();
            const pageOff = owner.isPaging() ? this._pageItems[0].vindex : 0;
            const gm = owner.groupModel();
            const pos = this._scrollPos;
            const off = this._scrollOff;
            if (index < 0 || index >= gm.itemCount()) {
                return;
            }
            index = gm.getItem(index).vindex - pageOff;
            if (index === pos) {
                if (off > 0) {
                    return { pos: index, off: 0 };
                }
            }
            else if (index < pos) {
                return { pos: index, off: 0 };
            }
            else if (index === pos + this._itemViews.length - 1) {
                return { pos: pos + 1, off: 0 };
            }
            else if (index >= pos + this._itemViews.length) {
                // TODO: 현재 수평 모드일 때 그룹핑할 수 없다.
                //if (this._vertical) {
                return this.$_pullUpVert(gm, index);
                //} else {
                //    return this.$_pullUpHorz(gm, index);
                //}
            }
        }
        // 아래쪽에 숨겨진 행을 최소한 위로 끌어 올린다.
        $_pullUpVert(gm, index) {
            const doc = this.doc;
            const listView = this._listView;
            // const itemCount = this.$_itemCount(gm);
            const width = this.width;
            const height = this.height;
            const views = this._itemViews = [];
            let h = height * 0.7 >> 0;
            let i = index;
            while (i >= 0) {
                const item = this.$_getItem(gm, i);
                let v = this.$_getItemView(doc, item, null);
                const sz = v.measure(doc, listView, width, height);
                views.unshift(v);
                h -= sz.height;
                if (h <= 0) {
                    break;
                }
                i--;
            }
            const pos = i;
            const off = -h;
            this._setScrollPos(pos, off, this.$_getTopRow());
            this._doRenderVert(this.doc, width, height);
            return { pos, off };
        }
        // 오른쪽에 숨겨진 행을 최소한 위로 끌어 올린다.
        $_pullUpHorz(gm, index) {
            this.doc;
            const listView = this._listView;
            const owner = listView.owner();
            owner.data();
            this.width;
            this.height;
            return;
        }
    }
    /**
     * @internal
     */
    class GroupItemView extends ListItemView {
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        model() {
            return this._model;
        }
        group() {
            return this._model.group;
        }
        row() {
            return this._model.row();
        }
        dv() {
            return null;
        }
        gindex() {
            return this._model.index;
        }
        vindex() {
            return this._model.index;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        setModel(model) {
            this._model = model;
            return this;
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        getItemStyle(manager) {
            return this._model.getStyle();
        }
    }
    /**
     * @internal
     *
     * Group header view for {@link DGroupHeader} model.
     */
    class GroupHeaderView extends GroupItemView {
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        getItemClass() {
            return GroupHeaderView.CLASS_NAME;
        }
        _getExpander() {
            const e = this._owner.getExpander(this.gindex());
            if (e) {
                const p = e.position();
                const pos = p === DRowExpanderPosition.HEAD ? DListControlBarPosition.NEAR :
                    p === DRowExpanderPosition.FOOT ? DListControlBarPosition.FAR : undefined;
                if (p) {
                    return { pos, size: 18 };
                }
            }
        }
        _isExpanded() {
            return this._model.group.expanded();
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    GroupHeaderView.CLASS_NAME = 'dlist-item dlist-group-header';
    /**
     * @internal
     *
     * Group footer view for {@link DGroupFooer} model.
     */
    class GroupFooterView extends GroupItemView {
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        getItemClass() {
            return GroupFooterView.CLASS_NAME;
        }
        _toggleExpanded() {
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    GroupFooterView.CLASS_NAME = 'dlist-group-footer';
    class RowsDeletingAniPre extends RowsDeletingAniImpl {
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doPrepare() {
            const body = this._bodyView;
            this._preparePre();
            // // points of itemLayer
            this._pLayer = body.itemLayerOff();
            this._oldLayer = body._prevPos; // 삭제 전 위치
        }
        _doRun(step) {
            super._doRun(step);
            const body = this._bodyView;
            // itemLayer
            body._moveItemLayer(-(this._oldLayer + (this._pLayer - this._oldLayer) * step));
        }
    }
    class GroupedPreBodyView extends GroupedListBodyView {
        constructor() {
            super(...arguments);
            //-------------------------------------------------------------------------
            // fields
            //-------------------------------------------------------------------------
            this._prevPos = 0; // itemLayer 이전 위치.
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doMeasureVert(doc, hintWidth, hintHeight) {
            const listView = this._listView;
            const owner = listView.owner();
            const gm = owner.groupModel();
            const itemCount = this.$_itemCount(gm);
            const views = this._itemViews;
            const pts = this._itemPts = [0];
            let scrollPos = listView.reqScrollPos;
            let scrollOff = listView.reqScrollOff;
            let i = 0;
            let h = 0;
            let w = 0;
            let arv;
            while (i < itemCount) {
                const item = this.$_getItem(gm, i);
                let v = this.$_getItemView(doc, item, null);
                const sz = v.measure(doc, listView, hintWidth - v.bodyIndent - v.bodyMargin, hintHeight);
                views.push(v);
                h += sz.height;
                pts.push(h);
                w = Math.max(w, sz.width);
                i++;
            }
            if (arv = this._measureAttached(doc, owner, true, hintWidth, h)) {
                h += arv.mh;
            }
            if (views.length > 0) {
                // fullMode가 아니고, 아래가 남아 있으면 아래로 내린다.
                if (this._preMode) {
                    const si = this.$_scrollTo(this.$_scrollOff(scrollPos, scrollOff), hintHeight);
                    this._setScrollPos(si.pos, si.off, views[si.pos].row());
                }
            }
            else {
                this.$_scrollTo(0, hintHeight);
                this._setScrollPos(0, 0, -1);
            }
            return { width: w, height: h };
        }
        // TODO: 현재 수평 모드일 때 그룹핑할 수 없다.
        _doMeasureHorz(doc, hintWidth, hintHeight) {
            const listView = this._listView;
            const owner = listView.owner();
            owner.groupModel();
            this._itemViews;
            let w = 0;
            let h = 0;
            return { width: w, height: h };
        }
        _renderVert(doc, scrollOff, width, height, render = true, renderArv = true) {
            const arv = this._attachedView;
            const views = this._itemViews;
            const cnt = views.length;
            let x = 0;
            let y = 0;
            let i = 0;
            this._rowCount = 0;
            while (i < cnt) {
                const v = views[i++];
                v.move(x + v.bodyIndent, y);
                // TODO: render() 호출을 지연시킬 수 있겠다.
                render && v.resizeByMeasure().render(doc);
                y += v.mh;
                if (v instanceof ListRowView) {
                    this._rowCount++;
                }
            }
            if (arv.visible) {
                if (y > height) {
                    arv.setVisible(false);
                }
                else {
                    arv.move(x, y);
                    renderArv && arv.resize(width, arv.mh).render(doc);
                    y += arv.mh;
                }
            }
            this.$_checkEnded();
        }
        _renderHorz(doc, scrollOff, width, height, render = true) {
            // TODO: 현재 수평 모드일 때 그룹핑할 수 없다.
        }
        // 화면을 아래(오른쪽)로 드래그한다. scrollPos가 작아진다.
        _doScrollNear(doc, oldPos, oldOff, delta, width, height) {
            const si = this.$_scrollBy(-delta);
            return { pos: si.pos, off: si.off, row: si.row };
        }
        // 화면을 위(왼쪽)로 드래그한다. scrollPos가 커진다.
        _doScrollFar(doc, oldPos, oldOff, delta, width, height) {
            const si = this.$_scrollBy(delta);
            return { pos: si.pos, off: si.off, row: si.row };
        }
        scrollToEnd(row) {
            if (row < 0) {
                const listView = this._listView;
                const owner = listView.owner();
                const doc = this.doc;
                const vertical = this._vertical;
                const width = this.width;
                const height = this.height;
                const arv = this._measureAttached(doc, owner, vertical, width, height);
                arv.resize(vertical ? width : arv.mw, vertical ? arv.mh : height);
                arv.render(doc);
            }
            this.$_scrollTo(Number.MAX_SAFE_INTEGER, this[this.SIZE]);
        }
        _createRowsDeleingAnimation(rowIds) {
            return new RowsDeletingAniPre(this, rowIds);
        }
        _moveItemLayer(p) {
            this._prevPos = this.itemLayerOff();
            super._moveItemLayer(p);
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        $_scrollOff(pos, off) {
            const views = this._itemViews;
            const msz = this.MEASURE_SIZE;
            let p = 0;
            for (let i = 0; i < pos; i++) {
                p += views[i][msz];
            }
            p += off;
            return p;
        }
        $_scrollBy(delta) {
            return this.$_scrollTo(-this._itemLayer[this.POS] + delta, this[this.SIZE]);
        }
        $_scrollTo(p, sz) {
            const views = this._itemViews;
            const msz = this.MEASURE_SIZE;
            const cnt = views.length;
            if (cnt > 0) {
                const szArv = this._arVis ? this._attachedView[this.MEASURE_SIZE] : 0;
                const pts = this._itemPts;
                const pLast = pts[cnt] + szArv;
                sz = pickNum(sz, this[this.SIZE]);
                p = Math.max(0, Math.min(p, pLast - sz));
                let pos = cnt - 1;
                let off = 0;
                let y = p;
                let h = 0;
                let i = 0;
                while (i < cnt) {
                    const h2 = views[i][msz];
                    if (h2 > y) {
                        pos = i;
                        off = y;
                        h += off;
                        break;
                    }
                    y -= h2;
                    h += h2;
                    i++;
                }
                y = pLast - pts[pos] - off;
                if (y < sz) {
                    y = sz - y;
                    if (off >= y) {
                        off -= y;
                        h -= y;
                    }
                    else {
                        while (pos > 0 && y > 0) {
                            const h2 = views[--pos][msz];
                            if (y > h2) {
                                y -= h2;
                                h -= h2;
                                off = 0;
                            }
                            else {
                                off = y;
                                h -= y;
                                y = 0;
                            }
                        }
                    }
                }
                this._moveItemLayer(-h);
                this.$_checkEnded();
                return { pos, off, row: views[pos].row() };
            }
            else {
                this._moveItemLayer(0);
                this.$_checkEnded();
                return { pos: 0, off: 0, row: -1 };
            }
        }
        $_checkEnded() {
            const pts = this._itemPts;
            const cnt = pts.length - 1;
            if (cnt > 0) {
                const sz = this[this.SIZE];
                const szArv = this._arVis ? this._attachedView[this.MEASURE_SIZE] : 0;
                const pLast = pts[cnt] + szArv;
                const p = -this._itemLayer[this.POS];
                this._rowEnded = pts[cnt - 1] - p <= sz;
                this._scrollEnded = pLast - p <= sz;
            }
            else {
                this._rowEnded = this._scrollEnded = true;
            }
        }
    }
    class DataGroupRowView extends ListRowView {
    }
    class DataGroupedListBodyView extends GroupedListBodyView {
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _getGroupOptions(owner) {
            return owner.current().dataGroup();
        }
        _createItemView(doc) {
            return new DataGroupRowView(doc);
        }
        _getRowIndent(v) {
            return this._theme.getItemIndent(v._model);
            // return v._model.group.level() * 12;
        }
        _getBodyIndent(v) {
            return this._theme.getBodyIndent(v._model);
        }
        _getBodyMargin(v) {
            return this._theme.getBodyMargin(v._model);
        }
        _getRowView(doc, row, model, before) {
            const rv = super._getRowView(doc, row, model, before);
            rv.setData('master', model.isLeaf() ? '0' : '1');
            return rv;
        }
    }
    class DataPreListBodyView extends GroupedPreBodyView {
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _getGroupOptions(owner) {
            return owner.current().dataGroup();
        }
        _createItemView(doc) {
            return new DataGroupRowView(doc);
        }
        _getRowIndent(v) {
            return this._theme.getItemIndent(v._model);
            // return v._model.group.level() * 12;
        }
        _getBodyIndent(v) {
            return this._theme.getBodyIndent(v._model);
        }
        _getBodyMargin(v) {
            return this._theme.getBodyMargin(v._model);
        }
        _getRowView(doc, row, model, before) {
            const rv = super._getRowView(doc, row, model, before);
            rv.setData('master', model.isLeaf() ? '0' : '1');
            return rv;
        }
    }
    /**
     * @internal
     *
     * Master/detail 행들을 표시하는 list view.
     */
    class DataGrouedListView extends GroupedListView {
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _createBodyView(doc, noCache, spare) {
            return noCache ? new DataPreListBodyView(doc) : new DataGroupedListBodyView(doc);
        }
        rowBorderVisible(rv) {
            if (super.rowBorderVisible(rv)) {
                if (this._owner.rowBorder.leafOnly && rv._master)
                    return false;
                return true;
            }
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     *
     * Button renderer impl for {@link ButtonRenderer}.
     */
    class ButtonRendererImpl extends DListRendererImpl {
        //-------------------------------------------------------------------------
        // static members
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // property fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doPrepare(ctx, div) {
            // button type 속성이 'button' 이어야 한다.
            div[BUTTON$1] = this.$_getButton(ctx, div);
        }
        _getStyleTarget(div) {
            return div[BUTTON$1].style;
        }
        _doMeasure(ctx, div, hintWidth, hintHeight) {
            const doc = ctx.doc;
            const model = this._model;
            const label = model.label;
            const imgUrl = model.imageUrl;
            const divButton = div[BUTTON$1];
            const button = _isSafari ? divButton.firstElementChild : divButton;
            let img = Dom.childByClass(button, ButtonRendererImpl.IMAGE_CLASS);
            let svg = Dom.childByClass(button, ButtonRendererImpl.SHAPE_CLASS);
            let w = model.buttonWidth;
            let h = model.buttonHeight;
            let deco;
            let shape;
            // 사용자가 값 변경 이벤트를 받으려면 id를 설정하거나 field가 연결돼야 한다.
            this._setContext(ctx, divButton, model);
            model.borderless && Dom.setData(divButton, 'borderless', 1);
            if (!model.borderless) {
                Dom.setData(button, 'image', 1);
            }
            this._setClass(button, ctx.row);
            if (imgUrl) {
                svg = Dom.remove(svg);
                if (!img) {
                    img = ctx.doc.createElement('img');
                    img.className = ButtonRendererImpl.IMAGE_CLASS;
                    img.style.pointerEvents = 'none';
                    img.style.verticalAlign = 'middle';
                    Dom.setAttr(img, 'aria-hidden', true);
                    button.appendChild(img);
                }
                let wImg = model.imageWidth;
                let hImg = model.imageHeight;
                img.src = imgUrl;
                !img.complete && ctx.useImage(imgUrl); // 실제 이미지가 로드됐을 때 다시 그려지도록 한다.
                if (isNaN(wImg) && isNaN(hImg)) {
                    const sz = _isSafari && ctx.getImageSize(imgUrl);
                    if (sz) {
                        wImg = sz.width;
                        hImg = sz.height;
                    }
                    else {
                        wImg = img.naturalWidth;
                        hImg = img.naturalHeight;
                    }
                }
                if (!isNaN(wImg)) {
                    img.width = wImg;
                }
                if (!isNaN(hImg)) {
                    img.height = hImg;
                }
                deco = img;
            }
            else if (shape = model.shape) {
                img = Dom.remove(img);
                const sz = model.getShapeSize();
                if (!svg || svg[T_NAME] !== shape) {
                    const shapes = ctx.manager().owner().shapes();
                    const s = shapes.createStock(ctx.doc, shape, ButtonRendererImpl.SHAPE_CLASS) || shapes.createCustom(shape, null, null);
                    svg = Dom.remove(svg);
                    if (s) {
                        if (s instanceof DCustomShape) {
                            s.setShape(shapes.getCustom(shape));
                        }
                        s.appendTo(button);
                        svg = s['_svg']['svg'];
                        svg[T_NAME] = shape;
                        svg.style.verticalAlign = 'middle';
                        s.resize(sz.width, sz.height);
                    }
                }
                else if (svg) {
                    Dom.resize(svg, sz.width, sz.height);
                }
                deco = svg;
            }
            if (deco) {
                _isSafari ? this.$_arrangeafari(doc, button, deco) : this.$_arrange(doc, button, deco);
            }
            else {
                let span = Dom.childByClass(button, ButtonRendererImpl.LABEL_CLASS);
                let br = Dom.childByClass(button, ButtonRendererImpl.BR_CLASS);
                img = Dom.remove(img);
                svg = Dom.remove(svg);
                br = Dom.remove(br);
                if (!span) {
                    span = this.$_createSpan(doc);
                    button.appendChild(span);
                }
                span.textContent = label;
                Dom.setData(button, 'image', void 0);
            }
            if (!isNaN(w)) {
                button.style.width = w + 'px';
            }
            if (!isNaN(h)) {
                button.style.height = h + 'px';
            }
            Dom.setDisabled(button.parentElement, model.disabled);
            if (DElement.TESTING) {
                if (isNaN(w)) {
                    w = button.offsetWidth;
                }
                if (isNaN(h)) {
                    h = button.offsetHeight;
                }
                return { width: Math.ceil(w), height: Math.ceil(h) };
            }
        }
        $_createSpan(doc) {
            const span = doc.createElement('span');
            span.className = ButtonRendererImpl.LABEL_CLASS;
            span.style.pointerEvents = 'none';
            span.style.verticalAlign = 'middle';
            return span;
        }
        $_arrange(doc, button, deco) {
            const model = this._model;
            const label = model.label;
            let span = Dom.childByClass(button, ButtonRendererImpl.LABEL_CLASS);
            let br = Dom.childByClass(button, ButtonRendererImpl.BR_CLASS);
            if (label && model.labelPosition !== DListButtonLabelPosition.NONE) {
                if (!span) {
                    span = this.$_createSpan(doc);
                }
                span.textContent = label;
                switch (model.labelPosition) {
                    case DListButtonLabelPosition.LEFT:
                        br = Dom.remove(br);
                        deco.style.paddingLeft = BUTTON_LABEL_GAP;
                        button.insertBefore(span, deco);
                        break;
                    case DListButtonLabelPosition.RIGHT:
                        br = Dom.remove(br);
                        deco.style.paddingRight = BUTTON_LABEL_GAP;
                        button.appendChild(span);
                        break;
                    case DListButtonLabelPosition.TOP:
                        button.insertBefore(span, deco);
                        button.insertBefore(br || Dom.createBR(doc, ButtonRendererImpl.BR_CLASS), deco);
                        deco.style.paddingTop = BUTTON_LABEL_GAP;
                        break;
                    default:
                        deco.style.paddingBottom = BUTTON_LABEL_GAP;
                        button.appendChild(span);
                        button.insertBefore(br || Dom.createBR(doc, ButtonRendererImpl.BR_CLASS), span);
                        break;
                }
            }
            else {
                br = Dom.remove(br);
                // NOTE: shape나 image가 혼자 있을 때, 높이가 버튼 기본 높이보다 작은 경우,
                //       verticalAlign을 middle로 설정해도 중앙 정렬되지 않는다.
                //       비어 있는 span을 추가하면 정렬된다.
                // span = Dom.remove(span);
                if (!span) {
                    span = this.$_createSpan(doc);
                }
                button.insertBefore(span, deco);
                span.textContent = '';
            }
        }
        // css flex 로 구현한다.
        $_arrangeafari(doc, button, deco) {
            const model = this._model;
            const label = model.label;
            let span = Dom.childByClass(button, ButtonRendererImpl.LABEL_CLASS);
            if (label && model.labelPosition !== DListButtonLabelPosition.NONE) {
                if (!span) {
                    span = this.$_createSpan(doc);
                }
                span.textContent = label;
                switch (model.labelPosition) {
                    case DListButtonLabelPosition.LEFT:
                        button.style.flexDirection = 'row';
                        deco.style.paddingLeft = BUTTON_LABEL_GAP; // iOS에서 gap 스타일이 적용되지 않는다.
                        button.insertBefore(span, deco);
                        break;
                    case DListButtonLabelPosition.RIGHT:
                        button.style.flexDirection = 'row';
                        deco.style.paddingRight = BUTTON_LABEL_GAP;
                        button.appendChild(span);
                        break;
                    case DListButtonLabelPosition.TOP:
                        button.insertBefore(span, deco);
                        deco.style.paddingTop = BUTTON_LABEL_GAP;
                        button.style.flexDirection = 'column';
                        break;
                    default:
                        button.style.flexDirection = 'column';
                        deco.style.paddingBottom = BUTTON_LABEL_GAP;
                        button.appendChild(span);
                        break;
                }
            }
            else {
                span = Dom.remove(span);
            }
        }
        _doRender(ctx, div, width, height) {
        }
        _doUnprepare(ctx, div) {
            div[BUTTON$1] = null;
        }
        setValue(layout, newValue) {
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        $_getButton(ctx, div) {
            let button = div.getElementsByClassName(ButtonRendererImpl.BUTTON_CLASS)[0];
            if (!button) {
                button = ctx.createElement('button');
                button.type = 'button'; // [접근성] submit이 아님을 명시적으로 표시.
                button.className = ButtonRendererImpl.BUTTON_CLASS;
                button[CLICKABLE] = '1';
                Object.assign(button.style, BUTTON_STYLE);
                div.appendChild(button);
                if (_isSafari) {
                    const flex = ctx.doc.createElement('div');
                    flex.style.display = 'flex';
                    flex.style.alignItems = 'center';
                    flex.style.justifyContent = 'center';
                    flex.style.boxSizing = 'border-box';
                    button.appendChild(flex);
                }
            }
            return button;
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    ButtonRendererImpl.BUTTON_CLASS = 'dlist-button-button';
    ButtonRendererImpl.BR_CLASS = 'dlist-button-br';
    ButtonRendererImpl.LABEL_CLASS = 'dlist-button-label';
    ButtonRendererImpl.IMAGE_CLASS = 'dlist-button-image';
    ButtonRendererImpl.SHAPE_CLASS = 'dlist-button-shape';

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     *
     * Check renderer impl for {@link CheckRenderer}.
     * check box를 opacity=0 으로 표시한다.
     */
    class CheckRendererImpl extends EditableRendererImpl {
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doPrepare(ctx, div) {
            div[BOX] = this.$_getBox(ctx, div);
        }
        _getStyleTarget(div) {
            return;
        }
        _measureBox(ctx, box) {
            box.checked = this._model.isTrue(this._value);
        }
        _doMeasure(ctx, div, hintWidth, hintHeight) {
            const model = this._model;
            const box = div[BOX];
            const label = div.getElementsByClassName(CheckRendererImpl.LABEL_CLASS)[0];
            let w = model.getBoxWidth();
            let h = model.getBoxHeight();
            this._setClass(box, ctx.row);
            // label이 wrap될 떄 높이가 제대로 계산될 수 있도록
            if (!isNaN(ctx._explicitWidth)) {
                Dom.setWidth(div.firstElementChild.firstElementChild, ctx._explicitWidth);
            }
            // 사용자가 값 변경 이벤트를 받으려면 id를 설정하거나 field가 연결돼야 한다.
            this._setContext(ctx, box, model);
            this._measureBox(ctx, box);
            // renderer 모델 크기가 지정되지 않으면 브라우저가 제공하는 checkbox 기본 크기.
            if (!isNaN(w)) {
                box.style.width = w + 'px';
            }
            if (!isNaN(h)) {
                box.style.height = w + 'px';
            }
            // label.style.whiteSpace = model.labelWrap && isNaN(ctx._explicitWidth) ? '' : 'nowrap';
            label.style.whiteSpace = model.labelWrap && isNaN(ctx._explicitWidth) ? 'pre-wrap' : 'pre';
            label.textContent = model.getLabel(box.checked);
            if (DElement.TESTING) {
                if (isNaN(w)) {
                    w = box.offsetWidth;
                }
                if (isNaN(h)) {
                    h = box.offsetHeight;
                }
                return { width: w, height: h };
            }
        }
        _doRender(ctx, div, width, height) {
        }
        _doUnprepare(ctx, div) {
        }
        getValue(layout) {
            const clazz = this._getBoxClass();
            const input = Dom.childByClass(layout, clazz);
            if (input) {
                const checked = input.checked;
                return checked ? this._model.trueValue : this._model.falseValue;
            }
        }
        setValue(layout, newValue) {
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        _getBoxType() {
            return 'checkbox';
        }
        _getBoxClass() {
            return CheckRendererImpl.BOX_CLASS;
        }
        $_getBox(ctx, div) {
            const clazz = this._getBoxClass();
            let box = div.getElementsByClassName(clazz)[0];
            if (!box) {
                const c2 = ctx.doc.createElement('div');
                c2.style.position = 'relative';
                // div로 씌우지 않으면 수직 중앙 정렬이 되지 않는다.
                const c = ctx.doc.createElement('div');
                c.style.display = 'flex';
                // c.style.gap = '5px'; // 아직 많이 지원하지 않는다. 아래 marginRight로 대체.
                c.style.alignItems = 'center';
                box = ctx.doc.createElement('input');
                box.className = clazz;
                box.style.marginRight = '5px';
                box.style.flex = 'none'; // to prevent a flex item from growing or shrinking. 이렇게 하지 않으면 label이 wrap될 때 box 크기가 작이진다.
                box.type = this._getBoxType();
                box.onclick = function () {
                    console.log('> CLICKED', box.type, box.id, clazz);
                };
                const label = ctx.doc.createElement('label');
                label.className = CheckRendererImpl.LABEL_CLASS;
                Object.assign(label.style, {
                    flexGrow: 1,
                });
                c.appendChild(box);
                c.appendChild(label);
                c2.appendChild(c);
                div.appendChild(c2);
            }
            return box;
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    CheckRendererImpl.BOX_CLASS = 'dlist-check-box';
    CheckRendererImpl.LABEL_CLASS = 'dlist-check-label';

    ////////////////////////////////////////////////////////////////////////////////
    class GaugeShape extends DShape {
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        draw(ctx) {
            const model = ctx.model;
            let style = model.getStyle();
            const w = Math.ceil((parseFloat(style.strokeWidth) || 0) / 2);
            const { cx, cy, rx, ry } = model.getExtents(ctx.width, ctx.height);
            const start = model.startAngle || 0;
            let angle = (model.endAngle || 0) - start;
            this._svg.clear();
            this._svg.arc(cx, cy, rx - w, ry - w, start, angle, model.clockwise, style);
            angle = angle * model.getValueRate(ctx.value);
            style = model.getValueStyle();
            this._svg.arc(cx, cy, rx - w, ry - w, start, angle, model.clockwise, style);
            // NOTE: fillSize(즉, 100%)가 safari에서 동작하지 않는다!
            this._svg.setSize(ctx.width, ctx.height);
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doInit(svg) {
            // svg.fillSize(); // 100%가 safari에서 동작하지 않는다!
        }
    }
    /**
     * @internal
     *
     * Gauge renderer impl for {@link GaugeRenderer}.
     */
    class GaugeRendererImpl extends ValueRendererImpl {
        //-------------------------------------------------------------------------
        // static members
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // property fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doPrepare(ctx, div) {
            // div[SHAPE] = new DShapeRenderer()
        }
        _getStyleTarget(div) {
            return;
        }
        _doMeasure(ctx, div, hintWidth, hintHeight) {
            const model = this.model();
            let w = model.getGaugeWidth();
            let h = model.getGaugeHeight();
            this._setClass(div, ctx.row);
            return { width: w, height: h };
        }
        _doRender(ctx, div, width, height) {
            // guage 크기는 내용과 상관없이 모델이나 layout view에서 결정하므로 measure에서 svg를 미리 생성할 필요가 없다.
            const shape = this._getShape(ctx, div);
            console.log('GAUGE', this._value);
            shape.draw({ model: this.model(), value: this._value, width, height });
        }
        _doUnprepare(ctx, div) {
        }
        setValue(layout, newValue) {
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        _getShape(ctx, div) {
            let svg = div.getElementsByClassName(GaugeRendererImpl.SVG_CLASS)[0];
            let shape;
            if (!svg) {
                shape = new GaugeShape(ctx.doc, GaugeRendererImpl.SVG_CLASS);
                shape.appendTo(div);
            }
            else {
                shape = new GaugeShape(svg, GaugeRendererImpl.SVG_CLASS);
            }
            return shape;
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    GaugeRendererImpl.SVG_CLASS = 'dlist-gauge-svg';

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     *
     * Icon renderer impl for {@link IconRenderer}.
     */
    class IconRendererImpl extends DListRendererImpl {
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doPrepare(ctx, div) {
            this._img = this.$_getImage(ctx, div);
        }
        _getStyleTarget(div) {
            return;
        }
        _doMeasure(ctx, div, hintWidth, hintHeight) {
            const model = this.model();
            const img = this._img;
            const icon = ctx.getIcon(model.iconSet, model.iconName);
            let w;
            let h;
            this._setClass(img, ctx.row);
            img.src = icon.url;
            img.alt = model.hint || icon.url;
            if (!isNaN(icon.width)) {
                img.width = w = icon.width;
            }
            if (!isNaN(icon.height)) {
                img.height = h = icon.height;
            }
            if (DElement.TESTING) {
                if (isNaN(w)) {
                    w = img.offsetWidth || 0;
                }
                if (isNaN(h)) {
                    h = img.offsetHeight || 0;
                }
                return { width: w, height: h };
            }
        }
        _doRender(ctx, div, width, height) {
        }
        _doUnprepare(ctx, div) {
            this._img = null;
        }
        setValue(layout, newValue) {
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        $_getImage(ctx, div) {
            let img = div.getElementsByClassName(IconRendererImpl.IMAGE_CLASS)[0];
            if (!img) {
                img = ctx.doc.createElement('img');
                img.className = IconRendererImpl.IMAGE_CLASS;
                div.appendChild(img);
            }
            return img;
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    IconRendererImpl.IMAGE_CLASS = 'dlist-icon-image';

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     *
     * Image renderer impl for {@link ImageRenderer}.
     */
    class ImageRendererImpl extends ValueRendererImpl {
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doPrepare(ctx, div) {
            div[IMG] = this.$_getImage(ctx, div);
        }
        _getStyleTarget(div) {
            return div[IMG].style;
        }
        _doMeasure(ctx, div, hintWidth, hintHeight) {
            const model = this.model();
            const img = div[IMG];
            const { url, isNull } = model.getUrl(this._value);
            let w = isNull ? model.nullWidth : model.imageWidth;
            let h = isNull ? model.nullHeight : model.imageHeight;
            const alt = img.alt = model.alt || model.hint || "";
            this._setClass(img, ctx.row);
            Dom.setAttr(img, 'aria-hidden', model.decorative || !alt);
            img.src = url;
            !img.complete && ctx.useImage(url); // 실제 이미지가 로드됐을 때 다시 그려지도록 한다.
            if (isNaN(w) && isNaN(h)) {
                w = img.naturalWidth;
                if (!isNaN(w)) {
                    h = img.naturalHeight;
                }
            }
            if (!isNaN(this._imageWidth = w)) {
                img.width = w;
            }
            if (!isNaN(this._imageHeight = h)) {
                img.height = h;
            }
            if (DElement.TESTING) {
                w = pickNum3(img.width, w, 0);
                h = pickNum3(img.height, h, 0);
                return { width: Math.ceil(w), height: Math.ceil(h) };
            }
        }
        _doRender(ctx, div, width, height) {
            if (isNaN(this._imageWidth) && isNaN(this._imageHeight)) {
                const img = div[IMG];
                img.width = width;
                img.height = height;
            }
        }
        _doUnprepare(ctx, div) {
            div[IMG] = null;
        }
        setValue(layout, newValue) {
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        $_getImage(ctx, div) {
            let img = div.getElementsByClassName(ImageRendererImpl.IMAGE_CLASS)[0];
            if (!img) {
                // parent가 'display:table' 이다. img는 'table-cell' 역할을 못한다. 
                // 즉, img에 verticalAlign, table에 textAlign이 적용되지 않는다.
                // div로 씌운다.
                const c = ctx.doc.createElement('div');
                img = ctx.doc.createElement('img');
                img.className = ImageRendererImpl.IMAGE_CLASS;
                c.appendChild(img);
                div.appendChild(c);
            }
            return img;
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    ImageRendererImpl.IMAGE_CLASS = 'dlist-image-image';

    ////////////////////////////////////////////////////////////////////////////////
    const AUTO_HIDE = 'autohide';
    /**
     * @internal
     *
     * Input renderer impl for {@link InputRenderer}.
     */
    class InputRendererImplBase extends EditableRendererImpl {
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doPrepare(ctx, div) {
            div[BOX] = this.$_getInput(ctx, div);
        }
        _getStyleTarget(div) {
            return;
        }
        _doMeasure(ctx, div, maxWidth, maxHeight) {
            const model = this._model;
            const elt = div[BOX];
            let w = model.boxWidth;
            let h = model.boxHeight;
            this._setClass(elt, ctx.row);
            elt.style.maxWidth = '';
            if (isNaN(w) && !isNaN(ctx._explicitWidth)) {
                w = ctx._explicitWidth * model.getFitWidth();
            }
            if (isNaN(h) && !isNaN(ctx._explicitHeight)) {
                h = ctx._explicitHeight * model.getFitHeight();
            }
            !isNaN(w) && Dom.setWidth(elt, w);
            !isNaN(h) && Dom.setHeight(elt, h);
            if (model.autoHide) {
                elt.dataset[AUTO_HIDE] = '1';
            }
            else {
                delete elt.dataset[AUTO_HIDE];
            }
            // 사용자가 값 변경 이벤트를 받으려면 id를 설정하거나 field가 연결돼야 한다.
            this._setContext(ctx, elt, model);
            elt.value = pickProp(this._valueToText(this._value), this._valueToText(this._getDefaultValue()));
            this._prepareInput(elt);
            if (DElement.TESTING) {
                return { width: w || 0, height: h || 0 };
            }
        }
        _doRender(ctx, div, width, height) {
            const elt = div[BOX];
            if (!elt.style.width) {
                elt.style.maxWidth = width + 'px';
            }
        }
        _doUnprepare(ctx, div) {
            div[BOX] = null;
        }
        getValue(layout) {
            const input = Dom.childByClass(layout, InputRendererImplBase.INPUT_CLASS);
            return input && this._textToValue(input.value);
        }
        setValue(layout, newValue) {
            const input = Dom.childByClass(layout, InputRendererImplBase.INPUT_CLASS);
            if (input) {
                input.value = this._valueToText(newValue);
            }
        }
        _initInput(input) {
        }
        _prepareInput(input) {
        }
        _getDefaultValue() {
            return '';
        }
        _valueToText(value) {
            return value;
        }
        _textToValue(text) {
            return text;
        }
        $_getInput(ctx, div) {
            let elt = div.getElementsByClassName(InputRendererImplBase.INPUT_CLASS)[0];
            if (!elt) {
                // div로 씌우지 않으면 수직 중앙 정렬이 되지 않는다.
                const c = ctx.doc.createElement('div');
                elt = ctx.doc.createElement('input');
                elt.className = InputRendererImplBase.INPUT_CLASS;
                elt.type = this._getInputType();
                elt.style.boxSizing = 'border-box';
                elt.onkeydown = function (ev) {
                    if (elt.dataset[AUTO_HIDE] === '1' && ev.key === 'Enter') {
                        ev.preventDefault();
                        ev.currentTarget.blur();
                    }
                };
                elt.onfocus = (ev) => {
                    DControl.currentInput = elt.id;
                };
                this._initInput(elt);
                c.appendChild(elt);
                div.appendChild(c);
            }
            return elt;
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    InputRendererImplBase.INPUT_CLASS = 'dlist-input-input';
    class InputRendererImpl extends InputRendererImplBase {
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _getInputType() {
            return 'text';
        }
    }
    class NumberRendererImpl extends InputRendererImplBase {
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _getInputType() {
            return 'number';
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     *
     * Text renderer impl for {@link TextRenderer}.
     *
     * layout 높이가 명시적으로 설정되면 text span을 중앙 정렬 시킨다.
     */
    class TextRendererImplBase extends ValueRendererImpl {
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _getStyleTarget(div) {
            return div[SPAN].firstElementChild.style;
        }
        needBounds() {
            return true;
        }
        _doPrepare(ctx, layout) {
            const model = this._model;
            const div = layout[SPAN];
            const span = div.firstElementChild;
            const css = span.style;
            this._setClass(span, ctx.row);
            Object.assign(css, model.singleLine ? TextRendererImpl.SPAN_STYLE_SINGLE : model.wrap ? TextRendererImpl.SPAN_STYLE_WRAP : TextRendererImpl.SPAN_STYLE);
            css.maxWidth = ''; // render시 설정하므로 반드시 초기화해야 한다.
            css.maxHeight = '';
            css.lineHeight = '';
            span.textContent = model.getText(ctx, this._value, ctx.manager().owner().lineSepReg());
        }
        // applyStyle(layout: HTMLDivElement, style: CSSStyles): void {
        //     super.applyStyle(layout, style);
        //     // const div = layout[SPAN] as HTMLDivElement;
        //     // (div.firstElementChild as HTMLSpanElement).style.verticalAlign = div.style.verticalAlign; // TODO: 하지 않으면 모바일에서 틀어진다.
        //     // 아래 $_getSpan 참조!
        // }
        _doMeasure(ctx, layout, maxWidth, maxHeight) {
            const div = layout[SPAN];
            const span = div.firstElementChild;
            div.style.maxWidth = maxWidth + 'px';
            div.style.maxHeight = maxHeight + 'px';
            // +1: https://stackoverflow.com/questions/31719624/displaytable-div-with-percentage-width-1px-bug
            // span.offsetHeight보다 div가 1보다 커지게 된다. 미리 div 높이를 리턴한다!
            return { width: span.offsetWidth + 1, height: div.offsetHeight };
        }
        _doRender(ctx, div, width, height) {
            const span = div[SPAN].firstElementChild;
            // div의 text-align이 동작할 수 있도록...
            // span.style.width = '';
            // 이렇게 지정해야 text-overflow(=ellipsis,...)를 지정할 수 있다.
            span.style.maxWidth = width + 'px';
            span.style.maxHeight = height + 'px';
        }
        _doUnprepare(ctx, div) {
            div[SPAN] = null;
        }
        setValue(layout, newValue) {
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    // NOTE: pre 대신 normal을 사용하면 너비를 지정하지 않을 때(0으로 간주하는 듯),
    //       모든 글자에서 wrap하므로 layout에 문제가 생긴다.
    //       text를 사용하는 모든 renderer 등에 해당한다.
    // linefeed나 <br>에서 줄 나누기
    TextRendererImplBase.SPAN_STYLE = {
        whiteSpace: 'pre',
        // wordBreak: 'keep-all',
        wordWrap: 'normal',
        textOverflow: 'ellipsis',
        overflow: 'hidden'
    };
    // 명시적으로 설정된 경우 너비를 초과하면 줄 나누기
    TextRendererImplBase.SPAN_STYLE_WRAP = {
        whiteSpace: 'pre-wrap',
        // wordBreak: 'break-all',
        textOverflow: 'ellipsis',
        overflow: 'hidden'
    };
    // linefeed 무시하고 무조건 한 줄에 표시
    TextRendererImplBase.SPAN_STYLE_SINGLE = {
        whiteSpace: 'nowrap',
        textOverflow: 'ellipsis',
        overflow: 'hidden'
    };
    /**
     * @internal
     *
     * Text renderer impl for {@link TextRenderer}.
     *
     * layout 높이가 명시적으로 설정되면 text span을 중앙 정렬 시킨다.
     */
    class TextRendererImpl extends TextRendererImplBase {
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doPrepare(ctx, layout) {
            layout[SPAN] = this.$_getSpan(ctx, layout);
            super._doPrepare(ctx, layout);
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        $_getSpan(ctx, layout) {
            let div = layout.getElementsByClassName(TextRendererImpl.SPAN_CLASS)[0];
            if (!div) {
                div = ctx.createElement('div');
                div.className = TextRendererImpl.SPAN_CLASS;
                const span = ctx.createElement('span');
                // span.style.display = 'inline-block'; // 매우 중요!. 자체 text-align이 적용된다.
                // 'inline-block'이고 'overflow:hidden'이면 중앙 정렬에 문제가 생겨서 span에 vertical-align을 지정해야 한다.
                // text-align은 상위 div에서 지정하고 내려 뱓게 되므로 'inline'을 유지 시킨다.
                div.appendChild(span);
                layout.appendChild(div);
            }
            return div;
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    TextRendererImpl.SPAN_CLASS = 'dlist-text-span';
    /**
     * @internal
     *
     * Testing mock class for TextRendererImpl
     */
    class TextRendererImplTest extends TextRendererImpl {
        _doMeasure(ctx, layout, maxWidth, maxHeight) {
            super._doMeasure(ctx, layout, maxWidth, maxHeight);
            const div = layout[SPAN];
            const width = Math.ceil(div.offsetWidth);
            const height = Math.ceil(div.offsetHeight);
            return { width, height };
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     *
     * Link renderer impl for {@link LinkRenderer}.
     */
    class LinkRendererImpl extends TextRendererImplBase {
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doPrepare(ctx, layout) {
            const div = layout[SPAN] = this.$_getAnchor(ctx, layout);
            super._doPrepare(ctx, layout);
            div.firstElementChild.href = this._model.getLink(ctx);
        }
        setValue(layout, newValue) {
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        $_getAnchor(ctx, layout) {
            let div = layout.getElementsByClassName(LinkRendererImpl.ANCHOR_CLASS)[0];
            if (!div) {
                div = ctx.createElement('div');
                div.className = LinkRendererImpl.ANCHOR_CLASS;
                const span = ctx.doc.createElement('a');
                // span.style.display = 'inline-block'; // 매우 중요!. 자체 text-align이 적용된다.
                div.appendChild(span);
                layout.appendChild(div);
            }
            return div;
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    LinkRendererImpl.ANCHOR_CLASS = 'dlist-link-anchor';

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     *
     * Meter renderer impl for {@link MeterRenderer}.
     */
    class MeterRendererImpl extends ValueRendererImpl {
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doPrepare(ctx, div) {
            div[BAR] = this.$_getBar(ctx, div);
        }
        _getStyleTarget(div) {
            return;
        }
        _doMeasure(ctx, div, hintWidth, hintHeight) {
            const model = this.model();
            let w = this._barWidth = model.barWidth;
            let h = this._barHeight = model.barHeight;
            const bar = div[BAR];
            const min = model.minValue;
            const max = model.maxValue;
            const low = model.lowValue;
            const high = model.highValue;
            const optimum = model.optimumValue;
            const value = Utils.pickNum(model.value, this._value);
            this._setClass(bar, ctx.row);
            if (!isNaN(min)) {
                bar.min = min;
            }
            if (!isNaN(max)) {
                bar.max = max;
            }
            if (!isNaN(low)) {
                bar.low = low;
            }
            if (!isNaN(high)) {
                bar.high = high;
            }
            if (!isNaN(optimum)) {
                bar.optimum = optimum;
            }
            if (!isNaN(value)) {
                bar.value = value;
            }
            if (!isNaN(w)) {
                bar.style.width = w + 'px';
            }
            if (!isNaN(h)) {
                bar.style.height = h + 'px';
            }
            if (DElement.TESTING) {
                w = bar.offsetWidth;
                h = bar.offsetHeight;
                return { width: w, height: h };
            }
        }
        _doRender(ctx, div, width, height) {
            const bar = div[BAR];
            if (isNaN(this._barWidth)) {
                bar.style.width = width + 'px';
            }
            if (isNaN(this._barHeight)) {
                bar.style.height = height + 'px';
            }
        }
        _doUnprepare(ctx, div) {
            div[BAR] = null;
        }
        setValue(layout, newValue) {
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        $_getBar(ctx, div) {
            let bar = div.getElementsByClassName(MeterRendererImpl.BAR_CLASS)[0];
            if (!bar) {
                bar = ctx.doc.createElement('meter');
                bar.className = MeterRendererImpl.BAR_CLASS;
                div.appendChild(bar);
            }
            return bar;
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    MeterRendererImpl.BAR_CLASS = 'dlist-meter-bar';

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     *
     * Progress renderer impl for {@link ProgressRenderer}.
     */
    class ProgressRendererImpl extends ValueRendererImpl {
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doPrepare(ctx, div) {
            div[BAR] = this.$_getBar(ctx, div);
        }
        _getStyleTarget(div) {
            return;
        }
        _doMeasure(ctx, div, hintWidth, hintHeight) {
            const model = this.model();
            const bar = div[BAR];
            let w = model.barWidth;
            let h = model.barHeight;
            const min = model.minValue;
            const max = model.maxValue;
            const value = +this._value;
            this._setClass(bar, ctx.row);
            if (!isNaN(min) && !isNaN(max) && !isNaN(value) && max > min) {
                bar.max = max - min;
                bar.value = value - min;
            }
            else {
                delete bar.value;
            }
            // layout이 고정 크기가 된 경우 layout에 대한 상대 크기로 고정할 수 있다.
            if (isNaN(w) && !isNaN(ctx._explicitWidth)) {
                w = ctx._explicitWidth * model.getFitWidth();
            }
            if (isNaN(h) && !isNaN(ctx._explicitHeight)) {
                w = ctx._explicitHeight * model.getFitHeight();
            }
            !isNaN(w) && Dom.setWidth(bar, w);
            !isNaN(h) && Dom.setHeight(bar, h);
            if (DElement.TESTING) {
                w = isNaN(w) ? bar.offsetWidth : w;
                h = isNaN(h) ? bar.offsetHeight : h;
                return { width: w, height: h };
            }
        }
        _doRender(ctx, div, width, height) {
            div[BAR];
            // // 모델 크기를 지정하지 않으면 field view 크기를 따른다.
            // if (isNaN(this._barWidth) && this._model.fillWidth) {
            //     bar.style.width = width + 'px';
            // }
            // if (isNaN(this._barHeight)) {
            //     bar.style.height = height + 'px';
            // }
        }
        _doUnprepare(ctx, div) {
            div[BAR] = null;
        }
        setValue(layout, newValue) {
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        $_getBar(ctx, div) {
            let bar = div.getElementsByClassName(ProgressRendererImpl.BAR_CLASS)[0];
            if (!bar) {
                bar = ctx.doc.createElement('progress');
                bar.className = ProgressRendererImpl.BAR_CLASS;
                div.appendChild(bar);
            }
            return bar;
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    ProgressRendererImpl.BAR_CLASS = 'dlist-progress-bar';

    function unwrapExports (x) {
    	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
    }

    function createCommonjsModule(fn, module) {
    	return module = { exports: {} }, fn(module, module.exports), module.exports;
    }

    var qrCodeStyling = createCommonjsModule(function (module, exports) {
    !function(t,e){module.exports=e();}(self,(function(){return (()=>{var t={192:(t,e)=>{var r,n,o=function(){var t=function(t,e){var r=t,n=a[e],o=null,i=0,u=null,v=[],y={},_=function(t,e){o=function(t){for(var e=new Array(t),r=0;r<t;r+=1){e[r]=new Array(t);for(var n=0;n<t;n+=1)e[r][n]=null;}return e}(i=4*r+17),m(0,0),m(i-7,0),m(0,i-7),x(),b(),S(t,e),r>=7&&M(t),null==u&&(u=P(r,n,v)),C(u,e);},m=function(t,e){for(var r=-1;r<=7;r+=1)if(!(t+r<=-1||i<=t+r))for(var n=-1;n<=7;n+=1)e+n<=-1||i<=e+n||(o[t+r][e+n]=0<=r&&r<=6&&(0==n||6==n)||0<=n&&n<=6&&(0==r||6==r)||2<=r&&r<=4&&2<=n&&n<=4);},b=function(){for(var t=8;t<i-8;t+=1)null==o[t][6]&&(o[t][6]=t%2==0);for(var e=8;e<i-8;e+=1)null==o[6][e]&&(o[6][e]=e%2==0);},x=function(){for(var t=s.getPatternPosition(r),e=0;e<t.length;e+=1)for(var n=0;n<t.length;n+=1){var i=t[e],a=t[n];if(null==o[i][a])for(var u=-2;u<=2;u+=1)for(var c=-2;c<=2;c+=1)o[i+u][a+c]=-2==u||2==u||-2==c||2==c||0==u&&0==c;}},M=function(t){for(var e=s.getBCHTypeNumber(r),n=0;n<18;n+=1){var a=!t&&1==(e>>n&1);o[Math.floor(n/3)][n%3+i-8-3]=a;}for(n=0;n<18;n+=1)a=!t&&1==(e>>n&1),o[n%3+i-8-3][Math.floor(n/3)]=a;},S=function(t,e){for(var r=n<<3|e,a=s.getBCHTypeInfo(r),u=0;u<15;u+=1){var c=!t&&1==(a>>u&1);u<6?o[u][8]=c:u<8?o[u+1][8]=c:o[i-15+u][8]=c;}for(u=0;u<15;u+=1)c=!t&&1==(a>>u&1),u<8?o[8][i-u-1]=c:u<9?o[8][15-u-1+1]=c:o[8][15-u-1]=c;o[i-8][8]=!t;},C=function(t,e){for(var r=-1,n=i-1,a=7,u=0,c=s.getMaskFunction(e),h=i-1;h>0;h-=2)for(6==h&&(h-=1);;){for(var d=0;d<2;d+=1)if(null==o[n][h-d]){var l=!1;u<t.length&&(l=1==(t[u]>>>a&1)),c(n,h-d)&&(l=!l),o[n][h-d]=l,-1==(a-=1)&&(u+=1,a=7);}if((n+=r)<0||i<=n){n-=r,r=-r;break}}},P=function(t,e,r){for(var n=h.getRSBlocks(t,e),o=d(),i=0;i<r.length;i+=1){var a=r[i];o.put(a.getMode(),4),o.put(a.getLength(),s.getLengthInBits(a.getMode(),t)),a.write(o);}var u=0;for(i=0;i<n.length;i+=1)u+=n[i].dataCount;if(o.getLengthInBits()>8*u)throw "code length overflow. ("+o.getLengthInBits()+">"+8*u+")";for(o.getLengthInBits()+4<=8*u&&o.put(0,4);o.getLengthInBits()%8!=0;)o.putBit(!1);for(;!(o.getLengthInBits()>=8*u||(o.put(236,8),o.getLengthInBits()>=8*u));)o.put(17,8);return function(t,e){for(var r=0,n=0,o=0,i=new Array(e.length),a=new Array(e.length),u=0;u<e.length;u+=1){var h=e[u].dataCount,d=e[u].totalCount-h;n=Math.max(n,h),o=Math.max(o,d),i[u]=new Array(h);for(var l=0;l<i[u].length;l+=1)i[u][l]=255&t.getBuffer()[l+r];r+=h;var f=s.getErrorCorrectPolynomial(d),p=c(i[u],f.getLength()-1).mod(f);for(a[u]=new Array(f.getLength()-1),l=0;l<a[u].length;l+=1){var g=l+p.getLength()-a[u].length;a[u][l]=g>=0?p.getAt(g):0;}}var v=0;for(l=0;l<e.length;l+=1)v+=e[l].totalCount;var y=new Array(v),w=0;for(l=0;l<n;l+=1)for(u=0;u<e.length;u+=1)l<i[u].length&&(y[w]=i[u][l],w+=1);for(l=0;l<o;l+=1)for(u=0;u<e.length;u+=1)l<a[u].length&&(y[w]=a[u][l],w+=1);return y}(o,n)};y.addData=function(t,e){var r=null;switch(e=e||"Byte"){case"Numeric":r=l(t);break;case"Alphanumeric":r=f(t);break;case"Byte":r=p(t);break;case"Kanji":r=g(t);break;default:throw "mode:"+e}v.push(r),u=null;},y.isDark=function(t,e){if(t<0||i<=t||e<0||i<=e)throw t+","+e;return o[t][e]},y.getModuleCount=function(){return i},y.make=function(){if(r<1){for(var t=1;t<40;t++){for(var e=h.getRSBlocks(t,n),o=d(),i=0;i<v.length;i++){var a=v[i];o.put(a.getMode(),4),o.put(a.getLength(),s.getLengthInBits(a.getMode(),t)),a.write(o);}var u=0;for(i=0;i<e.length;i++)u+=e[i].dataCount;if(o.getLengthInBits()<=8*u)break}r=t;}_(!1,function(){for(var t=0,e=0,r=0;r<8;r+=1){_(!0,r);var n=s.getLostPoint(y);(0==r||t>n)&&(t=n,e=r);}return e}());},y.createTableTag=function(t,e){t=t||2;var r="";r+='<table style="',r+=" border-width: 0px; border-style: none;",r+=" border-collapse: collapse;",r+=" padding: 0px; margin: "+(e=void 0===e?4*t:e)+"px;",r+='">',r+="<tbody>";for(var n=0;n<y.getModuleCount();n+=1){r+="<tr>";for(var o=0;o<y.getModuleCount();o+=1)r+='<td style="',r+=" border-width: 0px; border-style: none;",r+=" border-collapse: collapse;",r+=" padding: 0px; margin: 0px;",r+=" width: "+t+"px;",r+=" height: "+t+"px;",r+=" background-color: ",r+=y.isDark(n,o)?"#000000":"#ffffff",r+=";",r+='"/>';r+="</tr>";}return (r+="</tbody>")+"</table>"},y.createSvgTag=function(t,e,r,n){var o={};"object"==typeof arguments[0]&&(t=(o=arguments[0]).cellSize,e=o.margin,r=o.alt,n=o.title),t=t||2,e=void 0===e?4*t:e,(r="string"==typeof r?{text:r}:r||{}).text=r.text||null,r.id=r.text?r.id||"qrcode-description":null,(n="string"==typeof n?{text:n}:n||{}).text=n.text||null,n.id=n.text?n.id||"qrcode-title":null;var i,a,s,u,c=y.getModuleCount()*t+2*e,h="";for(u="l"+t+",0 0,"+t+" -"+t+",0 0,-"+t+"z ",h+='<svg version="1.1" xmlns="http://www.w3.org/2000/svg"',h+=o.scalable?"":' width="'+c+'px" height="'+c+'px"',h+=' viewBox="0 0 '+c+" "+c+'" ',h+=' preserveAspectRatio="xMinYMin meet"',h+=n.text||r.text?' role="img" aria-labelledby="'+O([n.id,r.id].join(" ").trim())+'"':"",h+=">",h+=n.text?'<title id="'+O(n.id)+'">'+O(n.text)+"</title>":"",h+=r.text?'<description id="'+O(r.id)+'">'+O(r.text)+"</description>":"",h+='<rect width="100%" height="100%" fill="white" cx="0" cy="0"/>',h+='<path d="',a=0;a<y.getModuleCount();a+=1)for(s=a*t+e,i=0;i<y.getModuleCount();i+=1)y.isDark(a,i)&&(h+="M"+(i*t+e)+","+s+u);return (h+='" stroke="transparent" fill="black"/>')+"</svg>"},y.createDataURL=function(t,e){t=t||2,e=void 0===e?4*t:e;var r=y.getModuleCount()*t+2*e,n=e,o=r-e;return w(r,r,(function(e,r){if(n<=e&&e<o&&n<=r&&r<o){var i=Math.floor((e-n)/t),a=Math.floor((r-n)/t);return y.isDark(a,i)?0:1}return 1}))},y.createImgTag=function(t,e,r){t=t||2,e=void 0===e?4*t:e;var n=y.getModuleCount()*t+2*e,o="";return o+="<img",o+=' src="',o+=y.createDataURL(t,e),o+='"',o+=' width="',o+=n,o+='"',o+=' height="',o+=n,o+='"',r&&(o+=' alt="',o+=O(r),o+='"'),o+"/>"};var O=function(t){for(var e="",r=0;r<t.length;r+=1){var n=t.charAt(r);switch(n){case"<":e+="&lt;";break;case">":e+="&gt;";break;case"&":e+="&amp;";break;case'"':e+="&quot;";break;default:e+=n;}}return e};return y.createASCII=function(t,e){if((t=t||1)<2)return function(t){t=void 0===t?2:t;var e,r,n,o,i,a=1*y.getModuleCount()+2*t,s=t,u=a-t,c={"██":"█","█ ":"▀"," █":"▄","  ":" "},h={"██":"▀","█ ":"▀"," █":" ","  ":" "},d="";for(e=0;e<a;e+=2){for(n=Math.floor((e-s)/1),o=Math.floor((e+1-s)/1),r=0;r<a;r+=1)i="█",s<=r&&r<u&&s<=e&&e<u&&y.isDark(n,Math.floor((r-s)/1))&&(i=" "),s<=r&&r<u&&s<=e+1&&e+1<u&&y.isDark(o,Math.floor((r-s)/1))?i+=" ":i+="█",d+=t<1&&e+1>=u?h[i]:c[i];d+="\n";}return a%2&&t>0?d.substring(0,d.length-a-1)+Array(a+1).join("▀"):d.substring(0,d.length-1)}(e);t-=1,e=void 0===e?2*t:e;var r,n,o,i,a=y.getModuleCount()*t+2*e,s=e,u=a-e,c=Array(t+1).join("██"),h=Array(t+1).join("  "),d="",l="";for(r=0;r<a;r+=1){for(o=Math.floor((r-s)/t),l="",n=0;n<a;n+=1)i=1,s<=n&&n<u&&s<=r&&r<u&&y.isDark(o,Math.floor((n-s)/t))&&(i=0),l+=i?c:h;for(o=0;o<t;o+=1)d+=l+"\n";}return d.substring(0,d.length-1)},y.renderTo2dContext=function(t,e){e=e||2;for(var r=y.getModuleCount(),n=0;n<r;n++)for(var o=0;o<r;o++)t.fillStyle=y.isDark(n,o)?"black":"white",t.fillRect(n*e,o*e,e,e);},y};t.stringToBytes=(t.stringToBytesFuncs={default:function(t){for(var e=[],r=0;r<t.length;r+=1){var n=t.charCodeAt(r);e.push(255&n);}return e}}).default,t.createStringToBytes=function(t,e){var r=function(){for(var r=y(t),n=function(){var t=r.read();if(-1==t)throw "eof";return t},o=0,i={};;){var a=r.read();if(-1==a)break;var s=n(),u=n()<<8|n();i[String.fromCharCode(a<<8|s)]=u,o+=1;}if(o!=e)throw o+" != "+e;return i}(),n="?".charCodeAt(0);return function(t){for(var e=[],o=0;o<t.length;o+=1){var i=t.charCodeAt(o);if(i<128)e.push(i);else {var a=r[t.charAt(o)];"number"==typeof a?(255&a)==a?e.push(a):(e.push(a>>>8),e.push(255&a)):e.push(n);}}return e}};var e,r,n,o,i,a={L:1,M:0,Q:3,H:2},s=(e=[[],[6,18],[6,22],[6,26],[6,30],[6,34],[6,22,38],[6,24,42],[6,26,46],[6,28,50],[6,30,54],[6,32,58],[6,34,62],[6,26,46,66],[6,26,48,70],[6,26,50,74],[6,30,54,78],[6,30,56,82],[6,30,58,86],[6,34,62,90],[6,28,50,72,94],[6,26,50,74,98],[6,30,54,78,102],[6,28,54,80,106],[6,32,58,84,110],[6,30,58,86,114],[6,34,62,90,118],[6,26,50,74,98,122],[6,30,54,78,102,126],[6,26,52,78,104,130],[6,30,56,82,108,134],[6,34,60,86,112,138],[6,30,58,86,114,142],[6,34,62,90,118,146],[6,30,54,78,102,126,150],[6,24,50,76,102,128,154],[6,28,54,80,106,132,158],[6,32,58,84,110,136,162],[6,26,54,82,110,138,166],[6,30,58,86,114,142,170]],r=1335,n=7973,i=function(t){for(var e=0;0!=t;)e+=1,t>>>=1;return e},(o={}).getBCHTypeInfo=function(t){for(var e=t<<10;i(e)-i(r)>=0;)e^=r<<i(e)-i(r);return 21522^(t<<10|e)},o.getBCHTypeNumber=function(t){for(var e=t<<12;i(e)-i(n)>=0;)e^=n<<i(e)-i(n);return t<<12|e},o.getPatternPosition=function(t){return e[t-1]},o.getMaskFunction=function(t){switch(t){case 0:return function(t,e){return (t+e)%2==0};case 1:return function(t,e){return t%2==0};case 2:return function(t,e){return e%3==0};case 3:return function(t,e){return (t+e)%3==0};case 4:return function(t,e){return (Math.floor(t/2)+Math.floor(e/3))%2==0};case 5:return function(t,e){return t*e%2+t*e%3==0};case 6:return function(t,e){return (t*e%2+t*e%3)%2==0};case 7:return function(t,e){return (t*e%3+(t+e)%2)%2==0};default:throw "bad maskPattern:"+t}},o.getErrorCorrectPolynomial=function(t){for(var e=c([1],0),r=0;r<t;r+=1)e=e.multiply(c([1,u.gexp(r)],0));return e},o.getLengthInBits=function(t,e){if(1<=e&&e<10)switch(t){case 1:return 10;case 2:return 9;case 4:case 8:return 8;default:throw "mode:"+t}else if(e<27)switch(t){case 1:return 12;case 2:return 11;case 4:return 16;case 8:return 10;default:throw "mode:"+t}else {if(!(e<41))throw "type:"+e;switch(t){case 1:return 14;case 2:return 13;case 4:return 16;case 8:return 12;default:throw "mode:"+t}}},o.getLostPoint=function(t){for(var e=t.getModuleCount(),r=0,n=0;n<e;n+=1)for(var o=0;o<e;o+=1){for(var i=0,a=t.isDark(n,o),s=-1;s<=1;s+=1)if(!(n+s<0||e<=n+s))for(var u=-1;u<=1;u+=1)o+u<0||e<=o+u||0==s&&0==u||a==t.isDark(n+s,o+u)&&(i+=1);i>5&&(r+=3+i-5);}for(n=0;n<e-1;n+=1)for(o=0;o<e-1;o+=1){var c=0;t.isDark(n,o)&&(c+=1),t.isDark(n+1,o)&&(c+=1),t.isDark(n,o+1)&&(c+=1),t.isDark(n+1,o+1)&&(c+=1),0!=c&&4!=c||(r+=3);}for(n=0;n<e;n+=1)for(o=0;o<e-6;o+=1)t.isDark(n,o)&&!t.isDark(n,o+1)&&t.isDark(n,o+2)&&t.isDark(n,o+3)&&t.isDark(n,o+4)&&!t.isDark(n,o+5)&&t.isDark(n,o+6)&&(r+=40);for(o=0;o<e;o+=1)for(n=0;n<e-6;n+=1)t.isDark(n,o)&&!t.isDark(n+1,o)&&t.isDark(n+2,o)&&t.isDark(n+3,o)&&t.isDark(n+4,o)&&!t.isDark(n+5,o)&&t.isDark(n+6,o)&&(r+=40);var h=0;for(o=0;o<e;o+=1)for(n=0;n<e;n+=1)t.isDark(n,o)&&(h+=1);return r+Math.abs(100*h/e/e-50)/5*10},o),u=function(){for(var t=new Array(256),e=new Array(256),r=0;r<8;r+=1)t[r]=1<<r;for(r=8;r<256;r+=1)t[r]=t[r-4]^t[r-5]^t[r-6]^t[r-8];for(r=0;r<255;r+=1)e[t[r]]=r;return {glog:function(t){if(t<1)throw "glog("+t+")";return e[t]},gexp:function(e){for(;e<0;)e+=255;for(;e>=256;)e-=255;return t[e]}}}();function c(t,e){if(void 0===t.length)throw t.length+"/"+e;var r=function(){for(var r=0;r<t.length&&0==t[r];)r+=1;for(var n=new Array(t.length-r+e),o=0;o<t.length-r;o+=1)n[o]=t[o+r];return n}(),n={getAt:function(t){return r[t]},getLength:function(){return r.length},multiply:function(t){for(var e=new Array(n.getLength()+t.getLength()-1),r=0;r<n.getLength();r+=1)for(var o=0;o<t.getLength();o+=1)e[r+o]^=u.gexp(u.glog(n.getAt(r))+u.glog(t.getAt(o)));return c(e,0)},mod:function(t){if(n.getLength()-t.getLength()<0)return n;for(var e=u.glog(n.getAt(0))-u.glog(t.getAt(0)),r=new Array(n.getLength()),o=0;o<n.getLength();o+=1)r[o]=n.getAt(o);for(o=0;o<t.getLength();o+=1)r[o]^=u.gexp(u.glog(t.getAt(o))+e);return c(r,0).mod(t)}};return n}var h=function(){var t=[[1,26,19],[1,26,16],[1,26,13],[1,26,9],[1,44,34],[1,44,28],[1,44,22],[1,44,16],[1,70,55],[1,70,44],[2,35,17],[2,35,13],[1,100,80],[2,50,32],[2,50,24],[4,25,9],[1,134,108],[2,67,43],[2,33,15,2,34,16],[2,33,11,2,34,12],[2,86,68],[4,43,27],[4,43,19],[4,43,15],[2,98,78],[4,49,31],[2,32,14,4,33,15],[4,39,13,1,40,14],[2,121,97],[2,60,38,2,61,39],[4,40,18,2,41,19],[4,40,14,2,41,15],[2,146,116],[3,58,36,2,59,37],[4,36,16,4,37,17],[4,36,12,4,37,13],[2,86,68,2,87,69],[4,69,43,1,70,44],[6,43,19,2,44,20],[6,43,15,2,44,16],[4,101,81],[1,80,50,4,81,51],[4,50,22,4,51,23],[3,36,12,8,37,13],[2,116,92,2,117,93],[6,58,36,2,59,37],[4,46,20,6,47,21],[7,42,14,4,43,15],[4,133,107],[8,59,37,1,60,38],[8,44,20,4,45,21],[12,33,11,4,34,12],[3,145,115,1,146,116],[4,64,40,5,65,41],[11,36,16,5,37,17],[11,36,12,5,37,13],[5,109,87,1,110,88],[5,65,41,5,66,42],[5,54,24,7,55,25],[11,36,12,7,37,13],[5,122,98,1,123,99],[7,73,45,3,74,46],[15,43,19,2,44,20],[3,45,15,13,46,16],[1,135,107,5,136,108],[10,74,46,1,75,47],[1,50,22,15,51,23],[2,42,14,17,43,15],[5,150,120,1,151,121],[9,69,43,4,70,44],[17,50,22,1,51,23],[2,42,14,19,43,15],[3,141,113,4,142,114],[3,70,44,11,71,45],[17,47,21,4,48,22],[9,39,13,16,40,14],[3,135,107,5,136,108],[3,67,41,13,68,42],[15,54,24,5,55,25],[15,43,15,10,44,16],[4,144,116,4,145,117],[17,68,42],[17,50,22,6,51,23],[19,46,16,6,47,17],[2,139,111,7,140,112],[17,74,46],[7,54,24,16,55,25],[34,37,13],[4,151,121,5,152,122],[4,75,47,14,76,48],[11,54,24,14,55,25],[16,45,15,14,46,16],[6,147,117,4,148,118],[6,73,45,14,74,46],[11,54,24,16,55,25],[30,46,16,2,47,17],[8,132,106,4,133,107],[8,75,47,13,76,48],[7,54,24,22,55,25],[22,45,15,13,46,16],[10,142,114,2,143,115],[19,74,46,4,75,47],[28,50,22,6,51,23],[33,46,16,4,47,17],[8,152,122,4,153,123],[22,73,45,3,74,46],[8,53,23,26,54,24],[12,45,15,28,46,16],[3,147,117,10,148,118],[3,73,45,23,74,46],[4,54,24,31,55,25],[11,45,15,31,46,16],[7,146,116,7,147,117],[21,73,45,7,74,46],[1,53,23,37,54,24],[19,45,15,26,46,16],[5,145,115,10,146,116],[19,75,47,10,76,48],[15,54,24,25,55,25],[23,45,15,25,46,16],[13,145,115,3,146,116],[2,74,46,29,75,47],[42,54,24,1,55,25],[23,45,15,28,46,16],[17,145,115],[10,74,46,23,75,47],[10,54,24,35,55,25],[19,45,15,35,46,16],[17,145,115,1,146,116],[14,74,46,21,75,47],[29,54,24,19,55,25],[11,45,15,46,46,16],[13,145,115,6,146,116],[14,74,46,23,75,47],[44,54,24,7,55,25],[59,46,16,1,47,17],[12,151,121,7,152,122],[12,75,47,26,76,48],[39,54,24,14,55,25],[22,45,15,41,46,16],[6,151,121,14,152,122],[6,75,47,34,76,48],[46,54,24,10,55,25],[2,45,15,64,46,16],[17,152,122,4,153,123],[29,74,46,14,75,47],[49,54,24,10,55,25],[24,45,15,46,46,16],[4,152,122,18,153,123],[13,74,46,32,75,47],[48,54,24,14,55,25],[42,45,15,32,46,16],[20,147,117,4,148,118],[40,75,47,7,76,48],[43,54,24,22,55,25],[10,45,15,67,46,16],[19,148,118,6,149,119],[18,75,47,31,76,48],[34,54,24,34,55,25],[20,45,15,61,46,16]],e=function(t,e){var r={};return r.totalCount=t,r.dataCount=e,r},r={getRSBlocks:function(r,n){var o=function(e,r){switch(r){case a.L:return t[4*(e-1)+0];case a.M:return t[4*(e-1)+1];case a.Q:return t[4*(e-1)+2];case a.H:return t[4*(e-1)+3];default:return}}(r,n);if(void 0===o)throw "bad rs block @ typeNumber:"+r+"/errorCorrectionLevel:"+n;for(var i=o.length/3,s=[],u=0;u<i;u+=1)for(var c=o[3*u+0],h=o[3*u+1],d=o[3*u+2],l=0;l<c;l+=1)s.push(e(h,d));return s}};return r}(),d=function(){var t=[],e=0,r={getBuffer:function(){return t},getAt:function(e){var r=Math.floor(e/8);return 1==(t[r]>>>7-e%8&1)},put:function(t,e){for(var n=0;n<e;n+=1)r.putBit(1==(t>>>e-n-1&1));},getLengthInBits:function(){return e},putBit:function(r){var n=Math.floor(e/8);t.length<=n&&t.push(0),r&&(t[n]|=128>>>e%8),e+=1;}};return r},l=function(t){var e=t,r={getMode:function(){return 1},getLength:function(t){return e.length},write:function(t){for(var r=e,o=0;o+2<r.length;)t.put(n(r.substring(o,o+3)),10),o+=3;o<r.length&&(r.length-o==1?t.put(n(r.substring(o,o+1)),4):r.length-o==2&&t.put(n(r.substring(o,o+2)),7));}},n=function(t){for(var e=0,r=0;r<t.length;r+=1)e=10*e+o(t.charAt(r));return e},o=function(t){if("0"<=t&&t<="9")return t.charCodeAt(0)-"0".charCodeAt(0);throw "illegal char :"+t};return r},f=function(t){var e=t,r={getMode:function(){return 2},getLength:function(t){return e.length},write:function(t){for(var r=e,o=0;o+1<r.length;)t.put(45*n(r.charAt(o))+n(r.charAt(o+1)),11),o+=2;o<r.length&&t.put(n(r.charAt(o)),6);}},n=function(t){if("0"<=t&&t<="9")return t.charCodeAt(0)-"0".charCodeAt(0);if("A"<=t&&t<="Z")return t.charCodeAt(0)-"A".charCodeAt(0)+10;switch(t){case" ":return 36;case"$":return 37;case"%":return 38;case"*":return 39;case"+":return 40;case"-":return 41;case".":return 42;case"/":return 43;case":":return 44;default:throw "illegal char :"+t}};return r},p=function(e){var r=t.stringToBytes(e);return {getMode:function(){return 4},getLength:function(t){return r.length},write:function(t){for(var e=0;e<r.length;e+=1)t.put(r[e],8);}}},g=function(e){var r=t.stringToBytesFuncs.SJIS;if(!r)throw "sjis not supported.";!function(t,e){var n=r("友");if(2!=n.length||38726!=(n[0]<<8|n[1]))throw "sjis not supported."}();var n=r(e);return {getMode:function(){return 8},getLength:function(t){return ~~(n.length/2)},write:function(t){for(var e=n,r=0;r+1<e.length;){var o=(255&e[r])<<8|255&e[r+1];if(33088<=o&&o<=40956)o-=33088;else {if(!(57408<=o&&o<=60351))throw "illegal char at "+(r+1)+"/"+o;o-=49472;}o=192*(o>>>8&255)+(255&o),t.put(o,13),r+=2;}if(r<e.length)throw "illegal char at "+(r+1)}}},v=function(){var t=[],e={writeByte:function(e){t.push(255&e);},writeShort:function(t){e.writeByte(t),e.writeByte(t>>>8);},writeBytes:function(t,r,n){r=r||0,n=n||t.length;for(var o=0;o<n;o+=1)e.writeByte(t[o+r]);},writeString:function(t){for(var r=0;r<t.length;r+=1)e.writeByte(t.charCodeAt(r));},toByteArray:function(){return t},toString:function(){var e="";e+="[";for(var r=0;r<t.length;r+=1)r>0&&(e+=","),e+=t[r];return e+"]"}};return e},y=function(t){var e=t,r=0,n=0,o=0,i={read:function(){for(;o<8;){if(r>=e.length){if(0==o)return -1;throw "unexpected end of file./"+o}var t=e.charAt(r);if(r+=1,"="==t)return o=0,-1;t.match(/^\s$/)||(n=n<<6|a(t.charCodeAt(0)),o+=6);}var i=n>>>o-8&255;return o-=8,i}},a=function(t){if(65<=t&&t<=90)return t-65;if(97<=t&&t<=122)return t-97+26;if(48<=t&&t<=57)return t-48+52;if(43==t)return 62;if(47==t)return 63;throw "c:"+t};return i},w=function(t,e,r){for(var n=function(t,e){var r=t,n=e,o=new Array(t*e),i={setPixel:function(t,e,n){o[e*r+t]=n;},write:function(t){t.writeString("GIF87a"),t.writeShort(r),t.writeShort(n),t.writeByte(128),t.writeByte(0),t.writeByte(0),t.writeByte(0),t.writeByte(0),t.writeByte(0),t.writeByte(255),t.writeByte(255),t.writeByte(255),t.writeString(","),t.writeShort(0),t.writeShort(0),t.writeShort(r),t.writeShort(n),t.writeByte(0);var e=a(2);t.writeByte(2);for(var o=0;e.length-o>255;)t.writeByte(255),t.writeBytes(e,o,255),o+=255;t.writeByte(e.length-o),t.writeBytes(e,o,e.length-o),t.writeByte(0),t.writeString(";");}},a=function(t){for(var e=1<<t,r=1+(1<<t),n=t+1,i=s(),a=0;a<e;a+=1)i.add(String.fromCharCode(a));i.add(String.fromCharCode(e)),i.add(String.fromCharCode(r));var u,c,h,d=v(),l=(u=d,c=0,h=0,{write:function(t,e){if(t>>>e!=0)throw "length over";for(;c+e>=8;)u.writeByte(255&(t<<c|h)),e-=8-c,t>>>=8-c,h=0,c=0;h|=t<<c,c+=e;},flush:function(){c>0&&u.writeByte(h);}});l.write(e,n);var f=0,p=String.fromCharCode(o[f]);for(f+=1;f<o.length;){var g=String.fromCharCode(o[f]);f+=1,i.contains(p+g)?p+=g:(l.write(i.indexOf(p),n),i.size()<4095&&(i.size()==1<<n&&(n+=1),i.add(p+g)),p=g);}return l.write(i.indexOf(p),n),l.write(r,n),l.flush(),d.toByteArray()},s=function(){var t={},e=0,r={add:function(n){if(r.contains(n))throw "dup key:"+n;t[n]=e,e+=1;},size:function(){return e},indexOf:function(e){return t[e]},contains:function(e){return void 0!==t[e]}};return r};return i}(t,e),o=0;o<e;o+=1)for(var i=0;i<t;i+=1)n.setPixel(i,o,r(i,o));var a=v();n.write(a);for(var s=function(){var t=0,e=0,r=0,n="",o={},i=function(t){n+=String.fromCharCode(a(63&t));},a=function(t){if(t<0);else {if(t<26)return 65+t;if(t<52)return t-26+97;if(t<62)return t-52+48;if(62==t)return 43;if(63==t)return 47}throw "n:"+t};return o.writeByte=function(n){for(t=t<<8|255&n,e+=8,r+=1;e>=6;)i(t>>>e-6),e-=6;},o.flush=function(){if(e>0&&(i(t<<6-e),t=0,e=0),r%3!=0)for(var o=3-r%3,a=0;a<o;a+=1)n+="=";},o.toString=function(){return n},o}(),u=a.toByteArray(),c=0;c<u.length;c+=1)s.writeByte(u[c]);return s.flush(),"data:image/gif;base64,"+s};return t}();o.stringToBytesFuncs["UTF-8"]=function(t){return function(t){for(var e=[],r=0;r<t.length;r++){var n=t.charCodeAt(r);n<128?e.push(n):n<2048?e.push(192|n>>6,128|63&n):n<55296||n>=57344?e.push(224|n>>12,128|n>>6&63,128|63&n):(r++,n=65536+((1023&n)<<10|1023&t.charCodeAt(r)),e.push(240|n>>18,128|n>>12&63,128|n>>6&63,128|63&n));}return e}(t)},void 0===(n="function"==typeof(r=function(){return o})?r.apply(e,[]):r)||(t.exports=n);},796:(t,e,r)=>{r.d(e,{default:()=>W});var n=function(){return (n=Object.assign||function(t){for(var e,r=1,n=arguments.length;r<n;r++)for(var o in e=arguments[r])Object.prototype.hasOwnProperty.call(e,o)&&(t[o]=e[o]);return t}).apply(this,arguments)},o=function(){for(var t=0,e=0,r=arguments.length;e<r;e++)t+=arguments[e].length;var n=Array(t),o=0;for(e=0;e<r;e++)for(var i=arguments[e],a=0,s=i.length;a<s;a++,o++)n[o]=i[a];return n},i=function(t){return !!t&&"object"==typeof t&&!Array.isArray(t)};function a(t){for(var e=[],r=1;r<arguments.length;r++)e[r-1]=arguments[r];if(!e.length)return t;var s=e.shift();return void 0!==s&&i(t)&&i(s)?(t=n({},t),Object.keys(s).forEach((function(e){var r=t[e],n=s[e];Array.isArray(r)&&Array.isArray(n)?t[e]=n:i(r)&&i(n)?t[e]=a(Object.assign({},r),n):t[e]=n;})),a.apply(void 0,o([t],e))):t}function s(t,e){var r=document.createElement("a");r.download=e,r.href=t,document.body.appendChild(r),r.click(),document.body.removeChild(r);}function u(t){var e=t.originalHeight,r=t.originalWidth,n=t.maxHiddenDots,o=t.maxHiddenAxisDots,i=t.dotSize,a={x:0,y:0},s={x:0,y:0};if(e<=0||r<=0||n<=0||i<=0)return {height:0,width:0,hideYDots:0,hideXDots:0};var u=e/r;return a.x=Math.floor(Math.sqrt(n/u)),a.x<=0&&(a.x=1),o&&o<a.x&&(a.x=o),a.x%2==0&&a.x--,s.x=a.x*i,a.y=1+2*Math.ceil((a.x*u-1)/2),s.y=Math.round(s.x*u),(a.y*a.x>n||o&&o<a.y)&&(o&&o<a.y?(a.y=o,a.y%2==0&&a.x--):a.y-=2,s.y=a.y*i,a.x=1+2*Math.ceil((a.y/u-1)/2),s.x=Math.round(s.y/u)),{height:s.y,width:s.x,hideYDots:a.y,hideXDots:a.x}}const c={L:.07,M:.15,Q:.25,H:.3},h="dots",d="rounded",l="classy",f="classy-rounded",p="square",g="extra-rounded";var v=function(){return (v=Object.assign||function(t){for(var e,r=1,n=arguments.length;r<n;r++)for(var o in e=arguments[r])Object.prototype.hasOwnProperty.call(e,o)&&(t[o]=e[o]);return t}).apply(this,arguments)};const y=function(){function t(t){var e=t.context,r=t.type;this._context=e,this._type=r;}return t.prototype.draw=function(t,e,r,n){var o,i=this._context;switch(this._type){case h:o=this._drawDot;break;case l:o=this._drawClassy;break;case f:o=this._drawClassyRounded;break;case d:o=this._drawRounded;break;case g:o=this._drawExtraRounded;break;case p:default:o=this._drawSquare;}o.call(this,{x:t,y:e,size:r,context:i,getNeighbor:n});},t.prototype._rotateFigure=function(t){var e=t.x,r=t.y,n=t.size,o=t.context,i=t.rotation,a=void 0===i?0:i,s=t.draw,u=e+n/2,c=r+n/2;o.translate(u,c),a&&o.rotate(a),s(),o.closePath(),a&&o.rotate(-a),o.translate(-u,-c);},t.prototype._basicDot=function(t){var e=t.size,r=t.context;this._rotateFigure(v(v({},t),{draw:function(){r.arc(0,0,e/2,0,2*Math.PI);}}));},t.prototype._basicSquare=function(t){var e=t.size,r=t.context;this._rotateFigure(v(v({},t),{draw:function(){r.rect(-e/2,-e/2,e,e);}}));},t.prototype._basicSideRounded=function(t){var e=t.size,r=t.context;this._rotateFigure(v(v({},t),{draw:function(){r.arc(0,0,e/2,-Math.PI/2,Math.PI/2),r.lineTo(-e/2,e/2),r.lineTo(-e/2,-e/2),r.lineTo(0,-e/2);}}));},t.prototype._basicCornerRounded=function(t){var e=t.size,r=t.context;this._rotateFigure(v(v({},t),{draw:function(){r.arc(0,0,e/2,-Math.PI/2,0),r.lineTo(e/2,e/2),r.lineTo(-e/2,e/2),r.lineTo(-e/2,-e/2),r.lineTo(0,-e/2);}}));},t.prototype._basicCornerExtraRounded=function(t){var e=t.size,r=t.context;this._rotateFigure(v(v({},t),{draw:function(){r.arc(-e/2,e/2,e,-Math.PI/2,0),r.lineTo(-e/2,e/2),r.lineTo(-e/2,-e/2);}}));},t.prototype._basicCornersRounded=function(t){var e=t.size,r=t.context;this._rotateFigure(v(v({},t),{draw:function(){r.arc(0,0,e/2,-Math.PI/2,0),r.lineTo(e/2,e/2),r.lineTo(0,e/2),r.arc(0,0,e/2,Math.PI/2,Math.PI),r.lineTo(-e/2,-e/2),r.lineTo(0,-e/2);}}));},t.prototype._basicCornersExtraRounded=function(t){var e=t.size,r=t.context;this._rotateFigure(v(v({},t),{draw:function(){r.arc(-e/2,e/2,e,-Math.PI/2,0),r.arc(e/2,-e/2,e,Math.PI/2,Math.PI);}}));},t.prototype._drawDot=function(t){var e=t.x,r=t.y,n=t.size,o=t.context;this._basicDot({x:e,y:r,size:n,context:o,rotation:0});},t.prototype._drawSquare=function(t){var e=t.x,r=t.y,n=t.size,o=t.context;this._basicSquare({x:e,y:r,size:n,context:o,rotation:0});},t.prototype._drawRounded=function(t){var e=t.x,r=t.y,n=t.size,o=t.context,i=t.getNeighbor,a=i?+i(-1,0):0,s=i?+i(1,0):0,u=i?+i(0,-1):0,c=i?+i(0,1):0,h=a+s+u+c;if(0!==h)if(h>2||a&&s||u&&c)this._basicSquare({x:e,y:r,size:n,context:o,rotation:0});else {if(2===h){var d=0;return a&&u?d=Math.PI/2:u&&s?d=Math.PI:s&&c&&(d=-Math.PI/2),void this._basicCornerRounded({x:e,y:r,size:n,context:o,rotation:d})}if(1===h)return d=0,u?d=Math.PI/2:s?d=Math.PI:c&&(d=-Math.PI/2),void this._basicSideRounded({x:e,y:r,size:n,context:o,rotation:d})}else this._basicDot({x:e,y:r,size:n,context:o,rotation:0});},t.prototype._drawExtraRounded=function(t){var e=t.x,r=t.y,n=t.size,o=t.context,i=t.getNeighbor,a=i?+i(-1,0):0,s=i?+i(1,0):0,u=i?+i(0,-1):0,c=i?+i(0,1):0,h=a+s+u+c;if(0!==h)if(h>2||a&&s||u&&c)this._basicSquare({x:e,y:r,size:n,context:o,rotation:0});else {if(2===h){var d=0;return a&&u?d=Math.PI/2:u&&s?d=Math.PI:s&&c&&(d=-Math.PI/2),void this._basicCornerExtraRounded({x:e,y:r,size:n,context:o,rotation:d})}if(1===h)return d=0,u?d=Math.PI/2:s?d=Math.PI:c&&(d=-Math.PI/2),void this._basicSideRounded({x:e,y:r,size:n,context:o,rotation:d})}else this._basicDot({x:e,y:r,size:n,context:o,rotation:0});},t.prototype._drawClassy=function(t){var e=t.x,r=t.y,n=t.size,o=t.context,i=t.getNeighbor,a=i?+i(-1,0):0,s=i?+i(1,0):0,u=i?+i(0,-1):0,c=i?+i(0,1):0;0!==a+s+u+c?a||u?s||c?this._basicSquare({x:e,y:r,size:n,context:o,rotation:0}):this._basicCornerRounded({x:e,y:r,size:n,context:o,rotation:Math.PI/2}):this._basicCornerRounded({x:e,y:r,size:n,context:o,rotation:-Math.PI/2}):this._basicCornersRounded({x:e,y:r,size:n,context:o,rotation:Math.PI/2});},t.prototype._drawClassyRounded=function(t){var e=t.x,r=t.y,n=t.size,o=t.context,i=t.getNeighbor,a=i?+i(-1,0):0,s=i?+i(1,0):0,u=i?+i(0,-1):0,c=i?+i(0,1):0;0!==a+s+u+c?a||u?s||c?this._basicSquare({x:e,y:r,size:n,context:o,rotation:0}):this._basicCornerExtraRounded({x:e,y:r,size:n,context:o,rotation:Math.PI/2}):this._basicCornerExtraRounded({x:e,y:r,size:n,context:o,rotation:-Math.PI/2}):this._basicCornersRounded({x:e,y:r,size:n,context:o,rotation:Math.PI/2});},t}(),w="square",_="extra-rounded";var m=function(){return (m=Object.assign||function(t){for(var e,r=1,n=arguments.length;r<n;r++)for(var o in e=arguments[r])Object.prototype.hasOwnProperty.call(e,o)&&(t[o]=e[o]);return t}).apply(this,arguments)};const b=function(){function t(t){var e=t.context,r=t.type;this._context=e,this._type=r;}return t.prototype.draw=function(t,e,r,n){var o,i=this._context;switch(this._type){case w:o=this._drawSquare;break;case _:o=this._drawExtraRounded;break;case"dot":default:o=this._drawDot;}o.call(this,{x:t,y:e,size:r,context:i,rotation:n});},t.prototype._rotateFigure=function(t){var e=t.x,r=t.y,n=t.size,o=t.context,i=t.rotation,a=void 0===i?0:i,s=t.draw,u=e+n/2,c=r+n/2;o.translate(u,c),a&&o.rotate(a),s(),o.closePath(),a&&o.rotate(-a),o.translate(-u,-c);},t.prototype._basicDot=function(t){var e=t.size,r=t.context,n=e/7;this._rotateFigure(m(m({},t),{draw:function(){r.arc(0,0,e/2,0,2*Math.PI),r.arc(0,0,e/2-n,0,2*Math.PI);}}));},t.prototype._basicSquare=function(t){var e=t.size,r=t.context,n=e/7;this._rotateFigure(m(m({},t),{draw:function(){r.rect(-e/2,-e/2,e,e),r.rect(-e/2+n,-e/2+n,e-2*n,e-2*n);}}));},t.prototype._basicExtraRounded=function(t){var e=t.size,r=t.context,n=e/7;this._rotateFigure(m(m({},t),{draw:function(){r.arc(-n,-n,2.5*n,Math.PI,-Math.PI/2),r.lineTo(n,-3.5*n),r.arc(n,-n,2.5*n,-Math.PI/2,0),r.lineTo(3.5*n,-n),r.arc(n,n,2.5*n,0,Math.PI/2),r.lineTo(-n,3.5*n),r.arc(-n,n,2.5*n,Math.PI/2,Math.PI),r.lineTo(-3.5*n,-n),r.arc(-n,-n,1.5*n,Math.PI,-Math.PI/2),r.lineTo(n,-2.5*n),r.arc(n,-n,1.5*n,-Math.PI/2,0),r.lineTo(2.5*n,-n),r.arc(n,n,1.5*n,0,Math.PI/2),r.lineTo(-n,2.5*n),r.arc(-n,n,1.5*n,Math.PI/2,Math.PI),r.lineTo(-2.5*n,-n);}}));},t.prototype._drawDot=function(t){var e=t.x,r=t.y,n=t.size,o=t.context,i=t.rotation;this._basicDot({x:e,y:r,size:n,context:o,rotation:i});},t.prototype._drawSquare=function(t){var e=t.x,r=t.y,n=t.size,o=t.context,i=t.rotation;this._basicSquare({x:e,y:r,size:n,context:o,rotation:i});},t.prototype._drawExtraRounded=function(t){var e=t.x,r=t.y,n=t.size,o=t.context,i=t.rotation;this._basicExtraRounded({x:e,y:r,size:n,context:o,rotation:i});},t}(),x="square";var M=function(){return (M=Object.assign||function(t){for(var e,r=1,n=arguments.length;r<n;r++)for(var o in e=arguments[r])Object.prototype.hasOwnProperty.call(e,o)&&(t[o]=e[o]);return t}).apply(this,arguments)};const S=function(){function t(t){var e=t.context,r=t.type;this._context=e,this._type=r;}return t.prototype.draw=function(t,e,r,n){var o,i=this._context;switch(this._type){case x:o=this._drawSquare;break;case"dot":default:o=this._drawDot;}o.call(this,{x:t,y:e,size:r,context:i,rotation:n});},t.prototype._rotateFigure=function(t){var e=t.x,r=t.y,n=t.size,o=t.context,i=t.rotation,a=void 0===i?0:i,s=t.draw,u=e+n/2,c=r+n/2;o.translate(u,c),a&&o.rotate(a),s(),o.closePath(),a&&o.rotate(-a),o.translate(-u,-c);},t.prototype._basicDot=function(t){var e=t.size,r=t.context;this._rotateFigure(M(M({},t),{draw:function(){r.arc(0,0,e/2,0,2*Math.PI);}}));},t.prototype._basicSquare=function(t){var e=t.size,r=t.context;this._rotateFigure(M(M({},t),{draw:function(){r.rect(-e/2,-e/2,e,e);}}));},t.prototype._drawDot=function(t){var e=t.x,r=t.y,n=t.size,o=t.context,i=t.rotation;this._basicDot({x:e,y:r,size:n,context:o,rotation:i});},t.prototype._drawSquare=function(t){var e=t.x,r=t.y,n=t.size,o=t.context,i=t.rotation;this._basicSquare({x:e,y:r,size:n,context:o,rotation:i});},t}(),C="radial";var P=[[1,1,1,1,1,1,1],[1,0,0,0,0,0,1],[1,0,0,0,0,0,1],[1,0,0,0,0,0,1],[1,0,0,0,0,0,1],[1,0,0,0,0,0,1],[1,1,1,1,1,1,1]],O=[[0,0,0,0,0,0,0],[0,0,0,0,0,0,0],[0,0,1,1,1,0,0],[0,0,1,1,1,0,0],[0,0,1,1,1,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,0,0]];const z=function(){function t(t){this._canvas=document.createElement("canvas"),this._canvas.width=t.width,this._canvas.height=t.height,this._options=t;}return Object.defineProperty(t.prototype,"context",{get:function(){return this._canvas.getContext("2d")},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"width",{get:function(){return this._canvas.width},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"height",{get:function(){return this._canvas.height},enumerable:!1,configurable:!0}),t.prototype.getCanvas=function(){return this._canvas},t.prototype.clear=function(){var t=this.context;t&&t.clearRect(0,0,this._canvas.width,this._canvas.height);},t.prototype.drawQR=function(t){return e=this,r=void 0,o=function(){var e,r,n,o,i,a,s,h,d,l=this;return function(t,e){var r,n,o,i,a={label:0,sent:function(){if(1&o[0])throw o[1];return o[1]},trys:[],ops:[]};return i={next:s(0),throw:s(1),return:s(2)},"function"==typeof Symbol&&(i[Symbol.iterator]=function(){return this}),i;function s(i){return function(s){return function(i){if(r)throw new TypeError("Generator is already executing.");for(;a;)try{if(r=1,n&&(o=2&i[0]?n.return:i[0]?n.throw||((o=n.return)&&o.call(n),0):n.next)&&!(o=o.call(n,i[1])).done)return o;switch(n=0,o&&(i=[2&i[0],o.value]),i[0]){case 0:case 1:o=i;break;case 4:return a.label++,{value:i[1],done:!1};case 5:a.label++,n=i[1],i=[0];continue;case 7:i=a.ops.pop(),a.trys.pop();continue;default:if(!((o=(o=a.trys).length>0&&o[o.length-1])||6!==i[0]&&2!==i[0])){a=0;continue}if(3===i[0]&&(!o||i[1]>o[0]&&i[1]<o[3])){a.label=i[1];break}if(6===i[0]&&a.label<o[1]){a.label=o[1],o=i;break}if(o&&a.label<o[2]){a.label=o[2],a.ops.push(i);break}o[2]&&a.ops.pop(),a.trys.pop();continue}i=e.call(t,a);}catch(t){i=[6,t],n=0;}finally{r=o=0;}if(5&i[0])throw i[1];return {value:i[0]?i[1]:void 0,done:!0}}([i,s])}}}(this,(function(f){switch(f.label){case 0:return e=t.getModuleCount(),r=Math.min(this._options.width,this._options.height)-2*this._options.margin,n=Math.floor(r/e),o={hideXDots:0,hideYDots:0,width:0,height:0},this._qr=t,this._options.image?[4,this.loadImage()]:[3,2];case 1:if(f.sent(),!this._image)return [2];i=this._options,a=i.imageOptions,s=i.qrOptions,h=a.imageSize*c[s.errorCorrectionLevel],d=Math.floor(h*e*e),o=u({originalWidth:this._image.width,originalHeight:this._image.height,maxHiddenDots:d,maxHiddenAxisDots:e-14,dotSize:n}),f.label=2;case 2:return this.clear(),this.drawBackground(),this.drawDots((function(t,r){var n,i,a,s,u,c;return !(l._options.imageOptions.hideBackgroundDots&&t>=(e-o.hideXDots)/2&&t<(e+o.hideXDots)/2&&r>=(e-o.hideYDots)/2&&r<(e+o.hideYDots)/2||(null===(n=P[t])||void 0===n?void 0:n[r])||(null===(i=P[t-e+7])||void 0===i?void 0:i[r])||(null===(a=P[t])||void 0===a?void 0:a[r-e+7])||(null===(s=O[t])||void 0===s?void 0:s[r])||(null===(u=O[t-e+7])||void 0===u?void 0:u[r])||(null===(c=O[t])||void 0===c?void 0:c[r-e+7]))})),this.drawCorners(),this._options.image&&this.drawImage({width:o.width,height:o.height,count:e,dotSize:n}),[2]}}))},new((n=void 0)||(n=Promise))((function(t,i){function a(t){try{u(o.next(t));}catch(t){i(t);}}function s(t){try{u(o.throw(t));}catch(t){i(t);}}function u(e){var r;e.done?t(e.value):(r=e.value,r instanceof n?r:new n((function(t){t(r);}))).then(a,s);}u((o=o.apply(e,r||[])).next());}));var e,r,n,o;},t.prototype.drawBackground=function(){var t=this.context,e=this._options;if(t){if(e.backgroundOptions.gradient){var r=e.backgroundOptions.gradient,n=this._createGradient({context:t,options:r,additionalRotation:0,x:0,y:0,size:this._canvas.width>this._canvas.height?this._canvas.width:this._canvas.height});r.colorStops.forEach((function(t){var e=t.offset,r=t.color;n.addColorStop(e,r);})),t.fillStyle=n;}else e.backgroundOptions.color&&(t.fillStyle=e.backgroundOptions.color);t.fillRect(0,0,this._canvas.width,this._canvas.height);}},t.prototype.drawDots=function(t){var e=this;if(!this._qr)throw "QR code is not defined";var r=this.context;if(!r)throw "QR code is not defined";var n=this._options,o=this._qr.getModuleCount();if(o>n.width||o>n.height)throw "The canvas is too small.";var i=Math.min(n.width,n.height)-2*n.margin,a=Math.floor(i/o),s=Math.floor((n.width-o*a)/2),u=Math.floor((n.height-o*a)/2),c=new y({context:r,type:n.dotsOptions.type});r.beginPath();for(var h=function(r){for(var n=function(n){return t&&!t(r,n)?"continue":d._qr.isDark(r,n)?void c.draw(s+r*a,u+n*a,a,(function(i,a){return !(r+i<0||n+a<0||r+i>=o||n+a>=o)&&!(t&&!t(r+i,n+a))&&!!e._qr&&e._qr.isDark(r+i,n+a)})):"continue"},i=0;i<o;i++)n(i);},d=this,l=0;l<o;l++)h(l);if(n.dotsOptions.gradient){var f=n.dotsOptions.gradient,p=this._createGradient({context:r,options:f,additionalRotation:0,x:s,y:u,size:o*a});f.colorStops.forEach((function(t){var e=t.offset,r=t.color;p.addColorStop(e,r);})),r.fillStyle=r.strokeStyle=p;}else n.dotsOptions.color&&(r.fillStyle=r.strokeStyle=n.dotsOptions.color);r.fill("evenodd");},t.prototype.drawCorners=function(t){var e=this;if(!this._qr)throw "QR code is not defined";var r=this.context;if(!r)throw "QR code is not defined";var n=this._options,o=this._qr.getModuleCount(),i=Math.min(n.width,n.height)-2*n.margin,a=Math.floor(i/o),s=7*a,u=3*a,c=Math.floor((n.width-o*a)/2),h=Math.floor((n.height-o*a)/2);[[0,0,0],[1,0,Math.PI/2],[0,1,-Math.PI/2]].forEach((function(i){var d,l,f,p,g,v,w,_,m,x,M=i[0],C=i[1],z=i[2];if(!t||t(M,C)){var D=c+M*a*(o-7),I=h+C*a*(o-7);if(null===(d=n.cornersSquareOptions)||void 0===d?void 0:d.type){var A=new b({context:r,type:null===(l=n.cornersSquareOptions)||void 0===l?void 0:l.type});r.beginPath(),A.draw(D,I,s,z);}else {var k=new y({context:r,type:n.dotsOptions.type});r.beginPath();for(var q=function(t){for(var e=function(e){if(!(null===(f=P[t])||void 0===f?void 0:f[e]))return "continue";k.draw(D+t*a,I+e*a,a,(function(r,n){var o;return !!(null===(o=P[t+r])||void 0===o?void 0:o[e+n])}));},r=0;r<P[t].length;r++)e(r);},R=0;R<P.length;R++)q(R);}if(null===(p=n.cornersSquareOptions)||void 0===p?void 0:p.gradient){var B=n.cornersSquareOptions.gradient,E=e._createGradient({context:r,options:B,additionalRotation:z,x:D,y:I,size:s});B.colorStops.forEach((function(t){var e=t.offset,r=t.color;E.addColorStop(e,r);})),r.fillStyle=r.strokeStyle=E;}else (null===(g=n.cornersSquareOptions)||void 0===g?void 0:g.color)&&(r.fillStyle=r.strokeStyle=n.cornersSquareOptions.color);if(r.fill("evenodd"),null===(v=n.cornersDotOptions)||void 0===v?void 0:v.type){var L=new S({context:r,type:null===(w=n.cornersDotOptions)||void 0===w?void 0:w.type});r.beginPath(),L.draw(D+2*a,I+2*a,u,z);}else {k=new y({context:r,type:n.dotsOptions.type}),r.beginPath();var N=function(t){for(var e=function(e){if(!(null===(_=O[t])||void 0===_?void 0:_[e]))return "continue";k.draw(D+t*a,I+e*a,a,(function(r,n){var o;return !!(null===(o=O[t+r])||void 0===o?void 0:o[e+n])}));},r=0;r<O[t].length;r++)e(r);};for(R=0;R<O.length;R++)N(R);}if(null===(m=n.cornersDotOptions)||void 0===m?void 0:m.gradient){B=n.cornersDotOptions.gradient;var T=e._createGradient({context:r,options:B,additionalRotation:z,x:D+2*a,y:I+2*a,size:u});B.colorStops.forEach((function(t){var e=t.offset,r=t.color;T.addColorStop(e,r);})),r.fillStyle=r.strokeStyle=T;}else (null===(x=n.cornersDotOptions)||void 0===x?void 0:x.color)&&(r.fillStyle=r.strokeStyle=n.cornersDotOptions.color);r.fill("evenodd");}}));},t.prototype.loadImage=function(){var t=this;return new Promise((function(e,r){var n=t._options,o=new Image;if(!n.image)return r("Image is not defined");"string"==typeof n.imageOptions.crossOrigin&&(o.crossOrigin=n.imageOptions.crossOrigin),t._image=o,o.onload=function(){e();},o.src=n.image;}))},t.prototype.drawImage=function(t){var e=t.width,r=t.height,n=t.count,o=t.dotSize,i=this.context;if(!i)throw "canvasContext is not defined";if(!this._image)throw "image is not defined";var a=this._options,s=Math.floor((a.width-n*o)/2),u=Math.floor((a.height-n*o)/2),c=s+a.imageOptions.margin+(n*o-e)/2,h=u+a.imageOptions.margin+(n*o-r)/2,d=e-2*a.imageOptions.margin,l=r-2*a.imageOptions.margin;i.drawImage(this._image,c,h,d<0?0:d,l<0?0:l);},t.prototype._createGradient=function(t){var e,r=t.context,n=t.options,o=t.additionalRotation,i=t.x,a=t.y,s=t.size;if(n.type===C)e=r.createRadialGradient(i+s/2,a+s/2,0,i+s/2,a+s/2,s/2);else {var u=((n.rotation||0)+o)%(2*Math.PI),c=(u+2*Math.PI)%(2*Math.PI),h=i+s/2,d=a+s/2,l=i+s/2,f=a+s/2;c>=0&&c<=.25*Math.PI||c>1.75*Math.PI&&c<=2*Math.PI?(h-=s/2,d-=s/2*Math.tan(u),l+=s/2,f+=s/2*Math.tan(u)):c>.25*Math.PI&&c<=.75*Math.PI?(d-=s/2,h-=s/2/Math.tan(u),f+=s/2,l+=s/2/Math.tan(u)):c>.75*Math.PI&&c<=1.25*Math.PI?(h+=s/2,d+=s/2*Math.tan(u),l-=s/2,f-=s/2*Math.tan(u)):c>1.25*Math.PI&&c<=1.75*Math.PI&&(d+=s/2,h+=s/2/Math.tan(u),f-=s/2,l-=s/2/Math.tan(u)),e=r.createLinearGradient(Math.round(h),Math.round(d),Math.round(l),Math.round(f));}return e},t}();var D=function(){return (D=Object.assign||function(t){for(var e,r=1,n=arguments.length;r<n;r++)for(var o in e=arguments[r])Object.prototype.hasOwnProperty.call(e,o)&&(t[o]=e[o]);return t}).apply(this,arguments)};const I=function(){function t(t){var e=t.svg,r=t.type;this._svg=e,this._type=r;}return t.prototype.draw=function(t,e,r,n){var o;switch(this._type){case h:o=this._drawDot;break;case l:o=this._drawClassy;break;case f:o=this._drawClassyRounded;break;case d:o=this._drawRounded;break;case g:o=this._drawExtraRounded;break;case p:default:o=this._drawSquare;}o.call(this,{x:t,y:e,size:r,getNeighbor:n});},t.prototype._rotateFigure=function(t){var e,r=t.x,n=t.y,o=t.size,i=t.rotation,a=void 0===i?0:i,s=r+o/2,u=n+o/2;(0, t.draw)(),null===(e=this._element)||void 0===e||e.setAttribute("transform","rotate("+180*a/Math.PI+","+s+","+u+")");},t.prototype._basicDot=function(t){var e=this,r=t.size,n=t.x,o=t.y;this._rotateFigure(D(D({},t),{draw:function(){e._element=document.createElementNS("http://www.w3.org/2000/svg","circle"),e._element.setAttribute("cx",String(n+r/2)),e._element.setAttribute("cy",String(o+r/2)),e._element.setAttribute("r",String(r/2));}}));},t.prototype._basicSquare=function(t){var e=this,r=t.size,n=t.x,o=t.y;this._rotateFigure(D(D({},t),{draw:function(){e._element=document.createElementNS("http://www.w3.org/2000/svg","rect"),e._element.setAttribute("x",String(n)),e._element.setAttribute("y",String(o)),e._element.setAttribute("width",String(r)),e._element.setAttribute("height",String(r));}}));},t.prototype._basicSideRounded=function(t){var e=this,r=t.size,n=t.x,o=t.y;this._rotateFigure(D(D({},t),{draw:function(){e._element=document.createElementNS("http://www.w3.org/2000/svg","path"),e._element.setAttribute("d","M "+n+" "+o+"v "+r+"h "+r/2+"a "+r/2+" "+r/2+", 0, 0, 0, 0 "+-r);}}));},t.prototype._basicCornerRounded=function(t){var e=this,r=t.size,n=t.x,o=t.y;this._rotateFigure(D(D({},t),{draw:function(){e._element=document.createElementNS("http://www.w3.org/2000/svg","path"),e._element.setAttribute("d","M "+n+" "+o+"v "+r+"h "+r+"v "+-r/2+"a "+r/2+" "+r/2+", 0, 0, 0, "+-r/2+" "+-r/2);}}));},t.prototype._basicCornerExtraRounded=function(t){var e=this,r=t.size,n=t.x,o=t.y;this._rotateFigure(D(D({},t),{draw:function(){e._element=document.createElementNS("http://www.w3.org/2000/svg","path"),e._element.setAttribute("d","M "+n+" "+o+"v "+r+"h "+r+"a "+r+" "+r+", 0, 0, 0, "+-r+" "+-r);}}));},t.prototype._basicCornersRounded=function(t){var e=this,r=t.size,n=t.x,o=t.y;this._rotateFigure(D(D({},t),{draw:function(){e._element=document.createElementNS("http://www.w3.org/2000/svg","path"),e._element.setAttribute("d","M "+n+" "+o+"v "+r/2+"a "+r/2+" "+r/2+", 0, 0, 0, "+r/2+" "+r/2+"h "+r/2+"v "+-r/2+"a "+r/2+" "+r/2+", 0, 0, 0, "+-r/2+" "+-r/2);}}));},t.prototype._drawDot=function(t){var e=t.x,r=t.y,n=t.size;this._basicDot({x:e,y:r,size:n,rotation:0});},t.prototype._drawSquare=function(t){var e=t.x,r=t.y,n=t.size;this._basicSquare({x:e,y:r,size:n,rotation:0});},t.prototype._drawRounded=function(t){var e=t.x,r=t.y,n=t.size,o=t.getNeighbor,i=o?+o(-1,0):0,a=o?+o(1,0):0,s=o?+o(0,-1):0,u=o?+o(0,1):0,c=i+a+s+u;if(0!==c)if(c>2||i&&a||s&&u)this._basicSquare({x:e,y:r,size:n,rotation:0});else {if(2===c){var h=0;return i&&s?h=Math.PI/2:s&&a?h=Math.PI:a&&u&&(h=-Math.PI/2),void this._basicCornerRounded({x:e,y:r,size:n,rotation:h})}if(1===c)return h=0,s?h=Math.PI/2:a?h=Math.PI:u&&(h=-Math.PI/2),void this._basicSideRounded({x:e,y:r,size:n,rotation:h})}else this._basicDot({x:e,y:r,size:n,rotation:0});},t.prototype._drawExtraRounded=function(t){var e=t.x,r=t.y,n=t.size,o=t.getNeighbor,i=o?+o(-1,0):0,a=o?+o(1,0):0,s=o?+o(0,-1):0,u=o?+o(0,1):0,c=i+a+s+u;if(0!==c)if(c>2||i&&a||s&&u)this._basicSquare({x:e,y:r,size:n,rotation:0});else {if(2===c){var h=0;return i&&s?h=Math.PI/2:s&&a?h=Math.PI:a&&u&&(h=-Math.PI/2),void this._basicCornerExtraRounded({x:e,y:r,size:n,rotation:h})}if(1===c)return h=0,s?h=Math.PI/2:a?h=Math.PI:u&&(h=-Math.PI/2),void this._basicSideRounded({x:e,y:r,size:n,rotation:h})}else this._basicDot({x:e,y:r,size:n,rotation:0});},t.prototype._drawClassy=function(t){var e=t.x,r=t.y,n=t.size,o=t.getNeighbor,i=o?+o(-1,0):0,a=o?+o(1,0):0,s=o?+o(0,-1):0,u=o?+o(0,1):0;0!==i+a+s+u?i||s?a||u?this._basicSquare({x:e,y:r,size:n,rotation:0}):this._basicCornerRounded({x:e,y:r,size:n,rotation:Math.PI/2}):this._basicCornerRounded({x:e,y:r,size:n,rotation:-Math.PI/2}):this._basicCornersRounded({x:e,y:r,size:n,rotation:Math.PI/2});},t.prototype._drawClassyRounded=function(t){var e=t.x,r=t.y,n=t.size,o=t.getNeighbor,i=o?+o(-1,0):0,a=o?+o(1,0):0,s=o?+o(0,-1):0,u=o?+o(0,1):0;0!==i+a+s+u?i||s?a||u?this._basicSquare({x:e,y:r,size:n,rotation:0}):this._basicCornerExtraRounded({x:e,y:r,size:n,rotation:Math.PI/2}):this._basicCornerExtraRounded({x:e,y:r,size:n,rotation:-Math.PI/2}):this._basicCornersRounded({x:e,y:r,size:n,rotation:Math.PI/2});},t}();var A=function(){return (A=Object.assign||function(t){for(var e,r=1,n=arguments.length;r<n;r++)for(var o in e=arguments[r])Object.prototype.hasOwnProperty.call(e,o)&&(t[o]=e[o]);return t}).apply(this,arguments)};const k=function(){function t(t){var e=t.svg,r=t.type;this._svg=e,this._type=r;}return t.prototype.draw=function(t,e,r,n){var o;switch(this._type){case w:o=this._drawSquare;break;case _:o=this._drawExtraRounded;break;case"dot":default:o=this._drawDot;}o.call(this,{x:t,y:e,size:r,rotation:n});},t.prototype._rotateFigure=function(t){var e,r=t.x,n=t.y,o=t.size,i=t.rotation,a=void 0===i?0:i,s=r+o/2,u=n+o/2;(0, t.draw)(),null===(e=this._element)||void 0===e||e.setAttribute("transform","rotate("+180*a/Math.PI+","+s+","+u+")");},t.prototype._basicDot=function(t){var e=this,r=t.size,n=t.x,o=t.y,i=r/7;this._rotateFigure(A(A({},t),{draw:function(){e._element=document.createElementNS("http://www.w3.org/2000/svg","path"),e._element.setAttribute("clip-rule","evenodd"),e._element.setAttribute("d","M "+(n+r/2)+" "+o+"a "+r/2+" "+r/2+" 0 1 0 0.1 0zm 0 "+i+"a "+(r/2-i)+" "+(r/2-i)+" 0 1 1 -0.1 0Z");}}));},t.prototype._basicSquare=function(t){var e=this,r=t.size,n=t.x,o=t.y,i=r/7;this._rotateFigure(A(A({},t),{draw:function(){e._element=document.createElementNS("http://www.w3.org/2000/svg","path"),e._element.setAttribute("clip-rule","evenodd"),e._element.setAttribute("d","M "+n+" "+o+"v "+r+"h "+r+"v "+-r+"zM "+(n+i)+" "+(o+i)+"h "+(r-2*i)+"v "+(r-2*i)+"h "+(2*i-r)+"z");}}));},t.prototype._basicExtraRounded=function(t){var e=this,r=t.size,n=t.x,o=t.y,i=r/7;this._rotateFigure(A(A({},t),{draw:function(){e._element=document.createElementNS("http://www.w3.org/2000/svg","path"),e._element.setAttribute("clip-rule","evenodd"),e._element.setAttribute("d","M "+n+" "+(o+2.5*i)+"v "+2*i+"a "+2.5*i+" "+2.5*i+", 0, 0, 0, "+2.5*i+" "+2.5*i+"h "+2*i+"a "+2.5*i+" "+2.5*i+", 0, 0, 0, "+2.5*i+" "+2.5*-i+"v "+-2*i+"a "+2.5*i+" "+2.5*i+", 0, 0, 0, "+2.5*-i+" "+2.5*-i+"h "+-2*i+"a "+2.5*i+" "+2.5*i+", 0, 0, 0, "+2.5*-i+" "+2.5*i+"M "+(n+2.5*i)+" "+(o+i)+"h "+2*i+"a "+1.5*i+" "+1.5*i+", 0, 0, 1, "+1.5*i+" "+1.5*i+"v "+2*i+"a "+1.5*i+" "+1.5*i+", 0, 0, 1, "+1.5*-i+" "+1.5*i+"h "+-2*i+"a "+1.5*i+" "+1.5*i+", 0, 0, 1, "+1.5*-i+" "+1.5*-i+"v "+-2*i+"a "+1.5*i+" "+1.5*i+", 0, 0, 1, "+1.5*i+" "+1.5*-i);}}));},t.prototype._drawDot=function(t){var e=t.x,r=t.y,n=t.size,o=t.rotation;this._basicDot({x:e,y:r,size:n,rotation:o});},t.prototype._drawSquare=function(t){var e=t.x,r=t.y,n=t.size,o=t.rotation;this._basicSquare({x:e,y:r,size:n,rotation:o});},t.prototype._drawExtraRounded=function(t){var e=t.x,r=t.y,n=t.size,o=t.rotation;this._basicExtraRounded({x:e,y:r,size:n,rotation:o});},t}();var q=function(){return (q=Object.assign||function(t){for(var e,r=1,n=arguments.length;r<n;r++)for(var o in e=arguments[r])Object.prototype.hasOwnProperty.call(e,o)&&(t[o]=e[o]);return t}).apply(this,arguments)};const R=function(){function t(t){var e=t.svg,r=t.type;this._svg=e,this._type=r;}return t.prototype.draw=function(t,e,r,n){var o;switch(this._type){case x:o=this._drawSquare;break;case"dot":default:o=this._drawDot;}o.call(this,{x:t,y:e,size:r,rotation:n});},t.prototype._rotateFigure=function(t){var e,r=t.x,n=t.y,o=t.size,i=t.rotation,a=void 0===i?0:i,s=r+o/2,u=n+o/2;(0, t.draw)(),null===(e=this._element)||void 0===e||e.setAttribute("transform","rotate("+180*a/Math.PI+","+s+","+u+")");},t.prototype._basicDot=function(t){var e=this,r=t.size,n=t.x,o=t.y;this._rotateFigure(q(q({},t),{draw:function(){e._element=document.createElementNS("http://www.w3.org/2000/svg","circle"),e._element.setAttribute("cx",String(n+r/2)),e._element.setAttribute("cy",String(o+r/2)),e._element.setAttribute("r",String(r/2));}}));},t.prototype._basicSquare=function(t){var e=this,r=t.size,n=t.x,o=t.y;this._rotateFigure(q(q({},t),{draw:function(){e._element=document.createElementNS("http://www.w3.org/2000/svg","rect"),e._element.setAttribute("x",String(n)),e._element.setAttribute("y",String(o)),e._element.setAttribute("width",String(r)),e._element.setAttribute("height",String(r));}}));},t.prototype._drawDot=function(t){var e=t.x,r=t.y,n=t.size,o=t.rotation;this._basicDot({x:e,y:r,size:n,rotation:o});},t.prototype._drawSquare=function(t){var e=t.x,r=t.y,n=t.size,o=t.rotation;this._basicSquare({x:e,y:r,size:n,rotation:o});},t}();var B=[[1,1,1,1,1,1,1],[1,0,0,0,0,0,1],[1,0,0,0,0,0,1],[1,0,0,0,0,0,1],[1,0,0,0,0,0,1],[1,0,0,0,0,0,1],[1,1,1,1,1,1,1]],E=[[0,0,0,0,0,0,0],[0,0,0,0,0,0,0],[0,0,1,1,1,0,0],[0,0,1,1,1,0,0],[0,0,1,1,1,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,0,0]];const L=function(){function t(t){this._element=document.createElementNS("http://www.w3.org/2000/svg","svg"),this._element.setAttribute("width",String(t.width)),this._element.setAttribute("height",String(t.height)),this._defs=document.createElementNS("http://www.w3.org/2000/svg","defs"),this._element.appendChild(this._defs),this._options=t;}return Object.defineProperty(t.prototype,"width",{get:function(){return this._options.width},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"height",{get:function(){return this._options.height},enumerable:!1,configurable:!0}),t.prototype.getElement=function(){return this._element},t.prototype.clear=function(){var t,e=this._element;this._element=e.cloneNode(!1),null===(t=null==e?void 0:e.parentNode)||void 0===t||t.replaceChild(this._element,e),this._defs=document.createElementNS("http://www.w3.org/2000/svg","defs"),this._element.appendChild(this._defs);},t.prototype.drawQR=function(t){return e=this,r=void 0,o=function(){var e,r,n,o,i,a,s,h,d,l=this;return function(t,e){var r,n,o,i,a={label:0,sent:function(){if(1&o[0])throw o[1];return o[1]},trys:[],ops:[]};return i={next:s(0),throw:s(1),return:s(2)},"function"==typeof Symbol&&(i[Symbol.iterator]=function(){return this}),i;function s(i){return function(s){return function(i){if(r)throw new TypeError("Generator is already executing.");for(;a;)try{if(r=1,n&&(o=2&i[0]?n.return:i[0]?n.throw||((o=n.return)&&o.call(n),0):n.next)&&!(o=o.call(n,i[1])).done)return o;switch(n=0,o&&(i=[2&i[0],o.value]),i[0]){case 0:case 1:o=i;break;case 4:return a.label++,{value:i[1],done:!1};case 5:a.label++,n=i[1],i=[0];continue;case 7:i=a.ops.pop(),a.trys.pop();continue;default:if(!((o=(o=a.trys).length>0&&o[o.length-1])||6!==i[0]&&2!==i[0])){a=0;continue}if(3===i[0]&&(!o||i[1]>o[0]&&i[1]<o[3])){a.label=i[1];break}if(6===i[0]&&a.label<o[1]){a.label=o[1],o=i;break}if(o&&a.label<o[2]){a.label=o[2],a.ops.push(i);break}o[2]&&a.ops.pop(),a.trys.pop();continue}i=e.call(t,a);}catch(t){i=[6,t],n=0;}finally{r=o=0;}if(5&i[0])throw i[1];return {value:i[0]?i[1]:void 0,done:!0}}([i,s])}}}(this,(function(f){switch(f.label){case 0:return e=t.getModuleCount(),r=Math.min(this._options.width,this._options.height)-2*this._options.margin,n=Math.floor(r/e),o={hideXDots:0,hideYDots:0,width:0,height:0},this._qr=t,this._options.image?[4,this.loadImage()]:[3,2];case 1:if(f.sent(),!this._image)return [2];i=this._options,a=i.imageOptions,s=i.qrOptions,h=a.imageSize*c[s.errorCorrectionLevel],d=Math.floor(h*e*e),o=u({originalWidth:this._image.width,originalHeight:this._image.height,maxHiddenDots:d,maxHiddenAxisDots:e-14,dotSize:n}),f.label=2;case 2:return this.clear(),this.drawBackground(),this.drawDots((function(t,r){var n,i,a,s,u,c;return !(l._options.imageOptions.hideBackgroundDots&&t>=(e-o.hideXDots)/2&&t<(e+o.hideXDots)/2&&r>=(e-o.hideYDots)/2&&r<(e+o.hideYDots)/2||(null===(n=B[t])||void 0===n?void 0:n[r])||(null===(i=B[t-e+7])||void 0===i?void 0:i[r])||(null===(a=B[t])||void 0===a?void 0:a[r-e+7])||(null===(s=E[t])||void 0===s?void 0:s[r])||(null===(u=E[t-e+7])||void 0===u?void 0:u[r])||(null===(c=E[t])||void 0===c?void 0:c[r-e+7]))})),this.drawCorners(),this._options.image&&this.drawImage({width:o.width,height:o.height,count:e,dotSize:n}),[2]}}))},new((n=void 0)||(n=Promise))((function(t,i){function a(t){try{u(o.next(t));}catch(t){i(t);}}function s(t){try{u(o.throw(t));}catch(t){i(t);}}function u(e){var r;e.done?t(e.value):(r=e.value,r instanceof n?r:new n((function(t){t(r);}))).then(a,s);}u((o=o.apply(e,r||[])).next());}));var e,r,n,o;},t.prototype.drawBackground=function(){var t,e,r=this._element,n=this._options;if(r){var o=null===(t=n.backgroundOptions)||void 0===t?void 0:t.gradient,i=null===(e=n.backgroundOptions)||void 0===e?void 0:e.color;(o||i)&&this._createColor({options:o,color:i,additionalRotation:0,x:0,y:0,height:n.height,width:n.width,name:"background-color"});}},t.prototype.drawDots=function(t){var e,r,n=this;if(!this._qr)throw "QR code is not defined";var o=this._options,i=this._qr.getModuleCount();if(i>o.width||i>o.height)throw "The canvas is too small.";var a=Math.min(o.width,o.height)-2*o.margin,s=Math.floor(a/i),u=Math.floor((o.width-i*s)/2),c=Math.floor((o.height-i*s)/2),h=new I({svg:this._element,type:o.dotsOptions.type});this._dotsClipPath=document.createElementNS("http://www.w3.org/2000/svg","clipPath"),this._dotsClipPath.setAttribute("id","clip-path-dot-color"),this._defs.appendChild(this._dotsClipPath),this._createColor({options:null===(e=o.dotsOptions)||void 0===e?void 0:e.gradient,color:o.dotsOptions.color,additionalRotation:0,x:u,y:c,height:i*s,width:i*s,name:"dot-color"});for(var d=function(e){for(var o=function(o){return t&&!t(e,o)?"continue":(null===(r=l._qr)||void 0===r?void 0:r.isDark(e,o))?(h.draw(u+e*s,c+o*s,s,(function(r,a){return !(e+r<0||o+a<0||e+r>=i||o+a>=i)&&!(t&&!t(e+r,o+a))&&!!n._qr&&n._qr.isDark(e+r,o+a)})),void(h._element&&l._dotsClipPath&&l._dotsClipPath.appendChild(h._element))):"continue"},a=0;a<i;a++)o(a);},l=this,f=0;f<i;f++)d(f);},t.prototype.drawCorners=function(){var t=this;if(!this._qr)throw "QR code is not defined";var e=this._element,r=this._options;if(!e)throw "Element code is not defined";var n=this._qr.getModuleCount(),o=Math.min(r.width,r.height)-2*r.margin,i=Math.floor(o/n),a=7*i,s=3*i,u=Math.floor((r.width-n*i)/2),c=Math.floor((r.height-n*i)/2);[[0,0,0],[1,0,Math.PI/2],[0,1,-Math.PI/2]].forEach((function(e){var o,h,d,l,f,p,g,v,y,w,_,m,b=e[0],x=e[1],M=e[2],S=u+b*i*(n-7),C=c+x*i*(n-7),P=t._dotsClipPath,O=t._dotsClipPath;if(((null===(o=r.cornersSquareOptions)||void 0===o?void 0:o.gradient)||(null===(h=r.cornersSquareOptions)||void 0===h?void 0:h.color))&&((P=document.createElementNS("http://www.w3.org/2000/svg","clipPath")).setAttribute("id","clip-path-corners-square-color-"+b+"-"+x),t._defs.appendChild(P),t._cornersSquareClipPath=t._cornersDotClipPath=O=P,t._createColor({options:null===(d=r.cornersSquareOptions)||void 0===d?void 0:d.gradient,color:null===(l=r.cornersSquareOptions)||void 0===l?void 0:l.color,additionalRotation:M,x:S,y:C,height:a,width:a,name:"corners-square-color-"+b+"-"+x})),null===(f=r.cornersSquareOptions)||void 0===f?void 0:f.type){var z=new k({svg:t._element,type:r.cornersSquareOptions.type});z.draw(S,C,a,M),z._element&&P&&P.appendChild(z._element);}else for(var D=new I({svg:t._element,type:r.dotsOptions.type}),A=function(t){for(var e=function(e){if(!(null===(p=B[t])||void 0===p?void 0:p[e]))return "continue";D.draw(S+t*i,C+e*i,i,(function(r,n){var o;return !!(null===(o=B[t+r])||void 0===o?void 0:o[e+n])})),D._element&&P&&P.appendChild(D._element);},r=0;r<B[t].length;r++)e(r);},q=0;q<B.length;q++)A(q);if(((null===(g=r.cornersDotOptions)||void 0===g?void 0:g.gradient)||(null===(v=r.cornersDotOptions)||void 0===v?void 0:v.color))&&((O=document.createElementNS("http://www.w3.org/2000/svg","clipPath")).setAttribute("id","clip-path-corners-dot-color-"+b+"-"+x),t._defs.appendChild(O),t._cornersDotClipPath=O,t._createColor({options:null===(y=r.cornersDotOptions)||void 0===y?void 0:y.gradient,color:null===(w=r.cornersDotOptions)||void 0===w?void 0:w.color,additionalRotation:M,x:S+2*i,y:C+2*i,height:s,width:s,name:"corners-dot-color-"+b+"-"+x})),null===(_=r.cornersDotOptions)||void 0===_?void 0:_.type){var L=new R({svg:t._element,type:r.cornersDotOptions.type});L.draw(S+2*i,C+2*i,s,M),L._element&&O&&O.appendChild(L._element);}else {D=new I({svg:t._element,type:r.dotsOptions.type});var N=function(t){for(var e=function(e){if(!(null===(m=E[t])||void 0===m?void 0:m[e]))return "continue";D.draw(S+t*i,C+e*i,i,(function(r,n){var o;return !!(null===(o=E[t+r])||void 0===o?void 0:o[e+n])})),D._element&&O&&O.appendChild(D._element);},r=0;r<E[t].length;r++)e(r);};for(q=0;q<E.length;q++)N(q);}}));},t.prototype.loadImage=function(){var t=this;return new Promise((function(e,r){var n=t._options,o=new Image;if(!n.image)return r("Image is not defined");"string"==typeof n.imageOptions.crossOrigin&&(o.crossOrigin=n.imageOptions.crossOrigin),t._image=o,o.onload=function(){e();},o.src=n.image;}))},t.prototype.drawImage=function(t){var e=t.width,r=t.height,n=t.count,o=t.dotSize,i=this._options,a=Math.floor((i.width-n*o)/2),s=Math.floor((i.height-n*o)/2),u=a+i.imageOptions.margin+(n*o-e)/2,c=s+i.imageOptions.margin+(n*o-r)/2,h=e-2*i.imageOptions.margin,d=r-2*i.imageOptions.margin,l=document.createElementNS("http://www.w3.org/2000/svg","image");l.setAttribute("href",i.image||""),l.setAttribute("x",String(u)),l.setAttribute("y",String(c)),l.setAttribute("width",h+"px"),l.setAttribute("height",d+"px"),this._element.appendChild(l);},t.prototype._createColor=function(t){var e=t.options,r=t.color,n=t.additionalRotation,o=t.x,i=t.y,a=t.height,s=t.width,u=t.name,c=s>a?s:a,h=document.createElementNS("http://www.w3.org/2000/svg","rect");if(h.setAttribute("x",String(o)),h.setAttribute("y",String(i)),h.setAttribute("height",String(a)),h.setAttribute("width",String(s)),h.setAttribute("clip-path","url('#clip-path-"+u+"')"),e){var d;if(e.type===C)(d=document.createElementNS("http://www.w3.org/2000/svg","radialGradient")).setAttribute("id",u),d.setAttribute("gradientUnits","userSpaceOnUse"),d.setAttribute("fx",String(o+s/2)),d.setAttribute("fy",String(i+a/2)),d.setAttribute("cx",String(o+s/2)),d.setAttribute("cy",String(i+a/2)),d.setAttribute("r",String(c/2));else {var l=((e.rotation||0)+n)%(2*Math.PI),f=(l+2*Math.PI)%(2*Math.PI),p=o+s/2,g=i+a/2,v=o+s/2,y=i+a/2;f>=0&&f<=.25*Math.PI||f>1.75*Math.PI&&f<=2*Math.PI?(p-=s/2,g-=a/2*Math.tan(l),v+=s/2,y+=a/2*Math.tan(l)):f>.25*Math.PI&&f<=.75*Math.PI?(g-=a/2,p-=s/2/Math.tan(l),y+=a/2,v+=s/2/Math.tan(l)):f>.75*Math.PI&&f<=1.25*Math.PI?(p+=s/2,g+=a/2*Math.tan(l),v-=s/2,y-=a/2*Math.tan(l)):f>1.25*Math.PI&&f<=1.75*Math.PI&&(g+=a/2,p+=s/2/Math.tan(l),y-=a/2,v-=s/2/Math.tan(l)),(d=document.createElementNS("http://www.w3.org/2000/svg","linearGradient")).setAttribute("id",u),d.setAttribute("gradientUnits","userSpaceOnUse"),d.setAttribute("x1",String(Math.round(p))),d.setAttribute("y1",String(Math.round(g))),d.setAttribute("x2",String(Math.round(v))),d.setAttribute("y2",String(Math.round(y)));}e.colorStops.forEach((function(t){var e=t.offset,r=t.color,n=document.createElementNS("http://www.w3.org/2000/svg","stop");n.setAttribute("offset",100*e+"%"),n.setAttribute("stop-color",r),d.appendChild(n);})),h.setAttribute("fill","url('#"+u+"')"),this._defs.appendChild(d);}else r&&h.setAttribute("fill",r);this._element.appendChild(h);},t}(),N="canvas";for(var T={},j=0;j<=40;j++)T[j]=j;const F={type:N,width:300,height:300,data:"",margin:0,qrOptions:{typeNumber:T[0],mode:void 0,errorCorrectionLevel:"Q"},imageOptions:{hideBackgroundDots:!0,imageSize:.4,crossOrigin:void 0,margin:0},dotsOptions:{type:"square",color:"#000"},backgroundOptions:{color:"#fff"}};var Q=function(){return (Q=Object.assign||function(t){for(var e,r=1,n=arguments.length;r<n;r++)for(var o in e=arguments[r])Object.prototype.hasOwnProperty.call(e,o)&&(t[o]=e[o]);return t}).apply(this,arguments)};function H(t){var e=Q({},t);if(!e.colorStops||!e.colorStops.length)throw "Field 'colorStops' is required in gradient";return e.rotation?e.rotation=Number(e.rotation):e.rotation=0,e.colorStops=e.colorStops.map((function(t){return Q(Q({},t),{offset:Number(t.offset)})})),e}function G(t){var e=Q({},t);return e.width=Number(e.width),e.height=Number(e.height),e.margin=Number(e.margin),e.imageOptions=Q(Q({},e.imageOptions),{hideBackgroundDots:Boolean(e.imageOptions.hideBackgroundDots),imageSize:Number(e.imageOptions.imageSize),margin:Number(e.imageOptions.margin)}),e.margin>Math.min(e.width,e.height)&&(e.margin=Math.min(e.width,e.height)),e.dotsOptions=Q({},e.dotsOptions),e.dotsOptions.gradient&&(e.dotsOptions.gradient=H(e.dotsOptions.gradient)),e.cornersSquareOptions&&(e.cornersSquareOptions=Q({},e.cornersSquareOptions),e.cornersSquareOptions.gradient&&(e.cornersSquareOptions.gradient=H(e.cornersSquareOptions.gradient))),e.cornersDotOptions&&(e.cornersDotOptions=Q({},e.cornersDotOptions),e.cornersDotOptions.gradient&&(e.cornersDotOptions.gradient=H(e.cornersDotOptions.gradient))),e.backgroundOptions&&(e.backgroundOptions=Q({},e.backgroundOptions),e.backgroundOptions.gradient&&(e.backgroundOptions.gradient=H(e.backgroundOptions.gradient))),e}var X=r(192),U=r.n(X),Y=function(t,e,r,n){return new(r||(r=Promise))((function(o,i){function a(t){try{u(n.next(t));}catch(t){i(t);}}function s(t){try{u(n.throw(t));}catch(t){i(t);}}function u(t){var e;t.done?o(t.value):(e=t.value,e instanceof r?e:new r((function(t){t(e);}))).then(a,s);}u((n=n.apply(t,e||[])).next());}))},$=function(t,e){var r,n,o,i,a={label:0,sent:function(){if(1&o[0])throw o[1];return o[1]},trys:[],ops:[]};return i={next:s(0),throw:s(1),return:s(2)},"function"==typeof Symbol&&(i[Symbol.iterator]=function(){return this}),i;function s(i){return function(s){return function(i){if(r)throw new TypeError("Generator is already executing.");for(;a;)try{if(r=1,n&&(o=2&i[0]?n.return:i[0]?n.throw||((o=n.return)&&o.call(n),0):n.next)&&!(o=o.call(n,i[1])).done)return o;switch(n=0,o&&(i=[2&i[0],o.value]),i[0]){case 0:case 1:o=i;break;case 4:return a.label++,{value:i[1],done:!1};case 5:a.label++,n=i[1],i=[0];continue;case 7:i=a.ops.pop(),a.trys.pop();continue;default:if(!((o=(o=a.trys).length>0&&o[o.length-1])||6!==i[0]&&2!==i[0])){a=0;continue}if(3===i[0]&&(!o||i[1]>o[0]&&i[1]<o[3])){a.label=i[1];break}if(6===i[0]&&a.label<o[1]){a.label=o[1],o=i;break}if(o&&a.label<o[2]){a.label=o[2],a.ops.push(i);break}o[2]&&a.ops.pop(),a.trys.pop();continue}i=e.call(t,a);}catch(t){i=[6,t],n=0;}finally{r=o=0;}if(5&i[0])throw i[1];return {value:i[0]?i[1]:void 0,done:!0}}([i,s])}}};const W=function(){function t(t){this._options=t?G(a(F,t)):F,this.update();}return t._clearContainer=function(t){t&&(t.innerHTML="");},t.prototype._getQRStylingElement=function(t){return void 0===t&&(t="png"),Y(this,void 0,void 0,(function(){var e,r,n;return $(this,(function(o){switch(o.label){case 0:if(!this._qr)throw "QR code is empty";return "svg"!==t.toLowerCase()?[3,2]:(r=void 0,e=void 0,this._svg&&this._svgDrawingPromise?(e=this._svg,r=this._svgDrawingPromise):(e=new L(this._options),r=e.drawQR(this._qr)),[4,r]);case 1:return o.sent(),[2,e];case 2:return r=void 0,n=void 0,this._canvas&&this._canvasDrawingPromise?(n=this._canvas,r=this._canvasDrawingPromise):(n=new z(this._options),r=n.drawQR(this._qr)),[4,r];case 3:return o.sent(),[2,n]}}))}))},t.prototype.update=function(e){t._clearContainer(this._container),this._options=e?G(a(this._options,e)):this._options,this._options.data&&(this._qr=U()(this._options.qrOptions.typeNumber,this._options.qrOptions.errorCorrectionLevel),this._qr.addData(this._options.data,this._options.qrOptions.mode||function(t){switch(!0){case/^[0-9]*$/.test(t):return "Numeric";case/^[0-9A-Z $%*+\-./:]*$/.test(t):return "Alphanumeric";default:return "Byte"}}(this._options.data)),this._qr.make(),this._options.type===N?(this._canvas=new z(this._options),this._canvasDrawingPromise=this._canvas.drawQR(this._qr),this._svgDrawingPromise=void 0,this._svg=void 0):(this._svg=new L(this._options),this._svgDrawingPromise=this._svg.drawQR(this._qr),this._canvasDrawingPromise=void 0,this._canvas=void 0),this.append(this._container));},t.prototype.append=function(t){if(t){if("function"!=typeof t.appendChild)throw "Container should be a single DOM node";this._options.type===N?this._canvas&&t.appendChild(this._canvas.getCanvas()):this._svg&&t.appendChild(this._svg.getElement()),this._container=t;}},t.prototype.getRawData=function(t){return void 0===t&&(t="png"),Y(this,void 0,void 0,(function(){var e,r,n;return $(this,(function(o){switch(o.label){case 0:if(!this._qr)throw "QR code is empty";return [4,this._getQRStylingElement(t)];case 1:return e=o.sent(),"svg"===t.toLowerCase()?(r=new XMLSerializer,n=r.serializeToString(e.getElement()),[2,new Blob(['<?xml version="1.0" standalone="no"?>\r\n'+n],{type:"image/svg+xml"})]):[2,new Promise((function(r){return e.getCanvas().toBlob(r,"image/"+t,1)}))]}}))}))},t.prototype.download=function(t){return Y(this,void 0,void 0,(function(){var e,r,n,o,i;return $(this,(function(a){switch(a.label){case 0:if(!this._qr)throw "QR code is empty";return e="png",r="qr","string"==typeof t?(e=t,console.warn("Extension is deprecated as argument for 'download' method, please pass object { name: '...', extension: '...' } as argument")):"object"==typeof t&&null!==t&&(t.name&&(r=t.name),t.extension&&(e=t.extension)),[4,this._getQRStylingElement(e)];case 1:return n=a.sent(),"svg"===e.toLowerCase()?(o=new XMLSerializer,i='<?xml version="1.0" standalone="no"?>\r\n'+(i=o.serializeToString(n.getElement())),s("data:image/svg+xml;charset=utf-8,"+encodeURIComponent(i),r+".svg")):s(n.getCanvas().toDataURL("image/"+e),r+"."+e),[2]}}))}))},t}();}},e={};function r(n){if(e[n])return e[n].exports;var o=e[n]={exports:{}};return t[n](o,o.exports,r),o.exports}return r.n=t=>{var e=t&&t.__esModule?()=>t.default:()=>t;return r.d(e,{a:e}),e},r.d=(t,e)=>{for(var n in e)r.o(e,n)&&!r.o(t,n)&&Object.defineProperty(t,n,{enumerable:!0,get:e[n]});},r.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r(796)})().default}));

    });

    var QRCodeStyling = unwrapExports(qrCodeStyling);
    qrCodeStyling.QRCodeStyling;

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     *
     * https://www.npmjs.com/package/qr-code-styling 라이브러리로 구현.
     *
     * Qrcode renderer impl for {@link QrcodeRenderer}.
     * 접근성 - alt 속성에 대체 텍스트 표시.
     */
    class QrcodeRendererImpl extends ValueRendererImpl {
        //-------------------------------------------------------------------------
        // static members
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // property fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doPrepare(ctx, div) {
            const q = div[SHAPE] = new QRCodeStyling({
                qrOptions: {
                    errorCorrectionLevel: QrcodeErrorCorrectionLevel.Q
                }
            });
            q.append(div);
        }
        _getStyleTarget(div) {
            return;
        }
        _doMeasure(ctx, div, hintWidth, hintHeight) {
            const model = this._model;
            const qrcode = div[SHAPE];
            const value = this._value;
            const s = value == null ? '' : String(value);
            const { w, h } = model.getQrcodeSize();
            // this._setClass(qrcode, ctx.row);
            qrcode.update({
                type: model.output || 'canvas',
                width: w,
                height: h,
                data: s,
                dotsOptions: {
                // type: 'dots'
                },
                backgroundOptions: {
                // color: '#00ff0000'
                }
            });
            if (DElement.TESTING) {
                return { width: w, height: h };
            }
        }
        _doRender(ctx, div, width, height) {
        }
        _doUnprepare(ctx, div) {
            div[SHAPE] = null;
        }
        setValue(layout, newValue) {
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    QrcodeRendererImpl.SPAN_CLASS = 'dlist-qrcode-span';
    /**
     * @internal
     *
     * Testing mock class for QrcodeRendererImpl
     */
    class QrcodeRendererImplTest extends QrcodeRendererImpl {
        _doPrepare(ctx, div) {
            div[SHAPE] = null;
        }
        _getStyleTarget(div) {
            return div.style;
        }
        _doMeasure(ctx, div, maxWidth, maxHeight) {
            const { w, h } = this._model.getQrcodeSize();
            return { width: w, height: h };
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     *
     * RadioGroup renderer impl for {@link RadioGroupRenderer}.
     */
    class RadioGroupRendererImpl extends DListRendererImpl {
        //-------------------------------------------------------------------------
        // static members
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // property fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doPrepare(ctx, div) {
            div[GROUP] = this.$_buildGroup(ctx, this._model, div);
        }
        _getStyleTarget(div) {
            return div.style;
        }
        _doMeasure(ctx, div, hintWidth, hintHeight) {
            const model = this._model;
            const values = model.values;
            const count = values ? values.length : 0;
            const g = div[GROUP].firstElementChild;
            let w = 0;
            let h = 0;
            this._setClass(g, ctx.row);
            this._setContext(ctx, div, model);
            if (count > 0) {
                const value = ctx.value();
                const labels = model.labels || [];
                // const wrap = model.labelWrap && isNaN(ctx._explicitWidth) ? '' : 'nowrap';
                const wrap = model.labelWrap && !isNaN(ctx._explicitWidth) ? 'pre-wrap' : 'pre';
                const boxGap = model.boxGap + 'px';
                const itemGap = model.itemGap + 'px';
                values.forEach((v, i) => {
                    const itemDiv = g.children[i];
                    const box = itemDiv.firstElementChild;
                    const label = itemDiv.children[1];
                    const id = div.id + '-' + i;
                    // label이 wrap될 떄 높이가 제대로 계산될 수 있도록
                    if (wrap) {
                        Dom.setWidth(itemDiv, ctx._explicitWidth);
                    }
                    // itemDiv.style.gap = model.boxGap + 'px'; // 아직 많이 지원하지 않는다. 아래 marginRight로 대체.
                    box.checked = v === value;
                    box.id = id;
                    box.name = div.id;
                    box.style.marginRight = boxGap;
                    label.style.whiteSpace = wrap;
                    label.textContent = labels[i] || values[i];
                    label.htmlFor = id;
                    if (i < count - 1) {
                        itemDiv.style.marginBottom = itemGap;
                    }
                });
                // g.style.gap = model.itemGap + 'px';// 아직 많이 지원하지 않는다. 위 marginBottom으로 대체.
            }
            w = div.offsetWidth;
            h = div.offsetHeight;
            return { width: w, height: h };
        }
        _doRender(ctx, div, width, height) {
            div[GROUP];
            // g.style.display = 'table-cell';
        }
        _doUnprepare(ctx, div) {
            div[GROUP] = null;
        }
        setValue(layout, newValue) {
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        $_buildGroup(ctx, model, div) {
            let elt = div.getElementsByClassName(RadioGroupRendererImpl.CLASS_NAME)[0];
            let g;
            if (!elt) {
                elt = ctx.doc.createElement('div');
                elt.className = RadioGroupRendererImpl.CLASS_NAME;
                g = ctx.doc.createElement('div');
                g.className = RadioGroupRendererImpl.GROUP_CLASS;
                Object.assign(g.style, {
                    display: 'flex',
                    flexDirection: 'column'
                });
                elt.appendChild(g);
                div.appendChild(elt);
            }
            else {
                g = elt.firstElementChild;
            }
            const n = model.valueCount;
            while (g.children.length < n) {
                const itemDiv = ctx.doc.createElement('div');
                const box = ctx.doc.createElement('input');
                const label = ctx.doc.createElement('label');
                Object.assign(itemDiv.style, {
                    display: 'flex'
                });
                box.className = RadioGroupRendererImpl.BOX_CLASS;
                box.type = 'radio';
                Object.assign(box.style, {
                    flex: 'none' // to prevent a flex item from growing or shrinking. 이렇게 하지 않으면 label이 wrap될 때 box 크기가 작이진다.
                });
                label.className = RadioGroupRendererImpl.LABEL_CLASS;
                Object.assign(label.style, {
                    flexGrow: 1,
                });
                itemDiv.appendChild(box);
                itemDiv.appendChild(label);
                g.appendChild(itemDiv);
            }
            while (g.children.length > n) {
                g.lastElementChild.remove();
            }
            return elt;
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    RadioGroupRendererImpl.CLASS_NAME = 'dlist-radiogroup';
    RadioGroupRendererImpl.GROUP_CLASS = 'dlist-radiogroup-group';
    RadioGroupRendererImpl.BOX_CLASS = 'dlist-radiogroup-box';
    RadioGroupRendererImpl.LABEL_CLASS = 'dlist-radiogroup-label';

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     *
     * Radio renderer impl for {@link RadioRenderer}.
     * radio box를 opacity=0 으로 표시한다.
     */
    class RadioRendererImpl extends CheckRendererImpl {
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _measureBox(ctx, box) {
            super._measureBox(ctx, box);
            const m = this._model;
            box.name = (m.group || '_dlist_radio_group_') + ctx.row;
        }
        setValue(layout, newValue) {
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        _getBoxType() {
            return 'radio';
        }
        _getBoxClass() {
            return RadioRendererImpl.BOX_CLASS;
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    RadioRendererImpl.BOX_CLASS = 'dlist-radio-box';

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     *
     * Rating renderer impl for {@link RatingRenderer}.
     */
    class RatingRendererImpl extends DListRendererImpl {
        //-------------------------------------------------------------------------
        // static members
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // property fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doPrepare(ctx, div) {
            div[GROUP] = this.$_getGroup(ctx, div);
        }
        _getStyleTarget(div) {
            return;
        }
        _doMeasure(ctx, div, hintWidth, hintHeight) {
            let w = 0;
            let h = 0;
            // this._setClass(span, ctx.row);
            return { width: w, height: h };
        }
        _doRender(ctx, div, width, height) {
        }
        _doUnprepare(ctx, div) {
        }
        setValue(layout, newValue) {
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        $_getGroup(ctx, div) {
            let g = div.getElementsByClassName(RatingRendererImpl.GROUP_CLASS)[0];
            if (!g) {
                g = ctx.doc.createElement('div');
                g.className = RatingRendererImpl.GROUP_CLASS;
                div.appendChild(g);
            }
            return g;
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    RatingRendererImpl.GROUP_CLASS = 'dlist-rating-group';

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     *
     * Select renderer impl for {@link SelectRenderer}.
     */
    class SelectRendererImpl extends DListRendererImpl {
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        // 자식 dom들에 설정된 이벤트 핸들러 등의 연결을 끊는다.
        _doDisposeContent(div) {
            div.getElementsByClassName(SelectRendererImpl.BOX_CLASS)[0].onchange = null;
        }
        _doPrepare(ctx, div) {
            div[BOX] = this.$_getSelect(ctx, div);
        }
        _getStyleTarget(div) {
            return;
        }
        _doMeasure(ctx, div, hintWidth, hintHeight) {
            const model = this._model;
            const box = div[BOX];
            let w = model.boxWidth;
            this._setClass(box, ctx.row);
            if (isNaN(w) && !isNaN(ctx._explicitWidth)) {
                w = ctx._explicitWidth * model.getFitWidth();
            }
            !isNaN(w) && Dom.setWidth(box, w);
            // 사용자가 값 변경 이벤트를 받으려면 id를 설정하거나 field가 연결돼야 한다.
            this._setContext(ctx, box, model);
            if (model.itemsChanged) {
                Dom.clearChildren(box);
                model.isGrouped ? this.$_buildGroups(ctx.doc, model, box) : this.$_buildOptions(ctx.doc, model, box);
            }
            // if (!isNaN(model.dropDownCount)) {
            //     box.size = model.dropDownCount;
            // }
            box.value = ctx.value();
            if (DElement.TESTING) {
                const w = box.offsetWidth;
                const h = box.offsetHeight;
                return { width: w, height: h };
            }
        }
        _doRender(ctx, div, width, height) {
            // this._box.style.width = width + 'px';
        }
        _doUnprepare(ctx, div) {
            div[BOX] = null;
        }
        setValue(layout, newValue) {
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        $_getSelect(ctx, div) {
            let box = div.getElementsByClassName(SelectRendererImpl.BOX_CLASS)[0];
            if (!box) {
                // div로 씌우지 않으면 수직 중앙 정렬이 되지 않는다.
                const c = ctx.doc.createElement('div');
                box = ctx.doc.createElement('select');
                box.className = SelectRendererImpl.BOX_CLASS;
                box.onchange = (ev) => {
                    const result = {
                        id: box.id,
                        field: box[T_FIELD],
                        selectedIndex: box.selectedIndex,
                        selectedValue: box.value
                    };
                    console.log('select changed', result, ev);
                };
                c.appendChild(box);
                div.appendChild(c);
            }
            return box;
        }
        $_buildOptions(doc, model, box) {
            const values = model['_values'];
            const count = values ? values.length : 0;
            if (count > 0) {
                const labels = model['_labels'];
                const labelCount = labels ? labels.length : 0;
                for (let i = 0; i < count; i++) {
                    const opt = doc.createElement('option');
                    opt.value = values[i];
                    opt.text = labelCount > i ? labels[i] : values[i];
                    box.add(opt);
                }
            }
        }
        $_buildGroups(doc, model, box) {
            const groups = model['_groups'];
            groups.length;
            for (let g of groups) {
                const values = g.values;
                const labels = g.labels;
                const vCount = values ? values.length : 0;
                const lCount = labels ? labels.length : 0;
                const grp = doc.createElement('optgroup');
                grp.label = g.group;
                if (vCount > 0) {
                    for (let i = 0; i < vCount; i++) {
                        const opt = doc.createElement('option');
                        opt.value = values[i];
                        opt.text = lCount > i ? labels[i] : values[i];
                        grp.appendChild(opt);
                    }
                    box.add(grp);
                }
            }
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    SelectRendererImpl.BOX_CLASS = 'dlist-select-box';

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     *
     * Shape renderer impl for {@link ShapeRenderer}.
     */
    class ShapeRendererImpl extends DListRendererImpl {
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        // 자식 dom들에 설정된 이벤트 핸들러 등의 연결을 끊는다.
        _doDisposeContent() {
            this._shape = DObject.destroy(this._shape);
        }
        _doPrepare(ctx, div) {
            this._shape = this.$_getShape(ctx, div);
            // div[SVG] = this.$_getShape(ctx, div);
        }
        _getStyleTarget(div) {
            // return div[SVG].style;
            return this._shape && this._shape.styleTarget();
        }
        _doMeasure(ctx, div, maxWidth, maxHeight) {
            const model = this.model();
            // const dom = div[SVG];
            let w = model.getShapeWidth() || ctx._explicitWidth;
            let h = model.getShapeHeight() || ctx._explicitHeight;
            if (this._shape) {
                const dom = this._shape.dom();
                this._setClass(dom, ctx.row);
                const alt = model.hint || "";
                this._shape.resize(w, h);
                Dom.resize(dom, w, h);
                Dom.setAttr(dom, 'aria-label', alt);
                Dom.setAttr(dom, 'aria-hidden', model.decorative || !alt);
            }
            return;
            // return { width: w, height: h };
        }
        _doRender(ctx, div, width, height) {
        }
        _doUnprepare(ctx, div) {
            div[SVG] = null;
        }
        setValue(layout, newValue) {
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        // rendererImpl은 여러 row에 공유될 수 있다. this._shape를 가지고 다닐 수 없다.
        // 기존에 모양이 같은 svg를 가지고 있다면 재활용한다.
        $_getShape(ctx, div) {
            const shapes = ctx.manager().owner().shapes();
            const name = this._model.getShapeName();
            const svg = div.getElementsByClassName(ShapeRendererImpl.SVG_CLASS)[0];
            let shape;
            if (!svg || div[T_NAME] !== name) {
                svg && svg.remove();
                shape = shapes.createStock(ctx.doc, name, ShapeRendererImpl.SVG_CLASS) || shapes.createCustom(name, null, null);
                if (shape) {
                    if (shape instanceof DCustomShape) {
                        shape.setShape(shapes.getCustom(name));
                    }
                    shape.appendTo(div);
                    div[T_NAME] = name;
                    this._shape = shape;
                }
            }
            else if (svg) {
                shape = shapes.createStock(svg, name, ShapeRendererImpl.SVG_CLASS) || shapes.createCustom(name, svg, null);
            }
            return shape;
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    ShapeRendererImpl.SVG_CLASS = 'dlist-shape-svg';
    /**
     * @internal
     *
     * Testing mock class for ShapeRendererimpl
     */
    class ShapeRendererImplTest extends ShapeRendererImpl {
        _doPrepare(ctx, div) {
            this._shape = div[SVG] = null;
        }
        _getStyleTarget(div) {
            return div.style;
        }
        _doMeasure(ctx, div, maxWidth, maxHeight) {
            const model = this.model();
            let w = model.getShapeWidth() || ctx._explicitWidth;
            let h = model.getShapeHeight() || ctx._explicitHeight;
            return { width: w, height: h };
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     *
     * Spark renderer impl for {@link SparkRenderer}.
     */
    class SparkRendererImpl extends DSvgRendererImpl {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doMeasure(ctx, div, maxWidth, maxHeight) {
            const model = this._model;
            const values = this._values = this._getValues(ctx, model.baseValue);
            let w = pickNum(model.chartWidth, ctx._explicitWidth);
            let h = pickNum(model.chartHeight, ctx._explicitHeight);
            this._setClass(this._svg.svg, ctx.row);
            if (isNaN(w)) {
                w = this._measureChart(ctx, this._svg, values.values);
            }
            else {
                this._wPoint = NaN;
            }
            if (isNaN(h)) {
                h = Math.min(SparkRendererImpl.DEF_HEIGHT, maxHeight);
            }
            return { width: w, height: h };
        }
        _doRender(ctx, div, width, height) {
            this._svg.setSize(width, height);
            // TODO: 기존 상태(모델 및 data)와 동일하면 renderging 하지 않기 (가능한가?, 필요한가?)
            this._svg.clear();
            if (this._values.values.length) {
                this._renderChart(ctx, this._svg, this._values, width, height);
            }
        }
        setValue(layout, newValue) {
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        _measureChart(ctx, svg, values) {
            const w = this._wPoint = Math.max(1, pickNum(this._model.pointWidth, 1));
            return w * values.length;
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    SparkRendererImpl.DEF_HEIGHT = 30;
    class SparkBarRendererImpl extends SparkRendererImpl {
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _getSvgClass() {
            return SparkBarRendererImpl.SVG_CLASS;
        }
        _renderChart(ctx, svg, calced, w, h) {
            const model = this._model;
            const vals = calced.values;
            const hasBelow = calced.hasBelow;
            const max = pickNum(model.maxValue, calced.max);
            const len = vals.length;
            const wPoint = pickNum(this._wPoint, w / len);
            const wBar = wPoint * this._model.pointSize;
            let x = 0;
            if (hasBelow) ;
            else {
                let min = pickNum(model.minValue, model.baseValue);
                if (isNaN(min)) {
                    min = calced.min;
                    if (model.minPadding > 0) {
                        min -= (max - min) * model.minPadding;
                    }
                }
                for (let i = 0; i < len; i++) {
                    const v = vals[i];
                    const p = x + wPoint / 2;
                    const y = h - ((vals[i] - min) * h / (max - min));
                    const style = svg.rect(p - wBar / 2, y, wBar, h, null).style;
                    if (i === 0 && model.firstStyle) {
                        Object.assign(style, model.firstStyle);
                    }
                    if (i === len - 1 && model.lastStyle) {
                        Object.assign(style, model.lastStyle);
                    }
                    if (v === calced.max && model.maxStyle) {
                        Object.assign(style, model.maxStyle);
                    }
                    if (v === calced.min && model.minStyle) {
                        Object.assign(style, model.minStyle);
                    }
                    x += wPoint;
                }
            }
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    SparkBarRendererImpl.SVG_CLASS = 'dlist-sparkbar-svg';
    class SparkLineRendererImpl extends SparkRendererImpl {
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _getSvgClass() {
            return SparkLineRendererImpl.SVG_CLASS;
        }
        _renderChart(ctx, svg, calced, w, h) {
            const model = this._model;
            const vals = calced.values;
            const max = pickNum(model.maxValue, calced.max);
            const len = vals.length;
            const wPoint = pickNum(this._wPoint, w / len);
            const pts = [];
            let x = 0;
            let min = model.minValue;
            if (isNaN(min)) {
                min = calced.min;
                if (model.minPadding > 0) {
                    min -= (max - min) * model.minPadding;
                }
            }
            for (let i = 0; i < len; i++) {
                const p = x + wPoint / 2;
                const y = h - ((vals[i] - min) * h / (max - min));
                pts.push(p, y);
                x += wPoint;
            }
            svg.polyline(pts);
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    SparkLineRendererImpl.SVG_CLASS = 'dlist-sparkline-svg';
    /**
     * @internal
     *
     * Testing mock class for SparkBarRendererImpl
     */
    class SparkBarRendererImplTest extends SparkBarRendererImpl {
        _doPrepare(ctx, div) {
        }
        _getStyleTarget(div) {
            return div.style;
        }
        _doMeasure(ctx, div, maxWidth, maxHeight) {
            return { width: 10, height: 10 };
        }
        _doRender(ctx, div, width, height) {
        }
    }
    /**
     * @internal
     *
     * Testing mock class for SparkLineRendererImpl
     */
    class SparkLineRendererImplTest extends SparkLineRendererImpl {
        _doPrepare(ctx, div) {
        }
        _getStyleTarget(div) {
            return div.style;
        }
        _doMeasure(ctx, div, maxWidth, maxHeight) {
            return { width: 10, height: 10 };
        }
        _doRender(ctx, div, width, height) {
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     *
     * Svg renderer impl for {@link SvgRenderer}.
     */
    class SvgRendererImpl extends DSvgRendererImpl {
        //-------------------------------------------------------------------------
        // static members
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // property fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _getSvgClass() {
            return SvgRendererImpl.SVG_CLASS;
        }
        _doMeasure(ctx, div, hintWidth, hintHeight) {
            const model = this.model();
            let w = ctx._explicitWidth || model.getSvgWidth();
            let h = ctx._explicitHeight || model.getSvgHeight();
            if (this._svg) {
                const svg = this._svg;
                const shapes = model.shapes;
                const dom = svg.svg;
                svg.clear();
                if (Array.isArray(shapes)) {
                    shapes.forEach(shape => svg.path(shape));
                }
                else if (shapes) {
                    svg.path(shapes);
                }
                svg.setViewSize(model.getVboxWidth(), model.getVboxHeight());
                svg.setSize(model.getSvgWidth(), model.getSvgHeight());
                this._setClass(dom, ctx.row);
                const alt = model.hint || "";
                Dom.resize(dom, w, h);
                Dom.setAttr(dom, 'aria-label', alt);
                Dom.setAttr(dom, 'aria-hidden', model.decorative || !alt);
            }
            //return { width: w, height: h };
            return;
        }
        _doRender(ctx, div, width, height) {
        }
        setValue(layout, newValue) {
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    SvgRendererImpl.SVG_CLASS = 'dlist-svg-svg';

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     *
     * Switch renderer impl for {@link SwitchRenderer}.
     * check box를 opacity=0 으로 표시한다. role='switch'.
     */
    class SwitchRendererImpl extends EditableRendererImpl {
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        getValue(layout) {
            let elt = layout.getElementsByClassName(SwitchRendererImpl.BOX_CLASS)[0];
            return elt instanceof HTMLInputElement && !!elt.checked;
        }
        // 자식 dom들에 설정된 이벤트 핸들러 등의 연결을 끊는다.
        _doDisposeContent(div) {
            let elt = div.getElementsByClassName(SwitchRendererImpl.CLASS_NAME)[0];
            if (elt) {
                const sw = elt.firstElementChild;
                const span = sw.children[1];
                span.onclick = null;
            }
        }
        _doPrepare(ctx, div) {
            div[GROUP] = this.$_getSwitch(ctx, div);
        }
        _getStyleTarget(div) {
            return;
        }
        _doMeasure(ctx, div, hintWidth, hintHeight) {
            const model = this._model;
            const sw = div[GROUP].firstElementChild;
            const box = sw.firstElementChild;
            const span = sw.children[1];
            const sz = Utils.pickNum(model.boxSize, SwitchRendererImpl.DEF_SIZE);
            let w = sz * 1.7;
            let h = sz;
            this._setClass(sw, ctx.row);
            // 사용자가 값 변경 이벤트를 받으려면 id를 설정하거나 field가 연결돼야 한다.
            this._setContext(ctx, box, model);
            span.id = model.id + '_span';
            box.checked = model.isTrue(this._value);
            sw.style.setProperty('--switch-size', sz + 'px');
            sw.style.setProperty('--switch-on', sz * 0.7 + 'px');
            if (model.style && model.style.backgroundColor) {
                sw.style.setProperty('--switch-color', model.style.backgroundColor);
            }
            span.style.width = w + 'px';
            span.style.height = h + 'px';
            if (DElement.TESTING) {
                return { width: w, height: h };
            }
        }
        _doRender(ctx, div, width, height) {
        }
        _doUnprepare(ctx, div) {
            div[GROUP] = null;
        }
        setValue(layout, newValue) {
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        $_getSwitch(ctx, div) {
            let elt = div.getElementsByClassName(SwitchRendererImpl.CLASS_NAME)[0];
            if (!elt) {
                elt = ctx.doc.createElement('div');
                elt.className = SwitchRendererImpl.CLASS_NAME;
                const sw = ctx.doc.createElement('div');
                sw.className = SwitchRendererImpl.SWITCH_CLASS;
                Object.assign(sw.style, {
                // display: 'flex',
                });
                const box = ctx.doc.createElement('input');
                box.className = SwitchRendererImpl.BOX_CLASS;
                box.type = 'checkbox';
                box.style.display = 'none';
                const span = ctx.doc.createElement('div');
                span.className = SwitchRendererImpl.SPAN_CLASS;
                Object.assign(span.style, {
                    position: 'relative',
                    display: "block"
                });
                // NOTE: () => 함수로 설정해서 리스트 컨트롤과 연결하면 안된다.
                span.onclick = function (ev) {
                    const check = ev.target.parentElement.getElementsByClassName(SwitchRendererImpl.BOX_CLASS)[0];
                    check.checked = !check.checked;
                    // DElement['TESTING'] && console.log('switch clicked', check.id, check.checked);
                };
                span[CLICKABLE] = true;
                sw.appendChild(box);
                sw.appendChild(span);
                elt.appendChild(sw);
                div.appendChild(elt);
            }
            return elt;
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    SwitchRendererImpl.CLASS_NAME = 'dlist-switch';
    SwitchRendererImpl.SWITCH_CLASS = 'dlist-switch-switch';
    SwitchRendererImpl.BOX_CLASS = 'dlist-switch-box';
    SwitchRendererImpl.SPAN_CLASS = 'dlist-switch-span';
    SwitchRendererImpl.SWITCH_SIZE = '--dl-switch-size';
    SwitchRendererImpl.SWITCH_COLOR = '--dl-switch-color';
    SwitchRendererImpl.DEF_SIZE = 24;

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     *
     * Label renderer impl for {@link LabelRenderer}.
     */
    class LabelRendererImpl extends TextRendererImplBase {
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doPrepare(ctx, layout) {
            layout[SPAN] = this.$_getLabel(ctx, layout);
            super._doPrepare(ctx, layout);
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        $_getLabel(ctx, layout) {
            let div = layout.getElementsByClassName(LabelRendererImpl.LABEL_CLASS)[0];
            if (!div) {
                div = ctx.createElement('div');
                div.className = LabelRendererImpl.LABEL_CLASS;
                const label = ctx.doc.createElement('label');
                // label.style.display = 'inline-block'; // 매우 중요!. 자체 text-align이 적용된다.
                div.appendChild(label);
                layout.appendChild(div);
            }
            return div;
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    LabelRendererImpl.LABEL_CLASS = 'dlist-label-label';

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     *
     * LetterRenderer renderer impl for {@link LetterRenderer}.
     */
    class LetterRendererImpl extends DListRendererImpl {
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doPrepare(ctx, div) {
            div[SVG] = this.$_getShape(ctx, div);
        }
        _getStyleTarget(div) {
            return div[SVG].style;
        }
        _doMeasure(ctx, div, maxWidth, maxHeight) {
            const model = this.model();
            const svg = div[SVG];
            const text = svg.firstElementChild;
            this._setClass(text, ctx.row);
            text.textContent = model.letter;
            text.setAttribute('x', (50 + (model.offsetX || 0) * 100) + '%');
            text.setAttribute('y', (50 + (model.offsetY || 0) * 100) + '%');
            // svg 기본 크기가 300 * 150 이다. 크기를 지정해야 한다.
            const r = text.getBoundingClientRect();
            svg.style.width = r.width + 'px';
            svg.style.height = r.height + 'px';
            if (DElement.TESTING) {
                return { width: 20, height: 30 };
            }
        }
        _doRender(ctx, div, width, height) {
        }
        _doUnprepare(ctx, div) {
            div[SVG] = null;
        }
        setValue(layout, newValue) {
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        $_getShape(ctx, div) {
            let svg = div.getElementsByClassName(LetterRendererImpl.SVG_CLASS)[0];
            if (!svg) {
                const text = ctx.doc.createElementNS(SVGNS, 'text');
                text.setAttribute('x', '50%');
                text.setAttribute('y', '50%');
                text.setAttribute('dominant-baseline', 'middle');
                text.setAttribute('text-anchor', 'middle');
                svg = ctx.doc.createElementNS(SVGNS, 'svg');
                svg.classList.add(LetterRendererImpl.SVG_CLASS);
                svg.appendChild(text);
                div.appendChild(svg);
            }
            return svg;
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    LetterRendererImpl.SVG_CLASS = 'dlist-letter-svg';

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     *
     * Line renderer impl for {@link LineRenderer}.
     */
    class LineRendererImpl extends DListRendererImpl {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doPrepare(ctx, div) {
            div[SPAN] = this.$_getSpan(ctx, div);
        }
        _getStyleTarget(div) {
            return div[SPAN].style;
        }
        _doMeasure(ctx, div, maxWidth, maxHeight) {
            const model = this.model();
            const wLine = this._wLine = model.thickness || 0;
            const span = div[SPAN];
            const layout = ctx.layout._parent;
            const horz = this._horz = model.dir === 'horizontal' || (model.dir !== 'vertical' && layout.canContainVspace());
            const width = horz ? pickNum(ctx._explicitWidth, maxWidth) : pickNum(ctx._explicitWidth, wLine);
            const height = horz ? pickNum(ctx._explicitHeight, wLine) : pickNum(ctx._explicitHeight, maxHeight);
            const css = span.style;
            this._setClass(span, ctx.row);
            if (horz) {
                css.borderWidth = `0 0 ${wLine}px 0`;
            }
            else {
                css.borderWidth = `0 ${wLine}px 0 0`;
            }
            css.borderColor = model.lineColor;
            css.borderStyle = model.lineStyle;
            return { width, height };
        }
        _doRender(ctx, div, width, height) {
            const span = div[SPAN];
            const wLine = this._wLine;
            if (this._horz) {
                if (height !== wLine) {
                    Dom.setHeight(span, wLine);
                    Dom.moveY(span, (height - wLine) / 2);
                }
            }
            else {
                if (width !== wLine) {
                    Dom.setWidth(span, wLine);
                    Dom.moveX(span, (width - wLine) / 2);
                }
            }
        }
        _doUnprepare(ctx, div) {
            div[SPAN] = null;
        }
        setValue(layout, newValue) {
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        $_getSpan(ctx, div) {
            let span = div.getElementsByClassName(LineRendererImpl.SPAN_CLASS)[0];
            if (!span) {
                span = ctx.createElement('span');
                span.className = LineRendererImpl.SPAN_CLASS;
                Object.assign(span.style, {
                    display: 'block',
                    position: 'absolute',
                    boxSizing: 'border-box',
                    width: '100%',
                    height: '100%'
                });
                div.appendChild(span);
            }
            return span;
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    LineRendererImpl.SPAN_CLASS = 'dlist-line-span';

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     *
     * Spinner renderer impl for {@link SpinnerRenderer}.
     */
    class SpinnerRendererImpl extends DListRendererImpl {
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doPrepare(ctx, div) {
            div[SVG] = this.$_getSVG(ctx, div);
        }
        _getStyleTarget(div) {
            return div[SVG].style;
        }
        _doMeasure(ctx, div, maxWidth, maxHeight) {
            const model = this.model();
            const svg = div[SVG];
            let w = model.getSpinnerWidth() || ctx._explicitWidth;
            let h = model.getSpinnerHeight() || ctx._explicitHeight;
            this._setClass(svg, ctx.row);
            if (svg) {
                const old = svg[T_CLASS];
                const alt = model.hint || "";
                let cls;
                switch (model.spinnerType) {
                    case DListSpinnerType.SPOKES:
                        cls = 'dlist-spinner-spoke';
                        break;
                    default:
                        cls = 'dlist-spinner-default';
                        break;
                }
                old && svg.classList.remove(old);
                svg.classList.add(cls);
                svg[T_CLASS] = cls;
                Dom.setAttr(svg, 'aria-label', alt);
                Dom.setAttr(svg, 'aria-hidden', !alt);
                Dom.clearChildren(svg);
                Dom.resize(svg, w, h);
                return;
            }
        }
        _doRender(ctx, div, width, height) {
            const model = this.model();
            const svg = div[SVG];
            Dom.resize(svg, width, height);
            DSpinner.render(ctx.doc, svg, {
                type: model.spinnerType,
                width: width,
                height: height,
                itemCount: model.itemCount,
                duration: model.duration
            });
        }
        _doUnprepare(ctx, div) {
            div[SVG] = null;
        }
        setValue(layout, newValue) {
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        $_getSVG(ctx, div) {
            let svg = div.getElementsByClassName(SpinnerRendererImpl.SVG_CLASS)[0];
            if (!svg) {
                const doc = ctx.doc;
                svg = DSvg.create(doc);
                svg.classList.add(SpinnerRendererImpl.SVG_CLASS);
                div.appendChild(svg);
            }
            return svg;
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    SpinnerRendererImpl.SVG_CLASS = 'dlist-spinner-svg';
    /**
     * @internal
     *
     * Testing mock class for SpinnerRendererimpl
     */
    class SpinnerRendererImplTest extends SpinnerRendererImpl {
        _doMeasure(ctx, div, maxWidth, maxHeight) {
            const model = this.model();
            let w = model.getSpinnerWidth() || ctx._explicitWidth;
            let h = model.getSpinnerHeight() || ctx._explicitHeight;
            return { width: w, height: h };
        }
        _doRender(ctx, div, width, height) {
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    const ONE = '①'.charCodeAt(0);
    /**
     * @internal
     *
     * Field renderer impl for {@link FieldRenderer}.
     */
    class FieldRendererImpl extends ValueRendererImpl {
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doPrepare(ctx, div) {
            div[SPAN] = this.$_getDiv(ctx, div);
        }
        _doMeasure(ctx, layout, maxWidth, maxHeight) {
            function getField() {
                return dv && dv.fieldByName(model.field || ctx.layout.getField());
            }
            const model = this._model;
            const dv = ctx.manager().data();
            const fld = getField();
            const sort = fld && (dv instanceof ListDataView) && dv.isSorted(fld);
            const orderVis = this._orderVis = this.$_getOrderVisible(ctx, model);
            const { span, dir, order } = this.$_getSpans(layout);
            let w = 0;
            let h = 0;
            this._setClass(span, ctx.row);
            span.textContent = model.label || (fld ? fld.displayText() : (model.field || this._value));
            if (sort) {
                Dom.show(dir);
                dir.textContent = sort.dir === DListSortDirection.ASCENDING ? '↓' : '↑';
                w = dir.offsetWidth;
                if (orderVis) {
                    Dom.show(order);
                    order.textContent = String.fromCharCode(ONE + sort.order);
                    w += order.offsetWidth;
                }
                else {
                    Dom.hide(order);
                }
            }
            else {
                Dom.hide(dir);
                Dom.hide(order);
            }
            w += span.offsetWidth;
            h = Math.max(span.offsetHeight, dir.offsetHeight);
            if (orderVis) {
                h = Math.max(h, order.offsetHeight);
            }
            return { width: this._wSpans = w, height: h };
            // // span의 parent가 table이어서 계산할 필요가 없다.
            // if (DElement.TESTING) {
            //     const div = layout[SPAN];
            //     const width = Math.ceil(div.offsetWidth);
            //     const height = Math.ceil(div.offsetHeight);
            //     return { width, height };
            // }
        }
        _doRender(ctx, layout, width, height) {
            const { span, dir, order } = this.$_getSpans(layout);
            let x;
            // absolute로 위치를 지정하므로 layout view의 align 설정이 반영되지 않는다.
            // 여기에서 반영시킨다.
            switch (ctx.align()) {
                case DListHorizontalAlign.LEFT:
                    x = 0;
                    break;
                case DListHorizontalAlign.RIGHT:
                    x = Math.max(0, width = this._wSpans);
                    break;
                default:
                    x = (width - this._wSpans) / 2;
                    break;
            }
            Dom.move(span, x, (height - span.offsetHeight) / 2);
            x += span.offsetWidth;
            Dom.move(dir, x, (height - dir.offsetHeight) / 2);
            if (this._orderVis) {
                x += dir.offsetWidth;
                Dom.move(order, x, (height - order.offsetHeight) / 2);
            }
        }
        _doUnprepare(ctx, div) {
            div[SPAN] = null;
        }
        setValue(layout, newValue) {
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        $_getDiv(ctx, layout) {
            function addSpan() {
                const span = ctx.doc.createElement('span');
                span.style.position = 'absolute';
                div.appendChild(span);
                return span;
            }
            let div = layout.getElementsByClassName(FieldRendererImpl.FIELD_CLASS)[0];
            if (!div) {
                div = ctx.createElement('div');
                div.className = FieldRendererImpl.FIELD_CLASS;
                // div.style.position = 'relative';
                Dom.setStyle(addSpan(), {
                    whiteSpace: 'nowrap',
                    overflow: 'hidden',
                    textOverflow: 'ellipsis'
                });
                addSpan().className = FieldRendererImpl.DIR_CLASS;
                addSpan().className = FieldRendererImpl.ORDER_CLASS;
                layout.appendChild(div);
            }
            return div;
        }
        $_getSpans(layout) {
            const div = layout[SPAN];
            const childs = div.children;
            return {
                span: childs[0],
                dir: childs[1],
                order: childs[2]
            };
        }
        $_getOrderVisible(ctx, model) {
            const vis = model.orderVisibility;
            if (vis === DListFieldOrderVisibility.VISIBLE) {
                return true;
            }
            if (vis === DListFieldOrderVisibility.HIDDEN) {
                return false;
            }
            const c = ctx.manager().layoutContainer;
            if (c && c[FieldRendererImpl.IS_FIELD_ORDER_VISIBLE]) {
                return c[FieldRendererImpl.IS_FIELD_ORDER_VISIBLE]();
            }
            return false;
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    FieldRendererImpl.FIELD_CLASS = 'dlist-field-field';
    FieldRendererImpl.DIR_CLASS = 'dlist-field-dir';
    FieldRendererImpl.ORDER_CLASS = 'dlist-field-order';
    FieldRendererImpl.IS_FIELD_ORDER_VISIBLE = 'isFieldOrderVisible';

    ////////////////////////////////////////////////////////////////////////////////
    const DUMMY_STYLE = {
        width: '',
        color: 'transparent',
        borderRadius: '5px',
    };
    const SKELETON_STYLE = Object.assign(DUMMY_STYLE, {
        backgroundColor: '#e0e0e0',
        backgroundImage: 'linear-gradient(90deg, #e0e0e0, #efefef 50%, #e0e0e0)',
        backgroundRepeat: 'no-repeat'
    });
    /**
     * @internal
     *
     * Dummy renderer impl for {@link DummyRenderer}.
     */
    class DummyRendererImpl extends DListRendererImpl {
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        setAnimation(ani) {
            this._ani = ani;
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doPrepare(ctx, layout) {
            layout[SPAN] = this.$_getDiv(ctx, layout);
        }
        _doMeasure(ctx, layout, maxWidth, maxHeight) {
            this._model;
            const div = layout[SPAN];
            this._setClass(div, ctx.row);
            div.style.width = !isNaN(ctx._explicitWidth) ? ctx._explicitWidth + 'px' : '';
            div.textContent = 'Hello';
            // span의 parent가 table이어서 계산할 필요가 없다.
            if (DElement.TESTING) {
                const div = layout[SPAN];
                const width = Math.ceil(div.offsetWidth);
                const height = Math.ceil(div.offsetHeight);
                return { width, height };
            }
        }
        _doRender(ctx, layout, width, height) {
            const div = layout[SPAN];
            const ani = this._ani;
            div.style.maxWidth = width + 'px';
            if (ani) {
                const div = layout[SPAN];
                const r1 = ani.container.getBoundingClientRect();
                const r2 = div.getBoundingClientRect();
                // console.log(r2.x - r1.x, r1.width - r2.x);
                div.style.backgroundSize = `50px ${r1.height}px`;
                div.animate([
                    { backgroundPositionX: `${r1.x - r2.x}px` },
                    { backgroundPositionX: `${r1.x + r1.width - r2.x}px` }
                ], {
                    duration: pickNum(ani.duration, ani.duration || 1200),
                    iterations: Infinity
                });
            }
        }
        _doUnprepare(ctx, layout) {
            layout[SPAN] = null;
        }
        setValue(layout, newValue) {
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        $_getDiv(ctx, layout) {
            let div = layout.getElementsByClassName(DummyRendererImpl.DUMMY_CLASS)[0];
            if (!div) {
                div = ctx.createElement('div');
                div.className = DummyRendererImpl.DUMMY_CLASS;
                Object.assign(div.style, TextRendererImplBase.SPAN_STYLE);
                Object.assign(div.style, ctx.manager().isSkeleton() ? SKELETON_STYLE : DUMMY_STYLE);
                div.style.display = 'inline-blick';
                layout.appendChild(div);
            }
            return div;
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    DummyRendererImpl.DUMMY_CLASS = 'dlist-dummy-dummy';

    ////////////////////////////////////////////////////////////////////////////////
    const TEMPL_ID = '$_tid_';
    /**
     * @internal
     *
     * Html renderer impl for {@link HtmlRenderer}.
     */
    class HtmlRendererImpl extends ValueRendererImpl {
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doPrepare(ctx, div) {
            const dom = div[IMG] = this.$_getHtml(ctx, div);
            this._setClass(dom, ctx.row);
        }
        _getStyleTarget(div) {
            return div[IMG].style;
        }
        needBounds() {
            // NOTE: textRenderer와 유사하게 상위 너비를 지정해줘야 span이 바로 wrap하지 않는다.
            return true;
        }
        _doMeasure(ctx, div, hintWidth, hintHeight) {
            const dom = div[IMG];
            return { width: Math.ceil(dom.offsetWidth), height: Math.ceil(dom.offsetHeight) };
        }
        _doRender(ctx, div, width, height) {
        }
        _doUnprepare(ctx, div) {
            div[IMG] = null;
        }
        setValue(layout, newValue) {
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        $_getHtml(ctx, div) {
            const model = this.model();
            let c = div.getElementsByClassName(HtmlRendererImpl.HTML_CLASS)[0];
            // TODO: innerHtml을 매번 새로 설정하므로 현재 이 것은 별 의미가 없다.
            if (c && c[TEMPL_ID] !== model.tid) {
                div.removeChild(c);
                c = null;
            }
            if (!c) {
                c = ctx.doc.createElement('div');
                // html class를 밖에서 지정할 수 있어야 하므로 다른 renderer와 다르게 c에 설정한다..
                c.className = HtmlRendererImpl.HTML_CLASS;
                c[TEMPL_ID] = model.tid;
                div.appendChild(c);
            }
            c.style.width = '';
            let html = model.html;
            if (!html && model.domid) {
                const dom = ctx.manager().owner().getTemplateHtml(model.domid);
                if (dom instanceof HTMLElement) {
                    let s = DParamString.parse(model.useInner ? dom.innerHTML : dom.outerHTML);
                    html = s instanceof DParamString ? ctx.inflate(s) : s;
                }
            }
            c.innerHTML = html;
            return c;
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    HtmlRendererImpl.HTML_CLASS = 'dlist-html-html';

    ////////////////////////////////////////////////////////////////////////////////
    class DateRendererImplBase extends InputRendererImplBase {
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _initInput(input) {
            // for Android.
            input.style.backgroundColor = 'white';
        }
        _prepareInput(input) {
            // for iOS safari - 잘못된 날짜값이면 input 높이가 낮아짐.
            if (!(this._value instanceof Date) || isNaN(+this._value)) {
                input.style.height = '1.8em';
            }
            else {
                input.style.height = '';
            }
        }
        _getDefaultValue() {
            return new Date();
        }
        _textToValue(text) {
            return new Date(text);
        }
        setValue(layout, newValue) {
        }
    }
    /**
     * @internal
     *
     * Datetime renderer impl for {@link DatetimeRenderer}.
     */
    class DateRendererImpl extends DateRendererImplBase {
        //-------------------------------------------------------------------------
        // consts
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _getInputType() {
            return 'date';
        }
        _valueToText(value) {
            if (value instanceof Date) {
                return value.getFullYear() + '-' + Utils.pad(value.getMonth() + 1) + '-' + Utils.pad(value.getDate());
            }
            return value;
        }
    }
    /**
     * @internal
     *
     * Time renderer impl for {@link TimeRenderer}.
     */
    class TimeRendererImpl extends DateRendererImplBase {
        //-------------------------------------------------------------------------
        // consts
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _getInputType() {
            return 'time';
        }
        _valueToText(value) {
            if (value instanceof Date) {
                return Utils.pad(value.getHours()) + ':' + Utils.pad(value.getMinutes());
            }
            return value;
        }
        _textToValue(text) {
            const arr = text ? text.split(':') : null;
            let d = this._value;
            if (!(d instanceof Date)) {
                d = new Date();
            }
            if (arr) {
                arr.length > 0 && d.setHours(+arr[0]);
                arr.length > 1 && d.setMinutes(+arr[1]);
                arr.length > 2 && d.setSeconds(+arr[2]);
            }
            return d;
        }
    }
    /**
     * @internal
     *
     * Datetime renderer impl for {@link DatetimeRenderer}.
     */
    class DatetimeRendererImpl extends DateRendererImplBase {
        //-------------------------------------------------------------------------
        // consts
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _getInputType() {
            return 'datetime-local';
        }
        _valueToText(value) {
            if (value instanceof Date) {
                return value.getFullYear() + '-' + Utils.pad(value.getMonth() + 1) + '-' + Utils.pad(value.getDate())
                    + 'T' + Utils.pad(value.getHours()) + ':' + Utils.pad(value.getMinutes());
            }
            return value;
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    // import { BarcodeRendererImpl, BarcodeRendererImplTest } from "./BarcodeRendererImpl";
    const renderer_types = {
        'button': ButtonRendererImpl,
        'check': CheckRendererImpl,
        'date': DateRendererImpl,
        'datetime': DatetimeRendererImpl,
        'dummy': DummyRendererImpl,
        'field': FieldRendererImpl,
        'gauge': GaugeRendererImpl,
        'html': HtmlRendererImpl,
        'icon': IconRendererImpl,
        'image': ImageRendererImpl,
        'input': InputRendererImpl,
        'label': LabelRendererImpl,
        'letter': LetterRendererImpl,
        'line': LineRendererImpl,
        'link': LinkRendererImpl,
        'meter': MeterRendererImpl,
        'number': NumberRendererImpl,
        'progress': ProgressRendererImpl,
        'qrcode': QrcodeRendererImpl,
        'radio': RadioRendererImpl,
        'radiogroup': RadioGroupRendererImpl,
        'rating': RatingRendererImpl,
        'select': SelectRendererImpl,
        'shape': ShapeRendererImpl,
        'spacer': SpacerRendererImpl,
        'sparkbar': SparkBarRendererImpl,
        'sparkline': SparkLineRendererImpl,
        'spinner': SpinnerRendererImpl,
        'svg': SvgRendererImpl,
        'switch': SwitchRendererImpl,
        'text': TextRendererImpl,
        'time': TimeRendererImpl,
    };
    /**
     * @internal
     *
     * IListFieldRendererImpl pool.
     */
    class RendererImplPool {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor() {
            //-------------------------------------------------------------------------
            // fields
            //-------------------------------------------------------------------------
            this._impls = {};
            this._renderer = new TextRenderer();
            this._default = new TextRendererImpl(this._renderer);
        }
        //-------------------------------------------------------------------------
        // static members
        //-------------------------------------------------------------------------
        static setTesting() {
            // renderer_types['barcode'] = BarcodeRendererImplTest;
            renderer_types['qrcode'] = QrcodeRendererImplTest;
            renderer_types['shape'] = ShapeRendererImplTest;
            renderer_types['sparkbar'] = SparkBarRendererImplTest;
            renderer_types['sparkline'] = SparkLineRendererImplTest;
            renderer_types['svg'] = SvgRendererImpl;
            renderer_types['text'] = TextRendererImplTest;
            renderer_types['spinner'] = SpinnerRendererImplTest;
        }
        setTesting() {
            this._renderer = new TextRenderer();
            this._default = new TextRendererImplTest(this._renderer);
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        borrow(renderer) {
            if (renderer) {
                const type = renderer.type();
                const impls = this._impls[type] || (this._impls[type] = []);
                const impl = impls.pop() || this.$_createImpl(type);
                if (impl) {
                    impl.setModel(renderer);
                    return impl;
                }
            }
            // NOTE: 추후, 재사용대신 항상 생성해야 하는 상황이 되면 ListSection 등에 defRenderer를 지정한다.
            //       현재, fieldHeader.defRenderer만 'field'로 설정되어 있다.
            return this._default;
        }
        free(impl) {
            if (impl !== this._default) {
                const renderer = impl.model();
                const t = renderer ? renderer.type() : this.$_getType(impl.constructor);
                let impls = this._impls[t];
                if (!impls) {
                    impls = this._impls[t] = [];
                }
                impls.push(impl);
            }
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        $_getType(implClazz) {
            for (let type in renderer_types) {
                if (implClazz === renderer_types[type]) {
                    return type;
                }
            }
        }
        $_createImpl(type) {
            return new renderer_types[type]();
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     *
     * ListControl tool base.
     */
    class DListTool extends DEditTool {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(control) {
            super(control);
            this._listControl = control;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        get control() {
            return this._listControl;
        }
        get listView() {
            return this._listControl.listView();
        }
    }
    const THRESHOLD = 7;
    class DListDragTracker extends DragTracker {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(listView) {
            super(listView.control);
            this._handler = () => {
                this.list.scrollBy(this._delta);
                const views = this.list.listView().bodyView().itemViews();
                let row = -1;
                let edge;
                if (this._delta < 0) {
                    const iv = views[0];
                    if (iv instanceof ListRowView) {
                        row = iv.row();
                        edge = 'start';
                    }
                }
                else {
                    const iv = views[views.length - 1];
                    if (iv instanceof ListRowView) {
                        row = iv.row();
                        edge = 'end';
                    }
                }
                this._edge = edge;
                this._scrollCallback(views, row, edge);
            };
            this._body = listView.bodyView();
            this._vertical = this._body.isVertical();
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        get list() {
            return this.control;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        checkScroll(x, y, callback, endScollCallback) {
            const p = this._vertical ? y : x;
            const p1 = this._vertical ? this._body.y : this._body.x;
            const p2 = p1 + (this._vertical ? this._body.height : this._body.width);
            let delta = 0;
            if (p <= p1 + THRESHOLD) {
                if (this._body.scrollPos() > 0) {
                    delta = -10;
                }
            }
            else if (p >= p2 - THRESHOLD) {
                if (!this._body.isScrollEnded()) {
                    delta = 10;
                }
            }
            if (delta !== 0) {
                if (!this._timer) {
                    this._scrollCallback = callback;
                    this._endScrollCallback = endScollCallback;
                    this._delta = delta;
                    this._timer = setInterval(this._handler, 30);
                }
                return true;
            }
            else {
                // 이렇게 해야 방향을 바꿀 수 있다.
                this.$_ended(false);
            }
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doEnded() {
            this.$_ended(true);
        }
        //-------------------------------------------------------------------------
        // private members
        //-------------------------------------------------------------------------
        $_ended(commit) {
            if (this._timer) {
                try {
                    if (commit) {
                        this._endScrollCallback && this._endScrollCallback(this._edge);
                    }
                }
                finally {
                    clearInterval(this._timer);
                    this._timer = void 0;
                    this._scrollCallback = void 0;
                    this._endScrollCallback = void 0;
                }
            }
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     *
     * Drag tracker for ScrollBarView.
     */
    class ScrollBarTracker extends DragTracker {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(view) {
            super(view.control);
            this._view = view;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doStart(eventTarget, xStart, yStart, x, y) {
            // this._off = this.control.dom.offsetTop - this._view.dom.offsetTop;
            this._off = this._view.dom.offsetTop;
            return true;
        }
        _doDrag(eventTarget, xPrev, yPrev, x, y) {
            const p = this._view.calcPosition(y - this._off);
            this.control.setScrollIndex(p, 0);
            return true;
        }
        _doCanceled() {
        }
        _canAccept(eventTarget, x, y) {
            return true;
        }
        _doCompleted(eventTarget, x, y) {
        }
        _doEnded() {
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     *
     * Body Scroll tracker.
     */
    class BodyScrollTracker extends DragTracker {
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(control) {
            super(control);
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        canSwipe() {
            return true;
        }
        _doStart(eventTarget, xStart, yStart, x, y) {
            return true;
        }
        _doDrag(eventTarget, xPrev, yPrev, x, y) {
            const c = this.control;
            if (c.isVertical()) {
                if (Math.abs(yPrev - y) > Math.abs(xPrev - x)) {
                    c.scrollBy(yPrev - y);
                }
            }
            else {
                if (Math.abs(xPrev - x) > Math.abs(yPrev - y)) {
                    c.scrollBy(xPrev - x);
                }
            }
            return true;
        }
        _canAccept(eventTarget, x, y) {
            return true;
        }
        _doEnded() {
            this.control.releaseLock();
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     *
     * Row selection tracker.
     */
    class RowSelectTracker extends DragTracker {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(control) {
            super(control);
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _showFeedback(x, y) {
        }
        _moveFeedback(x, y) {
        }
        _hideFeedback() {
        }
        _doStart(eventTarget, xStart, yStart, x, y) {
            const r1 = this.control.getBounds();
            const r2 = this.control.listView().bodyView().getClientRect();
            this._xOff = r2.x - r1.x;
            this._yOff = r2.y - r1.y;
            return true;
        }
        _doDrag(eventTarget, xPrev, yPrev, x, y) {
            const control = this.control;
            const bodyView = control.listView().bodyView();
            const iv = bodyView.itemViewAt(x - this._xOff, y - this._yOff);
            if (iv) {
                if (isNaN(iv.gindex())) {
                    control.resizeSelection(iv.row());
                }
                else {
                    control.resizeSelection(iv.gindex());
                }
                return true;
            }
        }
        _doCanceled() {
        }
        _canAccept(eventTarget, x, y) {
            return true;
        }
        _doCompleted(eventTarget, x, y) {
        }
        _doEnded() {
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     *
     * Drag tracker for PageScroller.
     */
    class PageScrollTracker extends DragTracker {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(view) {
            super(view.control);
            this._view = view;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doStart(eventTarget, xStart, yStart, x, y) {
            return true;
        }
        _doDrag(eventTarget, xPrev, yPrev, x, y) {
            this._view.scrollBy(x - xPrev);
            return true;
        }
        _doCanceled() {
        }
        _canAccept(eventTarget, x, y) {
            return true;
        }
        _doCompleted(eventTarget, x, y) {
        }
        _doEnded() {
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     *
     * Drag tracker for page no changing.
     */
    class PageMoveTracker extends DragTracker {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(control) {
            super(control);
            this._nextPage = -1;
            this._listView = control.listView();
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doStart(eventTarget, xStart, yStart, x, y) {
            this._dx = x - xStart;
            this.$_preparePageMove(this._dx);
            return true;
        }
        _doDrag(eventTarget, xPrev, yPrev, x, y) {
            this._dx = x - xPrev;
            this.$_movePage(this._dx);
            return true;
        }
        _doCanceled() {
            this.$_cancelPageMove();
        }
        _canAccept(eventTarget, x, y) {
            return true;
        }
        _doCompleted(eventTarget, x, y) {
            this.$_commitPageMove(this._dx);
        }
        _doSwipe(dir) {
            return this.$_swipePageMove(dir);
        }
        _doEnded() {
            this.$_endPageMove(this._dx);
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        $_preparePageMove(dx) {
            const listView = this._listView;
            const bodyView = listView.bodyView();
            let spare = listView.getSpareBody();
            this._bodyPos = bodyView.x;
            this.control.lock(() => {
                // NOTE: 먼저 추가해야 setPage()가 동작한다.
                listView.addChild(spare);
                // this.insertBefore(spare, bodyView);
                spare.setPage(listView.owner().page() + (dx < 0 ? 1 : -1), bodyView, false);
                spare.moveX(0);
            });
            this._nextPage = -1;
            listView.pageMoving = true;
        }
        $_unpreparePageMove() {
            const listView = this._listView;
            const bodyView = listView.bodyView();
            const spare = listView.getSpareBody();
            bodyView.moveX(this._bodyPos);
            listView.removeChild(spare);
            spare.setPage(-1);
            bodyView.$_removeEndEffect();
            listView.pageMoving = false;
            if (this._nextPage >= 0) {
                listView.owner().setPage(this._nextPage);
                this.control.updateNow();
            }
        }
        $_movePage(dx) {
            if (dx === 0)
                return;
            const listView = this._listView;
            const owner = listView.owner();
            const bodyView = listView.bodyView();
            const spareView = listView.getSpareBody();
            const page = owner.page();
            const w = bodyView.width;
            let x = bodyView.x + dx;
            bodyView.moveX(x);
            x = bodyView.x;
            if (x < this._bodyPos) {
                spareView.setPage(page + 1, bodyView, false);
                spareView.moveX(x + w + 1);
            }
            else if (x > this._bodyPos) {
                spareView.setPage(page - 1, bodyView, false);
                spareView.moveX(x - w - 1);
            }
        }
        $_cancelPageMove() {
        }
        $_commitPageMove(dx) {
            const listView = this._listView;
            const bodyView = listView.bodyView();
            const owner = listView.owner();
            const spare = listView.getSpareBody();
            const page = owner.page();
            const p = this._bodyPos;
            const w = bodyView.width;
            if (spare.page > page && spare.x <= p + w * 0.55) {
                this._nextPage = spare.page;
            }
            else if (spare.page < page && bodyView.x >= p + w * 0.45) {
                this._nextPage = spare.page;
            }
        }
        $_swipePageMove(dir) {
            const listView = this._listView;
            const bodyView = listView.bodyView();
            const owner = listView.owner();
            const page = owner.page();
            const p = this._bodyPos;
            const w = bodyView.width;
            const x = listView.getSpareBody().x;
            if (dir === Direction.LEFT && x < p + w) {
                this._nextPage = page + 1;
                return true;
            }
            if (dir === Direction.RIGHT && x + w > p) {
                this._nextPage = page - 1;
                return true;
            }
        }
        // dx: 오른쪽 드래그이면 양수.
        $_endPageMove(dx) {
            const listView = this._listView;
            if (listView.canAnimate()) {
                const spare = listView.getSpareBody();
                const body = listView.bodyView();
                const completed = this._nextPage >= 0;
                const w = listView.width;
                let x = completed ? 0 : (spare.x < 0 ? -w : w);
                const ani = spare.dom.animate([
                    { left: spare.x + 'px' },
                    { left: x + 'px' }
                ], {
                    duration: 100,
                    fill: 'none'
                });
                ani.addEventListener('finish', () => {
                    this.$_unpreparePageMove();
                });
                x = completed ? (body.x < 0 ? -w : w) : 0;
                body.dom.animate([
                    { left: body.x + 'px' },
                    { left: x + 'px' }
                ], {
                    duration: 100,
                    fill: 'none'
                });
            }
            else {
                this.$_unpreparePageMove();
            }
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     *
     * Drag tracker for single row body view.
     */
    class SingleRowTracker extends DragTracker {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(control) {
            super(control);
            this._nextRow = -1;
            this._bodyView = control.listView().bodyView();
            this._singleView = this._bodyView.singleView();
            this._spareView = this._bodyView.spareSingleView();
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doStart(eventTarget, xStart, yStart, x, y) {
            this._dx = x - xStart;
            this.$_prepareSingleMove();
            return true;
        }
        _doDrag(eventTarget, xPrev, yPrev, x, y) {
            this._dx = x - xPrev;
            this.$_moveSingle(x - xPrev);
            return true;
        }
        _doCanceled() {
            this.$_cancelMoveSingle();
        }
        _canAccept(eventTarget, x, y) {
            return true;
        }
        _doCompleted(eventTarget, x, y) {
            this.$_commitMoveSingle(this._dx);
        }
        _doSwipe(dir) {
            return this.$_swipeMoveSingle(dir);
        }
        _doEnded() {
            this.$_endSingleMove(this._dx);
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        $_prepareSingleMove() {
            // console.log('PREPARE')
            const bodyView = this._bodyView;
            const singleView = this._singleView;
            const spareView = this._spareView;
            this._singlePos = singleView.x;
            this.control.lock(() => {
                bodyView.insertBefore(spareView, singleView);
                spareView.moveX(0);
                spareView.setDimmed(1);
            });
            this._nextRow = -1;
            bodyView.singleMoving = true;
        }
        $_unprepareSingleMove() {
            // console.log('UNPREPARE')
            const bodyView = this._bodyView;
            const singleView = this._singleView;
            const spareView = this._spareView;
            singleView.moveX(this._singlePos);
            bodyView.removeChild(spareView);
            spareView.setRow(-1, singleView);
            bodyView.$_removeEndEffect();
            bodyView.singleMoving = false;
            if (this._nextRow >= 0) {
                bodyView.owner().setScrollIndex(this._nextRow);
                singleView.setRow(this._nextRow, singleView);
                this.control.updateNow();
            }
        }
        $_moveSingle(dx) {
            // console.log('MOVE', dx)
            if (dx === 0)
                return;
            const singleView = this._singleView;
            const spare = this._spareView;
            const row = singleView.row();
            const w = singleView.width;
            let x = singleView.x + dx;
            singleView.moveX(x);
            x = singleView.x;
            if (x < this._singlePos) {
                spare.setRow(row + 1, singleView);
                spare.moveX(x + w + 1);
                spare.setDimmed(Utils.clamp((spare.x - w * 0.55) / (w * 0.45), 0, 1));
            }
            else {
                spare.setRow(row - 1, singleView);
                spare.moveX(x - w - 1);
                spare.setDimmed(Utils.clamp((w * 0.45 - x) / (w * 0.45), 0, 1));
            }
        }
        $_cancelMoveSingle() {
        }
        $_getNextRow() {
            const singleView = this._singleView;
            const spare = this._spareView;
            const row = singleView.row();
            const p = this._singlePos;
            const w = singleView.width;
            if (spare.row() > row && spare.x <= p + w * 0.55) {
                return spare.row();
            }
            else if (spare.row() < row && singleView.x >= p + w * 0.45) {
                return spare.row();
            }
            return -1;
        }
        $_commitMoveSingle(dx) {
            this._nextRow = this.$_getNextRow();
        }
        $_swipeMoveSingle(dir) {
            // console.log('### SWIPE')
            const bodyView = this._bodyView;
            const singleView = this._singleView;
            const row = singleView.row();
            const p = this._singlePos;
            const w = singleView.width;
            const x = bodyView.spareSingleView().x;
            singleView.setDimmed(0);
            if (dir === Direction.LEFT && x < p + w) {
                this._nextRow = row + 1;
                return true;
            }
            if (dir === Direction.RIGHT && x + w > p) {
                this._nextRow = row - 1;
                return true;
            }
        }
        // dx: 오른쪽 드래그이면 양수.
        $_endSingleMove(dx) {
            // console.log('### END')
            const bodyView = this._bodyView;
            if (bodyView.canAnimate()) {
                const singleView = this._singleView;
                const spareView = this._spareView;
                const completed = this._nextRow >= 0;
                const w = bodyView.width;
                let x = completed ? 0 : (spareView.x < 0 ? -w : w);
                singleView.setDimmed(0);
                spareView.dom.style.left = x + 'px';
                const ani = spareView.dom.animate([
                    { left: spareView.x + 'px' },
                    { left: x + 'px' }
                ], {
                    duration: 100,
                    fill: 'none'
                });
                if (ani) {
                    console.log('END ANIMATE');
                    ani.addEventListener('finish', () => {
                        this.$_unprepareSingleMove();
                    });
                    x = completed ? (singleView.x < 0 ? -w : w) : 0;
                    singleView.dom.animate([
                        { left: singleView.x + 'px' },
                        { left: x + 'px' }
                    ], {
                        duration: 100,
                        fill: 'none'
                    });
                }
            }
            else {
                this.$_unprepareSingleMove();
            }
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     *
     * Drag tracker for RowPageView.
     */
    class RowPageTracker extends DragTracker {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(pageView) {
            super(pageView.control);
            this._view = pageView;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doStart(eventTarget, xStart, yStart, x, y) {
            return true;
        }
        _doDrag(eventTarget, xPrev, yPrev, x, y) {
            // if (Math.abs(yPrev - y) > Math.abs(xPrev - x)) {
            this._view.scrollBy(y - yPrev);
            // }
            return true;
        }
        _doCanceled() {
        }
        _canAccept(eventTarget, x, y) {
            return true;
        }
        _doCompleted(eventTarget, x, y) {
        }
        _doEnded() {
            this.control.releaseLock();
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    let XY = 'y';
    let POS = 'top';
    let SIZE = 'height';
    let MOVE = 'moveY';
    /**
     * @internal
     *
     * Row move tracker.
     */
    class RowMoveTracker extends DListDragTracker {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(listView) {
            super(listView);
            this._off = 0;
            this._scrolling = false;
            this._callback = (itemViews, row, edge) => {
                const up = edge === 'start';
                this._scrolling = true;
                this.$_resetItems(itemViews);
                if (row >= 0) {
                    let view;
                    if (up) {
                        view = itemViews[0];
                    }
                    else {
                        view = itemViews[itemViews.length - 1];
                    }
                    if (this._body.canMoveTo(this._row, view)) {
                        this.$_setTarget(view, up, true);
                    }
                    else {
                        // debugger; // groupview에서 발생한다.
                        this.$_swapViews(-1, up, true);
                    }
                }
                else {
                    // debugger; // groupview에서 발생한다.
                    this.$_swapViews(-1, up, true);
                }
            };
            this._endCallback = (edge) => {
                if (this._target) {
                    // data move가 실행 된 후...
                    setTimeout(() => {
                        this.list.makeRowVisible(this._target);
                    }, 0);
                }
            };
            if (!this._vertical) {
                XY = 'x';
                POS = 'left';
                SIZE = 'width';
                MOVE = 'moveX';
            }
            this.$_resetItems(this._body.itemViews());
            this._targetFeedback = this.$_createTargetFeedback(listView.doc);
        }
        $_createTargetFeedback(doc) {
            const elt = doc.createElement('div');
            elt.className = 'dlist-row-move-target';
            Object.assign(elt.style, {
                position: 'absolute',
                boxSizing: 'border-box'
            });
            return elt;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        setRequest(req) {
            const v = this._body.getRowView(this._row = req.row);
            this._target = this._pts = void 0;
            this._hRow = v.height;
            this._pRow = v[XY];
            this._rowFeedback = this.$_createFeedback(v);
            return this;
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doStart(eventTarget, xStart, yStart, x, y) {
            const body = this._body;
            const p = this.control.toElement(body, x, y);
            this._off = p[XY] - this._pRow;
            this.control.setLock();
            this.$_resetItems(body.itemViews());
            Dom.setVisible(this._targetFeedback, false);
            body.addFeedback(this._targetFeedback);
            this.$_moveFeedback(this._rowFeedback, x, y);
            return true;
        }
        _doDrag(eventTarget, xPrev, yPrev, x, y) {
            const body = this._body;
            const vertical = this._vertical;
            const off = this._off;
            const up = vertical ? y < yPrev : x < xPrev; // 마우스가 올라가면 up
            const h = this._hRow;
            this.$_moveFeedback(this._rowFeedback, x, y);
            if (this.checkScroll(x, y, this._callback, this._endCallback)) {
                return true;
            }
            // 직전에 scroll 중이었다면 행들을 스크롤 중에 source 행이 빠져 있었으므로 재배치해야 한다.
            if (this._scrolling) {
                this._scrolling = false;
                this.$_resetItems(body.itemViews());
                this.$_swapViews(this._row, up, false);
            }
            // up일 때는 시작변, down일 때는 끝변.
            x += vertical ? 0 : (up ? -off : h - off);
            y += vertical ? (up ? -off : h - off) : 0;
            const pt = this.control.toElement(body, x, y);
            const v = this.$_itemViewAt(pt[XY] + body.scrollOff());
            let view = v && v.view;
            if (view && view.row() !== this._row) {
                if (body.canMoveTo(this._row, view)) {
                    // console.log('###', v.view.row());
                    // 중앙 위에 갔을 때 이동 시킨다.
                    if (up && v.pos > view.height / 2) {
                        view = null;
                    }
                    // 중앙 아래에 갔을 때 이동 시킨다.
                    else if (!up && v.pos < view.height / 2) {
                        view = null;
                    }
                }
                else {
                    view = null;
                }
            }
            if (view) {
                this.$_setTarget(view, up, false);
            }
            Dom.setVisible(this._targetFeedback, !!this._target);
            return true;
        }
        _doCanceled() {
        }
        _canAccept(eventTarget, x, y) {
            return this._target >= 0 && this._target !== this._row;
        }
        _doCompleted(eventTarget, x, y) {
            const data = this.control.data();
            if (data instanceof ListData) {
                console.log('MOVE', this._row, this._target);
                data.moveRow(this._row, this._target);
            }
        }
        _doEnded() {
            super._doEnded();
            this._views.forEach(v => v.visible = true);
            this._rowFeedback.remove();
            this._rowFeedback = null;
            this._targetFeedback.remove();
            this.control.releaseLock();
            this.control.invalidateLayout();
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        // tracking을 위해 item view들을 재구성한다.
        $_resetItems(itemViews) {
            const pts = this._pts = [0];
            (this._views = itemViews).forEach(v => {
                pts.push(pts[pts.length - 1] + v[SIZE]);
            });
        }
        $_itemViewAt(p) {
            const pts = this._pts;
            for (let i = 0, n = pts.length - 1; i < n; i++) {
                if (p >= pts[i] && p < pts[i + 1]) {
                    return { view: this._views[i], pos: p - pts[i] };
                }
            }
        }
        $_createFeedback(rv) {
            const fv = rv.dom.cloneNode(true);
            Object.assign(fv.style, {
                boxShadow: '0px 0px 5px'
            });
            this._body.listView().addFeedback(fv);
            return fv;
        }
        $_moveFeedback(feedback, x, y) {
            if (this._vertical) {
                Dom.move(this._rowFeedback, 0, y - this._off);
            }
            else {
                Dom.move(this._rowFeedback, x - this._off, 0);
            }
        }
        $_swapViews(row, up, scrolling) {
            const pts2 = [];
            const views = this._views;
            const views2 = views.slice(0);
            const off = -this._body.scrollOff();
            let p = 0;
            let i;
            // source view를 빼서
            i = views.findIndex(view => view.row() === this._row);
            if (i >= 0) {
                const v2 = views2.splice(i, 1)[0];
                if (!scrolling) {
                    // target에 집어 넣는다.
                    i = views.findIndex(view => view.row() === row);
                    if (i >= 0) {
                        views2.splice(i, 0, v2);
                    }
                }
                v2.move(-100000, -10000);
            }
            pts2.push(p);
            views2.forEach(v2 => {
                v2.aniTag = v2[XY];
                if (v2.row() === row) {
                    Dom.setRect(this._targetFeedback, v2.getBounds());
                }
                v2[MOVE](p + off);
                p += v2.height;
                pts2.push(p);
            });
            this._prevUp = up;
            this._views = views2;
            this._pts = pts2;
            this._target = row;
            // console.log('TARGET', scrolling, views2.map(v => v.row()), views2.map(v => v.hash), views2.map(v => v[XY]), views.map(v => v.hash));
            // console.log('TARGET', views2.map(v => v.row()), views2.map(v => v[XY]), pts2);
            // console.log('TARGET', views2.map(v => v.row()), views.map(v => v.row()));
            return views2;
        }
        $_setTarget(v, up, scrolling) {
            if (v.row() !== this._row && (!this._target || up !== this._prevUp || v.row() !== this._target)) {
                // if (scrolling) debugger;
                const views = this.$_swapViews(v.row(), up, scrolling);
                if (!scrolling) {
                    views.forEach(view2 => {
                        const i = views.findIndex(v => v.row() === view2.row());
                        const oldP = view2.aniTag;
                        const p = view2[XY];
                        if (view2 instanceof ListRowView && i >= 0 && p !== oldP) {
                            Dom.animate(view2.dom, POS, pixel(oldP), pixel(p)); //, 3000);
                        }
                    });
                }
            }
            else if (scrolling) {
                this.$_swapViews(v.row(), up, scrolling);
            }
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     *
     * Row move tracker.
     */
    class CheckTracker extends DListDragTracker {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(listView) {
            super(listView);
            this._callback = (itemViews, row) => {
                this._views = itemViews.filter(v => v instanceof ListRowView);
                this.$_checkRow(row);
            };
            if (!this._vertical) ;
            this._views = this._body.itemViews().filter(v => v instanceof ListRowView);
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        setRequest(req) {
            // this._row = req.row;
            return this;
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doStart(eventTarget, xStart, yStart, x, y) {
            return true;
        }
        _doDrag(eventTarget, xPrev, yPrev, x, y) {
            if (this.checkScroll(x, y, this._callback, null)) {
                return true;
            }
            for (const v of this._views) {
                if (v.rowCell.displayOfDom(eventTarget) === DListRowBarDisplay.CHECK) {
                    this.$_checkRow(v.row());
                    break;
                }
            }
            return true;
        }
        _doCanceled() {
        }
        _canAccept(eventTarget, x, y) {
            return true;
        }
        _doCompleted(eventTarget, x, y) {
        }
        _doEnded() {
            super._doEnded();
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        $_checkRow(row) {
            if (row >= 0 && row !== this._prev) {
                switch (this._body['_owner'].current()._rowBar.check().dragMode()) {
                    case DListDragCheckMode.CHECK:
                        this.list.checkRow(row, true);
                        break;
                    case DListDragCheckMode.UNCHECK:
                        this.list.checkRow(row, false);
                        break;
                    case DListDragCheckMode.TOGGLE:
                        this.list.toggleChecked(row);
                        break;
                }
                this._prev = row;
            }
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    class FitScroller {
        constructor() {
            this._handler = () => {
                if (this._off <= 0 || this._control.listView().bodyView().isScrollEnded()) {
                    clearInterval(this._timer);
                    this._timer = null;
                }
                else {
                    this._control.scrollBy(Math.min(this._step * this._dir, this._off));
                    this._off -= this._step;
                }
            };
        }
        run(control, dir, step) {
            const iv = control.listView().bodyView().getItemView(0);
            const sz = control.isVertical() ? iv.height : iv.width;
            this._control = control;
            this._dir = dir;
            this._step = step;
            this._off = dir > 0 ? sz - control.scrollOff() : control.scrollOff();
            this._timer = setInterval(this._handler, 20);
        }
    }
    /**
     * @internal
     *
     * 기본 tool.
     * 선택, 스크롤 등.
     */
    class DefaultTool extends DListTool {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(control) {
            super(control);
            this._clickRow = -1;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        $_isClickable(dom, view) {
            if (dom instanceof HTMLAnchorElement) {
                return true;
            }
            if (dom instanceof HTMLInputElement || dom instanceof HTMLSelectElement || dom instanceof HTMLLabelElement || dom[CLICKABLE]) {
                return true;
            }
            if (dom instanceof HTMLButtonElement && view instanceof SimpleLayoutView) {
                return true;
            }
            if (view instanceof ButtonElement && view.enabled()) {
                return true;
            }
            if (view instanceof DListElement && view.clickable()) {
                return true;
            }
        }
        _doTouchStart(dom) {
            const control = this.control;
            const fullMode = control.fullMode();
            const listView = control.listView();
            const bodyView = listView.bodyView();
            const row = bodyView.getRow(dom);
            const gitem = bodyView instanceof GroupedListBodyView ? bodyView.getGroupItem(dom) : null;
            const view = control.elementOfDom(dom);
            clearTimeout(this._touchTimer);
            listView.menuView() && listView.menuView().clearTouched();
            control.releaseLock();
            this._clickDom = dom;
            this._clickRow = row;
            this._clickItem = gitem;
            this._flingScroller = this._flingScroller && this._flingScroller.destroy();
            // 메뉴가 표시된 상태에서 메뉴 아닌 곳을 클릭하면 메뉴를 닫고 리턴한다.
            // TODO: 더 일반화 시켜야 하는 거 아닌가?
            if (!listView.isMenuView(dom) && listView.hideMenu(true)) {
                return true;
            }
            // 아래처럼 fullmode와 상관없이 false를 리턴해야 doClick()이 발생한다.
            // 그렇지 않으면 이 함수 이후에 stopEvnet가 호출돼서 click 이벤트가 발생하지 않는다.
            if (this.$_isClickable(dom, view)) {
                return false;
            }
            if (control.editPageView() && control.editPageView().visible) {
                return false;
            }
            if (!(view instanceof CommandButton)) {
                bodyView.clearCommands(true);
            }
            if (view instanceof RowCellElement) {
                return false;
            }
            if (view instanceof ListMenuItemView) {
                listView.menuView().setTouched(view);
            }
            else if (view instanceof ActionableSectionView) ;
            else if (!control.isSingleRow()) { // single row일 때는 선택 효과가 필요 없다.
                if (fullMode) {
                    this.$_rowTouched(this._clickRow);
                }
                else {
                    this._touchTimer = setTimeout(() => {
                        this.$_rowTouched(this._clickRow);
                    }, 50);
                }
                // this.dragTracker = this.$_getDragTracker(dom);
            }
            return !fullMode;
            // return !(control.fullMode() && !this.dragTracker);
        }
        _doTouchMove(dom) {
            if (this.dragging) {
                this._clearTouchEffects();
                if (!this.control.listView().isInPanel(dom)) {
                    this.control.closePanel(true);
                }
            }
        }
        _doTouchEnd(dom) {
            const view = this.control.elementOfDom(dom);
            if (view instanceof ListMenuItemView) {
                this.listView.menuView().clearTouched();
            }
            return !this.$_isClickable(dom, view);
            // return !(dom instanceof HTMLButtonElement || dom instanceof HTMLAnchorElement || dom instanceof HTMLInputElement || dom instanceof HTMLSelectElement || dom instanceof HTMLLabelElement || dom[CLICKABLE]);
        }
        _clearTouchEffects() {
            clearTimeout(this._touchTimer);
            this.$_rowTouched(-1);
        }
        _processClick(dom) {
            const control = this.control;
            const listView = control.listView();
            const rowListView = control.rowPageView();
            const bodyView = listView.bodyView();
            const view = control.elementOfDom(dom);
            const oldPanel = listView.activePanel();
            const layoutView = listView.getLayoutView(dom);
            let panelView = !layoutView && listView.getPanel(dom);
            let panelClose = !!oldPanel;
            if (!(view instanceof ListMenuItemView) && listView.isMenuView(dom)) {
                listView.menu().autoHide && listView.hideMenu(true);
            }
            else if (view instanceof DListElement && view.clickable()) {
                const { x, y } = control.toElement(view, this.touchX(), this.touchY());
                view.click(dom, x, y);
            }
            else if (view instanceof PanelButtonElement) {
                panelClose = panelView.clickButton(view, control);
            }
            else if (view instanceof ButtonElement) {
                view.enabled() && view.click(control);
            }
            else if (view instanceof ListMenuItemView) {
                if (listView.menu().clickItem(control.wrapperOrThis(), view.model())) {
                    control.closeMenu(true);
                }
                else if (view.model().type === DListMenuItemType.RADIO) {
                    listView.menuView().resetRadios();
                }
                else {
                    view.refresh();
                }
            }
            else if (view instanceof ItemExpanderView) {
                if (view.parent instanceof DataGroupRowView) {
                    control.dataGroup().toggle(control.getDataGroupOfRow(view.parent.row(), true), false);
                }
                else if (view.parent instanceof ListRowView) ;
                else if (view.parent instanceof ListItemView) {
                    control.groupModel().toggle(view.parent.model().group, false);
                }
            }
            else if (view instanceof SvgButton) {
                view.enabled() && view.click();
            }
            else if (view instanceof RowBarCell) {
                view.click(control.rowBar(), dom);
            }
            else if (view instanceof EditBarCell) {
                view.click(control.editBar(), dom);
            }
            else if (layoutView) {
                layoutView.clickable() && layoutView.click(dom, NaN, NaN);
            }
            else if (panelView) {
                panelClose = panelView.click(dom, NaN, NaN);
            }
            else {
                let processed = false;
                if (rowListView) {
                    const renderer = rowListView.getRenderer(dom);
                    if (renderer) {
                        renderer.clicked(control, -1, null);
                        processed = true;
                    }
                }
                if (!processed) {
                    const row = this._clickRow >= 0 && bodyView.getRow(dom) === this._clickRow ? this._clickRow : -1;
                    const renderer = bodyView.getRenderer(row, dom); // row < 0일 때도 renderer가 존재할 수 있다. ex) EmptyPage
                    if (renderer) {
                        const field = dom[T_FIELD];
                        processed = renderer.clicked(control, row, field);
                    }
                    else if (bodyView instanceof GroupedListBodyView) {
                        if (this._clickItem && this._clickItem === bodyView.getGroupItem(dom)) {
                            control.$_groupItemClicked(this._clickItem);
                            processed = true;
                        }
                    }
                    if (!processed && row >= 0) {
                        control.$_rowClicked(row);
                    }
                }
            }
            if (panelClose && listView.activePanel() !== oldPanel) {
                panelClose = false;
            }
            panelClose && control.closePanel(true);
        }
        _doTap(dom, xStart, yStart, x, y) {
            if (dom !== this._clickDom)
                return;
            const control = this.control;
            const listView = control.listView();
            const bodyView = listView.bodyView();
            const view = control.elementOfDom(dom);
            if (!(view instanceof CommandButton)) {
                bodyView.clearCommands(true);
            }
            // doClick()에서 처리하게 한다.
            if (this.$_isClickable(dom, view)) {
                return;
            }
            this._processClick(dom);
        }
        // NOTE: doTap() 이 후 발생한다.
        //       중복되지 않도록,
        //       html input, button 관련된 click 처리는 doTap()이 아니고 여기에서.
        _doClick(dom) {
            if (dom !== this._clickDom)
                return;
            const control = this.control;
            const listView = control.listView();
            const bodyView = listView.bodyView();
            bodyView.clearCommands(true);
            this._processClick(dom);
        }
        _doLongPressed(dom, x, y) {
            const control = this.control;
            const bodyView = this.listView.bodyView();
            const row = bodyView.getRow(dom);
            if (row >= 0 && row === this._clickRow) {
                const renderer = dom === this._clickDom && bodyView.getRenderer(row, dom);
                let processed = false;
                if (renderer) {
                    const field = dom[T_FIELD];
                    processed = renderer.longPressed(this.control, row, field);
                }
                if (!processed) {
                    control.$_rowLongPressed(row);
                }
            }
        }
        _doSwipe(dom, prevTracker, dir, duration, distance) {
            const control = this.control;
            const view = control.elementOfDom(dom);
            if (view instanceof ButtonElement) {
                return;
            }
            const listView = control.listView();
            const pageView = control.rowPageView();
            const clickRow = this._clickRow;
            const threshold = control.fitRowWhenScroll ? 1 : 0.3;
            if (!listView.isInPanel(dom)) {
                control.closePanel(true);
            }
            if (pageView && pageView.layoutBack().contains(dom)) {
                const d = dir === Direction.UP ? 1 : -1;
                // DLog.log('FLING VERT - ROW PAGE VIEW', dir, distance, duration);
                this._flingScroller = new FlingScroller(distance, duration, threshold, (delta, step) => {
                    return pageView.scrollBy(-delta * d) === true;
                }).run();
                return true;
            }
            else if (listView.bodyView().containsDom(dom)) {
                if (control.isVertical()) {
                    if (dir === Direction.UP || dir === Direction.DOWN) {
                        const d = dir === Direction.UP ? 1 : -1;
                        if (!control.fullMode() && (!prevTracker || prevTracker.canSwipe())) {
                            // DLog.log('FLING VERT', dir, distance, duration);
                            this._flingScroller = new FlingScroller(distance, duration, threshold, (delta, step) => {
                                return control.scrollBy(delta * d) !== true;
                            }, () => {
                                if (control.fitRowWhenScroll && listView.scrollOff() > 0) {
                                    new FitScroller().run(control, d, threshold);
                                }
                            }).run();
                            return true;
                        }
                    }
                    else {
                        if (clickRow >= 0) {
                            control.swipeRow(clickRow);
                            return true;
                        }
                    }
                }
                else {
                    if (dir === Direction.LEFT || dir === Direction.RIGHT) {
                        const d = dir === Direction.LEFT ? 1 : -1;
                        if (!control.fullMode() && (!this.dragTracker || this.dragTracker.canSwipe())) {
                            DLog.log('FLING HORZ', dir, distance, duration);
                            this._flingScroller = new FlingScroller(distance, duration, threshold, (delta, step) => {
                                return control.scrollBy(delta * d) !== true;
                            }, () => {
                                if (control.fitRowWhenScroll && listView.scrollOff() > 0) {
                                    new FitScroller().run(control, d, threshold);
                                }
                            }).run();
                            return true;
                        }
                    }
                    else {
                        if (clickRow >= 0) {
                            control.swipeRow(clickRow);
                            return true;
                        }
                    }
                }
            }
        }
        _doKeyPress(ev) {
            const target = ev.target;
            const key = ev.key;
            const control = this.control;
            const view = control.elementOfDom(ev.target);
            if (key === 'Enter') {
                if (target instanceof HTMLInputElement) {
                    target.blur();
                    if (view instanceof SearchBarView && view.canEnter()) {
                        view.search();
                    }
                    else if (view instanceof SearchPanelView) {
                        if (view.search()) {
                            control.closePanel(true);
                        }
                    }
                    this.$_moveToNextInput(target);
                }
            }
        }
        getTrackerFromRequest(request) {
            const listView = this.listView;
            if (request instanceof MoveRowRequest) {
                if (!this._rowMoveTracker) {
                    this._rowMoveTracker = new RowMoveTracker(listView);
                }
                return this._rowMoveTracker.setRequest(request);
            }
            else if (request instanceof CheckDragRequest) {
                if (!this._checkTracker) {
                    this._checkTracker = new CheckTracker(listView);
                }
                return this._checkTracker.setRequest(request);
            }
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        _getDragTracker(dom, dx, dy) {
            const control = this.control;
            const options = control.current();
            const pageView = control.rowPageView();
            const listView = control.listView();
            const scrollBar = listView.scrollBarView();
            const pageScroller = listView.pageScrollerView();
            const view = control.elementOfDom(dom);
            let tracker;
            if (view instanceof RowCellElement) {
                tracker = this.getTrackerFromRequest(view.getDragRequest(dom, options));
            }
            else if (view instanceof ButtonElement && view.enabled()) ;
            else if (scrollBar && scrollBar.isView(dom)) {
                tracker = this._scrollBarTracker || (this._scrollBarTracker = new ScrollBarTracker(scrollBar));
            }
            else if (pageScroller && pageScroller.isView(dom)) {
                tracker = this._pageScrollTracker || (this._pageScrollTracker = new PageScrollTracker(pageScroller));
            }
            else if (pageView) {
                tracker = this._rowPageTracker || (this._rowPageTracker = new RowPageTracker(pageView));
            }
            else if (listView.bodyView().containsDom(dom)) {
                if (control.isSingleRow() && Math.abs(dx) >= Math.abs(dy)) {
                    if (listView.canMoveSingle(dx, true)) {
                        tracker = this._singleRowTracker || (this._singleRowTracker = new SingleRowTracker(control));
                    }
                }
                else if (control.current().row().swipeAction() === DListRowSwipeAction.PAGE && Math.abs(dx) >= Math.abs(dy)) {
                    if (listView.canMovePage(dx, true)) {
                        tracker = this._pageMoveTracker || (this._pageMoveTracker = new PageMoveTracker(control));
                    }
                }
                else {
                    const row = listView.bodyView().getRow(dom);
                    if (row >= 0 && control.dragSelectable /*&& control.getSelection()?.isRowSelected(row)*/) {
                        tracker = this._rowSelectTracker || (this._rowSelectTracker = new RowSelectTracker(control));
                    }
                    else if (!control.fullMode()) {
                        tracker = this._bodyTracker || (this._bodyTracker = new BodyScrollTracker(control));
                    }
                }
            }
            return tracker;
        }
        $_rowTouched(row) {
            this.control.$_rowTouched(row);
        }
        $_moveToNextInput(dom) {
        }
    }

    const default_options = {
        // 기본 row styles. row template에서 별도 설정할 수 있다.
        rowStyle: {
            padding: "5px 6px"
        }
    };

    var LicType;
    (function (LicType) {
        LicType["Developer"] = "dev";
        LicType["Evaluation"] = "evl";
        LicType["Limited"] = "lim";
        LicType["Enterprise"] = "ent";
    })(LicType || (LicType = {}));

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     *
     * 행 관련 편집 명령.
     * 컨트롤을 통해 CommandRunner에 등록된 command는 변경할 수 없다.
     * 등록/헤제를 통해 변경해야 한다.
     *
     * style 내용을 수정할 수 없게 하도록 위함. 즉, view에서 style을 단일 값 처럼 다룰 수 있도록 한다.
     * 단, stock command의 label은 command class의 static member 'Label'로 변경할 수 있다.
     */
    class RowCommand {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(label, style) {
            this.label = label;
            if (typeof style === 'string') {
                this.className = style;
            }
            else if (style) {
                this.style = Object.assign({}, style);
            }
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        getStyle() {
            return this.style;
        }
        run(ctx, data, row) {
            if (!this._canRun(ctx, data, row))
                return;
            if (this.enableCallback && this.enableCallback(ctx, this.label, data, row) === false)
                return;
            this._doRun(ctx, data, row);
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _canRun(ctx, data, row) {
            return true;
        }
    }
    class CustomRowCommand extends RowCommand {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(name, config) {
            super(config.label || name, config.style);
            this.className = config.className;
            this.enableCallback = config.enableCallback;
            this._runner = config.run;
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doRun(ctx, data, row) {
            this._runner(ctx, data, row);
        }
    }
    class RowCommandRunner {
        constructor() {
            //-------------------------------------------------------------------------
            // fields
            //-------------------------------------------------------------------------
            this._commandMap = {
                // stock command
                '@info': new RowInfoCommand(),
                '@edit': new EditRowCommand(),
                '@create': new CreateRowCommand(),
                '@delete': new DeleteRowCommand(),
                '@moveup': new MoveUpRowCommand(),
                '@movedown': new MoveDownRowCommand(),
            };
            this.row = -1;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        registeredCommands() {
            return Object.keys(this._commandMap);
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        register(name, command, overwrite) {
            if (!name) {
                throwError(locale.requireCommandName);
            }
            if (!overwrite && name in this._commandMap) {
                throwFormat(locale.commandNameDuplicated, name);
            }
            if (Utils.isObject(command) && typeof command.run === 'function') {
                this._commandMap[name] = new CustomRowCommand(name, command);
            }
        }
        unregister(names) {
        }
        get(commandName) {
            const cls = this._commandMap[commandName];
            if (typeof cls === 'function') {
                return new cls();
            }
            else {
                return cls;
            }
        }
        update(commandName, config) {
            if (config) {
                const cmd = this._commandMap[commandName];
                return cmd && Utils.assignStyleAndProps(cmd, config);
            }
        }
    }
    class StockRowCommand extends RowCommand {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(label, className) {
            super(label);
            this.className = className;
        }
    }
    class RowInfoCommand extends StockRowCommand {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor() {
            super(RowInfoCommand.LABEL, 'dlist-command-info');
        }
        //-------------------------------------------------------------------------
        // override members
        //-------------------------------------------------------------------------
        _doRun(ctx, data, row) {
            ctx.showInfoPage(row, {}, true);
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    RowInfoCommand.LABEL = '자세히';
    class EditRowCommand extends StockRowCommand {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor() {
            super(EditRowCommand.LABEL, 'dlist-command-edit');
        }
        //-------------------------------------------------------------------------
        // override members
        //-------------------------------------------------------------------------
        _doRun(ctx, data, row) {
            ctx.showEditPage(row, {}, true);
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    EditRowCommand.LABEL = '수정';
    class CreateRowCommand extends StockRowCommand {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor() {
            super(CreateRowCommand.LABEL, 'dlist-command-create');
        }
        //-------------------------------------------------------------------------
        // override members
        //-------------------------------------------------------------------------
        _doRun(ctx, data, row) {
            ctx.showEditPage(-1, {}, true);
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    CreateRowCommand.LABEL = '추가';
    class DeleteRowCommand extends StockRowCommand {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor() {
            super(DeleteRowCommand.LABEL, 'dlist-command-delete');
            //-------------------------------------------------------------------------
            // fields
            //-------------------------------------------------------------------------
            this.confirm = false;
        }
        //-------------------------------------------------------------------------
        // override members
        //-------------------------------------------------------------------------
        _doRun(ctx, data, row) {
            if (data && row >= 0 && row < data.rowCount()) {
                if (this.confirm) {
                    if (window.confirm(this.confirmMessage || DeleteRowCommand.MESSAGE)) {
                        data.deleteRow(row, false);
                    }
                }
                else {
                    data.deleteRow(row, false);
                }
            }
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    DeleteRowCommand.LABEL = '삭제';
    DeleteRowCommand.MESSAGE = '정말로 삭제하시겠습니까?';
    class MoveUpRowCommand extends StockRowCommand {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor() {
            super(MoveUpRowCommand.LABEL, 'dlist-command-moveup');
        }
        //-------------------------------------------------------------------------
        // override members
        //-------------------------------------------------------------------------
        _doRun(ctx, data, row) {
            alert('Move Up!');
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    MoveUpRowCommand.LABEL = '↑';
    class MoveDownRowCommand extends StockRowCommand {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor() {
            super(MoveDownRowCommand.LABEL, 'dlist-command-movedown');
        }
        //-------------------------------------------------------------------------
        // override members
        //-------------------------------------------------------------------------
        _doRun(ctx, data, row) {
            alert('Move Down!');
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    MoveDownRowCommand.LABEL = '↓';

    ////////////////////////////////////////////////////////////////////////////////
    class SearchResult extends DObject {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(owner, fields) {
            super();
            this._owner = owner;
            this._fields = fields || [];
            this._current = -1;
        }
        _doDestory() {
            this._owner = null;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        fields() {
            return this._fields;
        }
        count() {
            return this._fields.length;
        }
        isEmpty() {
            return this._fields.length === 0;
        }
        current() {
            return this._current;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        getCurrrentField() {
            return this.isEmpty() ? null : this._fields[this._current];
        }
        moveFirst() {
            if (this.isEmpty())
                return null;
            if (this._current !== 0) {
                this._current = 0;
                this._owner.searchIndexChanged(this);
            }
            return this._fields[this._current];
        }
        movePrev() {
            if (this.isEmpty())
                return null;
            if (this._current !== (this._fields.length + this._current - 1) % this._fields.length) {
                this._current = (this._fields.length + this._current - 1) % this._fields.length;
                this._owner.searchIndexChanged(this);
            }
            return this._fields[this._current];
        }
        moveNext() {
            if (this.isEmpty())
                return null;
            if (this._current !== (this._current + 1) % this._fields.length) {
                this._current = (this._current + 1) % this._fields.length;
                this._owner.searchIndexChanged(this);
            }
            return this._fields[this._current];
        }
        moveLast() {
            if (this.isEmpty())
                return null;
            if (this._current !== this._fields.length - 1) {
                this._current = this._fields.length - 1;
                this._owner.searchIndexChanged(this);
            }
            return this._fields[this._current];
        }
        clear() {
            this._owner.clearSearch(this);
        }
    }
    const isMatched = function (key, value, options) {
        if (key == value)
            return true;
        let sKey = Utils.toStr(key);
        let sVal = Utils.toStr(value);
        if (sKey && sVal) {
            if (!options.matchCase) {
                if (sKey)
                    sKey = sKey.toLowerCase();
                if (sVal)
                    sVal = sVal.toLowerCase();
            }
            if (options.matchWholeWord) {
                return sKey === sVal;
            }
            else {
                return sVal.indexOf(sKey) >= 0;
            }
        }
    };
    class SearchModel {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(owner) {
            this._owner = owner;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        search(options, key, scope) {
            let result;
            options = Object.assign({}, this._owner.searchOptions(), options);
            this.filtering = options.filtering;
            if (scope instanceof ListDataOjbject) {
                result = this.$_searchData(scope, options, key);
            }
            else if (scope instanceof GroupModel) {
                result = this.$_searchGroup(scope, options, key);
            }
            // result && console.log(result.fields().length, 'SEARCHED in', +new Date() - t1, 'ms');
            return result;
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        $_search(dv, options, key, row, results) {
            const layout = this._owner.getSearchLayout(row);
            const simples = layout.getSimples();
            if (simples) {
                for (let layout of simples) {
                    layout.row = row;
                    layout.dv = dv;
                    const value = layout.getValue();
                    if (isMatched(key, value, options)) {
                        const field = layout instanceof DLayoutField ? layout.field : void 0;
                        const sf = { dv, row, value, field, layout: layout };
                        results.push(sf);
                    }
                }
            }
        }
        $_searchData(dv, options, key) {
            const count = dv.rowCount();
            const from = options.fromRow || 0;
            const fields = [];
            if (options.searchAll) {
                const to = (isNaN(options.toRow) || options.toRow < 0) ? from : options.toRow;
                if (to <= from) {
                    for (let r = from; r < count; r++) {
                        this.$_search(dv, options, key, r, fields);
                    }
                    for (let r = 0; r < from; r++) {
                        this.$_search(dv, options, key, r, fields);
                    }
                }
                else {
                    for (let r = from; r < to; r++) {
                        this.$_search(dv, options, key, r, fields);
                    }
                }
            }
            else {
                let r = from;
                do {
                    this.$_search(dv, options, key, r, fields);
                    if (fields.length > 0) {
                        break;
                    }
                    r = (r + 1) % count;
                } while (r !== from);
            }
            // return fields.length > 0 ? new SearchResult(this._owner, fields) : null;
            return new SearchResult(this._owner, fields);
        }
        $_searchGroup(gm, options, key) {
            const dv = gm.data();
            const count = gm.itemCount();
            const from = Math.max(options.fromRow >= 0 ? gm.visIndexOfRow(options.fromRow) : -1, gm.firstVisRow().vindex);
            const fields = [];
            if (options.searchAll) {
                const to = (isNaN(options.toRow) || options.toRow < 0) ? from : Math.max(from, gm.visIndexOfRow(options.toRow));
                if (to <= from) {
                    for (let i = from; i < count; i++) {
                        const r = gm.getItem(i).row();
                        r >= 0 && this.$_search(dv, options, key, r, fields);
                    }
                    for (let i = 0; i < from; i++) {
                        const r = gm.getItem(i).row();
                        r >= 0 && this.$_search(dv, options, key, r, fields);
                    }
                }
                else {
                    for (let i = from; i < to; i++) {
                        const r = gm.getItem(i).row();
                        r >= 0 && this.$_search(dv, options, key, r, fields);
                    }
                }
            }
            else {
                let i = from;
                do {
                    const r = gm.getItem(i).row();
                    r >= 0 && this.$_search(dv, options, key, r, fields);
                    if (fields.length > 0) {
                        break;
                    }
                    i = (i + 1) % count;
                } while (i !== from);
            }
            // return fields.length > 0 ? new SearchResult(this._owner, fields) : null;
            return new SearchResult(this._owner, fields);
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     *
     * Skeleton 행들만 표시하는 ListView.
     */
    class SkeletonListView extends ListView {
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        isSkeleton() {
            return true;
        }
        _createBodyView(doc, noCache, spare) {
            return new SkeletonListBodyView(doc);
        }
    }
    class SkeletonRowView extends ListItemView {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        dv() { return; }
        row() { return -1; }
        model() { return; }
        group() { return; }
        gindex() { return -1; }
        vindex() { return -1; }
        getItemStyle(manager) { return; }
        getItemClass() {
            return SkeletonRowView.CLASS_NAME;
        }
        _doMeasure(doc, hintWidth, hintHeight) {
            const sz = super._doMeasure(doc, hintWidth, hintHeight);
            if (this._layoutView instanceof ListLayoutView) {
                const views = this._layoutView.simplesByRenderer(DummyRenderer.TYPE);
                const ani = { container: this.dom, duration: 1000 };
                for (let v of views) {
                    v.rendererImpl().setAnimation(ani);
                }
            }
            return sz;
        }
        _doApplyStyles(css) {
            this.dom.className = this.getItemClass();
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    SkeletonRowView.CLASS_NAME = 'dlist-skeleton-row';
    /**
     * @internal
     *
     * Skeleton 행들만 표시하는 body view.
     */
    class SkeletonListBodyView extends ListBodyView {
        constructor() {
            super(...arguments);
            //-------------------------------------------------------------------------
            // fields
            //-------------------------------------------------------------------------
            this._rowViews = [];
            this._rowPool = [];
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        isRowEnded() { return true; }
        isScrollEnded() { return true; }
        footerView() { return; }
        bottomRow() { return this._topRow; }
        itemViewCount() { return 0; }
        rowViewCount() { return 0; }
        getItemView(index) { return; }
        itemViews() { return []; }
        itemViewAt(x, y) { return; }
        lastItemView() { return; }
        getItemViewPoints() { return; }
        validateViews() { }
        getPreLength() { return 0; }
        getPrePos(pos, off) { return; }
        getExpander(index) { return; }
        scrollToEnd(row) { return; }
        checkItemViewOrders() { }
        isRowVisible(row, full) { return false; }
        makeRowVisible(row) { return; }
        _itemPoints() { return; }
        _rowViewOfDom(dom) { return; }
        _createRowsDeleingAnimation(rowIds) { return; }
        _doRenderSelection(doc, vertical, selection, selectionView, width, height) { }
        _doScrollNear(doc, oldPos, oldOff, delta, hidth, height) { return; }
        _doScrollFar(doc, oldPos, oldOff, delta, hidth, height) { return; }
        _doPrepareRender(doc, owner) {
            super._doPrepareRender(doc, owner);
            this._rowPool = this._rowPool.concat(this._rowViews);
            this._rowViews = [];
            this._itemLayer.clear();
        }
        _doMeasureVert(doc, hintWidth, hintHeight) {
            const listView = this._listView;
            const itemCount = 10000;
            const pool = this._rowPool;
            const views = this._rowViews;
            let i = 0;
            let h = hintHeight;
            let w = 0;
            let sz;
            while (h > 0 && i < itemCount) {
                const v = pool.pop() || new SkeletonRowView(doc);
                const layout = listView.owner().getSkeletonLayout();
                v.setLayout(layout);
                this._itemLayer.addChild(v);
                sz = v.measure(doc, listView, hintWidth, hintHeight);
                views.push(v);
                h -= sz.height;
                w = Math.max(w, sz.width);
                i++;
            }
            return { width: w, height: hintHeight - h };
        }
        _doMeasureHorz(doc, hintWidth, hintHeight) {
            return;
        }
        _doRenderVert(doc, width, height) {
            const views = this._rowViews;
            const cnt = views.length;
            const pts = this._rowPts = [0];
            const x = 0;
            let y = pts[0];
            let i = 0;
            while (i < cnt && y < height) {
                const v = views[i++];
                const h = v.mh;
                v.move(x, y);
                v.resize(v.mw, h).render(doc);
                y += h;
                pts.push(y);
            }
        }
        _doRenderHorz(doc, width, height) {
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     *
     * 데이터행 하나를 컨트롤 전체 영역에 표시하는 view.
     * 헤더와 데이터행 layout view로 구성된다.
     */
    class RowPageView extends DListElement {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(doc, model, className) {
            super(doc, false, className);
            this._animated = 0;
            this._layoutChanged = false;
            this._hHeader = 0;
            this._hLayout = 0;
            this._scrollPos = 0;
            this._model = model;
            this.appendDom(this._layoutBack = this.$_createLayoutBack(doc));
            this.addChild(this._headerView = new ListHeaderView(doc, model.header()));
            this.setVisible(false);
        }
        _doDestory() {
            super._doDestory();
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        model() {
            return this._model;
        }
        setModel(value) {
            this._model = value;
        }
        row() {
            return this._row;
        }
        layoutBack() {
            return this._layoutBack;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        setRow(dv, row) {
            this._dv = dv;
            this._row = row;
        }
        /**
         * NOTE: silent가 true이면 표시 중일 때 요청된 것이다. 기존 편집 상태를 유지해야 한다.
         */
        refresh(width, height, layoutManager, silent = false) {
            const doc = this.doc;
            width = pickNum(width, this.width);
            height = pickNum(height, this.height);
            if (this._silent = silent) {
                this._doSilentRefresh();
            }
            try {
                this.measure(doc, layoutManager, width, height);
                this.resize(width, height);
                this.render(doc);
            }
            finally {
                if (silent) {
                    this._silent = false;
                }
            }
        }
        _doSilentRefresh() {
        }
        $_getDuration() {
            const d = this._model.effectDuration();
            if (d >= 0.1) {
                return d * 1000;
            }
            else {
                return RowPageView.SHOW_DURATION;
            }
        }
        show(manager, bounds, animate) {
            function getFrames(bounds, dir) {
                switch (dir) {
                    case DListSlideDirection.RIGHT:
                        return [{ left: -bounds.width + 'px' }, { left: '0' }];
                    case DListSlideDirection.LEFT:
                        return [{ left: bounds.width + 'px' }, { left: '0' }];
                    case DListSlideDirection.DOWN:
                        return [{ top: -bounds.height + 'px' }, { top: '0' }];
                    default:
                        return [{ top: bounds.height + 'px' }, { top: '0' }];
                }
            }
            if (this.visible)
                return;
            const now = Utils.now();
            const dur = this.$_getDuration();
            // 'finish'가 호출 안되는 경우(?)를 대비해서...
            if (this._animated > 0 && (now - this._animated < dur)) {
                return;
            }
            this._scrollPos = 0;
            this._internalVisible(true);
            this.refresh(bounds.width, bounds.height, manager);
            this._doShow();
            if (animate && this.canAnimate()) {
                const ani = this.dom.animate(getFrames(bounds, this._showDirection = this._model.getShowDirection()), {
                    duration: dur,
                    fill: 'none'
                });
                this._animated = Utils.now();
                ani.addEventListener('finish', () => {
                    this._animated = 0;
                    // this.control.invalidateLayout();
                });
            }
        }
        _doShow() {
        }
        hide(bounds, animate) {
            function getFrames(bounds, dir) {
                switch (dir) {
                    case DListSlideDirection.RIGHT:
                        return [{ left: '0' }, { left: bounds.width + 'px' }];
                    case DListSlideDirection.LEFT:
                        return [{ left: '0' }, { left: -bounds.width + 'px' }];
                    case DListSlideDirection.DOWN:
                        return [{ top: '0' }, { top: bounds.height + 'px' }];
                    default:
                        return [{ top: '0' }, { top: -bounds.height + 'px' }];
                }
            }
            if (!this.visible)
                return;
            const now = Utils.now();
            const dur = this.$_getDuration();
            // 'finish'가 호출 안되는 경우(?)를 대비해서...
            if (this._animated > 0 && (now - this._animated < dur)) {
                return;
            }
            this._doHide();
            if (animate && this.canAnimate()) {
                const ani = this.dom.animate(getFrames(bounds, this._model.getHideDirection(this._showDirection)), {
                    duration: dur,
                    fill: 'none'
                });
                this._animated = Utils.now();
                ani.addEventListener('finish', () => {
                    this._animated = 0;
                    this.setVisible(false);
                    this.control.invalidateLayout();
                });
            }
            else {
                this.setVisible(false);
            }
        }
        _doHide() {
        }
        getRenderer(dom) {
            return this._layoutView instanceof ListLayoutView && this._layoutView.getRenderer(dom);
        }
        scrollBy(dy) {
            this.setScrollPos(this._scrollPos - dy);
            return this._scrollPos === 0 || this._scrollPos >= (this._hLayout - this.height + this._hHeader);
        }
        setScrollPos(v) {
            const hHeader = this._hHeader;
            const dom = this._layoutBack;
            v = Math.max(0, Math.min(v, this._hLayout - (this.height - hHeader)));
            if (v !== this._scrollPos) {
                const p = this._scrollPos = v;
                dom.style.top = (hHeader - p) + 'px';
            }
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        $_createLayoutBack(doc) {
            const div = doc.createElement('div');
            div.className = 'dlist-row-page-back';
            Object.assign(div.style, {
                position: 'absolute',
                boxSizing: 'border-box'
            });
            return div;
        }
        _doPrepareRender(doc, hint) {
            this._layoutManager = hint;
            if (!this._silent || !this._layout) {
                const { layout, rowProps, rowStyle } = this._getLayout(this._dv, this._row);
                // 이 view가 수정/편집에 같이 사용된다.
                this._headerView.setModel(this._model.header());
                this._layoutChanged = !this._layout || (layout.tid !== this._layout.tid);
                this._layout = layout;
                this._rowStyle = rowStyle;
                if (this._layoutChanged && this._layoutView) {
                    this._layoutBack.removeChild(this._layoutView.dom);
                    this._layoutView = null;
                }
                if (!this._layoutView) {
                    this._layoutView = this._layoutManager.createLayoutView(doc, this._layout);
                    this._layoutBack.appendChild(this._layoutView.dom);
                    this._layoutView.dom.style.overflow = 'hidden';
                    this._layoutView.build(doc, this._layoutManager);
                }
                else {
                    // child들의 layout 모델을 갱신한다.
                    this._layoutView.refreshModels(this._layout); // as any는 억지다. _layoutView와 _layout의 종류가 일치한다고 가정한다.
                }
            }
        }
        _doApplyStyles(css) {
            const st = this._rowStyle && this._rowStyle.default;
            st && Object.assign(this._layoutBack.style, st);
        }
        _doMeasure(doc, hintWidth, hintHeight) {
            const hv = this._headerView;
            const lv = this._layoutView;
            const p = this._padding = Dom.getPadding(this._layoutBack);
            let hHeader = 0;
            let w = hintWidth;
            let h = hintHeight;
            // header
            if (hv.setVisible(hv.model().visible())) {
                hv.setLayout(hv.model().layout());
                h -= hHeader = hv.measure(doc, this._layoutManager, w, h).height;
            }
            w -= p.left + p.right;
            h -= p.top + p.bottom;
            // layout
            this._layout.setRow(this._dv, this._row, -1);
            lv._explicitWidth = w;
            lv.prepareLayout(doc, this._layoutManager);
            const sz = lv.measureLayout(doc, this._layoutManager, w, h);
            sz.width += p.left + p.right;
            sz.height += p.top + p.bottom;
            return { width: hintWidth, height: Math.max(hintHeight, sz.height + hHeader) };
        }
        _doRender(doc, width, height) {
            const p = this._padding;
            const lv = this._layoutView;
            let hv = this._headerView;
            let x = 0;
            let y = 0;
            height = Math.max(height, hv.mh + lv.mh + p.top + p.bottom);
            // header
            if (hv && hv.visible) {
                const h = this._hHeader = hv.mh;
                hv.resize(width, h).move(x, y);
                height -= h;
                y += h;
                hv.render(doc);
            }
            else {
                this._hHeader = 0;
            }
            height = this._hLayout = Math.max(0, height);
            // layout back
            Dom.resize(this._layoutBack, width, height);
            Dom.move(this._layoutBack, x, y);
            // layout
            lv.resize(width - p.left - p.right, height - p.top - p.bottom);
            lv.render(doc);
        }
        _doAfterRender() {
            this._layoutManager = null;
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    RowPageView.SHOW_DURATION = 300;

    ////////////////////////////////////////////////////////////////////////////////
    class RowInfoPageView extends RowPageView {
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(doc, model) {
            super(doc, model, RowInfoPageView.CLASS_NAME);
            this._model = model;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _getLayout(dv, row) {
            return this._model.getLayout(dv, row);
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    RowInfoPageView.CLASS_NAME = 'dlist-row-info-page';

    ////////////////////////////////////////////////////////////////////////////////
    class RowEditPageView extends RowPageView {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(doc, model) {
            super(doc, model, RowEditPageView.CLASS_NAME);
            //-------------------------------------------------------------------------
            // fields
            //-------------------------------------------------------------------------
            this._changeHandler = (ev) => {
                const m = this.model();
                const lv = this._layoutView;
                if (lv instanceof ListLayoutView) {
                    const fv = lv.childOfDom(ev.target);
                    if (fv instanceof LayoutFieldView) {
                        const v = fv.getEditValue(this.control);
                        m.valueChanged(this._ctx, v.field, v.value, fv.value());
                    }
                }
            };
            this._ctx = {
                getValue: (id) => {
                    return this.getFieldValue(id);
                },
                setValue: (id, value) => {
                    this.setFieldValue(id, value);
                },
                isVisible: (id) => {
                    return this.isFieldVisible(id);
                },
                setVisible: (id, visible) => {
                    this.setFieldVisible(id, visible);
                }
            };
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        model() {
            return this._model;
        }
        setModel(value) {
            this._model = value;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        getValues(manager) {
            if (this._layoutView instanceof ListLayoutView) {
                return this._layoutView.getValues(manager);
            }
        }
        getFieldValue(id) {
            const lv = this._layoutView;
            if (lv instanceof ListLayoutView) {
                const fv = lv.simpleById(id, true);
                if (fv instanceof LayoutFieldView) {
                    const v = fv.getEditValue(this.control);
                    return v !== void 0 ? v.value : void 0;
                }
            }
        }
        setFieldValue(id, value) {
            const lv = this._layoutView;
            if (lv instanceof ListLayoutView) {
                const fv = lv.simpleById(id, true);
                if (fv instanceof LayoutFieldView) {
                    fv.setEditValue(this.control, value);
                }
            }
            this.refresh(this.width, this.height, this.control['_listView'], true);
        }
        isFieldVisible(id) {
            const lv = this._layoutView;
            if (lv instanceof ListLayoutView) {
                const fv = lv.simpleById(id, true);
                return fv && fv.visible;
            }
        }
        setFieldVisible(id, visible) {
            const lv = this._layoutView;
            if (lv instanceof ListLayoutView) {
                const fv = lv.simpleById(id, true);
                if (fv) {
                    fv.layout.visible = visible;
                    this.refresh(this.width, this.height, this.control['_listView'], true);
                }
            }
        }
        commit(values) {
            return this._model.commit(this._ctx, values);
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _getLayout(dv, row) {
            return this._model.getLayout(dv, row);
        }
        _doShow() {
            const dom = this.dom;
            this.$_clearHandlers();
            dom.addEventListener('change', this._changeHandler);
        }
        _doHide() {
            this.$_clearHandlers();
        }
        _doSilentRefresh() {
            if (this._layoutView instanceof ListLayoutView) {
                this._layoutView.saveEditValues(this.control);
            }
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        $_clearHandlers() {
            const dom = this.dom;
            dom.removeEventListener('change', this._changeHandler);
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    RowEditPageView.CLASS_NAME = 'dlist-row-edit-page';

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     *
     * SingleView row changer.
     */
    class SingleRowChanger extends DObject {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(body) {
            super();
            this._body = body;
            this._view = body.singleView();
            this._spare = body.spareSingleView();
        }
        _doDestory() {
            this._body = null;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        run(model, endCallback) {
            this.$_prepare(this._model = model);
            this._endCallback = endCallback;
            this._doRun();
            return this;
        }
        stop() {
            this.$_unprepare();
        }
        $_prepare(model) {
            this._body.control.lock(() => {
                this._body.addChild(this._spare);
            });
            this._doPrepare(model);
        }
        $_unprepare() {
            this._doUnprepare();
            this._body.removeChild(this._spare);
        }
    }
    /**
     * slide
     */
    class SingleRowSlider extends SingleRowChanger {
        constructor() {
            super(...arguments);
            this._handler = () => {
                const dur = this._model.changeDuration();
                const now = Utils.now();
                const dt = now - this._started;
                let delta = this._width - this._pos;
                if (dt >= dur || delta <= 0) {
                    this.$_stop();
                    this._endCallback(this._view.row());
                }
                else {
                    const dt2 = dur - dt;
                    delta *= (now - this._prev) / dt2;
                    this._prev = now;
                }
                if (delta) {
                    this._pos += delta;
                    this._view.moveX(-this._pos);
                    this._spare.moveX(this._width - this._pos);
                }
            };
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doPrepare(model) {
            this._nextRow = (this._view.row() + 1) % this._view.rowView().dv().rowCount();
            this._width = this._view.width;
            this._pos = 0;
            this._spare.setRow(this._nextRow, this._view);
            this._view.moveX(0);
            this._spare.moveX(this._width);
        }
        _doUnprepare() {
            this.$_stop();
        }
        _doRun() {
            this._started = this._prev = Utils.now();
            this._timer = setInterval(this._handler, 20);
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        $_stop() {
            if (this._timer) {
                clearTimeout(this._timer);
                this._timer = void 0;
                this._view.setRow(this._nextRow, null);
                this._view.moveX(0);
            }
        }
    }
    class SingleRowAnimator extends SingleRowChanger {
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doPrepare(model) {
        }
        _doUnprepare() {
        }
        _doRun() {
        }
    }
    /**
     * flip
     */
    class SingleRowFlipChanger extends SingleRowAnimator {
    }

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     *
     * Auto scroller.
     */
    class AutoScroller extends DObject {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(owner) {
            super();
            this._rowHandler = () => {
                const now = Utils.now();
                if (now >= this._prev + this._model.duration()) {
                    this._doStartChange(this._model);
                    this._prev = now;
                }
            };
            this._owner = owner;
            this._body = owner.bodyView();
        }
        _doDestory() {
            this._owner = this._body = null;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        start(model) {
            this.stop();
            if (this._doStart(model)) {
                this._model = model;
                this._prev = Utils.now();
                this._rowTimer = setInterval(this._rowHandler, 10);
            }
        }
        stop() {
            if (this._rowTimer) {
                clearTimeout(this._rowTimer);
                this._rowTimer = void 0;
                this._doStop();
                this._model = void 0;
            }
        }
        _showNext() {
            this._prev = Utils.now();
        }
    }
    class ListRowScroller extends AutoScroller {
        constructor() {
            super(...arguments);
            this._scrollHandler = () => {
                let delta2 = this._body.scrollPos() !== this._startRow ? 0 : this.$_getScrollAmount();
                const dur = this._model.changeDuration();
                const now = Utils.now();
                const dt = now - this._started;
                if (dt >= dur || delta2 <= 0) {
                    this.$_stopChange();
                    this._showNext();
                }
                else {
                    const dt2 = dur - dt;
                    delta2 *= (now - this._prev2) / dt2;
                    this._prev2 = now;
                }
                if (delta2) {
                    this._owner.scrollBy(delta2);
                }
            };
        }
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doStart(model) {
            return true;
        }
        _doStop() {
        }
        _doStartChange(model) {
            this.$_stopChange();
            this._started = this._prev2 = Utils.now();
            this._startRow = this._body.scrollPos();
            this._scrollTimer = setInterval(this._scrollHandler, 20);
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        $_getScrollAmount() {
            const delta = this._body.getItemView(0).height;
            return delta - this._body.scrollOff();
        }
        $_stopChange() {
            if (this._scrollTimer) {
                clearTimeout(this._scrollTimer);
                this._scrollTimer = void 0;
            }
        }
    }
    class SingleRowScroller extends AutoScroller {
        constructor() {
            super(...arguments);
            this._endCallback = (row) => {
                this._showNext();
                this._owner.setScrollIndex(row, 0);
            };
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doStart(model) {
            return true;
        }
        _doStop() {
            this.$_stopChange();
        }
        _doStartChange(model) {
            this.$_stopChange();
            const effect = this._model.changeEffect();
            const body = this._body;
            let changer;
            switch (effect) {
                case DListSingleRowChangeEffect.SLIDE:
                    changer = new SingleRowSlider(body);
                    break;
                case DListSingleRowChangeEffect.FLIP:
                    changer = new SingleRowFlipChanger(body);
                    break;
            }
            (this._changer = changer) && changer.run(this._model, this._endCallback);
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        $_stopChange() {
            if (this._changer) {
                this._changer.stop();
                this._changer = null;
            }
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    /** @internal */
    class RowInflater {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(owner) {
            this._row = -1;
            this._args = {
                context: this,
                control: void 0,
                row: -1,
                field: void 0,
                values: void 0
            };
            //-------------------------------------------------------------------------
            // stock inflator
            //-------------------------------------------------------------------------
            this._stocks = {
                'value': (field) => {
                    this._dv.checkField(field);
                    if (this._values) {
                        return this._values[field];
                    }
                    else {
                        this._values = this._data.internalRowValues(this._row);
                        return this._values[field];
                    }
                },
                'no': () => { return this._row + 1; },
                'row': () => { return this._row; },
                'detail_count': () => {
                    return this._dg ? this._dg.getDetailCount(this._row) : 0;
                },
                'is_landscape': () => {
                    return this._owner.isLandscape();
                },
                'is_portrait': () => {
                    return this._owner.isPortrait();
                }
            };
            this._owner = owner;
        }
        //-------------------------------------------------------------------------
        // IParamInflater
        //-------------------------------------------------------------------------
        inflateParam(row, field, param) {
            const p = param.name;
            if (this.templateParams) {
                const v = this.templateParams[p];
                if (typeof v === 'function') {
                    const args = this._args;
                    args.control = this._owner.wrapperOrThis();
                    args.row = row;
                    args.field = field;
                    // DParamString.inflate(...)에서 처리하지 않고 여기서 한다.
                    args.values = this._values = this._values || Object.freeze(this._dv.internalRowValues(row));
                    return v(args);
                }
                else if (v !== void 0) {
                    return v;
                }
            }
            const vals = this._owner.getRowParams(row);
            if (vals) {
                const v = vals[p];
                if (typeof v === 'function') {
                    const params = this._args;
                    params.control = this._owner.wrapperOrThis();
                    params.row = row;
                    params.field = field;
                    // DParamString.inflate(...)에서 처리하지 않고 여기서 한다.
                    params.values = this._values = this._values || Object.freeze(this._dv.internalRowValues(row));
                    return v(params);
                }
                else {
                    return v;
                }
            }
        }
        inflateStock(row, field, param) {
            const stock = this._stocks[param.name];
            if (stock) {
                return stock(field);
            }
            else {
                // ${@field} 형식으로 필드명을 지정할 수 있다.
                if (this._dv.containsField(param.name)) {
                    return this._stocks.value(param.name);
                }
                console.error('Invalid stock param: ' + param.source);
                return param.source;
            }
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        setData(data) {
            this._data = data;
            this._dg = data instanceof ListDataLinkView ? data : null;
        }
        setRow(row) {
            if (this._data instanceof ListDataLinkView) {
                const r = this._data.getSourceRow(row);
                this._dv = r.dv;
                this._row = r.row;
            }
            else {
                this._dv = this._data;
                this._row = row;
            }
            this._values = undefined;
            return this;
        }
    }
    /**
     * @internal
     */
    class LayoutPool {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(owner) {
            this._owner = owner;
            this._rowInflater = new RowInflater(owner);
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        prepareRender() {
            this._rowInflater.setData(this._owner.data());
        }
        getRowInflater(row) {
            return this._rowInflater.setRow(row);
        }
        getRowLayout(ctx, row, detailed) {
            const owner = this._owner;
            const t = owner.getRowTemplate(row);
            const layout = LayoutFactory.Instance.layoutFromTemplate(ctx || owner.wrapperOrThis(), row, false, detailed, t, this._rowInflater.setRow(row));
            return { layout, rowProps: t.rowProps, rowStyle: t.rowStyle };
        }
        getGroupItemLayout(item) {
            const gm = this._owner.groupModel();
            let collapsed;
            let template;
            if (item instanceof GroupHeader) {
                template = gm.getHeaderTemplate(item);
                collapsed = !item.group.expanded();
            }
            else if (item instanceof GroupFooter) {
                template = gm.getFooterTemplate(item);
            }
            const t = this._owner._templates.get(template) || UserTemplates.get(template) || StockTemplates.get(template);
            const layout = LayoutFactory.Instance.layoutFromTemplate(gm, item, collapsed, false, t, gm);
            return { layout };
        }
        inflate(ps, field) {
            return ps.inflate(this._owner.wrapperOrThis(), void 0, field, this._rowInflater);
        }
    }
    class DSearchOptions {
        constructor() {
            //-------------------------------------------------------------------------
            // property fields
            //-------------------------------------------------------------------------
            this.matchCase = false;
            this.matchWholeWord = false;
            this.useRegExp = false;
            this.dataOnly = true;
            this.ignoreFormat = true;
            this.searchAll = true; //false;
            this.fromRow = 0;
            this.toRow = -1;
            this.circular = true;
            this.filtering = false;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        assign(source) {
            Utils.assign(this, source);
        }
    }
    /**
     * @internal
     *
     * [접근성]
     * 1. grouping 상태면 'treegrid', 아니면 'grid'.
     */
    class ListControl extends DControl {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(doc, container, renderMode) {
            super(doc, container, ListControl.CLASS_NAME);
            this._alwaysFirstGroupHeader = true;
            this._searchOptions = new DSearchOptions();
            this.fitRowWhenScroll = false;
            this.fitRowWhenClick = true;
            this.skeletonVisible = false;
            this.alwaysEmptyPage = false;
            //-------------------------------------------------------------------------
            // fields
            //-------------------------------------------------------------------------
            this._renderMode = DListRenderMode.DEFAULT;
            this._flags = DummyDataFlags.Instance;
            this._templates = new Registy();
            this._runTextFormatter = getTextFormatter('');
            this._runBoolFormatter = getBoolFormatter(ListControl.BOOLEAN_FORMAT);
            this._runNumberFormatter = getNumberFormatter(ListControl.NUMBER_FORMAT);
            this._runDateFormatter = getDateFormatter(ListControl.DATE_FORMAT);
            this._imageList = [];
            this._imageList2 = {};
            this._imageSizes = {};
            this._imageLoaded = (ev) => {
                const img = ev.target;
                if (_isSafari) {
                    this._imageSizes[img['_src_']] = { width: img.naturalWidth, height: img.naturalHeight };
                }
                if (!this.bodyView().animating()) {
                    // TODO: DListMode 별 대응 필요.
                    this.invalidateLayout(true);
                }
                if (this._infoPageView && this._infoPageView.visible || this._editPageView && this._editPageView.visible) {
                    // [SAFARI] 이렇게 간격을 둬야 이미지 처리가 제대로 된다.
                    setTimeout(() => {
                        const iview = this._infoPageView;
                        iview && iview.visible && iview.refresh(NaN, NaN, this._listView, true);
                        const eview = this._editPageView;
                        eview && eview.visible && eview.refresh(NaN, NaN, this._listView, true);
                        this.listView().refreshPanel();
                    }, 0);
                }
            };
            this._menus = {};
            this._layoutNeeded = true;
            this._dataLoading = false;
            this._dataAppending = false;
            this._dataChanged = false;
            this._topRow = -1; // data row at top
            this._scrollIndex = 0; // item index
            this._scrollOff = 0; // item's top offset from list body view's top
            this._lastRowRevealed = false;
            this._focusedRow = -1;
            this._rowClickArgs = {
                control: this.wrapperOrThis(),
                row: -1,
                cancel: false
            };
            /**
             * true면 드래그로 행들을 선택할 수 있다.
             * 선택 영역은 하나만 존재할 수 있다.
             */
            this.dragSelectable = false;
            /**
             * true면 데이터 변경이 발생할 때 기존 선택을 제거한다.
             */
            this.autoClearSelection = false;
            this._renderMode = renderMode;
            this._fullMode = renderMode === DListRenderMode.FULL;
            this._preMode = renderMode === DListRenderMode.PRE;
            this._noCache = this._fullMode || this._preMode;
            this.addElement(this._listView = this._defaultListView = new DefaultListView(doc, this));
        }
        _doDestory() {
            super._doDestory();
            this._shapes = this._shapes.destroy();
        }
        //-------------------------------------------------------------------------
        // IListOptionItemOwner
        //-------------------------------------------------------------------------
        optionItemChanged(option) {
            this.invalidateLayout();
        }
        //-------------------------------------------------------------------------
        // IListAutoScrollOwner
        //-------------------------------------------------------------------------
        autoScrollChanged(scroll) {
            if (scroll instanceof ListRowScroll && !this._singleRow) {
                if (scroll.enabled()) {
                    if (!this._rowScroller) {
                        this._rowScroller = new ListRowScroller(this);
                        this._rowScroller.start(this._current.row().autoScroll());
                    }
                }
                else if (this._rowScroller) {
                    this._rowScroller.stop();
                    this._rowScroller = void 0;
                }
            }
            else if (scroll instanceof SingleRowScroll && this._singleRow) {
                if (scroll.enabled()) {
                    if (!this._singleScroller) {
                        this._singleScroller = new SingleRowScroller(this);
                        this._singleScroller.start(this._current.singleRow().autoScroll());
                    }
                }
                else {
                    this._singleScroller.stop();
                    this._singleScroller = void 0;
                }
            }
        }
        //-------------------------------------------------------------------------
        // ITemplateHtmlProvider
        //-------------------------------------------------------------------------
        getTemplateHtml(id) {
            const dom = this._htmlTempls[id];
            return dom && dom.cloneNode(true);
        }
        //-------------------------------------------------------------------------
        // IListSectionOwner
        //-------------------------------------------------------------------------
        sectionChanged(section) {
            this.invalidateLayout();
        }
        sectionLayoutChanged(section) {
            this.invalidateLayout();
        }
        //-------------------------------------------------------------------------
        // IListDataListener
        //-------------------------------------------------------------------------
        onDataReset(data) {
        }
        onDataValueUpdated(data, row, field, value, oldValue) {
        }
        onDataRowUpdated(data, row, oldValues) {
        }
        onDataRowsUpdated(data, rows) {
        }
        onDataRowAdded(data, row) {
        }
        onDataRowsAdded(data, row, count) {
        }
        onDataCleared(data, oldCount) {
        }
        onDataLoaded(data, oldCount) {
        }
        onDataRowDeleted(data, row, rowid) {
            if (this._current.row().deleteAnimation() && !this.isTesting()) {
                this.bodyView().$_addDeletingRows(rowid);
            }
        }
        onDataRowsDeleted(data, rows, rowids) {
            if (this._current.row().deleteAnimation() && !this.isTesting()) {
                this.bodyView().$_addDeletingRows(rowids);
            }
        }
        onDataRangeDeleted(data, row, count) {
        }
        onDataRowMoved(data, from, to) {
        }
        onDataRowsMoved(data, from, count, to) {
        }
        onDataCountChanged(data, newCount, oldCount) {
            if (this.isPaging()) {
                this._pageModel.$_reset();
                this.invalidateLayout();
            }
        }
        onDataStateChanged(data, row) {
        }
        onDataStatesChanged(data, rows) {
        }
        onDataChanged(data) {
            this._dataChanged = true;
            if (this._noCache) {
                // TODO: 개별 data event 별로 처리해야 한다!
                this.invalidateLayout();
            }
            else {
                this.invalidateLayout();
            }
        }
        onDataFlagChanged(data, flags, row, flag) {
            if (DataFlags.isCheckedFlag(flag)) {
                this.onRowCheck && this.onRowCheck({ control: this.wrapperOrThis(), row });
            }
            else if (DataFlags.isDetailedFlag(flag)) {
                this.onRowDetail && this.onRowDetail({ control: this.wrapperOrThis(), row });
            }
            else {
                flag = DataFlags.isUserFlag(flag);
                this.onRowFlagChange && this.onRowFlagChange({ control: this.wrapperOrThis(), row, flag });
            }
            this.invalidateLayout();
        }
        onDataFlagsChanged(data, flags, rows, flag) {
            if (DataFlags.isCheckedFlag(flag)) {
                this.onRowsCheck && this.onRowsCheck({ control: this.wrapperOrThis(), rows });
            }
            else if (DataFlags.isDetailedFlag(flag)) {
                this.onRowsDetail && this.onRowsDetail({ control: this.wrapperOrThis(), rows });
            }
            else {
                flag = DataFlags.isUserFlag(flag);
                this.onRowsFlagChange && this.onRowsFlagChange({ control: this.wrapperOrThis(), rows, flag });
            }
            this.invalidateLayout();
        }
        onDataFlagAllChanged(data, flags, flag) {
            if (DataFlags.isCheckedFlag(flag)) {
                this.onAllRowsCheck && this.onAllRowsCheck({ control: this.wrapperOrThis() });
            }
            else if (DataFlags.isDetailedFlag(flag)) {
                this.onAllRowsDetail && this.onAllRowsDetail({ control: this.wrapperOrThis() });
            }
            else {
                flag = DataFlags.isUserFlag(flag);
                this.onAllRowsFlagChange && this.onAllRowsFlagChange({ control: this.wrapperOrThis(), flag });
            }
            this.invalidateLayout();
        }
        //-------------------------------------------------------------------------
        // IListDataViewListener
        //-------------------------------------------------------------------------
        onDataViewFilterChanged(dv) {
            this.invalidateLayout();
        }
        onDataViewSortChanged(dv) {
            this.invalidateLayout();
        }
        //-------------------------------------------------------------------------
        // IListRowGroupListener
        //-------------------------------------------------------------------------
        onGroupExpanded(group, expanded) {
            this.invalidateLayout();
        }
        onGroupChecked(group, checked) {
            this.invalidateLayout();
        }
        //-------------------------------------------------------------------------
        // IListDataGroupListener
        //-------------------------------------------------------------------------
        onDataGroup2Expanded(group, expanded) {
            this.invalidateLayout();
        }
        //-------------------------------------------------------------------------
        // IListPageListener
        //-------------------------------------------------------------------------
        onPageChanged(model, page, oldPage) {
            this.setScrollIndex(0, 0);
            this.invalidateLayout();
            this._listView.pageChanged(page);
        }
        //-------------------------------------------------------------------------
        // IPagingOwner
        //-------------------------------------------------------------------------
        pageIndexClick(page) {
            this.setPage(page);
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        preMode() {
            return this._preMode;
        }
        fullMode() {
            return this._fullMode;
        }
        noCache() {
            return this._noCache;
        }
        /**
         * [접근성] 정보.
         * 컨트롤 div의 aria-label 속성으로 사용된다.
         */
        description() {
            return this._description;
        }
        setDescription(value) {
            if (value !== this._description) {
                this._description = value;
                this.invalidate();
            }
        }
        renderMode() {
            return this._renderMode;
        }
        rowInfos() {
            return this._current.dataRowInfos();
        }
        groupExpander() {
            return this._current.rowGroup().expander();
        }
        dataExpander() {
            return this._current.dataGroup().expander();
        }
        rowBar() {
            return this._current._rowBar;
        }
        editBar() {
            return this._current._editBar;
        }
        scrollIndicator() {
            return this._current._scrollIndicator;
        }
        indexBar() {
            return this._current._indexBar;
        }
        scrollBar() {
            return this._current._scrollBar;
        }
        pageNavigator() {
            return this._current._pageNavigator;
        }
        pageScroller() {
            return this._current._pageScroller;
        }
        commandBox() {
            return this._current._commandBox;
        }
        selectionMask() {
            return this._current._selectionMask;
        }
        options() {
            return this._defaults;
        }
        portrait() {
            return this._portrait;
        }
        landscape() {
            return this._landscape;
        }
        /**
         * {@link _screenOrientation  장치 방향}에 따라 현재 적용 중인 options.
         */
        current() {
            return this._current;
        }
        /**
         * data
         */
        data() {
            return this._data;
        }
        setData(value) {
            if (value != this._data) {
                const gm = this._groupModel;
                if (this._data) {
                    gm && this._data.removeListener(gm);
                    this._data.removeListener(this);
                }
                this._flags = DummyDataFlags.Instance;
                this._data && this._data.removeFlags(this);
                this._data = value;
                this._defRowTempl = new DefaultTemplate(this);
                if (this._data) {
                    this._data.addListener(this);
                    gm && this._data.addListener(gm);
                    this._flags = this._data.addFlags(this);
                }
                if (this._dataGroup) {
                    if (!(this._data instanceof ListDataLinkView)) {
                        this.$_destroyGroupModel(this._dataGroup);
                    }
                    else {
                        this._dataGroup.refresh(this._data);
                    }
                }
                else if (this._rowGroup) {
                    if (this._data instanceof ListDataLinkView) {
                        this.$_destroyGroupModel(this._rowGroup);
                    }
                    else {
                        this._rowGroup.refresh(this._data);
                    }
                }
                this.invalidateLayout();
            }
            return value;
        }
        /**
         * 단일 데이터 행 grouping된 상태인가?
         */
        isRowGrouped() {
            return this._rowGroup && this._rowGroup.levels() > 0;
        }
        /**
         * 마스터/데테일 상태인가?
         */
        isDataGrouped() {
            return this._dataGroup && this._dataGroup.levels() > 0;
            //return this._dataGroup && this._dataGroup.levels() > 0;
        }
        isGrouped() {
            return this._groupModel && this._groupModel.levels() > 0;
        }
        /**
         * 컨트롤이 페이징 상태인가?
         */
        isPaging() {
            return !!this._pageModel;
        }
        /**
         * 페이지 행 수.
         */
        pageSize() {
            return this._pageModel ? this._pageModel.size() : NaN;
        }
        /**
         * 전체 페이지 개수.
         */
        pageCount() {
            return this._pageModel ? this._pageModel.pageCount() : NaN;
        }
        /**
         * 현재 page 인덱스.
         * 범위(0 ~ {@link pageCount} - 1)을 벗어나게 설정하면 범위 내로 조정된다.
         * 하지만, 페이징 상태가 아닐 때 이 속성을 설정하면 예외가 발생한다.
         */
        page() {
            return this._pageModel ? this._pageModel.page() : NaN;
        }
        setPage(newPage) {
            if (!this.isPaging())
                throw new Error('Control is not a paging mode.');
            this._pageModel.setPage(newPage);
        }
        isVertical() {
            return this._current.orientation() === DListOrientation.VERTICAL;
        }
        isLandscape() {
            return this.orientation() === DScreenOrientation.LANDSCAPE;
        }
        /**
         * loading page를 표시한다.
         */
        setDataLoading(value) {
            if (value != this._dataLoading) {
                this._dataLoading = value;
                this.invalidateLayout();
                return true;
            }
            return false;
        }
        isDataLoading() {
            return this._dataLoading;
        }
        /**
         * onLastRowRevealed 이벤트 등,
         * 마지막 행이 표시된 상태에서 true로 설정하면 마지막행 다음 추가행 영역에 loading spinner를 표시한다.
         * data load가 끝나면 반드시 false로 호출해야 한다.
         */
        setDataAppending(appending, scroll) {
            if (this._dataAppending !== appending) {
                this._dataAppending = appending;
                if (scroll && appending) {
                    this.scrollToEnd(-1); // attached row가 표시되도록 한다.
                }
                else {
                    this.invalidateLayout();
                }
                return true;
            }
            return false;
        }
        isDataAppending() {
            return this._dataAppending;
        }
        isDataEmpty() {
            return !this._data || this._data.source().rowCount() < 1;
        }
        isEmpty() {
            return !this._data || this._data.rowCount() < 1;
        }
        shouldShowEmptyPage() {
            return this.isDataEmpty() || (this.alwaysEmptyPage && this.isEmpty());
        }
        isDataChanged() {
            return this._dataChanged;
        }
        /**
         * 현재 표시되는 시작(위쪽 혹은 왼쪽) 행(rows & group items) index.
         * 즉, 지정한 행이 표시되는 최초 행이 되게 한다.
         * 그룹핑 상태일 때는 그룹 아이템(header/footer/row) 행의 index, 아니면 row 행 index.
         * 컨트롤 렌더링 중에 실제 scrollIndex가 결정된다.
         * 이 속성을 변경하면 scrollOff는 0이 된다.
         * 또, 이 속성 설정 외에 {@link scrollBy} 호출을 통해 픽셀 단위로 스크롤 위치를 변경할 수 있다.
         */
        scrollIndex() {
            return this._scrollIndex;
        }
        setScrollIndex(value, off) {
            if (!this.isEmpty()) {
                value = Math.max(0, pickNum(value, 0));
                if (value !== this._scrollIndex || this._scrollOff !== off) {
                    this._reqScrollIndex = Math.max(0, value);
                    this._reqScrollOff = pickNum(off, 0);
                    this.invalidateLayout();
                }
            }
        }
        scrollOff() {
            return this._scrollOff;
        }
        /**
         * 현재 표시되는 시작(최상단) 데이터행 index.
         * 그룹핑 및 페이징이 아닌 경우 {@link scrollIndex}와 동일한 값이다.
         * 현재 표시되는 데이터행이 하나도 없다면 -1이다.
         */
        topRow() {
            return this._topRow;
        }
        setTopRow(value) {
            // TODO: DataGroup
            const idx = this._rowGroup ? this._rowGroup.visIndexOfRow(value) : value;
            this.setScrollIndex(idx, 0);
        }
        /**
         * 기본 string to string callback formatter.
         * 이 속성이 설정되면 textFormat은 무시된다.
         */
        textFormatter() {
            return this._textFormatter;
        }
        setTextFormatter(value) {
            if (value !== this._textFormatter) {
                this._textFormatter = value;
                this._runTextFormatter = void 0;
                this.invalidateLayout();
            }
        }
        /**
         * 기본 bool to string callback formatter.
         * 이 속성이 설정되면 boolFormat은 무시된다.
         */
        boolFormatter() {
            return this._boolFormatter;
        }
        setBoolFormatter(value) {
            if (value !== this._boolFormatter) {
                this._boolFormatter = value;
                this._runBoolFormatter = void 0;
                this.invalidateLayout();
            }
        }
        /**
         * 기본 number to string callback formatter.
         * 이 속성이 설정되면 numberFormat은 무시된다.
         */
        numberFormatter() {
            return this._numberFormatter;
        }
        setNumberFormatter(value) {
            if (value !== this._numberFormatter) {
                this._numberFormatter = value;
                this._runNumberFormatter = void 0;
                this.invalidateLayout();
            }
        }
        dateFormatter() {
            return this._dateFormatter;
        }
        setDateFormatter(value) {
            if (value !== this._dateFormatter) {
                this._dateFormatter = value;
                this._runDateFormatter = void 0;
                this.invalidateLayout();
            }
        }
        textFormat() {
            return this._textFormat;
        }
        setTextFormat(value) {
            if (value !== this._textFormat) {
                this._textFormat = value;
                this._runTextFormatter = void 0;
                this.invalidateLayout();
            }
        }
        boolFormat() {
            return this._boolFormat;
        }
        setBoolFormat(value) {
            if (value !== this._boolFormat) {
                this._boolFormat = value;
                this._runBoolFormatter = void 0;
                this.invalidateLayout();
            }
        }
        numberFormat() {
            return this._numberFormat;
        }
        setNumberFormat(value) {
            if (value !== this._numberFormat) {
                this._numberFormat = value;
                this._runNumberFormatter = void 0;
                this.invalidateLayout();
            }
        }
        /**
         * 기본 Date to string formatter.
         * {@link dateFormatter}가 설정되면 이 속성은 무시된다.
         */
        dateFormat() {
            return this._dateFormat;
        }
        setDateFormat(value) {
            if (value !== this._dateFormat) {
                this._dateFormat = value;
                this._runDateFormatter = void 0;
                this.invalidateLayout();
            }
        }
        groupModel() {
            return this._rowGroup || this._dataGroup;
        }
        /**
         * Row Group 모델.
         */
        rowGroup() {
            return this._rowGroup;
        }
        /**
         * Data Group 모델.
         */
        dataGroup() {
            return this._dataGroup;
        }
        /**
         * @internal
         * 페이지 모델.
         */
        pageModel() {
            return this._pageModel;
        }
        /**
         * @internal
         * for testing
         */
        get layoutViewManager() {
            return this._listView;
        }
        /**
         * true이면 최상단 데이터행의 group header를 항상 표시한다. (iphone 전화번호부)
         */
        get alwaysFirstGroupHeader() {
            return this._alwaysFirstGroupHeader;
        }
        set alwaysFirstGroupHeader(value) {
            if (value !== this._alwaysFirstGroupHeader) {
                this._alwaysFirstGroupHeader = value;
                this.isRowGrouped() && this.invalidateLayout();
            }
        }
        focusedRow() {
            return this._focusedRow;
        }
        rowCommands() {
            return this._rowCommands;
        }
        /**
         * Row command가 표시되는 데이터행 번호.
         */
        commandRow() {
            return this.bodyView().commandRow();
        }
        /**
         * Row command가 표시되는 데이터행을 지정한다.
         * 지정한 행이 현재 화면에 표시되는 위치가 아니면 스크롤해서 표시한다.
         * -1로 지정하면 기존 커맨드 표시가 감춰진다.
         * 커맨드 행으로 지정된 행이 스크롤로 사라지게 되거나, 다른 행을 터치하면 자동으로 감춘다.
         * 보통, 사용자가 데어터행을 swipe하거나 클릭해서 command를 표시하게 된다.
         *
         * @param row 데이터행 번호
         * @param animate true면 커맨드롤 표시하거나 감출 때 animation이 진행된다.
         */
        setCommandRow(row, animate) {
            if (row >= 0) {
                if (this.makeRowVisible(row)) {
                    this.updateNow();
                }
                //const cmds = this._rowCommands.getCommands();
                const cmds = this._current.getRowCommands();
                this.bodyView().setCommands(row, cmds, animate);
            }
            else {
                this.bodyView().clearCommands(animate);
            }
        }
        /**
         * @internal
         */
        listView() {
            return this._listView;
        }
        bodyView() {
            return this._listView.bodyView();
        }
        rowPageView() {
            return this._rowPageView;
        }
        infoPageView() {
            return this._infoPageView;
        }
        editPageView() {
            return this._editPageView;
        }
        leafRowCount() {
            if (this._dataGroup) {
                return this._dataGroup.leafRowCount();
            }
            else {
                return this._data ? this._data.rowCount() : 0;
            }
        }
        checkedRowCount() {
            return this._flags.checkedCount();
        }
        /**
         * 지정돤 문자열(들)을 개행문자로 바꿔 표시한다.
         */
        lineSeparator() {
            return Array.isArray(this._lineSeparator) ? this._lineSeparator.slice(0) : this._lineSeparator;
        }
        setLineSeparator(value) {
            if (value !== this._lineSeparator) {
                this._lineSeparator = Array.isArray(value) ? value.slice(0) : value;
                this._lineSepReg = Utils.makeLineSeparator(this._lineSeparator);
                this.invalidateLayout();
            }
        }
        shapes() {
            return this._shapes;
        }
        lineSepReg() {
            return this._lineSepReg;
        }
        /**
         * SearchPanel, SearcBar 설정에 적용되는 기본 검색 옵션.
         * Api를 통해 panel이나 bar 호출 시 옵션을 다르게 지정할 수 있다.
         */
        searchOptions() {
            return this._searchOptions;
        }
        setSearchOptions(value) {
            this._searchOptions.assign(value);
        }
        searchResult() {
            return this._searchResult;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        useImage(src) {
            // img.onload = this._imageLoaded;
            // this._imageList.push(img);
            if (src && !this._imageList2[src]) {
                const img2 = new Image();
                img2.src = src;
                img2['_src_'] = src;
                img2.onload = this._imageLoaded;
                this._imageList2[src] = img2;
            }
        }
        getImageSize(src) {
            return this._imageSizes[src];
        }
        registerShape(shapeName, d, width, height) {
            this._shapes.registerCustom(shapeName, d, width, height);
        }
        registerShapes(shapes) {
            this._shapes.registerCustoms(shapes);
        }
        registerIconSet(name, icons) {
            if (name && icons) {
                if (!(icons instanceof DIconSet) && Utils.isObject(icons)) {
                    icons = new DIconSet(icons);
                }
                this._iconSets[name] = icons;
            }
            else if (name) {
                delete this._iconSets[name];
            }
        }
        getIcon(set, icon) {
            const iconSet = this._iconSets[set];
            if (iconSet) {
                return {
                    width: iconSet.width,
                    height: iconSet.height,
                    url: iconSet.getUrl(icon)
                };
            }
        }
        registerTemplate(name, template, shared) {
            return shared ? registerUserTemplate(null, UserTemplates, name, template) : registerUserTemplate(this, this._templates, name, template);
        }
        getStockTemplate(name) {
            return StockTemplates.get(name);
        }
        getUserTemplate(name) {
            return this._templates.get(name) || UserTemplates.get(name);
        }
        getTemplate(name) {
            return this._templates.get(name) || UserTemplates.get(name) || StockTemplates.get(name);
        }
        getRowTemplate(row) {
            const t = this._current.getRowTemplate(row);
            return (this._templates.get(t) || UserTemplates.get(t) || StockTemplates.get(t) || this._defRowTempl);
        }
        getDefaultRowTemplate() {
            const template = this._current.getDefaultRowTemplate();
            return (this._templates.get(template) || UserTemplates.get(template) || StockTemplates.get(template) || this._defRowTempl);
        }
        getRowInflater(row) {
            return this._layoutPool.getRowInflater(row);
        }
        getRowParams(row) {
            return this._current.getRowParams();
        }
        /**
         * 현재 rendering 중인 데이터행의 값들을 inflate하므로 inflater의 row는 getRowLayout() 호출 시 이미 지정된 상태이다.
         */
        inflateField(ps, field) {
            return this._layoutPool.inflate(ps, field);
        }
        getRowLayout(row) {
            return this._layoutPool.getRowLayout(null, row, this.isRowDetailed(row));
        }
        // SearchModel에서 사용한다.
        getSearchLayout(row) {
            // TODO: pre mode인 경우 row view에서 가져온다.
            return this._layoutPool.getRowLayout(null, row, this.isRowDetailed(row)).layout;
        }
        getSkeletonLayout() {
            return this._layoutPool.getRowLayout(Skeleton, 0, false);
        }
        searchIndexChanged(sr) {
            const f = sr.getCurrrentField();
            this.makeRowVisible(f.row);
            this.invalidateLayout();
        }
        getGroupItemLayout(item) {
            return this._layoutPool.getGroupItemLayout(item);
        }
        getRowStyle(row) {
            let levelDef;
            // TODO: row style callback
            let dynamic;
            return {
                itemDef: this._current.getRowStyle(),
                levelDef,
                dynamic
            };
        }
        borrowRenderer(renderer) {
            return this._rendererPool.borrow(renderer);
        }
        freeRenderer(renderer) {
            this._rendererPool.free(renderer);
        }
        getTextFormatter() {
            return this._runTextFormatter;
        }
        getBoolFormatter() {
            return this._runBoolFormatter;
        }
        getNumberFormatter() {
            return this._runNumberFormatter;
        }
        getDateFormatter() {
            return this._runDateFormatter;
        }
        getRowCount() {
            // TODO: 그룹모드
            return this._pageModel ? this._pageModel.rowCount() : this._data ? this._data.visRowCount() : 0;
        }
        getStartRow() {
            // TODO: 그룹모드
            return this._pageModel ? this._pageModel.startRow() : 0;
        }
        getEndRow() {
            // TODO: 그룹모드
            return this._pageModel ? this._pageModel.endRow() : this.data ? this._data.visRowCount() - 1 : 0;
        }
        getRowAt(index) {
            // TODO: 그룹모드
            return this._pageModel ? this._pageModel.getRow(index) : index;
        }
        clearGroupBy() {
            if (this.isGrouped()) {
                const model = this._groupModel;
                this._data && this._data.removeListener(model);
                model.removeListener(this);
                model.clear();
                model.destroy();
                this._groupModel = this._rowGroup = this._dataGroup = null;
                this.invalidateLayout();
            }
        }
        $_destroyGroupModel(gm) {
            if (gm) {
                this._data && this._data.removeListener(gm);
                gm.removeListener(this);
                gm.clear();
                gm.destroy();
                this._groupModel = null;
                (gm === this._rowGroup) && (this._rowGroup = null);
                (gm === this._dataGroup) && (this._dataGroup = null);
            }
        }
        $_destroyPageModel() {
            if (this._pageModel) {
                this._pageModel.removeListener(this);
                this._pageModel = this._pageModel.destroy();
            }
        }
        /**
         * {@link RowGroupModel 그룹 모델}을 생성 구축한다.
         * 데이터그룹은 그룹핑할 수 없다.
         */
        rowGroupBy(infos) {
            if (this.current().orientation() === DListOrientation.HORIZONTAL) {
                throwError(locale.canNotHorzGrouping);
            }
            if (!this._data) {
                throwError(locale.dataMustSet);
            }
            if (!infos || infos.length === 0) {
                throwError(locale.requireGroupingInfos);
            }
            if (this._data instanceof ListDataLinkView) {
                throwError(locale.canNotRowGrouping);
            }
            // 페이징 취소
            this.$_destroyPageModel();
            // 그룹핑 취소
            this.$_destroyGroupModel(this._dataGroup);
            // grouping
            let model = this._rowGroup;
            const oldGrouped = this.isRowGrouped();
            const current = this._current;
            for (let i = 0; i < infos.length; i++) {
                const s = infos[i];
                if (typeof s === 'string') {
                    infos[i] = { field: s };
                }
            }
            // 매개변수로 설정하지 않으면 options 설정을 따른다.
            infos.forEach((info) => {
                info.header = info.header || current.rowGroup().header();
                info.footer = info.footer || current.rowGroup().footer();
            });
            if (model) {
                model.clear();
            }
            else {
                model = this._rowGroup = new RowGroupModel();
                this._data && this._data.addListener(model);
                model.addListener(this);
            }
            model.build(this._data, this._current.rowGroup(), infos);
            if (model.levels() == 0) {
                this.$_destroyGroupModel(model);
            }
            else {
                this._groupModel = model;
            }
            if (this.isRowGrouped() !== oldGrouped) {
                this.invalidateLayout();
            }
        }
        /**
         * {@link DataGroupModel 데이터그룹 모델}을 생성 구축한다.
         * 데이터그룹 view가 이닌 데이터에 대해 데이터그룹핑할 수 없다.
         */
        dataGroupBy(infos) {
            if (this.current().orientation() === DListOrientation.HORIZONTAL) {
                throwError(locale.canNotHorzGrouping);
            }
            if (!this._data) {
                throwError(locale.dataMustSet);
            }
            if (!(this._data instanceof ListDataLinkView)) {
                throwError(locale.canNotDataGrouping);
            }
            this.$_destroyPageModel();
            this.$_destroyGroupModel(this._rowGroup);
            let model = this._dataGroup;
            const oldGrouped = this.isDataGrouped();
            if (model) {
                model.clear();
            }
            else {
                model = this._dataGroup = new DataGroupModel();
                this._data && this._data.addListener(model);
                model.addListener(this);
            }
            model.build(this._data, this._current.dataGroup(), infos);
            this._groupModel = model;
            if (this.isDataGrouped() !== oldGrouped) {
                this.invalidateLayout();
            }
        }
        isMaster(row) {
            return this._data.isMaster(row);
        }
        /**
         * 데이터행들을 페이지 단위로 표시한다.

        * @param options IListPageOptions 페이징 설정 옵션. null이면 paiging 취소.
         */
        setPaging(options) {
            this.$_destroyPageModel();
            if (options) {
                this._pageModel = new ListPageModel(this._rowGroup || this._dataGroup || this._data, options);
                this._pageModel.addListener(this);
                this.invalidateLayout();
            }
        }
        getPageRows(page) {
            return this._pageModel.getPageRows(page);
        }
        isSingleRow() {
            return this._singleRow;
        }
        getSummary(field) {
            return this._data && this._data.getSummary(field);
        }
        /**
         * @internal
         *
         * NOTE: 드래그 ui에서만 호출해야 한다.
         *
         * 픽셀 단위로 스크롤 시킨다.
         * delta 만큼 scollPos나 scrollOff가 증가(감소)한다.
         * {@link scrollByRow}가 true이면 스크롤 양에 상관없이 최초 표시행은 항상 처음부터 온전히 표시된다.
         * 즉, 행 단위로 스크롤되어 표시된다.
         * 또, 가상 모드로 구현 중인 경우(기본 설정),
         * 현재 표시되는 control 크기 이상으로 delta를 지정하는 경우, 실제 몇 행이 스크롤될 지 예측할 수 없다.
         * {@link scrollIndex} 속성으로 시작 행을 직접 지정할 수 있다.
         * 컨트롤 렌더링 전에 scrollIndex 속성이 새로 지정되면 이 함수 호출은 무시된다.
         * 즉, scrollIndex 설정과 이 함수 호출을 동시에 호출하지 않아야 한다.

         * 위(왼)쪽으로 드래그하면 delta > 0 (to Far), 아래(오른)쪽으로 드래그하면 delta < 0 (to Near).
         *
         * @param delta 픽셀 단위의 이동 크기. 소수점 이하를 버린 값으로 설정된다.
         */
        scrollBy(delta) {
            if (this._fullMode || this.isEmpty()) {
                return false;
            }
            delta = delta > 0 ? Math.ceil(delta) : Math.floor(delta);
            if (delta === 0) {
                return false;
            }
            const listView = this._listView;
            // 빈번한 invaliate() 실행을 막기 위해... (굳이 필요한가?)
            this.setLock();
            try {
                const r = listView.scrollBy(delta);
                if (r === true) {
                    this._scrollIndex = listView.scrollPos();
                    this._scrollOff = listView.scrollOff();
                    this._topRow = listView.topRow();
                }
                else if (r === 'near' || r == 'far') {
                }
                this.$_checkRowEnded();
                // 이렇게 리턴해야 양끝에서 fling 진행이 중단된다.
                return r === true;
            }
            finally {
                this.releaseLock(false);
                this._reqScrollIndex = this._reqScrollOff = NaN;
            }
        }
        // row 행이 마지막에 표시되도록 scroll. 0보다 작거나 NaN이면 attached row.
        scrollToEnd(row) {
            if (this.isEmpty() || row >= this._data.rowCount()) {
                return;
            }
            row = pickNum(row, -1);
            const listView = this._listView;
            this.setLock();
            try {
                listView.scrollToEnd(row);
                this._scrollIndex = listView.scrollPos();
                this._scrollOff = listView.scrollOff();
                this._topRow = listView.topRow();
                this.$_checkRowEnded();
            }
            finally {
                this.releaseLock(false);
                this._reqScrollIndex = this._reqScrollOff = NaN;
            }
        }
        findView(row, tag) {
            return this.bodyView().findSimpleLayoutView(row, tag);
        }
        findElement(row, id) {
            return this.bodyView().findDom(row, id);
        }
        isRowCheckable(row) {
            return this._flags.isCheckable(row);
        }
        /**
         * TODO: Data field외 동기화.
         */
        isRowChecked(row) {
            return this._flags.isChecked(row);
        }
        checkRow(row, checked) {
            return this._flags.setChecked(row, checked);
        }
        toggleChecked(row) {
            this._flags.setChecked(row, !this._flags.isChecked(row));
        }
        checkAll(checked) {
            return this._flags.checkAll(checked);
        }
        isRowSearched(row) {
            if (this._searchResult && !this._searchModel.filtering) {
                return this._flags.isSearched(row);
            }
        }
        isRowDetailed(row) {
            return this._flags.isDetailed(row);
        }
        setRowDetailed(row, detailed, exclusive, animate) {
            this._flags.setDetailed(row, detailed, exclusive);
            if (animate) {
                this.bodyView().$_setDetailingRow(row);
            }
        }
        $_getFlags() {
            return this._flags;
        }
        getSelection() {
            return this._selection;
        }
        clearSelection() {
            if (this._selection) {
                this._selection = null;
                this.onSelectionClear && this.onSelectionClear({ control: this.wrapperOrThis() });
                this.invalidateLayout();
                return true;
            }
        }
        selectRows(start, end) {
            const data = this._data;
            this.clearSelection();
            end = end === void 0 ? start : end;
            if (data && start >= 0 && start < data.rowCount() && end >= 0 && end < data.rowCount()) {
                this._selection = new DSelection(this.isGrouped() ? this._groupModel : data, start, end);
                this.onSelectionAdd && this.onSelectionAdd({ control: this.wrapperOrThis(), startRow: this._selection.start, endRow: this._selection.end });
                this.invalidateLayout();
            }
        }
        resizeSelection(newEnd) {
            if (this._selection) {
                const oldEnd = this._selection.end;
                if (this._selection.resize(newEnd)) {
                    this.onSelectionResize && this.onSelectionResize({ control: this.wrapperOrThis(), newEnd, oldEnd });
                    this.invalidateLayout();
                }
            }
        }
        swipeRow(row) {
            let canceled = false;
            if (this.onRowSwipe) {
                const args = {
                    control: this.wrapperOrThis(),
                    row
                };
                this.onRowSwipe(args);
                canceled = args.cancel;
            }
            if (!canceled) {
                switch (this._current.row().swipeAction()) {
                    case DListRowSwipeAction.COMMAND:
                        this.setCommandRow(row, true);
                        break;
                    case DListRowSwipeAction.PAGE:
                        break;
                    case DListRowSwipeAction.TAP:
                        break;
                    case DListRowSwipeAction.INFO:
                        break;
                    case DListRowSwipeAction.EDIT:
                        break;
                    case DListRowSwipeAction.ROW_BAR:
                        break;
                    case DListRowSwipeAction.EDIT_BAR:
                        break;
                }
            }
        }
        closePanel(animate) {
            this._listView.closePanel(animate);
        }
        showPanel(panel, animate) {
            this._listView.showPanel(panel, animate);
        }
        togglePanel(panel, animate) {
            this._listView.togglePanel(this.current().$_getPanel(panel), animate);
        }
        showFormPanel(actionTemplate, animate) {
            actionTemplate && this.current().formPanel()._setActionTemplate(actionTemplate);
            this.showPanel(this.current().formPanel(), animate);
        }
        showButtonPanel(animate) {
            this.showPanel(this.current().buttonPanel(), animate);
        }
        showSearchPanel(options, animate) {
            this.showPanel(this.current().searchPanel(), animate);
        }
        showFilterPanel(options, animate) {
            const p = this.current().filterPanel();
            p.setModel(options);
            this.showPanel(p, animate);
        }
        registerMenu(name, menu) {
            if (name) {
                if (Utils.isObject(menu)) {
                    this._menus[name] = menu;
                }
                else {
                    this.unregisterMenu(name);
                }
            }
        }
        unregisterMenu(name) {
            delete this._menus[name];
        }
        showMenu(menu, animate) {
            if (typeof menu === 'string') {
                menu = this._menus[menu];
            }
            else if (!menu) {
                menu = this._menus[this._current.menu()];
            }
            if (menu && menu.items && menu.items.length > 0) {
                this._listView.showMenu(new ListMenu(this, menu), animate);
            }
        }
        closeMenu(animate) {
            this._listView.hideMenu(animate);
        }
        toggleMenu(menu, animate) {
            if (!this._listView.hideMenu(animate)) {
                this.showMenu(menu, animate);
            }
        }
        clearSearch(sr) {
            if (this._searchResult && (!sr || (sr === this._searchResult))) {
                this._flags.clearSearched();
                this.invalidateLayout();
                this._searchResult = this._searchResult.destroy();
                if (this._searchFilter) {
                    const d = this._data;
                    if (d instanceof ListDataView) {
                        d.removeFilter(this._searchFilter, true);
                    }
                    // TODO: DataGroup
                    this._searchFilter = null;
                }
            }
        }
        /**
         * 검색.
         */
        search(options, key) {
            this.clearSearch(null);
            if (this._data) {
                const scope = this._groupModel || this._data;
                const sm = this._searchModel = new SearchModel(this);
                const sr = key ? sm.search(options, key, scope) : null;
                const flds = sr && sr.fields();
                if (flds && flds.length > 0) {
                    for (const f of flds) {
                        this._flags.setSearched(f.row, true);
                    }
                }
                this._searchResult = sr;
                if (sm.filtering) {
                    const d = this._data;
                    this._searchFilter = ListControl.SEARCH_FILTER + Utils.irandom(10000);
                    if (d instanceof ListDataView) {
                        if (flds) {
                            flds.forEach(f => f['drow'] = d['_rows'][f.row]);
                        }
                        const frows = this._flags.getSearchedRows();
                        d.setDataTags(frows, 1);
                        const filter = {
                            name: this._searchFilter,
                            filter: (row, values) => {
                                return d.isDataTag(row, 1);
                                //return this._flags.isSearched(row);
                            }
                        };
                        d.addFilter(filter, true, true);
                        if (flds) {
                            flds.forEach(f => f.row = f['drow'].newIdx);
                        }
                    }
                    // TODO: DataGroup
                }
                sr && sr.moveNext();
                this.invalidateLayout();
                return sr;
            }
            else {
                return null;
            }
        }
        isRowPageVisible() {
            return this._rowPageView && this._rowPageView.visible;
        }
        closeRowPage(commit, animate) {
            let iv = this._rowPageView;
            if (iv && iv.visible) {
                if (iv instanceof RowEditPageView && commit) {
                    try {
                        const values = iv.getValues(this._listView);
                        if (!iv.commit(values))
                            return;
                    }
                    catch (err) {
                        console.error(err);
                        alert(err.message || err);
                        return;
                    }
                }
                this._rowPageView = null;
                iv.hide(this._listView.getOffsetBounds(), animate);
            }
        }
        isInfoPageVisible() {
            return this._infoPageView && this._infoPageView.visible;
        }
        /**
         * 행 정보 view 표시.
         * row가 타당한 값이 아니면 실행되지 않는다.
         */
        showInfoPage(row, info, animate) {
            if (this._rowPageView) {
                console.warn('이미 Row Info View가 표시되고 있습니다.');
                return;
            }
            let iv = this._infoPageView;
            let dv;
            if (this._data instanceof ListDataLinkView) {
                const r = this._data.getSourceRow(row);
                dv = r.dv;
                row = r.row;
            }
            else {
                dv = this._data;
            }
            if (dv && row >= 0 && row < dv.rowCount()) {
                const opts = this._current.infoPage();
                if (!iv) {
                    iv = this._infoPageView = new RowInfoPageView(this.doc(), opts);
                    this.addElement(iv);
                }
                else {
                    iv.setModel(opts);
                }
                opts.setModel(info);
                iv.setRow(dv, row);
                iv.show(this._listView, this._listView.getOffsetBounds(), animate);
                this._rowPageView = iv;
            }
        }
        isEditPageVisible() {
            return this._editPageView && this._editPageView.visible;
        }
        /**
         * 행 편집 view 표시.
         * row가 0보다 작으면 행 추가, row가 타당한 행 번호면 행 편집 view가 표시된다.
         * 아니면, 아무것도 실행하지 않는다.
         */
        showEditPage(row, model, animate) {
            if (this._rowPageView) {
                console.warn('이미 Row Edit View가 표시되고 있습니다.');
                return;
            }
            let ev = this._editPageView;
            let dv;
            if (this._data instanceof ListDataLinkView) {
                const r = this._data.getSourceRow(row);
                dv = r.dv;
                row = r.row;
            }
            else {
                dv = this._data;
            }
            if (dv && row < dv.rowCount()) {
                const opts = row >= 0 ? this._current.editPage() : this._current.addPage();
                if (!ev) {
                    ev = this._editPageView = new RowEditPageView(this.doc(), opts);
                    this.addElement(ev);
                }
                else {
                    ev.setModel(opts);
                }
                opts.setModel(model);
                ev.setRow(dv, row);
                ev.show(this._listView, this._listView.getOffsetBounds(), animate);
                this._rowPageView = ev;
            }
        }
        makeRowVisible(row) {
            const dv = this._data;
            if (dv && row >= 0 && row < dv.rowCount()) {
                const t = this.bodyView().makeRowVisible(row);
                if (t && (t.pos !== this._scrollIndex || t.off !== this._scrollOff)) {
                    this.setScrollIndex(t.pos, t.off);
                    return true;
                }
            }
        }
        makeGroupItemVisible(item) {
            if (item instanceof GroupItem) {
                const t = this._listView.makeItemVisible(item);
                if (t) {
                    this.setScrollIndex(t.pos, t.off);
                    return true;
                }
            }
        }
        setFocusedRow(row) {
            const old = this._focusedRow;
            const dv = this._data;
            if (dv && row >= 0 && row < dv.rowCount()) {
                if (old !== row) {
                    this._focusedRow = row;
                }
            }
            else if (old >= 0) {
                this._focusedRow = -1;
            }
            if (this._focusedRow !== old) {
                this.bodyView().setFocusedRow(this._focusedRow);
                this._listView.focusedRowChanged(this._focusedRow, old);
                if (this.onFocusedRowChange) {
                    const args = {
                        control: this.wrapperOrThis(),
                        row: this._focusedRow,
                        oldRow: old
                    };
                    this.onFocusedRowChange(args);
                }
                // this.invalidateLayout();
            }
        }
        getEditValues() {
            if (this._rowPageView === this._editPageView) {
                return this._editPageView.getValues(this._listView);
            }
        }
        // IListViewOwner
        addTooltipView(view) {
            this._listView.addTooltipView(view);
        }
        // IListViewOwner
        removeTooltipView(view) {
            this._listView.removeTooltipView(view);
        }
        showToast(toast) {
            if (typeof toast === 'string') {
                toast = { message: toast };
            }
            toast && (toast.message || toast.html) && this._listView.showToast(toast);
        }
        getDataGroupOfRow(row, visibleOnly) {
            const dg = this._dataGroup;
            return dg && dg.itemOfRow(row, visibleOnly).group;
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _prepareRenderers(dom) {
            const childs = dom.children;
            const templs = this._htmlTempls = {};
            for (let i = childs.length - 1; i >= 0; i--) {
                const elt = childs[i]; //.cloneNode(true);    
                dom.removeChild(elt);
                if (elt instanceof HTMLElement && elt.id) {
                    templs[elt.id] = elt;
                }
            }
        }
        invalidateLayout(force = false) {
            this.invalidate(force);
            this._layoutNeeded = true;
        }
        _windowResized() {
            this.invalidateLayout();
        }
        _creatDefaultTool() {
            return new DefaultTool(this);
        }
        _doInitModel() {
            // options
            this._defaults = new ListOptions(this, this, null, false).load(default_options);
            this._current = this._portrait = new ListOptions(this, this, this._defaults, false);
            this._landscape = new ListOptions(this, this, this._defaults, true);
            // resources
            this._layoutPool = new LayoutPool(this);
            this._iconSets = {};
            this._shapes = new Shapes(this);
            this._rendererPool = new RendererImplPool();
            this._defRowTempl = new DefaultTemplate(this);
            // row commands
            this._rowCommands = new RowCommandRunner();
        }
        _doInitView(doc) {
            this._current = this.orientation() === DScreenOrientation.LANDSCAPE ? this._landscape : this._portrait;
        }
        _doOrientationChanged(orientation) {
            this.closePanel(false);
            this._current = orientation === DScreenOrientation.LANDSCAPE ? this._landscape : this._portrait;
            this._orientationChanged && this._orientationChanged(orientation);
            this.invalidateLayout();
        }
        _doControlObjectChanged(obj, tag) {
            this.invalidateLayout();
        }
        _doBeforeRender() {
            // this.$_clearUsedImages();
            if (this._layoutNeeded) {
                this._current.prepareRender();
                this._defRowTempl.clear();
                this._layoutPool.prepareRender();
            }
            this._singleRow = this._current.singleRow().visible();
            const oldView = this._listView;
            if (this.isDataLoading() && this.skeletonVisible) {
                if (!this._skeletonListView) {
                    this._skeletonListView = new SkeletonListView(this.doc(), this);
                }
                this._listView = this._skeletonListView;
            }
            else if (this._singleRow) {
                this._listView = this._defaultListView;
            }
            else if (this.isRowGrouped()) {
                if (!this._groupedListView) {
                    this._groupedListView = new GroupedListView(this.doc(), this);
                }
                this._listView = this._groupedListView;
            }
            else if (this.isDataGrouped()) {
                if (!this._dataListView) {
                    this._dataListView = new DataGrouedListView(this.doc(), this);
                }
                this._listView = this._dataListView;
            }
            else {
                this._listView = this._defaultListView;
            }
            if (oldView && this._listView !== oldView) {
                // oldView.visible = false;
                this.removeElement(oldView);
            }
            this.addElement(this._listView);
            this._listView.visible = true;
            if (this._runTextFormatter === void 0) {
                this._runTextFormatter = this._textFormatter || getTextFormatter(this._textFormat);
            }
            if (this._runBoolFormatter === void 0) {
                this._runBoolFormatter = this._boolFormatter || getBoolFormatter(this._boolFormat);
            }
            if (this._runNumberFormatter === void 0) {
                this._runNumberFormatter = this._numberFormatter || getNumberFormatter(this._numberFormat);
            }
            if (this._runDateFormatter === void 0) {
                this._runDateFormatter = this._dateFormatter || getDateFormatter(this._dateFormat);
            }
            const rowBorder = this._current.row().borderLine();
            this.rowBorder = {
                style: rowBorder.style() || this.getCssVar('--dl-row-border-line'),
                masterStyle: rowBorder.masterStyle() || this.getCssVar('--dl-master-border-line'),
                skipLast: rowBorder.skipLast(),
                skipGroupLast: rowBorder.skipGroupLast(),
                leafOnly: rowBorder.leafOnly()
            };
        }
        _doRender(bounds) {
            if (this._rowPageView) {
                this.$_renderRowList(bounds);
            }
            else if (this._fullMode) {
                this.$_renderFull(bounds);
            }
            else {
                this.$_renderDefault(bounds);
            }
        }
        $_renderRowList(bounds) {
        }
        $_renderFull(bounds) {
            const measure = (doc, w, h) => {
                const info = {
                    scrollPos: 0,
                    scrollOff: 0
                };
                this._listView.measure(doc, info, w, h);
            };
            const render = (doc) => {
                const listView = this._listView;
                listView.resizeByMeasure().move(0, 0);
                listView.render(doc);
            };
            try {
                const doc = this.doc();
                const t = Utils.watch();
                measure(doc, bounds.width, Number.MAX_SAFE_INTEGER); // bounds.height);
                DLog.log('ListControl measured in ' + t.elapsedText(true));
                render(doc);
                this._setSize(NaN, this._listView.height);
                DLog.log('ListControl rendered in ' + t.elapsedText());
            }
            finally {
                this._layoutNeeded = false;
            }
        }
        $_renderDefault(bounds) {
            const measure = (doc, w, h) => {
                let pos = this._scrollIndex;
                let off = this._scrollOff;
                if (!isNaN(this._reqScrollIndex)) {
                    pos = this._reqScrollIndex;
                    off = pickNum(this._reqScrollOff, 0);
                }
                const info = {
                    scrollPos: pos,
                    scrollOff: off
                };
                this._listView.measure(doc, info, w, h);
            };
            const render = (doc) => {
                const listView = this._listView;
                const oldTop = this._scrollIndex;
                let x = 0;
                let y = 0;
                listView.resizeByMeasure().move(x, y);
                listView.render(doc);
                this._scrollIndex = listView.scrollPos();
                this._scrollOff = listView.scrollOff();
                this._topRow = listView.topRow();
                if (this._scrollIndex != oldTop) {
                    this.onScroll && this.onScroll({ control: this, top: this._scrollIndex });
                }
            };
            try {
                const doc = this.doc();
                const t1 = +new Date();
                measure(doc, bounds.width, bounds.height);
                const t2 = +new Date();
                DLog.log('ListControl measured in ' + (t2 - t1) + 'ms.');
                render(doc);
                DLog.log('ListControl rendered in ' + (+new Date() - t2) + 'ms.');
                // 마지막 데이터행이 새로 드러나게 됐는 지 확인.
                this.$_checkRowEnded();
            }
            finally {
                this._layoutNeeded = false;
                this._reqScrollIndex = this._reqScrollOff = NaN;
            }
        }
        _doAfterRender() {
            this._dataChanged = false;
            this.$_clearUsedImages();
            this._current.unprepareRender();
        }
        //-------------------------------------------------------------------------
        // internal members
        //-------------------------------------------------------------------------
        $_rowTouched(row) {
            this._current.row().touchEffect() && this.bodyView().setTouchedRow(row);
        }
        $_performRowClick(row, action) {
            switch (action) {
                case 'select': //DRowClickAction.SELECT:
                    this.selectRows(row);
                    break;
                // case DRowClickAction.FOUCS:
                //     this._rowFocusable && this.setFocusedRow(row);
                //     break;
                case DListRowClickAction.CHECK:
                    if (this.isRowCheckable(row)) {
                        this.checkRow(row, !this.isRowChecked(row));
                    }
                    break;
                case DListRowClickAction.COMMAND:
                    break;
                case DListRowClickAction.EXPAND:
                    if (this.isDataGrouped()) {
                        const dg = this._dataGroup;
                        dg && dg.toggle(dg.itemOfRow(row, true).group, false);
                    }
                    break;
                case DListRowClickAction.DETAIL:
                    this.setRowDetailed(row, !this.isRowDetailed(row), false, true);
                    break;
                case DListRowClickAction.DETAILEX:
                    this.setRowDetailed(row, !this.isRowDetailed(row), true, true);
                    break;
                case DListRowClickAction.LINK:
                    const link = this._current.row().link();
                    const url = link.getLink(this.wrapperOrThis(), this._data, row);
                    if (url) {
                        if (link.target()) {
                            window.open(url, link.target());
                        }
                        else {
                            location.href = url;
                        }
                    }
                    break;
                case DListRowClickAction.INFO:
                    this.showInfoPage(row, null, true);
                    break;
                case DListRowClickAction.EDIT:
                    this.showEditPage(row, null, true);
                    break;
                case DListRowClickAction.MOVE:
                    this.activeTool().requestDrag(new MoveRowRequest(row));
                    break;
            }
        }
        $_rowClicked(row) {
            if (row >= 0) {
                const options = this._current;
                if (this.fitRowWhenClick) {
                    if (this.makeRowVisible(row)) ;
                }
                if (options.row().focusable()) {
                    this.setFocusedRow(row);
                }
                if (this.onRowClick) {
                    const args = this._rowClickArgs;
                    args.control = this.wrapperOrThis();
                    args.row = row;
                    args.cancel = false;
                    this.onRowClick(args);
                    if (args.cancel) {
                        return;
                    }
                }
                let action = options.row().clickAction();
                if (this.isDataGrouped()) {
                    if (this._data.isMaster(row)) {
                        const ma = options.row().masterClickAction();
                        if (ma) {
                            action = ma;
                        }
                    }
                }
                this.$_performRowClick(row, action);
            }
        }
        $_rowLongPressed(row) {
            if (row >= 0) {
                const options = this._current;
                if (this.onRowLongPress) {
                    const args = this._rowClickArgs;
                    args.control = this.wrapperOrThis();
                    args.row = row;
                    args.cancel = false;
                    this.onRowLongPress(args);
                    if (args.cancel) {
                        return;
                    }
                }
                let action = options.row().pressAction();
                if (this.isDataGrouped()) {
                    if (this._data.isMaster(row)) {
                        const ma = options.row().masterPressAction();
                        if (ma) {
                            action = ma;
                        }
                    }
                }
                this.$_performRowClick(row, action);
            }
        }
        $_groupItemClicked(item) {
            if (item instanceof GroupRow) {
                this.$_rowClicked(item.row());
            }
            else {
                if (this.fitRowWhenClick) {
                    if (this.makeGroupItemVisible(item)) ;
                }
                this._listView.clickItem(item);
            }
        }
        $_clearUsedImages() {
            const images = this._imageList;
            for (let i = images.length - 1; i >= 0; i--) {
                const img = images[i];
                if (!img.parentElement || img.complete) {
                    img.onload = null;
                    images.splice(i, 1);
                }
            }
            const map = this._imageList2;
            for (const url in map) {
                const img = map[url];
                if (img.complete) {
                    img.onload = null;
                    delete map[url];
                    if (_isSafari) {
                        delete this._imageSizes[url];
                    }
                }
            }
        }
        $_checkRowEnded() {
            // 마지막 데이터행이 새로 드러나게 되었다면...
            const lastRevealed = this.bodyView().isRowEnded();
            if (lastRevealed && !this._lastRowRevealed) {
                setTimeout(() => {
                    this.onLastRowRevealed && this.onLastRowRevealed({ control: this.wrapperOrThis() });
                }, 0);
            }
            this._lastRowRevealed = lastRevealed;
        }
    }
    //-------------------------------------------------------------------------
    // consts
    //-------------------------------------------------------------------------
    ListControl.CLASS_NAME = 'dlist-control';
    ListControl.SEARCH_FILTER = '@_dlist_search_filter_';
    ListControl.NUMBER_FORMAT = '';
    ListControl.BOOLEAN_FORMAT = 'False:True';
    ListControl.DATE_FORMAT = 'yyyy.MM.dd HH:mm';
    let $_def_template_id = 1;
    /**
     * @internal
     *
     * 리스트컨트롤이 내부적으로 기본 생성하는 템플릿.
     */
    class DefaultTemplate {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(control) {
            //-------------------------------------------------------------------------
            // fields
            //-------------------------------------------------------------------------
            this.id = $_def_template_id++;
            this.detailId = $_def_template_id++;
            this.collapsedId = $_def_template_id++;
            this._rowStyle = new DListRowStyles();
            this._layouts = {};
            this._control = control;
        }
        //-------------------------------------------------------------------------
        // IListTemplate
        //-------------------------------------------------------------------------
        get rowProps() {
            return;
        }
        get rowStyle() {
            return this._rowStyle;
        }
        get layout() {
            function create(dv) {
                const fields = (dv && dv['fields']()) || [];
                const children = [];
                const template = { layout: VLinearLayout.TYPE, children };
                for (let f of fields) {
                    children.push({
                        field: f.name
                    });
                }
                // TODO: alternate 스타일로 처리..
                template.style = { backgroundColor: '#efefef' };
                return new DTemplateLayout(null, template, null);
            }
            const data = this._control.data();
            if (data instanceof ListDataLinkView) {
                const dv = data.getSource(this.target);
                let layout = this._layouts[dv.hash];
                if (!layout) {
                    layout = create(dv);
                    this._layouts[dv.hash] = layout;
                }
                return layout;
            }
            else {
                if (!this._layout) {
                    this._layout = create(data);
                }
                return this._layout;
            }
        }
        get detailed() {
            return null;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        clear() {
            this._layout = null;
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @internal
     */
    class DListRowCellObject extends DWrapper {
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * 리스트 컨트롤
         */
        get control() {
            return this.$_c.wrapper();
        }
        get cellStyle() {
            return this.$_c.cellStyle();
        }
        set cellStyle(value) {
            this.$_c.setCellStyle(value);
        }
        get cellStyleCallback() {
            return this.$_c.cellStyleCallback();
        }
        set cellStyleCallback(value) {
            this.$_c.setCellStyleCallback(value);
        }
        get style() {
            return this.$_c.style();
        }
        set style(value) {
            this.$_c.setStyle(value);
        }
        get styleCallback() {
            return this.$_c.styleCallback();
        }
        set styleCallback(value) {
            this.$_c.setStyleCallback(value);
        }
    }
    /**
     * 행 번호를 표시하는 {@link concepts.row_bar Row Bar 셀} 모델.
     * <br>
     */
    class DListRowOrder extends DListRowCellObject {
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * 표시할 값의 {@link DListRowOrderDisplay 종류}.
         *
         * @see prefix
         * @see suffix
         *
         * @default DListRowOrderDisplay.ROW
         */
        get display() {
            return this.$_c.display();
        }
        set display(value) {
            this.$_c.setDisplay(value);
        }
        /**
         * 0부터 시작하는 실제 데이터행 번호에 추가하는 값.
         * 예를 들어, 1로 설정하면 첫번째 번호가 1이 된다.
         *
         * @default 1
         */
        get rowOffset() {
            return this.$_c.rowOffset();
        }
        set rowOffset(value) {
            this.$_c.setRowOffset(value);
        }
        /**
         * 픽셀 단위로 지정하는 셀 최소 너비.
         *
         * @default 20
         */
        get minWidth() {
            return this.$_c.minWidth();
        }
        set minWidth(value) {
            this.$_c.setMinWidth(value);
        }
        /**
         * true로 지정하면 행 번호 너비와 관계없이 모든 행의 row bar 너비가 동일하게 표시된다.
         *
         * @defaul true
         */
        get fitWidth() {
            return this.$_c.fitWidth();
        }
        set fitWidth(value) {
            this.$_c.setFitWidth(value);
        }
        /**
         * 접두어.
         * 행 번호 앞 쪽에 추가되는 문자열.
         */
        get prefix() {
            return this.$_c.prefix();
        }
        set prefix(value) {
            this.$_c.setPrefix(value);
        }
        /**
         * 접미어.
         * 행 번호 뒤 쪽에 추가되는 문자열.
         */
        get suffix() {
            return this.$_c.suffix();
        }
        set suffix(value) {
            this.$_c.setSuffix(value);
        }
    }
    /**
     * {@link concepts.row_bar Row Bar}에 표시되는 체크 상자 model.
     * <br>
     * {@link DListRowBar.check} 속성으로 사용된다.
     *
     * @see DListRowBar.display
     */
    class DListRowCheckBox extends DListRowCellObject {
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * 체크 상자 크기를 픽셀 단위로 지정한다.
         * <br>
         *
         * @default 26 픽셀.
         */
        get size() {
            return this.$_c.size();
        }
        set size(value) {
            this.$_c.setSize(value);
        }
        /**
         * master행에 표시할 것인가?
         * <br>
         */
        get masterVisible() {
            return this.$_c.masterVisible();
        }
        set masterVisible(value) {
            this.$_c.setMasterVisible(value);
        }
        /**
         * check 상자들을 드래그할 때 개별 체크 상자들에 적용할 방식.
         * <br>
         */
        get dragMode() {
            return this.$_c.dragMode();
        }
        set dragMode(value) {
            this.$_c.setDragMode(value);
        }
    }
    /**
     * 데이터 행의 {@link concepts.row_bar Row Bar} 나
     * {@link concepts.edit_bar Edit Bar} 영역에 표시되는 버튼 설정 정보 모델 base.
     * <br>
     *
     * @see DListRowBar.button
     * @see DListEditBar.custom
     */
    class DListRowButton extends DListRowCellObject {
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * 버튼 label.
         * <br>
         */
        get label() {
            return this.$_c.label();
        }
        set label(value) {
            this.$_c.setLabel(value);
        }
        /**
         * 이미지의 alt,
         * 혹은 text가 불분명한 button의 aria-label 등으로 사용.
         * <br>
         */
        get hint() {
            return this.$_c.hint();
        }
        set hint(value) {
            this.$_c.setHint(value);
        }
        /**
         * 버튼 image url.
         */
        get imageUrl() {
            return this.$_c.imageUrl();
        }
        set imageUrl(value) {
            this.$_c.setImageUrl(value);
        }
        /**
         * 버튼 너비.
         * <br>
         * 지정하지 않거나 NaN이면 계산된 너비로 표시된다.
         */
        get width() {
            return this.$_c.width();
        }
        set width(value) {
            this.$_c.setWidth(value);
        }
        /**
         * 버튼 높이.
         * <br>
         * 지정하지 않거나 NaN이면 계산된 높이로 표시된다.
         */
        get height() {
            return this.$_c.height();
        }
        set height(value) {
            this.$_c.setHeight(value);
        }
        /**
         * 버튼 종류별로 설정되는 기본 class 외에 추가될 css class 이름.
         * <br>
         */
        get className() {
            return this.$_c.className();
        }
        set className(value) {
            this.$_c.setClassName(value);
        }
        /**
         * 이 속성이 설정되면 {@link label} 대신,
         * {@link IListRowButtonLetter.letter 한 글자}를 표시하는 단순 버튼으로 표시된다.
         * <br>
         * 또, {@link IListRowButtonLetter.transparent}에 따라 다른 style이 적용된다.
         * ```
         * // transaprent가 true이면
         * .dlist-row-button[data-type='letter-transparent']
         * // false이면
         * .dlist-row-button[data-type='letter']
         * ```
         */
        get letter() {
            return this.$_c.letter();
        }
        set letter(value) {
            this.$_c.setLetter(value);
        }
        /**
         * 버튼이 클릭되면 호출된다.
         * <br>
         */
        get onClick() {
            return this.$_c.onClick();
        }
        set onClick(value) {
            this.$_c.setOnClick(value);
        }
    }
    /**
     * 데이터 행의 rowBar 나 editBar 영역에 표시되는 이미지 설정 정보 모델.
     * <br>
     *
     * @see DListRowBar
     * @see concepts.row_bar RowBar 개요
     */
    class DListRowImage extends DListRowCellObject {
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * image url.
         */
        get imageUrl() {
            return this.$_c.imageUrl();
        }
        set imageUrl(value) {
            this.$_c.setImageUrl(value);
        }
        /**
         * 이미지 표시 너비.
         */
        get width() {
            return this.$_c.width();
        }
        set width(value) {
            this.$_c.setWidth(value);
        }
        /**
         * 이미지 표시 높이.
         */
        get height() {
            return this.$_c.height();
        }
        set height(value) {
            this.$_c.setHeight(value);
        }
        /**
         * true로 설정하면 이미지 클릭 시 {@link onClick} 이벤트 발생.
         *
         * @default false
         */
        get clickable() {
            return this.$_c.clickable();
        }
        set clickable(value) {
            this.$_c.setClickable(value);
        }
        /**
         * {@link clickable}이 true이면 이미지 클릭 시 호출된다.
         */
        get onClick() {
            return this.$_c.onClick();
        }
        set onClick(value) {
            this.$_c.setOnClick(value);
        }
        /**
         * 동적 url callback
         */
        get urlCallback() {
            return this.$_c.urlCallback();
        }
        set urlCallback(value) {
            this.$_c.setUrlCallback(value);
        }
    }
    /**
     * 데이터 행의 rowBar 나 editBar 영역에 표시되는 {@link concepts.shapes shape} 설정 정보 모델.
     * <br>
     * {@link DListRowBar.shape} 속성 객체로 사용됩니다.
     *
     * ```
     *  list.setConfig({
     *      options: {
     *          rowBar: {
     *              visible: true,
     *              display: 'shape',
     *              shape: {
     *                  shape: 'apple',
     *                  size: 24,
     *                  clickable: true,
     *                  onClick: args => {
     *                      alert(arg.row + ', clicked');
     *                  }
     *              }
     *          }
     *      }
     *  });
     * ```
     *
     * @see concepts.shapes Shape 개요
     * @see concepts.row_bar Row Bar 개요
     * @see DListRowBar
     */
    class DListRowShape extends DListRowCellObject {
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * 픽셀 단위 shape 크기.
         * <br>
         *
         * @default 20 pixel
         */
        get size() {
            return this.$_c.size();
        }
        set size(value) {
            this.$_c.setSize(value);
        }
        /**
         * 컨트롤에 등록된 shape 이름.
         * <br>
         * {@link DListControl.registerShape}나 {@link DListControl.registerShapes}로 등록한다.
         * 컨트롤에 미리 등록된 shape들의 이름은 '**@**'로 시작한다.
         * 또, {@link shapeCallback}을 지정해서 실행 시간에 동적으로 shape를 표시할 수 있다.
         *
         * @default '@star'
         */
        get shape() {
            return this.$_c.shape();
        }
        set shape(value) {
            this.$_c.setShape(value);
        }
        /**
         * true로 지정하면 실행 시간 사용자가 shape를 tap할 때,
         * {@link onClick} 콜백이 호출된다.
         * <br>
         */
        get clickable() {
            return this.$_c.clickable();
        }
        set clickable(value) {
            this.$_c.setClickable(value);
        }
        /**
         * 실행 시간에 동적으로 shape 이름을 리턴하는 콜백.
         * <br>
         * 콜백에서 shape 이름을 리턴하지 않으면 {@link shape}로 지정한 기본 shape가 표시된다.
         */
        get shapeCallback() {
            return this.$_c.shapeCallback();
        }
        set shapeCallback(value) {
            this.$_c.setShapeCallback(value);
        }
        /**
         * {@link clickable}이 true일 때, shape를 tap하면 호출되는 콜백.
         * <br>
         */
        get onClick() {
            return this.$_c.onClick();
        }
        set onClick(value) {
            this.$_c.setOnClick(value);
        }
    }
    /**
     * 데이터 행의 rowBar 나 editBar 영역에 표시되는 letter 설정 정보 모델.
     * <br>
     *
     * @see DListRowBar
     */
    class DListRowLetter extends DListRowCellObject {
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * letter
         */
        get letter() {
            return this.$_c.letter();
        }
        set letter(value) {
            this.$_c.setLetter(value);
        }
    }
    /**
     * 그룹 expander 설정 모델.
     * <br>
     * {@link DListRowGroupOptions.expander}나 {@link DListDataGroupOptions.expander} 속성으로 사용된다.
     *
     * @see concepts.row_grouping 행 그룹핑 개요
     * @see concepts.data_grouping 데이터 그룹핑 개요
     */
    class DListRowExpander extends DListRowButton {
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * 표시 위치.
         * <br>
         *
         * @default DRowExpanderPosition.FOOT
         */
        get position() {
            return this.$_c.position();
        }
        set position(value) {
            this.$_c.setPosition(value);
        }
    }
    /**
     * 데이터행 이동 핸들.
     * <br>
     *
     * @see concepts.row_bar Row Bar 개요
     * @see concepts.edit_bar Edit Bar 개요
     */
    class DListRowMover extends DListRowCellObject {
    }

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * {@link DListScrollIndicator 스크롤 인디케이너}나 {@link DListCommandBox 커맨드 상자} 등
     * 리스트 컨트롤 구성 요소들의 base 모델.
     *
     * @see DListControl
     */
    class DListControlObject extends DWrapper {
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * 표시 여부.
         * false로 지정하면 화면에 표시되지 않는다.
         *
         * @default true
         */
        get visible() {
            return this['$_c'].visible();
        }
        set visible(value) {
            this['$_c'].setVisible(value);
        }
        /**
         * 스타일셋 혹은 className.
         */
        get style() {
            return this.$_c.style();
        }
        set style(value) {
            this.$_c.setStyle(value);
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doAssignProps(source) {
            if (typeof source === 'boolean') {
                this.visible = source;
                return true;
            }
        }
    }
    /**
     * {@link DListRowBar RowBar}나 {@link DListEditBar EditBar}의 base 모델.
     *
     * @see DListControl
     * @see concepts.row_bar RowBar 개요
     * @see concepts.edit_bar EditBar 개요
     */
    class DListControlBar extends DListControlObject {
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * 버튼 등의 표시 방식.
         */
        get mode() {
            return this.$_c.mode();
        }
        set mode(value) {
            this.$_c.setMode(value);
        }
        /**
         * 컨트롤 bar가 표시될 위치.
         *
         * @default {@link DListControlBarPosition.NEAR}
         */
        get position() {
            return this.$_c.position();
        }
        set position(value) {
            this.$_c.setPosition(value);
        }
        /**
         * 이 속성을 NaN이 아닌 타당한 값으로 지정하면 내용과 상관없이 이 속성값의 폭으로 표시된다.
         * <br>
         * //단, 타당한 값으로 지정된 {@link minWidth}와 {@link maxWidth} 사이의 값으로 조정된다.
         */
        get size() {
            return this.$_c.size();
        }
        set size(value) {
            this.$_c.setSize(value);
        }
        /**
         * Bar와 왼쪽 영역 사이의 간격.
         *
         * @default 6 pixel.
         */
        get gapLeft() {
            return this.$_c.gapLeft();
        }
        set gapLeft(value) {
            this.$_c.setGapLeft(value);
        }
        /**
         * Bar와 오른쪽 영역 사이의 간격.
         *
         * @default 6 pixel.
         */
        get gapRight() {
            return this.$_c.gapRight();
        }
        set gapRight(value) {
            this.$_c.setGapRight(value);
        }
        /**
         * Bar와 위쪽 영역 사이의 간격.
         *
         * @default 0 pixel.
         */
        get gapTop() {
            return this.$_c.gapTop();
        }
        set gapTop(value) {
            this.$_c.setGapTop(value);
        }
        /**
         * Bar와 아래쪽 영역 사이의 간격.
         *
         * @default 6 pixel.
         */
        get gapBottom() {
            return this.$_c.gapBottom();
        }
        set gapBottom(value) {
            this.$_c.setGapBottom(value);
        }
    }
    /**
     * {@link concepts.row_bar Row Bar} 설정 모델.
     * <br>
     * 데이터행의 왼쪽 혹은 (수평 모드일 때)상단에 행 번호, 상태 및 기타 UI 등을 표시하는
     * 영역에 대한 속성들을 포함한다.
     * {@link DListOptions.rowBar} 속성으로 설정한다.
     *
     * ```
     * list.setConfig({
     *      options: {
     *          rowBar: {
     *              visible: true,
     *              display: 'shape',
     *              ...
     *          }
     *      }
     * });
     * ```
     *
     * ```
     * list.setConfig({
     *      options: {
     *          rowBar: false  // boolean 값으로 지정하면 visible 속성으로 설정된다.
     *      }
     * });
     * ```
     *
     * @see concepts.row_bar Row Bar 개요
     * @see concepts.shape Shape 개요
     * @see DListEditBar
     * @see concepts.edit_bar Edit Bar 개요
     */
    class DListRowBar extends DListControlBar {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(bar) {
            super();
            bar.setWrapper(this);
            this._order = bar.order().createWrapper(DListRowOrder);
            this._check = bar.check().createWrapper(DListRowCheckBox);
            this._shape = bar.shape().createWrapper(DListRowShape);
            this._letter = bar.letter().createWrapper(DListRowLetter);
            this._image = bar.image().createWrapper(DListRowImage);
            this._button = bar.button().createWrapper(DListRowButton);
            this._move = bar.move().createWrapper(DListRowMover);
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * Bar에 표시할 {@link DListRowBarDisplay 내용}.
         *
         * @default DListRowBarDisplay.ORDER
         */
        get display() {
            return this.$_c.display();
        }
        set display(value) {
            this.$_c.setDisplay(value);
        }
        // /**
        //  * Bar의 폭. 리스트 컨트롤이 수직 모드이면 바의 너비, 수평 모드이면 바의 높이.
        //  * 이 속성을 NaN이 아닌 타당한 값으로 지정하면 내용과 상관없이 이 속성값의 폭으로 표시된다.
        //  * 
        //  * @default undefined
        //  */
        // get size(): number {
        //     return this.$_c.size();
        // }
        // set size(value: number) {
        //     this.$_c.setSize(value);
        // }
        // /**
        //  * Bar의 최소 폭 크기.
        //  * 타당한 값으로 지정되면 내용이나 width, maxWidth 값과 관계없이 
        //  * 항상 이 속성값 이상의 폭으로 표시된다.
        //  * 
        //  * @default 20
        //  */
        // get minWidth(): number {
        //     return this.$_c.minWidth();
        // }
        // set minWidth(value: number) {
        //     this.$_c.setMinWidth(value);
        // }
        // /**
        //  * Bar의 최대 폭 크기.
        //  * 타당한 값으로 지정되면 내용이나 width 값과 관계없이 
        //  * 항상 이 속성값 이하의 폭으로 표시된다.
        //  * 
        //  * @default undefined
        //  */
        // get maxWidth(): number {
        //     return this.$_c.maxWidth();
        // }
        // set maxWidth(value: number) {
        //     this.$_c.setMaxWidth(value);
        // }
        /**
         * {@link DListRowBarDisplay.ORDER 행 번호} 셀 설정 모델.
         * <br>
         */
        get order() {
            return this._order;
        }
        /**
         * {@link DListRowBarDisplay.CHECK Check} 셀 설정 모델.
         * <br>
         */
        get check() {
            return this._check;
        }
        /**
         * {@link DListRowBarDisplay.SHAPE Shape} 셀 설정 모델.
         * <br>
         */
        get shape() {
            return this._shape;
        }
        /**
         * {@link DListRowBarDisplay.LETTER 문자} 셀 설정 모델.
         * <br>
         */
        get letter() {
            return this._letter;
        }
        /**
         * {@link DListRowBarDisplay.IMAGE 이미지} 셀 설정 모델.
         * <br>
         */
        get image() {
            return this._image;
        }
        /**
         * {@link DListRowBarDisplay.BUTTON 버튼} 셀 설정 모델.
         * <br>
         */
        get button() {
            return this._button;
        }
        /**
         * {@link DListRowBarDisplay.MOVE 이동} 셀 설정 모델.
         * <br>
         */
        get move() {
            return this._move;
        }
    }
    /**
     * 행 삭제를 실행하는 버튼 모델.
     * <br>
     * {@link DListOptions.editBar}의 {@link DListEditBar.delete} 설정 모델이다.
     * <br>
     * 기본 버튼 {@link DListRowButton.label label}은 'Delete'이다.
     *
     * @see concepts.edit_bar Edit Bar 개요
     * @see concepts.row_bar Row Bar 개요
     */
    class DListRowDeleteButton extends DListRowButton {
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * 삭제 확인 메시지. 이 속성이 설정되면 행 삭제 전 이 메시지롤 삭제 여부를 확인한다.
         */
        get confirmMessage() {
            return this.$_c.confirmMessage();
        }
        set confirmMessage(value) {
            this.$_c.setConfirmMessage(value);
        }
    }
    /**
     * 편집 버튼 설정 모델.
     * <br>
     *
     * @see concepts.edit_bar Edit Bar 개요
     */
    class DListRowEditButton extends DListRowButton {
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * row edit view header options.
         */
        get editHeader() {
            return this.$_c.editHeader();
        }
        set editHeader(value) {
            this.$_c.setEditHeader(value);
        }
        /**
         * 클릭 시 실행 될 row edit view template.
         */
        get editTemplate() {
            return this.$_c.editTemplate();
        }
        set editTemplate(value) {
            this.$_c.setEditTemplate(value);
        }
    }
    /**
     * 행 추가 버튼 설정 모델.
     * <br>
     *
     * @see concepts.edit_bar Edit Bar 개요
     */
    class DListRowAddButton extends DListRowEditButton {
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * true로 지정하면 마지막에 행을 추가하고, false면 버튼이 표시된 위치에 행을 삽입한다.
         * <br>
         *
         * @default false
         */
        get appending() {
            return this.$_c.appending;
        }
        set appending(value) {
            this.$_c.appending = value;
        }
    }
    /**
     * {@link DListEditBar Edit Bar}의 {@link DListEditBarAction.INFO} 버튼 설정 모델.
     * <br>
     * 문자가 'ⓘ'이고, transparent인 {@link letter}가 기본 설정된다.
     *
     * @see concepts.row_bar Row Bar 개요
     * @see concepts.edit_bar Edit Bar 개요
     */
    class DListRowInfoButton extends DListRowButton {
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * row info view header options.
         */
        get infoHeader() {
            return this.$_c.infoHeader();
        }
        set infoHeader(value) {
            this.$_c.setInfoHeader(value);
        }
        /**
         * 클릭 시 실행 될 row info view template.
         */
        get infoTemplate() {
            return this.$_c.infoTemplate();
        }
        set infoTemplate(value) {
            this.$_c.setInfoTemplate(value);
        }
    }
    /**
     * Link 버튼 설정 모델.
     * <br>
     *
     * @see concepts.edit_bar Edit Bar 개요
     */
    class DListRowLinkButton extends DListRowButton {
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * 버튼 클릭 시 지정된 url을 매개변수로 window.open(...)을 호출하는 데,
         * 이 속성 값이 target 매개변수로 지정된다.
         * <br>
         * 기본값은 현재 창을 대체하는 '_self'이다.
         * 새 창으로 url을 열기 위해서는 '_blank'를 지정한다.
         *
         * @default '_self'
         */
        get target() {
            return this.$_c.target();
        }
        set target(value) {
            this.$_c.setTarget(value);
        }
        /**
         * 버튼 클릭 시 이동할 페이지 주소.
         * <br>
         * 문자열에 포함된 '${row}'는 버튼이 포함된 데이터행의 번호로 변환된다.
         */
        get url() {
            return this.$_c.url();
        }
        set url(value) {
            this.$_c.setUrl(value);
        }
        /**
         * @callback
         *
         * 버튼 클릭 시 호출된다.
         * <br>
         * 이 콜백이 설정되면 {@link url} 속성은 무시된다.
         *
         * @cparam button 버튼 모델 객체 자신
         * @cparam row 데이터행 번호
         */
        get urlCallback() {
            return this.$_c.urlCallback();
        }
        set urlCallback(value) {
            this.$_c.setUrlCallback(value);
        }
    }
    /**
     * {@link concepts.edit_bar Edit Bar} 설정 모델.
     * <br>
     * 데이터행의 오른쪽 혹은 (수평 모드일 때)하단에 데이터행 기준으로 실행되는 action 버튼들이 표시되는
     * 영역에 대한 속성들을 포함한다.
     * {@link DListOptions.editBar} 속성으로 설정한다.
     *
     * ```
     * list.setConfig({
     *      options: {
     *          editBar: {
     *              visible: true,
     *              action: 'info',
     *              ...
     *          }
     *      }
     * });
     * ```
     *
     * ```
     * list.setConfig({
     *      options: {
     *          editBar: false  // boolean 값으로 지정하면 visible 속성으로 설정된다.
     *      }
     * });
     * ```
     *
     * @see concepts.edit_bar Edit Bar 개요
     * @see DListRowBar
     * @see concepts.row_bar Row Bar 개요
     */
    class DListEditBar extends DListControlBar {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(bar) {
            super();
            bar.setWrapper(this);
            this._delete = bar.delete().createWrapper(DListRowDeleteButton);
            this._add = bar.add().createWrapper(DListRowAddButton);
            this._edit = bar.edit().createWrapper(DListRowEditButton);
            this._info = bar.info().createWrapper(DListRowInfoButton);
            this._link = bar.link().createWrapper(DListRowLinkButton);
            this._custom = bar.custom().createWrapper(DListRowButton);
            this._move = bar.move().createWrapper(DListRowMover);
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * Bar에 표시할 {@link DListEditBarAction 실행 action}의 종류.
         * <br>
         */
        get action() {
            return this.$_c.action();
        }
        set action(value) {
            this.$_c.setAction(value);
        }
        /**
         * 데이터행 {@link DListEditBarAction.DELETE 삭제 action} 버튼 설정 객체.
         * <br>
         */
        get delete() {
            return this._delete;
        }
        setDelete(config) {
            this._delete.assignProps(config);
        }
        /**
         * 데이터행 {@link DListEditBarAction.ADD 추가 action} 버튼 설정 객체.
         * <br>
         */
        get add() {
            return this._add;
        }
        /**
         * 데이터행 {@link DListEditBarAction.EDIT 수정 action} 버튼 설정 객체.
         * <br>
         */
        get edit() {
            return this._edit;
        }
        /**
         * 데이터행 {@link DListEditBarAction.INFO 정보 action} 버튼 설정 객체.
         * <br>
         */
        get info() {
            return this._info;
        }
        /**
         * 데이터행 {@link DListEditBarAction.LINK 링크 action} 버튼 설정 객체.
         * <br>
         */
        get link() {
            return this._link;
        }
        /**
         * {@link DListEditBarAction.CUSTOM 커스텀 action} 버튼 설정 객체.
         * <br>
         */
        get custom() {
            return this._custom;
        }
        /**
         * 데이터행 {@link DListEditBarAction.MOVE 이동 action} 핸들 설정 객체.
         * <br>
         */
        get move() {
            return this._move;
        }
    }
    /**
     * @noimpl
     *
     * 한글 영문 알파벳들로 표시되는 스크롤 인덱스 bar.
     * <br>
     * 문자를 클릭하면 문자에 해당하는 최초의 데이터행 혹은 해당하는 그룹 헤더가 표시되도록 스크롤한다.
     * 컨트롤 생성 시 기본적으로 표시되지 않는다.
     *
     * @see concepts.index_bar 인덱스바 개요
     * @see DListScrollBar
     * @see DListScrollIndicator
     */
    class DListIndexBar extends DListControlObject {
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // events
        //-------------------------------------------------------------------------
        /**
         * 문자 클릭 시 호출된다.
         * undefined가 아닌 값을 리턴하면 해당 값의 위치로 스크롤한다.
         */
        get onLetterClick() {
            return this.$_c.onLetterClick();
        }
        set onLetterClick(value) {
            this.$_c.setOnLetterClick(value);
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * 인덱스바 전체 길이(높이 혹은 너비).
         * 최대 길이이다. 표시할 문자 수 등에 따라 실제 표시 길이는 이 속성 값보다 작을 수 있다.
         * 숫자나 컨트롤 길이에 대한 상대값을 '%'로 지정할 수 있다.
         * 잘못된 값으로 지정하면 '85%'로 계산된다.
         */
        get length() {
            return this.$_c.length();
        }
        set length(value) {
            this.$_c.setLength(value);
        }
        /**
         * true면 {@link width}로 지정한 자체 영역을 차지 않고 내용 위에 중첩돼서 표시된다.
         */
        get floating() {
            return this.$_c.floating();
        }
        set floating(value) {
            this.$_c.setFloating(value);
        }
        /**
         * 이 속성을 NaN이 아닌 값으로 지정하면 내용과 상관없이 이 속성값의 폭으로 표시된다.
         * 단, {@link minWidth}와 {@link maxWidth} 사이의 값으로 조정된다.
         */
        get width() {
            return this.$_c.width();
        }
        set width(value) {
            this.$_c.setWidth(value);
        }
        /**
         * 최소 폭 크기.
         * 타당한 값으로 지정되면 내용이나 width, maxWidth 값과 관계없이
         * 항상 이 속성값 이상의 폭으로 표시된다.
         */
        get minWidth() {
            return this.$_c.minWidth();
        }
        set minWidth(value) {
            this.$_c.setMinWidth(value);
        }
        /**
         * 최대 폭 크기.
         * 타당한 값으로 지정되면 내용이나 width 값과 관계없이
         * 항상 이 속성값 이하의 폭으로 표시된다.
         */
        get maxWidth() {
            return this.$_c.maxWidth();
        }
        set maxWidth(value) {
            this.$_c.setMaxWidth(value);
        }
        /**
         * 이 속성을 지정하면 문자 사이에 이 속성 글자를 표시해서 문자 간격을 유지시킨다.
         * 이 속성이 지정되면 {@link letterGap}은 무시된다.
         */
        get spaceCharacter() {
            return this.$_c.spaceCharacter();
        }
        set spaceCharacter(value) {
            this.$_c.setSpaceCharacter(value);
        }
        /**
         * true면 {@link autoScroll} 시 대소문자 구분하여 데이터행을 찾는다.
         */
        get caseSensitive() {
            return this.$_c.caseSensitive();
        }
        set caseSensitive(value) {
            this.$_c.setCaseSensitive(value);
        }
        /**
         * 표시할 문자들. 두 문자 이상 지정해도 첫 문자만 표시한다.
         * 인덱스 바의 크기에 따라 지정한 문자들이 모두 표시되지 못할 수 있다.
         * 문자들은 '-'을 이용하여 범위로 설정할 수 있고, ','을 이용하여 그룹으로 분할할 수 있다.
         * 적어도 각 그룹의 한 문자는 표시되도록 구성한다.
         * 이 속성을 지정하지 않으면 기본 문자셋 '가-하,A-Z'으로 표시 문자들을 구성한다.
         * 한글의 경우 항상 초성 낱자로 표시된다.
         * 즉, '가'로 지정해도 'ㄱ'로 표시된다.
         */
        get letters() {
            return this.$_c.letters();
        }
        set letters(value) {
            this.$_c.setLetters(value);
        }
        /**
         * letter 클릭 시 행 이동 기준이 되는 데이터 필드 이름.
         */
        get indexField() {
            return this.$_c.indexField();
        }
        set indexField(value) {
            this.$_c.setIndexField(value);
        }
        /**
         * 문자 클릭 시 해당 문자와 관련된 최초의 데이터행이 표시되도록 스크롤한다.
         * 단, {@link onLetterClick} 콜백에서 true를 리턴하면 자동 스크롤하지 않는다.
         */
        get autoScroll() {
            return this.$_c.autoScroll();
        }
        set autoScroll(value) {
            this.$_c.setAutoScroll(value);
        }
    }
    /**
     * 컨트롤 상단이나 하단에 얇은 bar로 스크롤 상태를 표시하는 스크롤인디케이터 설정 모델.
     * <br>
     * 행 단위의 스크롤 범위를 표시한다.
     * {@link DListOptions.scrollIndicator} 속성으로 사용된다.
     *
     * //TODO: 전체 행을 모두 준비하는 모드에서는 pixel 단위 스크롤이 가능하게 한다.
     *
     * @see concepts.scrolling#scroll-indicator 스크롤인디케이터 개요
     * @see DListScrollBar
     * @see DListOptions
     */
    class DListScrollIndicator extends DListControlObject {
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // events
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * 스크롤 인디케이터 표시 위치.
         *
         * @default 'near'
         */
        get position() {
            return this.$_c.position();
        }
        set position(value) {
            this.$_c.setPosition(value);
        }
        /**
         * 스크롤 인디케이터 표시 크기 기준. {@link DListScrollIndicatorMode} 참조.
         */
        get mode() {
            return this.$_c.mode();
        }
        set mode(value) {
            this.$_c.setMode(value);
        }
        /**
         * 스크롤 인디케이터의 픽셀 단위 폭.
         * 숫자로 변환되지 않는 값을 지정하면 기본 높이로 지정된다.
         *
         * @default 7
         */
        get barWidth() {
            return this.$_c.barWidth();
        }
        set barWidth(value) {
            this.$_c.setBarWidth(value);
        }
        /**
         * 리스트 컨트롤 선택 영역에 해당하는 부분을 다른 색상으로 구분해서 표시한다.
         */
        get showSelection() {
            return this.$_c.showSelection();
        }
        set showSelection(value) {
            this.$_c.setShowSelection(value);
        }
        /**
         * 인디케이터를 클릭한 지점에 해당하는 데이터행 위치로 스크롤한다.
         */
        get clickable() {
            return this.$_c.clickable();
        }
        set clickable(value) {
            this.$_c.setClickable(value);
        }
        /**
         * 스크롤 위치를 표시하는 툴팁 표시 여부.
         */
        get tooltipVisible() {
            return this.$_c.tooltipVisible();
        }
        set tooltipVisible(value) {
            this.$_c.setTooltipVisible(value);
        }
        /**
         * 툴팁에 표시할 값.
         * 'top'이면 리스트 상단에 표시된 행 번호,
         * 'bottom'이면 리스트 하단에 표시된 행 번호를 표시한다.
         *
         * @default 'top'
         *
         * @see firstTooltip
         * @see lastTooltip
         */
        get tooltipValue() {
            return this.$_c.tooltipValue();
        }
        set tooltipValue(value) {
            this.$_c.setTooltipValue(value);
        }
        /**
         * 첫 스크롤 위치일 때 표시되는 메시지.
         * 지정하지 않으면 {@link tooltipValue} 설정에 따른 첫 행 번호를 표시한다.
         *
         * @default 'First'
         *
         * @see lastTooltip
         */
        get firstTooltip() {
            return this.$_c.firstTooltip();
        }
        set firstTooltip(value) {
            this.$_c.setFirstTooltip(value);
        }
        /**
         * 미자막 스크롤 위치일 때 표시되는 메시지.
         * 지정하지 않으면 {@link tooltipValue} 설정에 따른 마지막 행 번호를 표시한다.
         *
         * @default 'Last'
         *
         * @see firstTooltip
         */
        get lastTooltip() {
            return this.$_c.lastTooltip();
        }
        set lastTooltip(value) {
            this.$_c.setLastTooltip(value);
        }
        /**
         * 툴팁 뷰에 적용할 스타일 셋.
         */
        get tooltipStyle() {
            return this.$_c.tooltipStyle();
        }
        set tooltipStyle(value) {
            this.$_c.setTooltipStyle(value);
        }
    }
    /**
     * 컨트롤 우측이나 아래쪽에 표시되는 스크롤바 설정 모델.
     * <br>
     *
     * Thumb을 드래그하여 행 단위로 스크롤한다.
     * 컨트롤 생성 시 기본적으로 표시되지 않는다.
     * {@link DListOptions.scrollBar} 속성으로 사용된다.
    *
     * @see concepts.scrolling#scroll-bar 스크롤바 개요
     * @see DListScrollIndicator
     * @see DListOptions
     */
    class DListScrollBar extends DListControlObject {
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * true면 행들 위에 중첩되어 표시된다.
         *
         * @default false
         */
        get floating() {
            return this.$_c.floating();
        }
        set floating(value) {
            this.$_c.setFloating(value);
        }
        /**
         * 스크롤바 전체 폭.
         * 숫자로 변환될 수 없는 값을 지정하면 기본 너비로 지정된다.
         *
         * @default 6 픽셀
         */
        get barWidth() {
            return this.$_c.barWidth();
        }
        set barWidth(value) {
            this.$_c.setBarWidth(value);
        }
        /**
         * 스크롤바 thumb 폭.
         * 숫자로 변환될 수 없는 값을 지정하면 기본 너비로 지정된다.
         *
         * @default 4 픽셀
         */
        get thumbWidth() {
            return this.$_c.thumbWidth();
        }
        set thumbWidth(value) {
            this.$_c.setThumbWidth(value);
        }
        /**
         * 스크롤바의 최소 길이.
         *
         * @default 30 픽셀
         */
        get minThumbLength() {
            return this.$_c.minThumbLength();
        }
        set minThumbLength(value) {
            this.$_c.setMinThumbLength(value);
        }
    }
    class DPageNavigatorItem extends DWrapper {
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // events
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        get action() {
            return this.$_c.action();
        }
        get label() {
            return this.$_c.label();
        }
        /**
         * 기본 스타일외에 추가로 설정할 css selector.
         */
        get className() {
            return this.$_c.className();
        }
        set className(value) {
            this.$_c.setClassName(value);
        }
        /**
         * 기본 스타일외에 disabled일 때 추가로 설정할 css selector.
         */
        get disabledClass() {
            return this.$_c.disabledClass();
        }
        set disabledClass(value) {
            this.$_c.setDisabledClass(value);
        }
        /**
         * [접근성] 정보.
         * 아이템 element의 title로 사용된다.
         * 지정하지 않으면 다음과 같은 기본값이 적용된다.
         *
         * 페이지 이동이 아나라 표시할 데이터를 바꾸는 것이다?
         * first: '시작 페이지 데이타 표시', //'시작 페이지로 이동',
         * last: '마지막 페이지 데이타 표시', //'마지막 페이지로 이동',
         * prev: '이전 페이지 데이타 표시', //'이전 페이지로 이동',
         * next: '다음 페이지 데이타 표시', //'다음 페이지로 이동'
         */
        get hint() {
            return this.$_c.hint();
        }
        set hint(value) {
            this.$_c.setHint(value);
        }
        /**
         * 비활성 상태.
         */
        get disabled() {
            return this.$_c.disabled();
        }
    }
    /**
     * {@link DListControl 컨트롤}이 {@link DListControl.isPaging paging} 상태일 때만 표시되는 페이지 이동 버튼들이 표시되는 영역 모델.
     * <br>
     * {@link first 시작}, {@link last 끝}, {@link prev 이전}, {@link next 다음} 페이지 버튼을 표시하고,
     * 중앙에 현재/전체 페이지 번호 표시.
     * <br>
     * {@link DListOptions.pageNavigator} 속성으로 사용된다.
     *
     * @see concepts.paging 페이징 개요
     */
    class DListPageNavigator extends DListControlObject {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(navigator) {
            super();
            navigator.setWrapper(this);
            this._first = navigator.first().createWrapper(DPageNavigatorItem);
            this._prev = navigator.prev().createWrapper(DPageNavigatorItem);
            this._next = navigator.next().createWrapper(DPageNavigatorItem);
            this._last = navigator.last().createWrapper(DPageNavigatorItem);
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * 페이지 네비게이터 표시 위치.
         * <br>
         * 화면이 portrait일 때 'far'이면 bottom에, 'near'이면 top에 표시.
         * landscape일 때 'far'이면 right, 'near'이면 left에 표시.
         */
        get position() {
            return this.$_c.position();
        }
        set position(value) {
            this.$_c.setPosition(value);
        }
        /**
         * 첫 페이지로 이동 버튼 모델.
         */
        get first() {
            return this._first;
        }
        /**
         * 이전 페이지로 이동 버튼 모델.
         */
        get prev() {
            return this._prev;
        }
        /**
         * 다음 페이지로 이동 버튼 모델.
         */
        get next() {
            return this._next;
        }
        /**
         * 마지막 페이지로 이동 버튼 모델.
         */
        get last() {
            return this._last;
        }
        /**
         * {@link orientation}이 {@link DOrientation.VERTICAL}일 때 내비게이터 너비.
         */
        get width() {
            return this.$_c.width();
        }
        set width(value) {
            this.$_c.setWidth(value);
        }
        /**
         * {@link orientation}이 {@link DOrientation.HORIZONTAL}일 때 내비게이터 높이.
         */
        get height() {
            return this.$_c.height();
        }
        set height(value) {
            this.$_c.setHeight(value);
        }
        /**
         * 아이템 사아의 간격.
         * <br>
         * 중앙 배치되는 페이지 번호/전체 항목을 기준으로 좌우 배치하는 간격.
         * 숫자값으로 지정하지 않으면 남아 있는 공간을 골고루 배분한다.
         */
        get itemGap() {
            return this.$_c.itemGap();
        }
        set itemGap(value) {
            this.$_c.setItemGap(value);
        }
        /**
         * 컨트롤이 landscape이고, navigator가 수직으로 배치될 때 아이템들 사이의 간격.
         * <br>
         * 지정하지 않고 {@link itemGap}이 설정된 상태면 itemGap의 반으로 계산된다.
         * itemGap도 설정되지 않으면 남아 있는 공간으로 골고루 배분한다.
         */
        get itemGap2() {
            return this.$_c.itemGap2();
        }
        set itemGap2(value) {
            this.$_c.setItemGap2(value);
        }
    }
    /**
     * @noimpl
     *
     * Page scroller index 모델.
     * 각 index는 한 페이지를 의마한다.
     */
    class DPageScrollerIndex extends DWrapper {
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // events
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * 기본 스타일외에 추가로 설정할 css selector.
         */
        get className() {
            return this.$_c.className();
        }
        set className(value) {
            this.$_c.setClassName(value);
        }
        /**
         * [접근성] 정보.
         * 인덱스 element의 title로 사용된다.
         * 지정하지 않으면 다음과 같은 기본값이 적용된다.
         *
         * first: '시작 페이지로 이동',
         * last: '마지막 페이지로 이동',
         * current: '현재 페이지',
         * page index: 'n페이지로 이동'
         *
         * 페이지 인덱스의 hint에는 '${page}'를 포함할 수 있는데,
         * 인덱스에 해당하는 페이지 번호로 대체된다.
         */
        get hint() {
            return this.$_c.hint();
        }
        set hint(value) {
            this.$_c.setHint(value);
        }
    }
    /**
     * @noimpl
     */
    class DPageScrollerEndIndex extends DPageScrollerIndex {
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * visible
         */
        get visible() {
            return this.$_c.visible();
        }
        set visible(value) {
            this.$_c.setVisible(value);
        }
    }
    /**
     * @noimpl
     *
     * 페이지 번호를 연속적으로 표시하고 드래그로 스크롤링한다.
     * 양끝에 시작 번호, 끝 번호를 표시한다.
     * 번호를 클릭해서 페이지로 이동한다.
     * 컨트롤이 paging 상태일 때만 표시될 수 있다.
     * page navigator와 동시에 표시될 경우 navigator 바깥에 표시된다.
     */
    class DListPageScroller extends DListControlObject {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(scroller) {
            super();
            scroller.setWrapper(this);
            this._first = scroller.first().createWrapper(DPageScrollerEndIndex);
            this._last = scroller.last().createWrapper(DPageScrollerEndIndex);
            this._index = scroller.index().createWrapper(DPageScrollerIndex);
            this._current = scroller.current().createWrapper(DPageScrollerIndex);
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * {@link PageScroller 페이지 스크롤러} 표시 위치.
         * 화면이 portrait일 때 'far'이면 bottom에, 'near'이면 top에 표시.
         * landscape일 때 'far'이면 right, 'near'이면 left에 표시.
         */
        get position() {
            return this.$_c.position();
        }
        set position(value) {
            this.$_c.setPosition(value);
        }
        // /**
        //  * 항목 배치 방향.
        //  */
        // get orientation(): DOrientation {
        //     return this._orientation;
        // }
        // set orientation(value: DOrientation) {
        //     if (value !== this._orientation) {
        //         this._orientation = value;
        //         this._changed('orientation');
        //     }
        // }
        /**
         * 페이지 인덱스 아이템들 사이의 간격.
         */
        get itemGap() {
            return this.$_c.itemGap();
        }
        set itemGap(value) {
            this.$_c.setItemGap(value);
        }
        /**
         * 컨트롤 페이지 인덱스가 변경됐을 때,
         * 현재 페이지 인덱스가 표시되지 않은 상태라면.
         * 표시되도록 자동 스크롤한다.
         */
        get autoScroll() {
            return this.$_c.autoScroll();
        }
        set autoScroll(value) {
            this.$_c.setAutoScroll(value);
        }
        /**
         * 시작 번호에 대한 설정.
         */
        get first() {
            return this._first;
        }
        /**
         * 끝 번호에 대한 설정.
         */
        get last() {
            return this._last;
        }
        /**
         * 페이지 번호들에 대한 설정.
         */
        get index() {
            return this._index;
        }
        /**
         * 현재 페이지에 대한 설정.
         */
        get current() {
            return this._current;
        }
        /**
         * {@link orientation}이 {@link DOrientation.VERTICAL}일 때 내비게이터 너비.
         */
        get width() {
            return this.$_c.width();
        }
        set width(value) {
            this.$_c.setWidth(value);
        }
        /**
         * {@link orientation}이 {@link DOrientation.HORIZONTAL}일 때 내비게이터 높이.
         */
        get height() {
            return this.$_c.height();
        }
        set height(value) {
            this.$_c.setHeight(value);
        }
    }
    /**
     * Row command 셀들이 표시되는 box 관련 설정 모델.
     * <br>
     * Command box는 대개 사용자가 {@link DListRow.swipeAction swipe} 등으로 설정한 데이터행에 표시되지만,
     * {@link DListControl.setCommandRow}를 호출해서 직접 표시되게 할 수도 있다.
     * {@link concepts.command_box Command 상자 개요}를 참조한다.
     *
     * @example
     *  list.setConfig({
     *      options: {
     *          commandBox: {
     *              mode: 'overlap'
     *          }
     *      }
     *  });
     *
     * @see concepts.command_box Command 상자 개요
     * @see DListControl.registerRowCommand
     * @see DListControl.unregisterRowCommands
     * @see DListControl.updateRowCommand
     * @see DListControl.setCommandRow
     */
    class DListCommandBox extends DListControlObject {
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * @noimpl
         *
         * Command 셀 배치 방향.
         */
        get orientation() {
            return this.$_c.orientation();
        }
        set orientation(value) {
            this.$_c.setOrientation(value);
        }
        /**
         * @noimpl
         *
         * 표시 방식. 데이터행을 밀어내거나, 겹쳐 표시한다.
         */
        get mode() {
            return this.$_c.mode();
        }
        set mode(value) {
            this.$_c.setMode(value);
        }
        /**
         * 최소 셀 너비.
         */
        get minCellWidth() {
            return this.$_c.minCellWidth();
        }
        set minCellWidth(value) {
            this.$_c.setMinCellWidth(value);
        }
        /**
         * 최소 셀 높이.
         */
        get minCellHeight() {
            return this.$_c.minCellHeight();
        }
        set minCellHeight(value) {
            this.$_c.setMinCellHeight(value);
        }
    }
    /**
     * @noimpl
     *
     * 선택 영역을 표시하는 mask 관련 설정 모델.
     */
    class DListSelectionMask extends DListControlObject {
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * 선택 영역을 변경하는 핸들 표시 여부.
         */
        get showHandle() {
            return this.$_c.showHandle();
        }
        set showHandle(value) {
            this.$_c.setShowHandle(value);
        }
    }
    /**
     * {@link DListRow.clickAction}이나 {@link DListRow.masterClickAction masterRowClickAction}이
     * {@link DListRowClickAction.link link}일 때,
     * 클릭된 row와 관련된 링크 설정 모델.
     * <br>
     * {@link DListRow.link} 속성 모델로 사용된다.
     *
     * @see concepts.data_row 데이터행 개요
     * @see concepts.options 컨트롤 Options
     */
    class DListRowLink extends DWrapper {
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * {@link linkField}나 {@link linkCallback}으로 리턴되는 url 앞에 첨부되는 루트 경로.
         */
        get rootUrl() {
            return this.$_c.rootUrl();
        }
        set rootUrl(value) {
            this.$_c.setRootUrl(value);
        }
        /**
         * 링크 url 값을 가진 데이터 필드 이름.
         * <br>
         * {@link linkCallback}이 설정되고 빈 값을 리턴하지 않으면 이 속성은 무시된다.
         *
         * @see rootUrl
         */
        get linkField() {
            return this.$_c.linkField();
        }
        set linkField(value) {
            this.$_c.setLinkField(value);
        }
        /**
         * 링크 url을 리턴하는 콜백.
         * <br>
         * 이 콜백에서 빈 값을 리턴하면 {@link linkField}로 지정한 필드 값이 사용된다.
         */
        get linkCallback() {
            return this.$_c.linkCallback();
        }
        set linkCallback(value) {
            this.$_c.setLinkCallback(value);
        }
        /**
         * 새 페이지가 load될 window 혹은 tap을 지정한다.
         * <br>
         * 자세한 내용은 Window.{@link https://developer.mozilla.org/en-US/docs/Web/API/Window/open open} 페이지를
         * 참조한다.
         *
         * @default '_blank' 새 창에 연다.
         */
        get target() {
            return this.$_c.target();
        }
        set target(value) {
            this.$_c.setTarget(value);
        }
    }
    /**
     * 기본 리스트나 {@link concepts.single_row Single Row} 모드에서 데이터행을 자동 스크롤하는 설정 모델.
     * <br>
     *
     * @see {@link DListRow.autoScroll}
     */
    class DListAutoScroll extends DWrapper {
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * 활성화 여부.
         * <br>
         */
        get enabled() {
            return this.$_c.enabled();
        }
        set enabled(value) {
            this.$_c.setEnabled(value);
        }
        /**
         * scroll mode
         * <br>
         */
        get mode() {
            return this.$_c.mode();
        }
        set mode(value) {
            this.$_c.setMode(value);
        }
        /**
         * 이전 행 방향으로 스크롤 진행.
         * <br>
         */
        get backward() {
            return this.$_c.backward();
        }
        set backward(value) {
            this.$_c.setBackward(value);
        }
        /**
         * 행 표시 기간. ms 단위.
         * <br>
         */
        get duration() {
            return this.$_c.duration();
        }
        set duration(value) {
            this.$_c.setDuration(value);
        }
        /**
         * 행 이동 기간. ms 단위.
         * <br>
         */
        get changeDuration() {
            return this.$_c.changeDuration();
        }
        set changeDuration(value) {
            this.$_c.setChangeDuration(value);
        }
    }
    /**
     * 데이터행 자동 스크롤 설정 모델.
     * <br>
     * {@link DListRow.autoScroll} 속성으로 사용된다.
     */
    class DListRowScroll extends DListAutoScroll {
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * 스크롤 당 이동 행 수.
         * <br>
         *
         * @default 1
         */
        get rowsPerScroll() {
            return this.$_c.rowsPerScroll();
        }
        set rowsPerScroll(value) {
            this.$_c.setRowsPerScroll(value);
        }
    }
    /**
     * 데이터 행 관련 설정 모델.
     * <br>
     * {@link DListOptions.row} 설정 모델로 사용된다.
     *
     * @see concepts.data_row 데이터행 개요
     */
    class DListRow extends DWrapper {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(row) {
            super();
            row.setWrapper(this);
            this._link = row.link().createWrapper(DListRowLink);
            this._borderLine = row.borderLine().createWrapper(DListRowBorderLine);
            this._focusMask = row.focusMask().createWrapper(DListRowFocusMask);
            this._autoScroll = row.autoScroll().createWrapper(DListRowScroll);
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * 데이터행 {@link concepts.layouts 레이아웃} 생성에 사용되는 {@link concepts.templates 템플릿} 이름.
         * <br>
         * 템플릿은 {@link DListControl.registerTemplate}이나 {@link DListControl.registerTemplates}으로
         * 사전 등록해야 한다.
         *
         * @see templateCallback
         * @see largeTemplate
         */
        get template() {
            return this.$_c.template();
        }
        set template(value) {
            this.$_c.setTemplate(value);
        }
        /**
         * 큰 화면의 기본 데이터행 {@link concepts.layouts 레이아웃} {@link concepts.templates 템플릿} 이름.
         * 템플릿은 {@link DListControl.registerTemplate}이나 {@link DListControl.registerTemplates}으로
         * 사전 등록해야 한다.
         *
         * @see template
         * @see templateCallback
         */
        get largeTemplate() {
            return this.$_c.largeTemplate();
        }
        set largeTemplate(value) {
            this.$_c.setLargeTemplate(value);
        }
        /**
         * 데이터행 별 template을 리턴하는 콜백.
         * <br>
         * 동적으로 행 템플릿을 지정하고자 할 때 사용한다.
         * 콜백에서 값을 리턴하지 않거나 빈 값을 리턴하면 기본 템플릿으로 표시한다.
         * 기본 행 템플릿은 {@link template} 속성으로 지정한다.
         *
         * @example
         * control.options.rowTemplateCallback = (dv, row) => {
         *     if (dv.getValue(row, 'status') === 'active') {
         *         return 'active';
         *     }
         * };
         */
        get templateCallback() {
            return this.$_c.templateCallback();
        }
        set templateCallback(value) {
            this.$_c.setTemplateCallback(value);
        }
        /**
         * 데이터행 {@link concepts.layouts 레이아웃} {@link concepts.templates 템플릿}에 포함된
         * 템플릿 param의 값을 갖는 json 객체. 값은 getter 속성일 수도 있다.
         * <br>
         * [주의] getter로 리턴된 object의 속성을 변경해도 control에 반영되지 않는다.
         */
        get templateParams() {
            return this.$_c.templateParams();
        }
        set templateParams(value) {
            this.$_c.setTemplateParams(value);
        }
        /**
         * 기본 데이터행 스타일 셋.
         * 이 스타일은 행 layout 및 양측의 {@link concepts.row_bar RowBar},
         * {@link concepts.edit_bar EditBar} cell 들을 모두 포함하는 데이터행 전체 영역에 적용된다.
         */
        get style() {
            return this.$_c.style();
        }
        set style(value) {
            this.$_c.setStyle(value);
        }
        /**
         * 데이터행 높이.
         * <br>
         * 0보다 큰 값으로 설정되면 행의 내용으로 높이를 계산하지 않고
         * 이 속성 값으로 행들의 높이가 동일하게 설정된다.
         * 이 속성이 설정되면 {@link minHeight}, {@link maxHeight}, {@link DListControl.rowCount}
         * 속성들은 무시된다.
         */
        get height() {
            return this.$_c.height();
        }
        set height(value) {
            this.$_c.setHeight(value);
        }
        /**
         * 데이터행 최소 높이.
         * <br>
         * 0보다 큰 값으로 설정되면 행의 최소 표시 높이가 된다.
         * <br>
         * {@link height}나, {@link DListControl.rowCount} 속성이 타당한 값으로 설정되면 이 속성 값은 무시된다.
         */
        get minHeight() {
            return this.$_c.minHeight();
        }
        set minHeight(value) {
            this.$_c.setMinHeight(value);
        }
        /**
         * 데이터행 최대 높이.
         * <br>
         * 0보다 큰 값으로 설정되면 행의 최대 표시 높이가 된다.
         * <br>
         * {@link height}나, {@link DListControl.rowCount} 속성이 타당한 값으로 설정되면 이 속성 값은 무시된다.
         * 또, {@link minHeight}가 이 속성보다 큰 값으로 설정되면 이 속성은 의미가 없다.
         */
        get maxHeight() {
            return this.$_c.maxHeight();
        }
        set maxHeight(value) {
            this.$_c.setMinHeight(value);
        }
        /**
         * 데이터행을 길게 눌렀을(long press) 때 실행되는 {@link DListRowClickAction action}.
         * <br>
         *
         * @default DListRowClickAction.NONE
         */
        get clickAction() {
            return this.$_c.clickAction();
        }
        set clickAction(value) {
            this.$_c.setClickAction(value);
        }
        /**
         * {@link concepts.data_grouping 데이터그룹핑} 상태일 때, 마스터 데이터행을 클릭하면 실행될 action.
         * <br>
         * 설정하지 않으면 {@link clickAction} 설정을 따른다.
         *
         * @default DListRowClickAction.EXPAND
         */
        get masterClickAction() {
            return this.$_c.masterClickAction();
        }
        set masterClickAction(value) {
            this.$_c.setMasterClickAction(value);
        }
        /**
         * 데이터행을 길게 누를(long press) 때 실행되는 {@link DListRowClickAction action}.
         * <br>
         *
         * @default DListRowClickAction.NONE
         */
        get pressAction() {
            return this.$_c.pressAction();
        }
        set pressAction(value) {
            this.$_c.setPressAction(value);
        }
        /**
         * {@link concepts.data_grouping 데이터그룹핑} 상태일 때, 데이터행을 길게 누르면(long press) 실행되는 {@link DListRowClickAction action}.
         * <br>
         */
        get masterPressAction() {
            return this.$_c.masterPressAction();
        }
        set masterPressAction(value) {
            this.$_c.setMasterPressAction(value);
        }
        /**
         * 데이터행을 좌우 혹은 상하(수평 모드)로 swipe할 때 실행될 {@link DListRowSwipeAction action}을 지정한다.
         * <br>
         * 단, {@link DListControl.onRowSwipe} 이벤트 핸들러에서 매개변수 객체의 cancel을 true로 지정하면
         * 이 속성 설정은 무시된다.
         * 이 속성은 무시된다.
         */
        get swipeAction() {
            return this.$_c.swipeAction();
        }
        set swipeAction(value) {
            this.$_c.setSwipeAction(value);
        }
        /**
         * 데이터행 {@link concepts.command_box command box}에 표시되는 실행 명령 들.
         */
        get commands() {
            return this.$_c.commands();
        }
        set commands(value) {
            this.$_c.setCommands(value);
        }
        /**
         * {@link clickAction}이나 {@link masterClickAction}이 '**link**'일 때,
         * 클릭된 row와 관련된 링크 설정 정보.
         */
        get link() {
            return this._link;
        }
        /**
         * 데이터행 아래 혹은 수평 모드에서 오른쪽에 표시되는 경계선 설정 모델.
         * <br>
         */
        get borderLine() {
            return this._borderLine;
        }
        /**
         * 포커스된 데이터행 위에 표시되는 마스크 설정 모델.
         * <br>
         */
        get focusMask() {
            return this._focusMask;
        }
        /**
         * 자동 scroll 설정 모델.
         * <br>
         */
        get autoScroll() {
            return this._autoScroll;
        }
        /**
         * 사용자가 데이터행을 tap 해서 {@link DListControl.focusedRow focused 상태}로 지정할 수 있다.
         * <br>
         */
        get focusable() {
            return this.$_c.focusable();
        }
        set focusable(value) {
            this.$_c.setFocusable(value);
        }
        /**
         * 데이터행을 tap할 때 다른 배경색등으로 구분해서 표시한다.
         */
        get touchEffect() {
            return this.$_c.touchEffect();
        }
        set touchEffect(value) {
            this.$_c.setTouchEffect(value);
        }
        /**
         * 데이터행 삭제를 애니메이션으로 표현할 것인 지 여부.
         * <br>
         *
         * @see {@link DListData.deleteRow}
         *
         * @default true
         */
        get deleteAnimation() {
            return this.$_c.deleteAnimation();
        }
        set rowDeleteAnimation(value) {
            this.$_c.setDeleteAnimation(value);
        }
    }
    /**
     * {@link DListHeader 리스트 헤더}나 {@link DListFooter 리스트 Footer} 등
     * 리스트 컨트롤의 일부를 차지하는 영역에 대한 설정 모델 기반 클래스.
     *
     * @see concepts.regions 리스트 컨트롤 영역들
     */
    class DListSection extends DWrapper {
        //-------------------------------------------------------------------------
        // consts
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        get control() {
            return this.$_c.owner().wrapper();
        }
        /**
         * 영역 표시 여부.
         * <br>
         * 섹션 종류에 따라 기본 표시 여부가 다르게 설정된다.
         */
        get visible() {
            return this.$_c.visible();
        }
        set visible(value) {
            this.$_c.setVisible(value);
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doAssignProps(source) {
            if (typeof source === 'boolean') {
                this.visible = source;
                return true;
            }
        }
    }
    /**
     * {@link DListHeader 리스트 헤더}나 {@link DListFooter 리스트 Footer} 등
     * 레이아웃 템플릿으로 구현되는 컨트롤 {@link DListSection 섹션}에 대한 설정 모델 기반 클래스.
     *
     * @tparam @no {@link concepts.single_row Single Row} 상태일 때 현재 행 번호.
     * @tparam @row-count 컨트롤에 지정된 데이터의 행 수.
     * @tparam @sum-[field] field 값들의 합계. 예) @sum-salary, @sum-price
     * @tparam @avg-[field] field 값들의 평균. 예) @avg-salary, @avg-price
     *
     * @see concepts.header 리스트 헤더
     * @see concepts.footer 리스트 Footer
     */
    class DListLayoutedSection extends DListSection {
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * 레이아웃 템플릿 이름.
         * 템플릿은 {@link DListControl.registerTemplate}이나 {@link DListControl.registerTemplates}으로
         * 사전 등록해야 한다.
         */
        get template() {
            return this.$_c.template();
        }
        set template(value) {
            this.$_c.setTemplate(value);
        }
        /**
         * template으로 부터 layout이 생성될 때 template param 들에 대치되는 값 목록.
         */
        get layoutParams() {
            return this.$_c.layoutParams();
        }
        set layoutParams(value) {
            this.$_c.setLayoutParams(value);
        }
        /**
         * section 기본 스타일
         */
        get style() {
            return this.$_c.style();
        }
        set style(value) {
            this.$_c.setStyle(value);
        }
        /**
         * section 내용의 기본 스타일
         */
        get layoutStyle() {
            return this.$_c.layoutStyle();
        }
        set layoutStyle(value) {
            this.$_c.setLayoutStyle(value);
        }
    }
    /**
     * {@link DListHeader 리스트 헤더}나 {@link DListFooter Footer} 등
     * 양 끝에 버튼을 추가할 수 있고,
     * 섹션을 tap했을 때 실행될 {@link clickAction action}을 설정할 수 있는
     * {@link DListLayoutedSection 섹션}에 대한 설정 모델 base.
     * <br>
     *
     * @see concepts.header Header 개요
     * @see concepts.footer Footer 개요
     */
    class DListActionableSection extends DListLayoutedSection {
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * 섹션 양 끝에 추가되는 버튼들의 {@link IListSectionButton 모델}을 배열로 설정한다.
         *
         * @see buttonGap
         */
        get buttons() {
            const buttons = this.$_c.buttons();
            return buttons && buttons.map(a => Object.assign({}, a));
        }
        set buttons(value) {
            this.$_c.setButtons(value);
        }
        /**
         * {@link buttons 버튼들} 사이의 간격을 픽셀 단위로 지정한다.
         *
         * @default 5 픽셀.
         */
        get buttonGap() {
            return this.$_c.buttonGap();
        }
        set buttonGap(value) {
            this.$_c.setButtonGap(value);
        }
        /**
         * 섹션 뷰가 tap 됐을 때 실행되는 {@link DListSectionAction action}.
         */
        get clickAction() {
            return this.$_c.clickAction();
        }
        set clickAction(value) {
            this.$_c.setClickAction(value);
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        getButton(name) {
            const button = this.$_c.getButton(name);
            return button && Object.assign({}, button);
        }
        /**
         * 기존에 동일한 이름의 버튼이 존재하면 속성들을 update하고,
         * 존재하지 않으면 새로 추가한다.
         */
        setButton(button) {
            this.$_c.setButton(button);
        }
        removeButton(name) {
            this.$_c.removeButton(name);
        }
        showButton(button) {
            this.$_c.setButtonVisible(button, true);
        }
        hideButton(button) {
            this.$_c.setButtonVisible(button, false);
        }
        setButtonEnabled(button, enabled) {
            this.$_c.setButtonEnabled(button, enabled);
        }
        getButtonState(button) {
            return this.$_c.getButtonState(button);
        }
        setButtonState(button, state) {
            this.$_c.setButtonState(button, state);
        }
    }
    /**
     * {@link DListControl List control}의 {@link concepts.header header} 영역 model.
     * <br>
     * {@link templates/it_list_header '@it_list_header'}가 기본 템플릿으로,
     * {@link caption} 속성 값을 표시한다.
     * {@link DListControl.footer footer}와 다르게 표시되지 않는 것이 기본 설정이다.
     *
     * @see {@link concepts.regions 컨트롤 영역들}
     * @see {@link DListOptions.header}
     * @see {@link DListControl.setOptions}
     * @see {@link DListFooter}
     */
    class DListHeader extends DListActionableSection {
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * 헤더 캡션.<br>
         * 리스트 헤더 기본 stock 템플릿에서 '**@caption**' {@link concepts.templates param} 값으로 사용된다.
         *
         * @default 'Header'
         */
        get caption() {
            return this.$_c.caption();
        }
        set caption(value) {
            this.$_c.setCaption(value);
        }
        /**
         * 리스트 헤더 기본 stock 템플릿에서 '**@caption**' {@link concepts.templates param} 문자열의 정렬 스타일로 사용된다.
         */
        get captionAlign() {
            return this.$_c.captionAlign();
        }
        set captionAlign(value) {
            this.$_c.setCaptionAlign(value);
        }
        /**
         * 리스트 헤더 기본 stock 템플릿에서 '**@caption**' {@link concepts.templates param} 문자열의 색상 스타일로 사용된다.
         */
        get captionColor() {
            return this.$_c.captionColor();
        }
        set captionColor(value) {
            this.$_c.setCaptionColor(value);
        }
        /**
         * 체크박스 표시 여부.
         *
         * @default false
         */
        get showCheck() {
            return this.$_c.showCheck();
        }
        set showCheck(value) {
            this.$_c.setShowCheck(value);
        }
        /**
         * 자동 check 모드.<br>
         * true로 설정되면 컨트롤의 행이 모두 checked 상태가 되면 check되고,
         * 하나라도 checked가 아니면 check가 해제된다.
         *
         * @default false
         */
        get autoCheck() {
            return this.$_c.autoCheck();
        }
        set autoCheck(value) {
            this.$_c.setAutoCheck(value);
        }
    }
    /**
     * 리스트 컨트롤의 footer view model.
     * <br>
     * 데이터행들의 합계 등 요약 정보를 표시하는 데 사용될 수 있다.
     * 기본적으로 컨트롤 하단에 고정적으로 표시되지만,
     * 데이터행과 마찬가지로 {@link template 템플릿}으로 표시 내용을 설정한다.
     * <br>
     * {@link templates/it_list_footer '@it_list_footer'}가 기본 템플릿이다.
     *
     * @see concepts.footer 리스트 Footer
     * @see {@link concepts.regions 컨트롤 영역들}
     * @see {@link DListOptions.footer}
     * @see {@link DListControl.setOptions}
     * @see {@link DListHeader}
     */
    class DListFooter extends DListActionableSection {
    }
    /**
     * 컨트롤 헤더 아래 표시되는 데이터필드 목록 표시 영역 모델.
     * <br>
     * 데이터 필드 목록을 표시하고, 사용자가 정렬 상태 등을 설정할 수 있게 한다.
     * {@link DListFieldBar 필드 Bar}와 다르게 layout으로 내용을 다양하게 구성할 수 있다.
     * 주로, FieldRenderer를 이용해 필드별 정렬 상태 등을 표시한다.
     * {@link DListOptions.fieldHeader} 속성으로 접근한다.
     *
     * @see concepts.sorting Sorting 개요
     */
    class DListFieldHeader extends DListLayoutedSection {
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * 정렬 순서 표시 여부.
         */
        get showOrder() {
            return this.$_c.showOrder();
        }
        set showOrder(value) {
            this.$_c.setShowOrder(value);
        }
    }
    /**
     * {@link concepts.search 검색 Bar} 설정 모델.
     *
     * @see DListSearchPanel
     * @see DListSearchResultBar
     */
    class DListSearchBar extends DListSection {
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * 검색 bar 표시 위치.
         */
        get position() {
            return this.$_c.position();
        }
        set position(value) {
            this.$_c.setPosition(value);
        }
        /**
         * reset 버튼 표시 여부
         */
        get resetVisible() {
            return this.$_c.resetVisible();
        }
        set resetVisible(value) {
            this.$_c.setResetVisible(value);
        }
        /**
         * options 버튼 표시 여부
         */
        get optionsVisible() {
            return this.$_c.optionsVisible();
        }
        set optionsVisible(value) {
            this.$_c.setOptionsVisible(value);
        }
        /**
         * 검색 결과가 0건이어도 결과 view를 표시한다.
         *
         * @default false
         */
        get alwaysResult() {
            return this.$_c.alwaysResult();
        }
        set alwaysResult(value) {
            this.$_c.setAlwaysResult(value);
        }
    }
    /**
     * {@link concept.SearchResultBar 검색 결과 bar} 설정 모델.
     * <br>
     * 검색 결과는 {@link DListSearchBar 검색 바}나
     * {@link DListSearchPanel 검색 페널}에서 검색을 실행한 결과가 존재할 때만 표시된다.
     * <br>
     * {@link DListOptions.searchResultBar} 속성으로 접근한다.
     *
     * @see concepts.search 검색 개요
     * @see concepts.options 컨트롤 Options
     * @see concepts.filtering Filtering
     * @see concepts.sorting Sorting
     */
    class DListSearchResultBar extends DListSection {
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * 검색 결과 bar 표시 위치.
         */
        get position() {
            return this.$_c.position();
        }
        set position(value) {
            this.$_c.setPosition(value);
        }
        /**
         * 데이터행을 기준으로 한 단계 수. levels와 같거나 작다.
         */
        get clearWhenClose() {
            return this.$_c.clearWhenClose();
        }
        set clearWhenClose(value) {
            this.$_c.setClearWhenClose(value);
        }
    }
    /**
     * 컨트롤 헤더 아래 표시되는 데이터필드 목록 표시 영역 모델.
     * <br>
     * 필드 목록을 표시하고, 사용자가 필드 정렬 상태를 설정할 수 있게 한다.
     * <br>
     * {@link DListOptions.fieldBar} 속성으로 접근한다.
     * 필드 목록 외에 버튼 등을 같이 표시하고 싶다면 {@link DListFieldHeader}를 사용한다.
     *
     * @see concepts.sorting Sorting 개요
     * @see DListOptions
     */
    class DListFieldBar extends DListSection {
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * options 버튼 표시 여부
         */
        get fields() {
            return this.$_c.fields();
        }
        set fields(value) {
            this.$_c.setFields(value);
        }
    }
    /**
     * 패널 base 모델.
     * <br>
     *
     * @see concepts.search#search-panel 검색 패널
     * @see concepts.filtering#filter-panel 필터 패널
     * @see concepts.button_panel Button 패널
     * @see concepts.form_panel Form 패널
     * @see concepts.options 컨트롤 Options
     */
    class DListPanel extends DWrapper {
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * panel 표시 위치.
         * <br>
         * {@link DActionPanelPosition.AUTO}로 설정하면 자동으로 배치된다.
         */
        get position() {
            return this.$_c.position();
        }
        set position(value) {
            this.$_c.setPosition(value);
        }
        /**
         * @noimpl
         *
         * panel을 드러내는 방식.
         * <br>
         */
        get showMode() {
            return this.$_c.showMode();
        }
        set showMode(value) {
            this.$_c.setShowMode(value);
        }
        /**
         * panel의 높이 혹은 너비를 지정한다.
         * <br>
         * 픽셀 단위의 고정 크기나 숫자와 '%'로 끝나는 문자열로 컨트롤 전체 크기에 대한 상태 크기로 지정할 수 있다.
         * 이 속성을 지정하지 않으면 panel에 표시되는 내용에 맞춰 크기가 결정된다.
         * 내용이 panel 크기를 벗어나게 되면 스크롤된다.
         * {@link minSize}와 {@link maxSize} 사이의 값으로 조정된다.
         */
        get size() {
            return this.$_c.size();
        }
        set size(value) {
            this.$_c.setSize(value);
        }
        /**
         * panel의 최소 크기.
         * <br>
         * {@link size} 속성으로 명시적으로 지정하거나,
         * 내용에 따라 크기가 결정되는 경우에도,
         * 이 속성이 지정되면 적어도 이 크기보다 크게 표시된다.
         */
        get minSize() {
            return this.$_c.minSize();
        }
        set minSize(value) {
            this.$_c.setMinSize(value);
        }
        /**
         * panel의 최대 크기.
         * <br>
         * {@link size} 속성으로 명시적으로 지정하거나,
         * 내용에 따라 크기가 결정되는 경우에도,
         * 이 속성이 지정되면 적어도 이 크기보다 작게 표시된다.
         * 단, {@link minSize}보다는 크게 표시된다.
         */
        get maxSize() {
            return this.$_c.maxSize();
        }
        set maxSize(value) {
            this.$_c.setMaxSize(value);
        }
        /**
         * 스타일셋 혹은 className.
         * <br>
         */
        get style() {
            return this.$_c.style();
        }
        set style(value) {
            this.$_c.setStyle(value);
        }
    }
    /**
     * 버튼들이 포시되는 패널 모델.
     * <br>
     *
     * @see IListButton
     * @see concepts.options#options 컨트롤 Options
     * @see concepts.button_panel 버튼 패널
     * @see concepts.search#search-panel 검색 패널
     * @see concepts.filtering#filter-panel 필터 패널
     */
    class DListButtonPanelBase extends DListPanel {
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * 표시할 버튼 모델 목록.
         *
         * @example
         * list.setConfig({
         *     options: {
         *         buttonPanel: {
         *             buttons: [{
         *                 label: '메시지',
         *                 imageUrl: '../asset/images/chat.png',
         *                 imageWidth: 24,
         *                 onClick: () => alert('Chat')
         *             }, {
         *                 label: '전화',
         *                 imageUrl: '../asset/images/phone.png',
         *                 imageWidth: 24,
         *                 onClick: () => alert('Phone')
         *             }]
         *         }
         *     }
         * });
         */
        get buttons() {
            return this.$_c.buttons();
        }
        set buttons(value) {
            this.$_c.setButtons(value);
        }
        /**
         * {@link buttons 버튼들} 사이의 픽셀 단위 간격.
         *
         * @default 16
         */
        get buttonGap() {
            return this.$_c.buttonGap();
        }
        set buttonGap(value) {
            this.$_c.setButtonGap(value);
        }
    }
    /**
     * 입력 element 등이 포함되는 content 영역과 버튼 영역으로 구분되는 panel.
     * <br>
     * 버튼 영역에는 기본적으로 입력 **승인** 및 **취소** 두 버튼이 표시된다.
     * {@link buttons} 속성으로 표시 버튼들을 다르게 지정할 수 있다.
     *
     * @see concepts.form_panel 폼 패널
     * @see concepts.search 검색 개요
     * @see concepts.filtering 필터링 개요
     */
    class DListDialogPanel extends DListButtonPanelBase {
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * 버튼들 표시 위치.
         */
        get buttonPosition() {
            return this.$_c.buttonPosition();
        }
        set buttonPosition(value) {
            this.$_c.setButtonPosition(value);
        }
        /**
         * **취소** 버튼 텍스트.
         * <br>
         *
         * @default 'Cancel'
         */
        get cancelLabel() {
            return this.$_c.cancelLabel();
        }
        set cancelLabel(value) {
            this.$_c.setCancelLabel(value);
        }
        /**
         * **확인** 버튼 텍스트.
         * <br>
         *
         * @default 'OK'
         */
        get okLabel() {
            return this.$_c.okLabel();
        }
        set okLabel(value) {
            this.$_c.setOkLabel(value);
        }
    }
    /**
     * 설정 정보 입력 등을 위한 폼 {@link concepts.layouts 레이아웃}을 표시하는 {@link concepts.form_panel 패널}.
     * <br>
     * {@link DListOptions.formPanel} 속성으로 접근한다.
     * <br>
     * 주로 리스트 헤더 아래 컨트롤 상단에 표시되지만,
     * {@link position} 속성으로 표시 위지를 지정할 수 있다.
     *
     * ```
     *  list.setConfig({
     *      options: {
     *          formPanel: {
     *              template: 'addr_form',
     *              position: 'top',
     *              size: '75%',
     *              ...
     *          }
     *      }
     *  });
     * ```
     *
     * @see concepts.form_panel 폼 패널 개요
     * @see DListSearchPanel
     * @see DListFilterPanel
     * @see DListButtonPanel
     */
    class DListFormPanel extends DListDialogPanel {
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * Layout {@link concepts.templates template} 이름.
         * <br>
         */
        get template() {
            return this.$_c.template();
        }
        set template(value) {
            this.$_c.setTemplate(value);
        }
    }
    /**
     * 하나 이상의 버튼들이 팝업으로 표시되는 버튼 패널에 대한 설정 모델.
     * <br>
     * {@link DListOptions.buttonPanel} 속성으로 접근한다.
     * <br>
     * 주로 리스트 헤더 아래 컨트롤 상단에 표시되지만,
     * {@link position} 속성으로 표시 위지를 지정할 수 있고,
     * {@link arrange} 속성으로 버튼들의 배치 방식들 다르게 할 수도 있다.
     *
     * @see concepts.button_panel 버튼 패널 개요
     * @see DListSearchPanel
     * @see DListFormPanel
     */
    class DListButtonPanel extends DListButtonPanelBase {
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * 버튼 배치 방식.
         *
         * @default DListButtonArrange.AUTO
         */
        get arrange() {
            return this.$_c.arrange();
        }
        set arrange(value) {
            this.$_c.setArrange(value);
        }
        /**
         * 버튼들의 위치.
         */
        get align() {
            return this.$_c.align();
        }
        set align(value) {
            this.$_c.setAlign(value);
        }
    }
    /**
     * 검색어 입력 창과 검색 옵션들을 표시하는 {@link concepts.search#search-panel 검색 패널}에 대한 설정 모델.
     * <br>
     * {@link DListOptions.searchPanel} 속성으로 접근한다.
     * <br>
     * 주로 리스트 헤더 아래 컨트롤 상단에 표시되지만,
     * {@link position} 속성으로 표시 위지를 지정할 수 있고,
     * {@link display} 속성으로 버튼들의 배치 방식들 다르게 할 수도 있다.

     * @see concepts.search 검색 개요
     * @see concepts/options 컨트롤 Options
     * @see DListSearchBar
     * @see DListSearchResultBar
     */
    class DListSearchPanel extends DListDialogPanel {
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * panel 항목 배치 방식.
         * <br>
         *
         * 기본값 auto로 지정하면 panel {@link position 표시 위치}와 기기 방향에 따라 자동 결정된다.
         *
         * @default DListSearchPanelDisplay.AUTO
         */
        get display() {
            return this.$_c.display();
        }
        set display(value) {
            this.$_c.setDisplay(value);
        }
        /**
         * '대소문자 구분' 체크 상자 label
         * <br>
         *
         * @default '대소문자 구분'
         */
        get matchCaseLabel() {
            return this.$_c.matchCaseLabel();
        }
        set matchCaseLabel(value) {
            this.$_c.setMatchCaseLabel(value);
        }
        /**
         * '전체 단어 일치' 체크 상자 label.
         * <br>
         *
         * @default '전체 단어 일치'
         */
        get wholeWordLabel() {
            return this.$_c.wholeWordLabel();
        }
        set wholeWordLabel(value) {
            this.$_c.setWholeWordLabel(value);
        }
        /**
         * '정규식 검색' 체크 상자 label.
         * <br>
         *
         * @default '정규식 사용'
         */
        get regExpLabel() {
            return this.$_c.regExpLabel();
        }
        set regExpLabel(value) {
            this.$_c.setRegExpLabel(value);
        }
        /**
         * '다음 찾기' radio 버튼 label.
         * <br>
         *
         * @default '다음 찾기'
         */
        get searchNextLabel() {
            return this.$_c.searchNextLabel();
        }
        set searchNextLabel(value) {
            this.$_c.setSearchNextLabel(value);
        }
        /**
         * '모두 찾기' radio 버튼 label.
         * <br>
         *
         * @default '모두 찾기'
         */
        get searchAllLabel() {
            return this.$_c.searchAllLabel();
        }
        set searchAllLabel(value) {
            this.$_c.setSearchAllLabel(value);
        }
        /**
         * 줄 사이 간격을 픽셀 단위로 지정한다.
         * <br>
         *
         * @default 10
         */
        get lineGap() {
            return this.$_c.lineGap();
        }
        set lineGap(value) {
            this.$_c.setLineGap(value);
        }
        /**
         * '모두 검색' 설정일 때 {@link DListSearchResultBar 결과 view}가 표시되는 데, 검색 결과가 0건이어도 표시한다.
         *
         * @default false
         */
        get alwaysResult() {
            return this.$_c.alwaysResult();
        }
        set alwaysResult(value) {
            this.$_c.setAlwaysResult(value);
        }
    }
    /**
     * 필터 목록을 표시하는 {@link concepts.filtering#filter-panel Filter 패널}에 대한 설정 모델.
     * <br>
     * {@link DListOptions.filterPanel} 속성으로 접근한다.
     * <br>
     * 주로 리스트 헤더 아래 컨트롤 상단에 표시되지만,
     * {@link position} 속성으로 표시 위지를 지정할 수 있고,
     * {@link display} 속성으로 버튼들의 배치 방식들 다르게 할 수도 있다.
     *
     * ```
     *  list.setConfig({
     *      options: {
     *          filterPanel: {
     *              cancelLabel: '취소',
     *              okLabel: '적용'
     *          }
     *      }
     *  });
     * ```
     *
     * @see concepts.filter 필터링 개요
     * @see concepts/options 컨트롤 Options
     * @see DListSearchPanel
     */
    class DListFilterPanel extends DListDialogPanel {
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * true로 설정하면 '실행', '취소' 버튼이 표시되지 않고,
         * 필터 항목이 변경될 때 자동으로 필터 설정을 반영한다.
         * <br>
         * //TODO: exclusive 상태가 아니면 'close' 버튼을 표시하고, 항목 변경은 리스트에 바로 반영한다.
         */
        get autoApply() {
            return this.$_c.autoApply();
        }
        set autoApply(value) {
            this.$_c.setAutoApply(value);
        }
    }
    /**
     * 행 그룹 header 설정 모델.
     * <br>
     * {@link DListRowGroupOptions.header} 속성으로 사용된다.
     * {@link templates.it_group_header '@it_group_header'}가 기본 템플릿이다.
     *
     * ```
     *  list.setConfig({
     *      options: {
     *          rowGroup: {
     *              rowIndents: 'inner',
     *              header: {
     *                  collapsedVisible: true
     *              }
     *          }
     *      }
     *  });
     * ```
     *
     * @see concepts.row_grouping 행 그룹핑
     * @see DListGroupFooter
     * @see DListHeader
     */
    class DListGroupHeader extends DWrapper {
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * visible.
         */
        get visible() {
            return this.$_c.visible;
        }
        set visible(value) {
            this.$_c.setVisible(value);
        }
        /**
         * visible when collapsed.
         */
        get collapsedVisible() {
            return this.$_c.collapsedVisible;
        }
        set collapsedVisible(value) {
            this.$_c.setCollapsedVisible(value);
        }
        /**
         * template
         */
        get template() {
            return this.$_c.template;
        }
        set template(value) {
            this.$_c.setTemplate(value);
        }
        /**
         * click action
         */
        get clickAction() {
            return this.$_c.clickAction();
        }
        set clickAction(value) {
            this.$_c.setClickAction(value);
        }
    }
    /**
     * 행 그룹 footer 설정 모델.
     * <br>
     * {@link DListRowGroupOptions.footer} 속성으로 사용된다.
     * {@link templates.it_group_footer '@it_group_footer'}가 기본 템플릿이다.
     *
     * ```
     *  list.setConfig({
     *      options: {
     *          rowGroup: {
     *              rowIndents: 'inner',
     *              footer: {
     *                  collapsedVisible: true
     *              }
     *          }
     *      }
     *  });
     * ```
     *
     * @see concepts.row_grouping 행 그룹핑
     * @see DListGroupHeader
     * @see DListFooer
     */
    class DListGroupFooter extends DListGroupHeader {
    }
    class DListGroupOptions extends DWrapper {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(c) {
            super();
            c.setWrapper(this);
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * 테마.
         */
        get theme() {
            return this.$_c.theme();
        }
        set theme(value) {
            this.$_c.setTheme(value);
        }
        /**
         * 데이터행을 들여쓰기 하는 방식.
         *
         * @default DListRowIndents.GROUP
         */
        get rowIndents() {
            return this.$_c.rowIndents();
        }
        set rowIndents(value) {
            this.$_c.setRowIndents(value);
        }
        /**
         * {@link rowIndents}가 {@link DListRowIndents.INNER}일 때 들여쓰기 픽셀 크기.
         */
        get indent() {
            return this.$_c.indent();
        }
        set indent(value) {
            this.$_c.setIndent(value);
        }
    }
    /**
     * {@link concepts.row_grouping 행 그룹핑} 설정 모델.
     * <br>
     * {@link DListOptions.rowGroup} 설정 모델로 사용한다.
     * <br>
     * {@link DListControl.rowGroupBy}를 호출해서 행 그룹핑한다.
     *
     * @see concepts.row_grouping 행 그룹핑 개요
     * @see concepts.data_grouping Data 그룹핑 개요
     */
    class DListRowGroupOptions extends DListGroupOptions {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(c) {
            super(c);
            this._header = c.header().createWrapper(DListGroupHeader);
            this._footer = c.footer().createWrapper(DListGroupFooter);
            this._expander = c.expander().createWrapper(DListRowExpander);
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * 그룹 헤더 모델.
         */
        get header() {
            return this._header;
        }
        /**
         * 그룹 footer 모델.
         */
        get footer() {
            return this._footer;
        }
        /**
         * 그룹 expander 모델.
         */
        get expander() {
            return this._expander;
        }
        /**
         * 데이터행을 들여쓰기 하는 방식.
         */
        get groupIndent() {
            return this.$_c.groupIndent();
        }
        set groupIndent(value) {
            this.$_c.setGroupIndent(value);
        }
        /**
         * row end margin.
         */
        get endMargin() {
            return this.$_c.endMargin();
        }
        set endMargin(value) {
            this.$_c.setEndMargin(value);
        }
    }
    /**
     * 데이터 그룹핑 설정 모델.
     * <br>
     *
     * @see concepts.data_grouping Data 그룹핑 개요
     */
    class DListDataGroupOptions extends DListGroupOptions {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(c) {
            super(c);
            this._expander = c.expander().createWrapper(DListRowExpander);
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * 데이터 그룹을 펼치거나 접는 핸들에 대한 설정 모델.
         * <br>
         */
        get expander() {
            return this._expander;
        }
    }
    class DListRowInfos extends DWrapper {
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        getInfo(dataName) {
            return this.$_c.getInfo(dataName);
        }
        setInfo(dataName, info) {
            this.$_c.setInfo(dataName, info);
        }
        setInfos(infos) {
            this.$_c.setInfos(infos);
        }
        setMaster(info) {
            this.$_c.setMaster(info);
        }
    }
    /**
     * 데이터행 view의 아래나 오른쪽(수평 모드일 때)에 표시되는 경계선에 대한 설정 모델.
     * <br>
     * {@link DListRow.borderLine} 속성으로 설정한다.
     *
     * @see concepts.data_row 데이터행 개요
     */
    class DListRowBorderLine extends DWrapper {
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * 표시 여부.
         * <br>
         *
         * @default true
         */
        get visible() {
            return this.$_c.visible();
        }
        set visible(value) {
            this.$_c.setVisible(value);
        }
        /**
         * 보더 line css 스타일.
         * <br>
         * '1px solid gray' 처럼 css border 스타일 방식으로 설정한다.
         * 이 속성을 지정하지 않으면 '.dlist-root' css 클래스에 선언된 '--dl-row-border-line' 스타일이 적용된다.
         */
        get style() {
            return this.$_c.style();
        }
        set style(value) {
            this.$_c.setStyle(value);
        }
        /**
         * 마스터행의 보더 line css 스타일.
         * <br>
         * '1px solid gray' 처럼 css border 스타일 방식으로 설정한다.
         * 이 속성을 지정하지 않으면 '.dlist-root' css 클래스에 선언된 '--dl-masterw-border-line' 스타일이 적용된다.
         */
        get masterStyle() {
            return this.$_c.masterStyle();
        }
        set masterStyle(value) {
            this.$_c.setMasterStyle(value);
        }
        /**
         * 데이터행 시작 부분 들여쓰기 방식.
         * <br>
         */
        get nearIndent() {
            return this.$_c.nearIndent();
        }
        set nearIndent(value) {
            this.$_c.setNearIndent(value);
        }
        /**
         * 데이터행 끝 부분 들여쓰기 방식.
         * <br>
         */
        get farIndent() {
            return this.$_c.farIndent();
        }
        set farIndent(value) {
            this.$_c.setFarIndent(value);
        }
        /**
         * true면 마지막행에는 표시하지 않는다.
         * <br>
         */
        get skipLast() {
            return this.$_c.skipLast();
        }
        set skipLast(value) {
            this.$_c.setSkipLast(value);
        }
        /**
         * true면 행 그룹핑일 때, 그룹 footer와 붙어 있는 데이터행에는 표시하지 않는다.
         * <br>
         */
        get skipGroupLast() {
            return this.$_c.skipGroupLast();
        }
        set skipGroupLast(value) {
            this.$_c.setSkipGroupLast(value);
        }
        /**
         * 데이터그룹에 연결된 경우 마지막 level의 detail 행들에만 표시.
         * <br>
         * 이 속성이 true이고 {@link skipGroupLast}가 true이면 master 행과 붙어있는 leaf 행에는 표시하지 않는다.
         */
        get leafOnly() {
            return this.$_c.leafOnly();
        }
        set leafOnly(value) {
            this.$_c.setLeafOnly(value);
        }
    }
    /**
     * Focus 데이터행 위에 표시되는 mask 관련 속성 모델.
     * <br>
     * {@link DListRow.focusMask} 속성으로 설정한다.
     *
     * @see concepts.data_row 데이터행 개요
     */
    class DListRowFocusMask extends DWrapper {
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * 표시 여부.
         * <br>
         *
         * @default true
         */
        get visible() {
            return this.$_c.visible();
        }
        set visible(value) {
            this.$_c.setVisible(value);
        }
        /**
         * 데이터행 시작 부분 들여쓰기 방식.
         * <br>
         */
        get nearIndent() {
            return this.$_c.nearIndent();
        }
        set nearIndent(value) {
            this.$_c.setNearIndent(value);
        }
        /**
         * 데이터행 끝 부분 들여쓰기 방식.
         * <br>
         */
        get farIndent() {
            return this.$_c.farIndent();
        }
        set farIndent(value) {
            this.$_c.setFarIndent(value);
        }
    }
    class DListRowPageHeader extends DListHeader {
    }
    /**
     * {@link DListRowInfoPage Info 뷰}와 {@link DListRowEditPage 편집 뷰} 등의 기반 클래스.
     *
     * @see concepts.info_page 행 정보 페이지 개요
     * @see concepts.edit_page 행 편집 페이지 개요
     * @see concepts.templates 템플릿 개요
     * @see concepts.layouts 레이아웃 개요
     */
    class DListRowPage extends DWrapper {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(c) {
            super();
            c.setWrapper(this);
            this._header = this._createHeader(c);
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * header
         */
        get header() {
            return this._header;
        }
        /**
         * true로 지정되면, layout 계산 크기가 list 본체 영역보다 작을 때 본체 영역 크기에 맞춘다.
         * 계산 크기가 넘치면 이 속성과 상관 없이 스크롤 시킨다.
         */
        get fitSize() {
            return this.$_c.fitSize();
        }
        set fitSize(value) {
            this.$_c.setFitSize(value);
        }
        /**
         * RowList view 스타일셋 혹은 className.
         */
        get style() {
            return this.$_c.style();
        }
        set style(value) {
            this.$_c.setStyle(value);
        }
        /**
         * show/hide animation effect duration.
         */
        get effectDuration() {
            return this.$_c.effectDuration();
        }
        set effectDuration(value) {
            this.$_c.setEffectDuration(value);
        }
        /**
         * Row page view's row layout template name.
         */
        get template() {
            return this.$_c.template();
        }
        set template(value) {
            this.$_c.setTemplate(value);
        }
        /**
         * 페이지가 애니메이션으로 표시될 때 드러나는 방향.
         */
        get showDirection() {
            return this.$_c.showDirection();
        }
        set showDirection(value) {
            this.$_c.setShowDirection(value);
        }
        /**
         * 페이지가 애니메이션으로 숨겨질 때 감춰지는 방향.
         */
        get hideDirection() {
            return this.$_c.hideDirection();
        }
        set hideDirection(value) {
            this.$_c.setHideDirection(value);
        }
        /**
         * 자동 생성 템플릿에 모든 필드를 포함시킨다.
         */
        get allFields() {
            return this.$_c.allFields();
        }
        set allFields(value) {
            this.$_c.setAllFields(value);
        }
        /**
         * 자동 생성 템플릿에 포함될 {@link IListRowViewField 필드} 목록.
         * <br>
         * 각 필드에는 표시 설정 정보들이 포함된다.
         * 이 목록에 포함되지 않은 필드들은 {@link allFields} 설정에 따라 표시 여부가 결정된다.
         */
        get fields() {
            return this.$_c.fields();
        }
        set fields(value) {
            this.$_c.setFields(value);
        }
        /**
         * 자동 생성 템플릿의 **vars**로 설정된다.
         * 즉, 여기에 설정된 값들은 {@link fields}에 추가되는 필드들의 style, renderer 설정에
         * **'--'** prefix를 추가해서 사용할 수 있다.
         *
         * @see concepts.templates 템플릿 개요
         */
        get templateVars() {
            return this.$_c.templateVars();
        }
        set templateVars(value) {
            this.$_c.setTemplateVars(value);
        }
        /**
         * 자동 생성 템플릿의 {@link concepts.templates Template} Params.
         */
        get templateParams() {
            return this.$_c.templateParams2();
        }
        set templateParams(value) {
            this.$_c.setTemplateParams2(value);
        }
    }
    class DListRowInfoPageHeader extends DListRowPageHeader {
    }
    /**
     * 데이터행 상세 정보 페이지 모델.
     * <br>
     * {@link DListOptions.infoPage} 속성으로 접근한다.
     *
     * ```
     *  list.setConfig({
     *      options: {
     *          infoPage: {
     *              header: { caption: '요소수 정보' },
     *              viewType: 'B',
     *              showDirection: 'right'
     *          }
     *      }
     *  });
     * ```
     *
     * @see concepts.info_page 행 정보 페이지 개요
     * @see concepts.edit_page 편집 페이지 개요
     * @see DListRowEditPage
     */
    class DListRowInfoPage extends DListRowPage {
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(c) {
            super(c);
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * viwe type.
         */
        get viewType() {
            return this.$_c.viewType();
        }
        set viewType(value) {
            this.$_c.setViewType(value);
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _createHeader(page) {
            return page.header().createWrapper(DListRowInfoPageHeader);
        }
    }
    class DListRowEditPageHeader extends DListRowPageHeader {
    }
    /**
     * 데이터행 편집 페이지 모델.
     * <br>
     * {@link DListOptions.editPage} 속성으로 접근한다.
     *
     * @see concepts.edit_page 편집 페이지 개요
     * @see concepts.info_page 행 정보 페이지 개요
     * @see DListRowInfoPage
     */
    class DListRowEditPage extends DListRowPage {
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(c) {
            super(c);
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * 페이지 뷰 템플릿 종류.
         * <br>
         *
         * @default DListEditPageType.DEFAULT
         */
        get viewType() {
            return this.$_c.viewType();
        }
        set viewType(value) {
            this.$_c.setViewType(value);
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _createHeader(page) {
            return page.header().createWrapper(DListRowEditPageHeader);
        }
    }
    /**
     * {@link concepts.single_row Single Row} 모드에서 데이행을 자동 이동시키는 설정 모델.
     * <br>
     * {@link DListSingleRow.autoScroll} 속성으로 사용된다.
     */
    class DListSingleRowScroll extends DListAutoScroll {
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * 행 이동시 효과.
         * <br>
         */
        get changeEffect() {
            return this.$_c.changeEffect();
        }
        set changeEffect(value) {
            this.$_c.setChangeEffect(value);
        }
    }
    /**
     * 리스트 컨트롤 전체를 데이터행 하나로 채우는 표시 방식 설정 모델.
     * <br>
     * {@link DListOptions.singleRow} 속성 모델로 사용된다.
     * <br>
     * 데이터행 내용이 컨트를 크기 범위를 벗어나면 스크롤된다.
     * {@link DListRenderModel.FULL full 모드}에서는 데이터행 내용에 맞게 높이가 조정된다.
     *
     * @see concepts.single_row Single Row 개요
     */
    class DListSingleRow extends DWrapper {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(row) {
            super();
            row.setWrapper(this);
            this._autoScroll = row.autoScroll().createWrapper(DListSingleRowScroll);
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * single row 표시 여부.
         * <br>
         *
         * @default false
         */
        get visible() {
            return this.$_c.visible();
        }
        set visible(value) {
            this.$_c.setVisible(value);
        }
        /**
         * 데이터행 레이아웃 자식들의 크기 합이 레이아웃 크기보다 클 때에도 shrink하지 않는다.
         * <br>
         * 데이터행 내용이 화면을 넘치면 스크롤되게 한다.
         *
         * @default true
         */
        get noShrink() {
            return this.$_c.noShrink();
        }
        set noShrink(value) {
            this.$_c.setNoShrink(value);
        }
        /**
         * 데이터행 변경 시 숨겨진 행 mask 효과.
         *
         * @default true
         */
        get maskEffect() {
            return this.$_c.maskEffect();
        }
        set maskEffect(value) {
            this.$_c.setMaskEffect(value);
        }
        /**
         * @noimpl
         *
         * true이고 rowTemplate의 brief 템플릿이 설정되면 상단에 표시.
         * <br>
         * 이 행을 클릭하면 이 행으로 이동.
         *
         * @default false
         */
        get showPrev() {
            return this.$_c.showPrev();
        }
        set showPrev(value) {
            this.$_c.setShowPrev(value);
        }
        /**
         * @noimpl
         *
         * true이고 rowTemplate의 brief 템플릿이 설정되면 하단에 표시.
         * <br>
         * 이 행을 클릭하면 이 행으로 이동.
         *
         * @default false
         */
        get showNext() {
            return this.$_c.showNext();
        }
        set showNext(value) {
            this.$_c.setShowNext(value);
        }
        /**
         * swipe 제스처로 행 이동 시 방향.
         * <br>
         *
         * @default DRowChangeDirection.DEFAULT
         */
        get rowChangeDir() {
            return this.$_c.rowChangeDir();
        }
        set rowChangeDir(value) {
            this.$_c.setRowChangeDir(value);
        }
        /**
         * @noimpl
         *
         * 행 이동 navigator. 필요한가?
         */
        get rowNavigator() {
            return this.$_c.rowNavigator();
        }
        set rowNavigator(value) {
            this.$_c.setRowNavigator(value);
        }
        /**
         * 이 속성이 true가 아니면 리스트 rowBorder.visible이 true이어도
         * single row 모드일 때 행 bottom/right 라인이 표시되지 않는다.
         * <br>
         *
         * @default false
         */
        get rowBorderVisible() {
            return this.$_c.rowBorderVisible();
        }
        set rowBorderVisible(value) {
            this.$_c.setRowBorderVisible(value);
        }
        /**
         * 자동 스크롤 설정 모델.
         * <br>
         */
        get autoScroll() {
            return this._autoScroll;
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doAssignProps(source) {
            if (typeof source === 'boolean') {
                this.$_c.setVisible(source);
                return true;
            }
        }
    }
    /**
     * {@link DListControl 리스트 컨트롤}이 {@link DListControl.paging paging} 상태가 아닐 때,
     * 마지막 데이터행 다음에 추가되는 첨부 행 영역에 대한 설정 모델.
     *
     * (주의)
     * {@link visible}이 true이고 {@link DListControl.scrollToEnd}(-1)를 호출했을 때 표시된다.
     * 또, {@link DListControl.setDataAppending}(true)를 호출해서
     * {@link DListControl.dataAppending}이 true가 되어 로딩 스피너를 표시하거나,
     * {@link rowTemplate}을 지정해야 표시된다.
     *
     * @see concepts.attached_row Attached Row 개요
     */
    class DListAttachedRow extends DWrapper {
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * 행 표시 여부.
         */
        get visible() {
            return this.$_c.visible();
        }
        set visible(value) {
            this.$_c.setVisible(value);
        }
        /**
         * 행 다음(아래쪽이나 오른쪽)에 추가되는 여분의 공간.
         */
        get endSpace() {
            return this.$_c.endSpace();
        }
        set endSpace(value) {
            this.$_c.setEndSpace(value);
        }
        /**
         * 표시할 행 템플릿.
         */
        get rowTemplate() {
            return this.$_c.rowTemplate();
        }
        set rowTemplate(value) {
            this.$_c.setRowTemplate(value);
        }
        /**
         * 리스트컨트롤이 setDataAppending을 통해 행 추가 모드로 설정될 때 표시되는 인디케이터 표시 여부.
         */
        get indicatorVisible() {
            return this.$_c.indicatorVisible();
        }
        set indicatorVisible(value) {
            this.$_c.setIndicatorVisible(value);
        }
        /**
         * 인디케이터 모양.
         */
        get indicatorType() {
            return this.$_c.indicatorType();
        }
        set indicatorType(value) {
            this.$_c.setIndicatorType(value);
        }
        /**
         * 인디케이터 지름.
         */
        get indicatorSize() {
            return this.$_c.indicatorSize();
        }
        set indicatorSize(value) {
            this.$_c.setIndicatorSize(value);
        }
        /**
         * 인디케이터 경계 여백 크기.
         */
        get indicatorMargin() {
            return this.$_c.indicatorMargin();
        }
        set indicatorMargin(value) {
            this.$_c.setIndicatorMargin(value);
        }
        /**
         * template으로 부터 layout이 생성될 때 template param 들의 값 목록.
         * {@link paramCallback}으로 전달되는 값이 더 우선한다.
         */
        get layoutParams() {
            return this.$_c.layoutParams();
        }
        set layoutParams(value) {
            this.$_c.setLayoutParams(value);
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        _doAssignProps(source) {
            if (typeof source === 'boolean') {
                this.$_c.setVisible(source);
                return true;
            }
        }
    }
    /**
     * 레이아웃 템플릿으로 페이지가 구성되는 모델 base.
     * <br>
     *
     * @see concepts.layouts Layout 개요
     * @see concepts.templates Template 개요
     * @see concepts.loading_page Loading Page
     * @see concepts.empty_page Empty Page
     */
    class DListLayoutedPage extends DWrapper {
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * 기본값 대신 사용되는 페이지 레이아웃 템플릿 이름.
         * <br>
         */
        get template() {
            return this.$_c.template();
        }
        set template(value) {
            this.$_c.setTemplate(value);
        }
        /**
         * template 속성으로 사용자 템플릿을 지정한 경우 {@link concepts.templates#params param} 값들을 포함한 객체.
         * <br>
         */
        get templateParams() {
            return this.$_c.templateParams2();
        }
        set templateParams(value) {
            this.$_c.setTemplateParams2(value);
        }
    }
    /**
     * 원본 데이터행이 하나도 없는 경우 표시되는 페이지 설정 모델.
     * <br>
     * 즉, 필터링된 {@link DListDataView}의 데이터행이 비었더라도 원본에 데이터가 존재하면 이 페이지는 표시되지 않는다.
     * 하지만 {@link DListDataControl.alwaysEmptyPage}가 true로 설정되면 이 경우에도 페이지가 표시된다.
     * <br>
     * 페이지는 내장된 {@link templates.it_empty_page '@it_empty_page'} 템플릿이 기본적으로 사용되고,
     * {@link template} 설정으로 사용자 템플릿을 지정할 수 있다.
     * 기본 내장 템플릿이 적용된 경우 이 모델의 속성들을 지정해서 메시지나 버튼 라벨 등을 변경할 수 있다.
     *
     * ```
     *  list.setConfig({
     *      options: {
     *          emptyPage: {
     *              template: 'empty_template'
     *          }
     *      }
     *  });
     * ```
     *
     * @see concepts.empty_page Empty 페이지
     * @see concepts.loading_page Loading 페이지
     * @see concepts.attached_row Attached Row
     */
    class DListEmptyPage extends DListLayoutedPage {
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * message text visible
         */
        get messageVisible() {
            return this.$_c.messageVisible();
        }
        set messageVisible(value) {
            this.$_c.setMessageVisible(value);
        }
        /**
         * message text
         */
        get message() {
            return this.$_c.message();
        }
        set message(value) {
            this.$_c.setMessage(value);
        }
        /**
         * load button visible
         */
        get loadVisible() {
            return this.$_c.loadVisible();
        }
        set loadVisible(value) {
            this.$_c.setLoadVisible(value);
        }
        /**
         * load button label
         */
        get loadLabel() {
            return this.$_c.loadLabel();
        }
        set loadLabel(value) {
            this.$_c.setLoadLabel(value);
        }
        /**
         * load button click callback
         */
        get onLoadClick() {
            return this.$_c.onLoadClick();
        }
        set onLoadClick(value) {
            this.$_c.setOnLoadClick(value);
        }
    }
    /**
     * {@link DListControl.setDataLoading}을 호출해서 데이터 로딩 상태가 되면 표시되는 페이지 뷰 모델.
     * <br>
     * {@link DListOptions.loadingPage} 속성으로 사용된다.
     * 페이지는 내장된 {@link templates.it_loading_page '@it_loading_page'} 템플릿이 기본적으로 사용되고,
     * {@link template} 설정으로 사용자 템플릿을 지정할 수 있다.
     *
     * ```
     *  list.setConfig({
     *      options: {
     *          loadingPage: {
     *              template: 'load_template'
     *          }
     *      }
     *  });
     * ```
     *
     * @see concepts.loading_page Loading 페이지 개요
     * @see DListEmptyPage
     */
    class DListLoadingPage extends DListLayoutedPage {
    }

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * {@link @DListControl 리스트 컨트롤} 설정 모델 기반 클래스.
     * <br>
     *
     * @see concepts.options 컨트롤 Options
     */
    class DListOptionsBase extends DWrapper {
        //-------------------------------------------------------------------------
        // fields
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(c) {
            super();
        }
    }
    class DListHeadRows extends DListOptionsBase {
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * visible
         */
        get visible() {
            return this.$_c.visible();
        }
        set visible(value) {
            this.$_c.setVisible(value);
        }
        /**
         * position.
         */
        get position() {
            return this.$_c.position();
        }
        set position(value) {
            this.$_c.setPosition(value);
        }
        /**
         * data view.
         */
        get data() {
            return this._data;
        }
        set data(value) {
            if (value !== this._data) {
                this._data = value;
                this.$_c.setData(value && value['$_d']);
            }
        }
        /**
         * rows
         */
        get rows() {
            return this.$_c.rows();
        }
        set rows(value) {
            this.$_c.setRows(value);
        }
    }
    /**
     * {@link DListControl 리스트 컨트롤} 설정 모델.
     * <br>
     * 템플릿이 적용되는 영역은 portrait/landscape로 별도 지정할 수 있다.
     *
     * @see concepts.options 컨트롤 Options 개요
     */
    class DListOptions extends DListOptionsBase {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(c) {
            super(c);
            this._rowBar = new DListRowBar(c._rowBar);
            this._editBar = new DListEditBar(c._editBar);
            this._indexBar = c._indexBar.createWrapper(DListIndexBar);
            this._scrollIndicator = c._scrollIndicator.createWrapper(DListScrollIndicator);
            this._scrollBar = c._scrollBar.createWrapper(DListScrollBar);
            this._pageNavigator = new DListPageNavigator(c._pageNavigator);
            this._pageScroller = new DListPageScroller(c._pageScroller);
            this._commandBox = c._commandBox.createWrapper(DListCommandBox);
            this._selectionMask = c._selectionMask.createWrapper(DListSelectionMask);
            this._row = new DListRow(c.row());
            this._headRows = c.headRows().setWrapper(new DListHeadRows(c.headRows())); // c._headRows.createWrapper(DListHeadRows);
            this._header = c._header.createWrapper(DListHeader);
            this._footer = c._footer.createWrapper(DListFooter);
            this._searchBar = c._searchBar.createWrapper(DListSearchBar);
            this._searchResultBar = c._searchResultBar.createWrapper(DListSearchResultBar);
            this._fieldBar = c._fieldBar.createWrapper(DListFieldBar);
            this._fieldHeader = c._fieldHeader.createWrapper(DListFieldHeader);
            this._formPanel = c._formPanel.createWrapper(DListFormPanel);
            this._buttonPanel = c._buttonPanel.createWrapper(DListButtonPanel);
            this._searchPanel = c._searchPanel.createWrapper(DListSearchPanel);
            this._filterPanel = c._filterPanel.createWrapper(DListFilterPanel);
            this._rowGroup = new DListRowGroupOptions(c._rowGroup);
            this._dataGroup = new DListDataGroupOptions(c._dataGroup);
            this._rowInfos = c._dataRowInfos.createWrapper(DListRowInfos);
            this._infoPage = new DListRowInfoPage(c._infoPage);
            this._editPage = new DListRowEditPage(c._editPage);
            this._addPage = new DListRowEditPage(c._addPage);
            this._singleRow = new DListSingleRow(c._singleRow);
            this._attachedRow = c._attachedRow.createWrapper(DListAttachedRow);
            this._emptyPage = c._emptyPage.createWrapper(DListEmptyPage);
            this._loadingPage = c._loadingPage.createWrapper(DListLoadingPage);
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * Landscape인가?
         */
        get isLandScape() {
            return this.$_c.isLandscape();
        }
        /**
         * row 배치 방향.
         * {@link DListOrientation.VERTICAL}이면 행들을 위에서 아래로 수직 배치하고,
         * {@link DListOrientation.HORIZONTAL}이면 왼쪽에서 오른쪽으로 수평 배치한다.
         *
         * 수직 모드일 때는 모든 행의 최대 너비가 컨트롤의 너비로 고정되고,
         * 수평 모드일 때는 모든 행의 최대 높이가 컨트롤의 높이로 고정된다.
         * 즉, 수직 모드일 때는 좌우로 스크롤되지 않고,
         * 수평 모드일 때는 상하로 스크롤 되지 않는다.
         *
         * @default DListOrientation.VERTICAL
         */
        get orientation() {
            return this.$_c.orientation();
        }
        set orientation(value) {
            this.$_c.setOrientation(value);
        }
        /**
         * **'large'** 템플릿을 사용해야 하는 기준 화면 너비.
         * <br>
         * Tablet등 일반적의 모바일폰 크기보다 큰 화면에 대응하기 위해 'large' 템플릿을 별도로 작성할 수 있다.
         * 기본 template 대신 'large' 템플릿을 사용해야 하는 컨트롤의 기준 크기를 설정한다.
         * portrait 모드에서는 컨트롤 너비,
         * landscape에서는 높이를 기준으로 한다.
         * [주의] 크기는 기기의 물리적 픽셀 수가 아니라 브라우저가 제공하는 논리적 픽셀 수이다.
         */
        get largeSize() {
            return this.$_c.largeSize();
        }
        set largeSize(value) {
            this.$_c.setLargeSize(value);
        }
        /**
         * 수평모드일 때 한 행의 너비.
         *
         * @default undefined
         */
        get rowWidth() {
            return this.$_c.rowWidth();
        }
        set rowWidth(value) {
            this.$_c.setRowWidth(value);
        }
        /**
         * 수평모드일 때 한 행의 최소 너비.
         *
         * @default undefined
         */
        get minRowWidth() {
            return this.$_c.minRowWidth();
        }
        set minRowWidth(value) {
            this.$_c.setMinRowWidth(value);
        }
        /**
         * 수평모드일 때 한 행의 최대 너비.
         *
         * @default undefined
         */
        get maxRowWidth() {
            return this.$_c.maxRowWidth();
        }
        set maxRowWidth(value) {
            this.$_c.setMaxRowWidth(value);
        }
        /**
         * row count.
         */
        get rowCount() {
            return this.$_c.rowCount();
        }
        set rowCount(value) {
            this.$_c.setRowCount(value);
        }
        /**
         * level indent
         */
        get levelIndent() {
            return this.$_c.levelIndent();
        }
        set levelIndent(value) {
            this.$_c.setLevelIndent(value);
        }
        /**
         * 컨트롤에 등록된 기본 menu 이름.
         * <br>
         * {@link IListSectionButton 버튼} {@link IListSectionButton.action 액션}이
         * {@link DListSectionAction.MENU}일 때 버튼을 클릭하면 이 메뉴를 표시한다.
         * 또, {@link DListControl.showMenu} 호출 시 메뉴를 지정하지 않을 때도 이 메뉴가 표시된다.
         *
         * @see concepts.menu 메뉴 개요
         */
        get menu() {
            return this.$_c.menu();
        }
        set menu(value) {
            this.$_c.setMenu(value);
        }
        /**
         * {@link concepts.row_bar Row Bar} 설정 모델.
         */
        get rowBar() {
            return this._rowBar;
        }
        /**
         * {@link concepts.edit_bar Edit Bar} 설정 모델.
         */
        get editBar() {
            return this._editBar;
        }
        /**
         * @noimpl
         *
         * {@link concepts.index_bar Index Bar} 설정 모델.
         */
        get indexBar() {
            return this._indexBar;
        }
        /**
         * {@link concepts.scroll_indicator 스크롤 인디케이터} 설정 모델.
         */
        get scrollIndicator() {
            return this._scrollIndicator;
        }
        /**
         * {@link concepts.scroll_bar 스크롤 Bar} 설정 모델.
         */
        get scrollBar() {
            return this._scrollBar;
        }
        /**
         * {@link concepts.page_navigator 페이지 네비게이터} 설정 모델.
         */
        get pageNavigator() {
            return this._pageNavigator;
        }
        /**
         * @noimpl
         *
         * {@link concepts.page_scroller 페이지 스크롤러} 설정 모델.
         */
        get pageScroller() {
            return this._pageScroller;
        }
        /**
         * {@link concepts.command_box 커맨드 박스} 설정 모델.
         */
        get commandBox() {
            return this._commandBox;
        }
        // /**
        //  * selection mask.
        //  */
        // get selectionMask(): DListSelectionMask { 
        //     return this._selectionMask; 
        // }
        /**
         * @readonly
         *
         * {@link concepts.data_row 데이터행} 관련 설정 모델.
         * <br>
         */
        get row() {
            return this._row;
        }
        // /**
        //  * head rows.
        //  */
        // get headRows(): DListHeadRows { 
        //     return this._headRows; 
        // }
        /**
         * {@link concepts.header 리스트 헤더} 설정 모델.
         */
        get header() {
            return this._header;
        }
        /**
         * {@link concepts.footer 리스트 푸터} 설정 모델.
         */
        get footer() {
            return this._footer;
        }
        /**
         * 검색 bar.
         */
        get searchBar() {
            return this._searchBar;
        }
        /**
         * 검색 결과 표시 bar.
         */
        get searchResultBar() {
            return this._searchResultBar;
        }
        /**
         * 필드 목록 bar.
         */
        get fieldBar() {
            return this._fieldBar;
        }
        /**
         * 필드 헤더.
         */
        get fieldHeader() {
            return this._fieldHeader;
        }
        /**
         * {@link concepts.form_panel 폼 패널} 설정 모델.
         */
        get formPanel() {
            return this._formPanel;
        }
        /**
         * {@link concepts.button_panel 버튼 패널} 설정 모델.
         */
        get buttonPanel() {
            return this._buttonPanel;
        }
        /**
         * search panel.
         */
        get searchPanel() {
            return this._searchPanel;
        }
        /**
         * filter panel.
         */
        get filterPanel() {
            return this._filterPanel;
        }
        /**
         * {@link concepts.row_grouping 행 그룹핑} 설정 모델.
         */
        get rowGroup() {
            return this._rowGroup;
        }
        /**
         * {@link concepts.data_grouping Data 그룹핑} 설정 모델.
         */
        get dataGroup() {
            return this._dataGroup;
        }
        /**
         * row infos
         */
        get rowInfos() {
            return this._rowInfos;
        }
        /**
         * single row options.
         */
        get singleRow() {
            return this._singleRow;
        }
        /**
         * 데이터행 끝에 추가 표시되는 영역에 대한 설정 모델.
         */
        get attachedRow() {
            return this._attachedRow;
        }
        /**
         * Empty page 설정 모델.
         */
        get emptyPage() {
            return this._emptyPage;
        }
        /**
         * Loading page 설정 모델.
         */
        get loadingPage() {
            return this._loadingPage;
        }
        /**
         * 행 정보 페이지 설정 모델.
         */
        get infoPage() {
            return this._infoPage;
        }
        /**
         * 행 편집 page 설정 모델.
         */
        get editPage() {
            return this._editPage;
        }
        /**
         * Row add page options.
         */
        get addView() {
            return this._addPage;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        assign(source) {
            if (source) {
                this.assignProps(source);
                source.rowInfos && this._rowInfos.setInfos(source.rowInfos);
            }
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * {@link DListControl.options}로 생성되는 리스트 컨트롤 기본 옵션 객체이다.
     * <br>
     *
     * 컨트롤의 {@link DListControl.portrait portrait}, {@link DListControl.landsacape landsacape},
     * {@link DListControl.current current}를 이 객체 수준에서 접근할 수 있도록 하였다.
     *
     * ```
     * list.landscape.orientation = DListOrientation.HORIZONTAL;
     * // options 수준에서 접근한다.
     * list.options.landscape.orientation = DListOrientation.HORIZONTAL;
     * ```
     *
     * @see concepts.options 컨트롤 Options
     */
    class DListDefaultOptions extends DListOptions {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        constructor(c, owner, portrait, landscape) {
            super(c);
            this._owner = owner;
            this._portrait = portrait;
            this._landscape = landscape;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * {@link DListControl.portrait}와 동일하다.
         */
        get portrait() {
            return this._portrait;
        }
        /**
         * {@link DListControl.landscape}와 동일하다.
         */
        get landscape() {
            return this._landscape;
        }
        /**
         * {@link DListControl.current}와 동일하다.
         */
        get current() {
            return this._owner.current;
        }
    }
    function getGroupInfo(group) {
        return group && {
            _idx: group.header().index,
            level: group.level(),
            field: group.field(),
            value: group.value(),
            expanded: group.expanded()
        };
    }
    /**
     * @desc Dataludi mobile data list control.
     *
     * 컨트롤에 연결된 {@link data}에 포함된 데이터행들의 필드 값들을 각각 하나의 리스트 행 view에 다양한 방식으로 표시한다.
     * 데이터행 표시 외에 데이터행을 관리하고 상태를 표시하는 등의 여러 요소로 구성된다.
     * <br>
     * 컨트롤은 데이터와 뷰를 연결하고 관리하는 말 그대로 컨트롤러이다.
     * {@link data}의 변경 사항은 즉시 컨트롤에 반영되고, 컨트롤 UI를 통해 변경된 값들은 {@link data}에 반영된다.
     * <br>
     * 컨트롤은 생성자 대신 주로 모듈 함수를 호출해서 생성한다.
     *
     * @example
     *  dlist = DList.createList(document, 'dlist'); // 'dlist'는 div의 id.
     *  dlist.setConfig(config);    // 컨트롤 속성 및 옵션 설정
     *  dlist.data = data;          // 데이터 연결
     *
     * @see {@link concepts.features 주요 기능들}
     * @see DListOptions
     */
    class DListControl extends DWrapper {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        /**
         * @internal
         *
         * @param doc
         * @param container
         * @param renderMode
         */
        constructor(doc, container, renderMode = DListRenderMode.DEFAULT) {
            super();
            const c = new ListControl(doc, container, renderMode).setWrapper(this)['$_c'];
            this._current = this._portrait = c.portrait().setWrapper(new DListOptions(c.portrait()));
            this._landscape = c.landscape().setWrapper(new DListOptions(c.landscape()));
            this._options = c.options().setWrapper(new DListDefaultOptions(c.options(), this, this._portrait, this._landscape));
            c._orientationChanged = orientation => {
                this._current = this.$_c.current().isWrapper(this._landscape) ? this._landscape : this._portrait;
            };
        }
        destory() {
            this.$_c = this.$_c.destroy();
        }
        //-------------------------------------------------------------------------
        // events
        //-------------------------------------------------------------------------
        /**
         * @event
         *
         * 데이터행들이 스크롤돼서 표시되는 {@link topRow 시작 행}이 변경됐을 때 발생한다.
         * 드래그해서 스크롤하거나 {@link topRow} 속성을 직접 변경할 수도 있다.
         *
         * @eparam control 컨트롤 객체
         * @eparam top top index
         */
        get onScroll() {
            return this.$_c.onScroll;
        }
        set onScroll(value) {
            this.$_c.onScroll = value;
        }
        /**
         * @event
         *
         * 데이터행을 탭(클릭)할 때 발생한다.
         *
         * @eparam control 컨트롤 객체
         */
        get onRowClick() {
            return this.$_c.onRowClick;
        }
        set onRowClick(value) {
            this.$_c.onRowClick = value;
        }
        /**
         * @event
         *
         * 데이터행 길게 눌렀을 때 발생한다.
         *
         * @eparam control 컨트롤 객체
         */
        get onRowLongPress() {
            return this.$_c.onRowLongPress;
        }
        set onRowLongPress(value) {
            this.$_c.onRowLongPress = value;
        }
        /**
         * @event
         *
         * 데이터행을 좌우로 swipe할 때 발생한다.
         * 이벤트 콜백 내에서 매개변수로 전달된 객체의 cancel 속성을 true로 지정하면,
         * {@link rowSwipeAction}으로 설정한 기본 동작이 무시된다.
         *
         * @eparam control 컨트롤 객체
         */
        get onRowSwipe() {
            return this.$_c.onRowSwipe;
        }
        set onRowSwipe(value) {
            this.$_c.onRowSwipe = value;
        }
        /**
         * @event
         *
         * 데이터행에 표시 중인 버튼을 탭(클릭)했을 때 발생한다.
         *
         * @eparam control 컨트롤 객체
         */
        get onButtonClick() {
            return this.$_c.onButtonClick;
        }
        set onButtonClick(value) {
            this.$_c.onButtonClick = value;
        }
        /**
         * @event
         *
         * 데이터행의 checked 상태가 변경될 때 발생한다.
         *
         * @eparam control 컨트롤 객체
         */
        get onRowCheck() {
            return this.$_c.onRowCheck;
        }
        set onRowCheck(value) {
            this.$_c.onRowCheck = value;
        }
        /**
         * @event
         *
         * 여러 데이터행들의 checked 상태가 변경될 때 발생한다.
         *
         * @eparam control 컨트롤 객체
         */
        get onRowsCheck() {
            return this.$_c.onRowsCheck;
        }
        set onRowsCheck(value) {
            this.$_c.onRowsCheck = value;
        }
        /**
         * @event
         *
         * 모든 데이터행의 checked 상태가 같은 값으로 변경된 후 발생한다.
         *
         * @eparam control 컨트롤 객체
         */
        get onAllRowsCheck() {
            return this.$_c.onAllRowsCheck;
        }
        set onAllRowsCheck(value) {
            this.$_c.onAllRowsCheck = value;
        }
        /**
         * @event
         *
         * 데이터행의 자세히 보기가 표시되거나 감춰질 때 발생한다.
         *
         * @eparam control 컨트롤 객체
         */
        get onRowDetail() {
            return this.$_c.onRowDetail;
        }
        set onRowDetail(value) {
            this.$_c.onRowDetail = value;
        }
        /**
         * @event
         *
         * 여러 데이터행들의 자세히 보기가 같은 상태로 변경될 때 발생한다.
         *
         * @eparam control 컨트롤 객체
         */
        get onRowsDetail() {
            return this.$_c.onRowsDetail;
        }
        set onRowsDetail(value) {
            this.$_c.onRowsDetail = value;
        }
        /**
         * @event
         *
         * 모든 데이터행들의 자세히 보기가 같은 상태로 변경될 때 발생한다.
         *
         * @eparam control 컨트롤 객체
         */
        get onAllRowsDetail() {
            return this.$_c.onAllRowsDetail;
        }
        set onAllRowsDetail(value) {
            this.$_c.onAllRowsDetail = value;
        }
        /**
         * @event
         *
         * 행 flag가 변경될 때 발생한다.
         *
         * @eparam control 컨트롤 객체
         */
        get onRowFlagChange() {
            return this.$_c.onRowFlagChange;
        }
        set onRowFlagChange(value) {
            this.$_c.onRowFlagChange = value;
        }
        /**
         * @event
         *
         * 복수 행의 flag가 같은 상태로 변경될 때 발생한다.
         *
         * @eparam control 컨트롤 객체
         */
        get onRowsFlagChange() {
            return this.$_c.onRowsFlagChange;
        }
        set onRowsFlagChange(value) {
            this.$_c.onRowsFlagChange = value;
        }
        /**
         * @event
         *
         * 모든 행의 flag가 같은 상태로 변경될 때 발생한다.
         *
         * @eparam control 컨트롤 객체
         */
        get onAllRowsFlagChange() {
            return this.$_c.onAllRowsFlagChange;
        }
        set onAllRowsFlagChange(value) {
            this.$_c.onAllRowsFlagChange = value;
        }
        /**
         * @event
         *
         * 데이터행이 하나 이상 선택됐을 때 발생한다.
         *
         * @eparam control 컨트롤 객체
         */
        get onSelectionAdd() {
            return this.$_c.onSelectionAdd;
        }
        set onSelectionAdd(value) {
            this.$_c.onSelectionAdd = value;
        }
        /**
         * @event
         *
         * 기존 행 선택이 제거될 때 발생한다.
         *
         * @eparam control 컨트롤 객체
         */
        get onSelectionClear() {
            return this.$_c.onSelectionClear;
        }
        set onSelectionClear(value) {
            this.$_c.onSelectionClear = value;
        }
        /**
         * @event
         *
         * 행 선택 범위가 변경될 때 발생한다.
         *
         * @eparam control 컨트롤 객체
         */
        get onSelectionResize() {
            return this.$_c.onSelectionResize;
        }
        set onSelectionResize(value) {
            this.$_c.onSelectionResize = value;
        }
        /**
         * @event
         *
         * 끝까지 스크롤돼서 마지막 데이터행이 표시되게 될 때 발생한다.
         *
         * @eparam control 컨트롤 객체
         */
        get onLastRowRevealed() {
            return this.$_c.onLastRowRevealed;
        }
        set onLastRowRevealed(value) {
            this.$_c.onLastRowRevealed = value;
        }
        /**
         * @event
         *
         * {@link concepts.row_grouping 그룹핑} 상태일 때,
         * 접힌 그룹이 펼쳐지기 전 호출되는 콜백.
         * false를 명시적으로 리턴하면 그룹이 펼쳐지지 않는다.
         *
         * @eparam control 컨트롤 객체
         * @eparam group 펼쳐지는 group 객체
         * @eparam cancel out true로 지정하면 펼쳐지지 않는다.
         */
        get onBeforeGroupExpand() {
            return this.$_c.onBeforeGroupExpand;
        }
        set onBeforeGroupExpand(value) {
            this.$_c.onBeforeGroupExpand = value;
        }
        /**
         * @event
         *
         * {@link concepts.row_grouping 그룹핑} 상태일 때,
         * 접힌 그룹이 펼쳐진 후 호출되는 콜백.
         *
         * @eparam control 컨트롤 객체
         */
        get onGroupExpand() {
            return this.$_c.onGroupExpand;
        }
        set onGroupExpand(value) {
            this.$_c.onGroupExpand = value;
        }
        /**
         * @event
         *
         * {@link concepts.row_grouping 그룹핑} 상태일 때,
         * 펼쳐진 그룹이 접히기 전 호출되는 콜백.
         * false를 명시적으로 리턴하면 그룹이 접히지 않는다.
         *
         * @eparam control 컨트롤 객체
         */
        get onBeforeGroupCollapse() {
            return this.$_c.onBeforeGroupCollapse;
        }
        set onBeforeGroupCollapse(value) {
            this.$_c.onBeforeGroupCollapse = value;
        }
        /**
         * @event
         *
         * {@link concepts.row_grouping 그룹핑} 상태일 때,
         * 펼쳐진 그룹이 접힌 후 호출되는 콜백.
         *
         * @eparam control 컨트롤 객체
         */
        get onGroupCollapse() {
            return this.$_c.onGroupCollapse;
        }
        set onGroupCollapse(value) {
            this.$_c.onGroupCollapse = value;
        }
        /**
         * @event
         *
         * {@link concepts.paging 페이징} 상태일 때,
         * 페이지가 변경되기 전에 호출되는 콜백.
         * false를 명시적으로 리턴하면 페이지가 변경되지 않는다.
         *
         * @eparam control 컨트롤 객체
         */
        get onBeforePageChange() {
            return this.$_c.onBeforePageChange;
        }
        set onBeforePageChange(value) {
            this.$_c.onBeforePageChange = value;
        }
        /**
         * @event
         *
         * {@link concepts.paging 페이징} 상태일 때,
         * 페이지가 변경된 후 호출되는 콜백.
         *
         * @eparam control 컨트롤 객체
         */
        get onPageChange() {
            return this.$_c.onPageChange;
        }
        set onPageChange(value) {
            this.$_c.onPageChange = value;
        }
        /**
         * @event
         *
         * 포커스 데이터행의 위치가 변경됐다.
         *
         * @eparam control 컨트롤 객체
         */
        get onFocusedRowChange() {
            return this.$_c.onFocusedRowChange;
        }
        set onFocusedRowChange(value) {
            this.$_c.onFocusedRowChange = value;
        }
        /**
         * @event
         *
         * 편집 뷰에서 사용작 입력 필드의 값을 변경하거나,
         * 콜백 내에서 다른 필드의 값을 직접 변경할 때 호출된다.
         *
         * @see {@link onEditCommit}
         *
         * @eparam control 컨트롤 객체
         */
        get onEditFieldChange() {
            return this.$_c.onEditFieldChange;
        }
        set onEditFieldChange(value) {
            this.$_c.onEditFieldChange = value;
        }
        /**
         * @event
         *
         * 편집 뷰를 완료할 때 호출된다.
         * 콜백에서 false를 리턴하면 완료가 중지된다.
         *
         * @see {@link onEditFieldChange}
         *
         * @eparam control 컨트롤 객체
         */
        get onEditCommit() {
            return this.$_c.onEditCommit;
        }
        set onEditCommit(value) {
            this.$_c.onEditCommit = value;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * @readonly
         *
         * 컨트롤 방향.
         * 이 속성에 따라 컨트롤의 표시 옵션들이 결정된다.
         */
        get orientation() {
            return this.$_c.orientation();
        }
        /**
         * 컨트롤 크기 변경에 따라 자동을 orientation을 설정한다.
         */
        get syncOrientation() {
            return this.$_c.syncOrientation();
        }
        set syncOrientation(value) {
            this.$_c.setSyncOrientation(value);
        }
        /**
         * @readonly
         *
         * 스크린 방향.
         * 이 속성에 따라 컨트롤의 표시 옵션들이 결정된다.
         */
        get screenOrientation() {
            return this.$_c.screenOrientation();
        }
        /**
         * syncOrientation이 true일 때,
         * 컨트롤 크기와 상관 없이 단말기 방향에 맞춰 orientation 속성을 자동 설정.
         */
        get syncScreenOrientation() {
            return this.$_c.syncScreenOrientation();
        }
        set screenSyncOrientation(value) {
            this.$_c.setScreenSyncOrientation(value);
        }
        /**
         * 컨트롤 생성 시 지정된 render 모드.
         * <br>
         */
        get renderMode() {
            return this.$_c.renderMode();
        }
        /**
         * [접근성] 정보.
         * 컨트롤 div의 aria-label 속성으로 사용된다.
         */
        get description() {
            return this.$_c.description();
        }
        set description(value) {
            this.$_c.setDescription(value);
        }
        /**
         * 이 리스트 컨트롤에 표시할 데이터행들이 포함된 데이터 객체.
         * <br>
         * {@link DListData}, {@link DListDataView}, 혹은 {@link DListDataLinkView}을 설정할 수 있다.
         * 대개 컨트롤 생성 등 초기화 시점에 연결해서 계속 사용된다.
         * 컨트롤은 연결된 데이터의 행들을 표시한다.
         *
         * ```
         * const data = DList.createData('data');
         * list.data = data;
         * ```
         *
         * @see concepts.data 데이터 모델 개요
         */
        get data() {
            return this._data;
        }
        set data(value) {
            if (value !== this._data) {
                this._data = value;
                this.$_c.setData(value ? value['$_d'] : null);
            }
        }
        /**
         * 기본 text to string callback formatter.
         * 이 속성이 설정되면 {@link textFormat}은 무시된다.
         */
        get textFormatter() {
            return this.$_c.textFormatter();
        }
        set textFormatter(value) {
            this.$_c.setTextFormatter(value);
        }
        /**
         * 기본 bool to string callback formatter.<br>
         * 이 속성이 설정되면 {@link boolFormat}은 무시된다.
         */
        get boolFormatter() {
            return this.$_c.boolFormatter();
        }
        set boolFormatter(value) {
            this.$_c.setBoolFormatter(value);
        }
        /**
         * 기본 number to string callback formatter.
         * 이 속성이 설정되면 {@link numberFormat}은 무시된다.
         */
        get numberFormatter() {
            return this.$_c.numberFormatter();
        }
        set numberFormatter(value) {
            this.$_c.setNumberFormatter(value);
        }
        /**
         * 기본 date to string callback formatter.
         * 이 속성이 설정되면 {@link dataFormat}은 무시된다.
         */
        get dateFormatter() {
            return this.$_c.dateFormatter();
        }
        set dateFormatter(value) {
            this.$_c.setDateFormatter(value);
        }
        /**
         * 기본 text to string format.
         * {@link textFormatter}가 설정되면 이 속성은 무시된다.
         */
        get textFormat() {
            return this.$_c.textFormat();
        }
        set textFormat(value) {
            this.$_c.setTextFormat(value);
        }
        /**
         * 기본 boolean to string format.<br>
         * {@link boolFormatter}가 설정되면 이 속성은 무시된다.
         */
        get boolFormat() {
            return this.$_c.boolFormat();
        }
        set boolFormat(value) {
            this.$_c.setBoolFormat(value);
        }
        /**
         * 기본 number to string format.<br>
         * {@link numberFormatter}가 설정되면 이 속성은 무시된다.
         */
        get numberFormat() {
            return this.$_c.numberFormat();
        }
        set numberFormat(value) {
            this.$_c.setNumberFormat(value);
        }
        /**
         * 기본 Date to string formatter.
         * {@link dateFormatter}가 설정되면 이 속성은 무시된다.
         */
        get dateFormat() {
            return this.$_c.dateFormat();
        }
        set dateFormat(value) {
            this.$_c.setDateFormat(value);
        }
        /**
         * @readonly
         *
         * 기본 option 객체.
         */
        get options() {
            return this._options;
        }
        /**
         * 공통 옵션 속성들을 동시에 설정한다.
         *
         * @param config 속성 설정 값들
         * @returns 컨트롤 객체 자신
         */
        setOptions(config) {
            config && this._options.assign(config);
            return this;
        }
        /**
         * @readonly
         *
         * portrait 상태일 때 options 객체.
         */
        get portrait() {
            return this._portrait;
        }
        /**
         * portrait 옵션 속성들을 동시에 설정한다.
         *
         * @param config 속성 설정 값들
         * @returns 컨트롤 객체 자신
         */
        setPortrait(config) {
            config && this._portrait.assign(config);
            return this;
        }
        /**
         * @readonly
         *
         * landscape 상태일 때 options 객체.
         */
        get landscape() {
            return this._landscape;
        }
        /**
         * landscape 옵션 속성들을 동시에 설정한다.
         *
         * @param config 속성 설정 값들
         * @returns 컨트롤 객체 자신
         */
        setLandscape(config) {
            config && this._landscape.assign(config);
            return this;
        }
        /**
         * @readonly
         *
         * 수평/수직 상태에 따른 현재 적용 중인 {@link DListOptions options} 객체.
         * <br>
         * 즉, 수평 모드이면 {@link landscape} 옵션이고,
         * 수직 모드이면 {@link portrait} 옵션이다.
         */
        get current() {
            return this._current;
        }
        /**
         * @readonly
         *
         * {@link data}가 설정되지 않거나 데이터행이 하나도 없으면 true.
         */
        get isEmpty() {
            return this.$_c.isEmpty();
        }
        /**
         * 현재 표시되는 시작(최상단) 데이터행 index.
         * <br>
         * 현재 표시되는 데이터행이 하나도 없다면 -1이다.
         */
        get topRow() {
            return this.$_c.topRow();
        }
        set topRow(value) {
            this.$_c.setTopRow(value);
        }
        /**
         * @readonly
         *
         * {@link concepts.row_grouping 행 그룹핑} 상태면 true.
         */
        get isRowGrouped() {
            return this.$_c.isRowGrouped();
        }
        /**
         * @readonly
         *
         * {@link concepts.paging 마스터&디테일 그룹핑} 상태면 true.
         */
        get isDataGrouped() {
            return this.$_c.isRowGrouped();
        }
        /**
         * @readonly
         *
         * {@link concepts.paging 페이징} 상태면 true.
         */
        get isPaging() {
            return this.$_c.isPaging();
        }
        /**
         * @readonly
         *
         * single row 상태면 true.
         */
        get isSingleRow() {
            return this.$_c.isSingleRow();
        }
        /**
         * @readonly
         *
         * {@link concepts.paging 페이징} 상태일 때,
         * 페이지 당 데이터행 수.
         */
        get pageSize() {
            return this.$_c.pageSize();
        }
        /**
         * @readonly
         *
         * {@link concepts.paging 페이징} 상태일 때,
         * 전체 페이지 개수.
         */
        get pageCount() {
            return this.$_c.pageCount();
        }
        /**
         * {@link concepts.paging 페이징} 상태일 때, 현재 페이지 인덱스.
         * <br>
         * 범위(0 ~ {@link pageCount} - 1)을 벗어나게 설정하면 범위 내로 조정된다.
         * 하지만, 페이징 상태가 아닐 때 이 속성을 설정하면 예외가 발생한다.
         */
        get page() {
            return this.$_c.page();
        }
        set page(value) {
            this.$_c.setPage(value);
        }
        /**
         * @readonly
         *
         * 등록되어 있는 데이터행 {@link concepts.command_box 커맨드 이름} 목록.
         * <br>
         * 라이브러리에서 미리 등록한 것들도 포함된다.
         */
        get registeredRowCommands() {
            return this.$_c.rowCommands().registeredCommands();
        }
        /**
         * @readonly
         *
         * {@link concepts.command_box Row command}가 표시되는 데이터행 번호.
         */
        get commandRow() {
            return this.$_c.commandRow();
        }
        /**
         * @readonly
         *
         * check된 행들의 개수.
         * <br>
         * {@link checkRow}나 {@link toggleChecked} 등으로 데이터행 checked 상태를 설절할 수 있다.
         */
        get checkedRowCount() {
            return this.$_c.checkedRowCount();
        }
        /**
         * <br> 태그를 줄바꿈으로 사용할 지 여부. renderer별로 별도 지정할 수도 있다.
         */
        get lineSeparator() {
            return this.$_c.lineSeparator();
        }
        set lineSeparator(value) {
            this.$_c.setLineSeparator(value);
        }
        /**
         * 기본 검색 옵션.
         * Search panel에서 사용자가 설정한 값들이 반영된다.
         * 단일 값처럼 적용해야 한다.
         * 즉, control.searchOptions.filtering = true 방식으로 설정해서는 안된다.
         * contro.searchOptions = { filtering: true } 로 설정해야 한다.
         */
        get searchOptions() {
            return Object.assign({}, this.$_c.searchOptions());
        }
        set searchOptions(value) {
            this.$_c.setSearchOptions(value);
        }
        /**
         * Fliing 스크롤 시 최상위 행이 중간에 걸치지 않도록 한다.
         *
         * @default false
         */
        get fitRowWhenScroll() {
            return this.$_c.fitRowWhenScroll;
        }
        set fitRowWhenScroll(value) {
            this.$_c.fitRowWhenScroll = value;
        }
        /**
         * 행 클릭 시 행이 모두 표시되게 한다.
         *
         * @default true
         */
        get fitRowWhenClick() {
            return this.$_c.fitRowWhenClick;
        }
        set fitRowWhenClick(value) {
            this.$_c.fitRowWhenClick = value;
        }
        /**
         * 스크롤 위치.
         */
        get scrollIndex() {
            return this.$_c.scrollIndex();
        }
        set scrollIndex(value) {
            this.$_c.setScrollIndex(value, 0);
        }
        /**
         * @readonly
         *
         * 데이터행 tap이나 {@link setFocusedRow} 호출로 focused 상태가 된 데이터행 번호.
         *
         * @see setFocusedRow
         */
        get focusedRow() {
            return this.$_c.focusedRow();
        }
        /**
         * @readonly
         *
         * true로 지정하면 loading 페이지가 표시된다.
         * 단 skeletionVisible이 true로 지정되면 loading 페이지 대신 skeleton view가 표시된다.
         */
        get dataLoading() {
            return this.$_c.isDataLoading();
        }
        /**
         * dataLoading 상태를 변경한다. 실제 변경되면 true를 리턴한다.
         */
        setDataLoading(value) {
            return this.$_c.setDataLoading(value);
        }
        /**
         * @readonly
         *
         * true로 지정하면 {@link concepts.attached_row attached row} 영역에 spinner가 표시된다.
         */
        get dataAppending() {
            return this.$_c.isDataAppending();
        }
        /**
         * dataAppending 상태를 변경한다. 실제 변경되면 true를 리턴한다.
         * appending, scroll 모두 true이면 마지막 행 다음에,
         * 행 추가 spinner가 표시되는 attached row가 표시되도록 마지막 행 끝까지 스크롤된다.
         *
         * @see concepts.attached_row
         * @see DListAttachedRow
         *
         * @param appending 추가 여부
         * @param scroll 끝까지 스크롤할 것인 지 여부
         */
        setDataAppending(appending, scroll = true) {
            return this.$_c.setDataAppending(appending, scroll);
        }
        /**
         * dataLoading이 true로 지정되고,
         * 이 속성이 true로 지정되면 skeleton view가 표시된다.
         */
        get skeletonVisible() {
            return this.$_c.skeletonVisible;
        }
        set skeletonVisible(value) {
            this.$_c.skeletonVisible = value;
        }
        /**
         * {@link concepts.empty_page Empty 페이지}는 {@link DListDataView 데이터뷰}의 필터링 상태와 상관없이
         * 원본 데이터가 비었을 때만 표시되지만, 이 속성을 true로 지정하면 필터링 후 표시할 데이터가 없는 경우에도 표시된다.
         */
        get alwaysEmptyPage() {
            return this.$_c.alwaysEmptyPage;
        }
        set alwaysEmptyPage(value) {
            this.$_c.alwaysEmptyPage = value;
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        /**
         * 지정한 설정 정보로 리스트 컨트롤을 초기 구성한다.
         * 정보의 모든 항목들은 개별 속성 api를 통해 별도로 설정할 수 있지만,
         * 하나의 설정 객체를 통해 보다 편리하게 리스트를 초기 구성할 수 있다.<br>
         * 크게 컨트롤 속성과 옵션 설정으로 나뉘는 데,
         * 옵션은 주로 컨트롤 구성 요소들에 대한 것으로,
         * 모바일 기기 상태에 따라 별도의 템플릿 설정이 필요한 것들이다.
         *
         * @example
         *  dlist = DList.createList(document, 'dlist');
         *  dlist.setConfig({
         *      props: {
         *          numberFormat: ',',
         *          templates: {
         *              'row': row_template,
         *              'prow': portrait_row,
         *              'lrow': landscape_row,
         *              'footer': footer_template
         *          },
         *          commands: [],
         *          shapes: [],
         *          icons: [],
         *          ...
         *      },
         *      options: {      // 공통 옵션
         *          rowTemplate: 'row',
         *          header: {
         *              ...
         *          },
         *          footer: {
         *              template: 'footer',
         *              ...
         *          },
         *          ...
         *      },
         *      landscape: {    // 기기가 가로 모드일 때 옵션
         *          rowTemplate: 'prow',
         *          ...
         *      },
         *      portrait: {     // 기기기 세로 모드일 때 옵션
         *          rowTemplate: 'lrow',
         *          ...
         *      }
         *  })
         *
         * @param configs 설정 정보 객체(들).
         */
        setConfig(configs) {
            for (let i = 0, n = arguments.length; i < n; i++) {
                const config = arguments[i];
                if (!isObject(config))
                    return;
                const props = config.props;
                if (isObject(props)) {
                    const $c = this.$_c;
                    const cmds = props.rowCommands;
                    const icons = props.icons;
                    const menus = props.menus;
                    props.shapes && $c.registerShapes(props.shapes);
                    props.templates && this.registerTemplates(props.templates);
                    // row command 속성 설정
                    if (cmds) {
                        for (const c in cmds) {
                            if (c.startsWith('@')) {
                                $c.rowCommands().update(c, cmds[c]);
                            }
                            else {
                                $c.rowCommands().register(c, cmds[c], true);
                            }
                        }
                    }
                    // iconSet들
                    if (icons) {
                        if (Array.isArray(icons)) {
                            icons.forEach(icon => $c.registerIconSet(icon.name, icon));
                        }
                        else if (Utils.isObject(icons)) {
                            $c.registerIconSet(icons.name, icons);
                        }
                    }
                    // menus
                    if (menus) {
                        for (const m in menus) {
                            this.$_c.registerMenu(m, menus[m]);
                        }
                    }
                    this.assignProps(props);
                }
                this.setOptions(config.options);
                this.setPortrait(config.portrait);
                this.setLandscape(config.landscape);
            }
            return this;
        }
        /**
         * 이 컨트롤에 한정된 {@link concepts.templates 템플릿}을 컨트롤에 등록한다.
         * 등록된 템플릿들은 템플릿을 설정하는 여러 영영에서 템플릿 이름으로 지정될 수 있다.
         *
         * @see {@link concepts.templates 템플릿}
         *
         * @param template 템플릿 object.
         * @param name 템플릿 이름. 이 값을 지정하지 않으면 template 객체의 name이나 자동 생성되는 이름으로 저장된다.
        */
        registerTemplate(template, name) {
            name = name || template.name || getNextTemplateName();
            this.$_c.registerTemplate(name, template, false);
            return name;
        }
        /**
         * 이 컨트롤에 한정된 하나 이상의 {@link concepts.templates 템플릿}을 컨트롤에 등록한다.
         * 등록된 템플릿들은 템플릿을 설정하는 여러 영영에서 템플릿 이름으로 지정될 수 있다.
         *
         * @param templates 템플릿 object map.
         */
        registerTemplates(templates) {
            if (isObject(templates)) {
                // let t1 = +new Date();
                // for (let i = 0; i < 30; i++)
                for (let name in templates) {
                    this.registerTemplate(templates[name], name);
                }
                // console.log("TEMPLATES", (+new Date() - t1), 'ms.');
            }
        }
        /**
         * 모든 컨트롤에서 공유 가능한 템플릣을 등록한다.
         * 등록된 템플릿들은 템플릿을 설정하는 여러 영영에서 템플릿 이름으로 지정될 수 있다.
         * NOTE: html 템플릿을 공유 템플릿으로 등록할 수 없다.
         *
         * @param template 템플릿 object.
         * @param name 템플릿 이름. 이 값을 지정하지 않으면 template 객체의 name이나 자동 생성되는 이름으로 저장된다.
         */
        registerSharedTemplate(template, name) {
            name = name || template.name || getNextTemplateName();
            this.$_c.registerTemplate(name, template, true);
            return name;
        }
        /**
         * 모든 컨트롤에서 공유 가능한 하나 이상의 템플릣을 등록한다.
         * 등록된 템플릿들은 템플릿을 설정하는 여러 영영에서 템플릿 이름으로 지정될 수 있다.
         * NOTE: html 템플릿을 공유 템플릿으로 등록할 수 없다.
         *
         * @param templates 템플릿 object map.
         */
        registerSharedTemplates(templates) {
            if (isObject(templates)) {
                for (let name in templates) {
                    this.registerSharedTemplate(templates[name], name);
                }
            }
        }
        /**
         * 데이터 행의 {@link concepts.row_bar Row Bar} 나 {@link concepts.edit_bar Edit Bar} 영역에 표시되는
         * {@link concepts.shapes Shape}를 등록한다.
         * <br>
         *
         * ```
         *  list.registerShape({
         *      name: 'people',
         *      d: 'M18.4 44 V17 Q25.3 11.3 23.8 11.3Z',
         *      width:  48,
         *      height: 48
         *  );
         * ```
         *
         * @param shape shape 정보 객체. name 속성이 '**@**'로 시작하면 미리 등록된(stock) shape의 svg를 변경한다.
         *
         * @see concepts.shape Shape 개요
         */
        registerShape(shape) {
            shape && this.$_c.registerShape(shape.name, shape.d, shape.width, shape.height);
        }
        /**
         * 데이터 행의 {@link concepts.row_bar Row Bar} 나 {@link concepts.edit_bar Edit Bar} 영역에 표시되는
         * 여러 {@link concepts.shapes Shape}들을 동시에 등록한다.
         * <br>
         *
         * ```
         * list.registerShapes([{
         *     name: 'man',
         *     d: 'M18.4 44V17.1q-4.75-1-7.625-4.275Q7.9 9.55 7.9 5.2h3 Q25.3 11.3 23.8 11.3Z',
         *     width: 48,
         *     height: 48
         * }, {
         *     name: 'woman',
         *     d: 'M21 44V33h-6l5.1-16.4q.4-1.25 1.5-1.925T24 14 Q25.5 11.3 24 11.3Z',
         *     width: 48,
         *     height: 48
         * }]);
         * ```
         * @param shapes Shape 이름별 등록 정보가 설정된 json 객체. shape 이름이 '**@**'로 시작하면 미리 등록된(stock) shape의 svg를 변경한다.
         */
        registerShapes(shapes) {
            const map = {};
            if (Array.isArray(shapes)) {
                shapes.forEach(shape => {
                    if (shape.name) {
                        map[shape.name] = shape;
                    }
                });
            }
            this.$_c.registerShapes(map);
        }
        /**
         * {@link IListIconRenderer} 등에서 사용할 수 있도록,
         * 동일한 크기로 표시되는 관련된 이미지 아아콘들의 url을 묶어서 등록한다.
         *
         * @param name 아이콘셋 이름
         * @param icons 아이콘셋 정보
         */
        registerIconSet(name, icons) {
            if (!name) {
                throw new Error('IconSet의 이름이 지정돼야 합니다.');
            }
            this.$_c.registerIconSet(name, icons);
        }
        /**
         * 그룹핑한다.
         * 기존에 paging 상태였다면, pagin을 먼저 취소한다.
         */
        rowGroupBy(infos) {
            if (infos && !Array.isArray(infos)) {
                infos = [infos];
            }
            this.$_c.rowGroupBy(infos);
        }
        /**
         * row 행이 포함된그룹의 정보를 리턴한다.
         * {@link isListGrouped 그룹핑 상태}가 이니거나 존재하지 않는 데이터행이면 null을 리턴한다.
         *
         * @param row 데이터행 번호.
         * @returns 그룹 정보 객체.
         */
        groupOfRow(row) {
            const model = this.$_c['_group'];
            return model ? getGroupInfo(model.groupOfRow(row)) : null;
        }
        /**
         * 지정한 group의 부모 그룹 정보를 리턴한다.
         * {@link isListGrouped 그룹핑 상태}가 이니거나 존재하지 그룹이면 null을 리턴한다.
         *
         * @param group 그룹 정보.
         * @returns 부모 그룹 정보 객체.
         */
        parentOfGroup(group) {
            if (group) {
                const model = this.$_c['_group'];
                if (model) {
                    const g = model.getItem(group._idx);
                    return g && getGroupInfo(g.group.parent);
                }
            }
        }
        /**
         * 지정한 group의 부모 그룹 정보를 리턴한다. 하나도 없으면 빈 배열을 리턴한다.
         * {@link isListGrouped 그룹핑 상태}가 이니거나 존재하지 않는 아이템 위치이면 null을 리턴한다.
         *
         * @param group 그룹 정보.
         * @returns 자식 그룹 정보 배열.
         */
        childrenOfGroup(group) {
            if (group) {
                const model = this.$_c['_group'];
                if (model) {
                    const g = model.getItem(group._idx);
                    if (g) {
                        return g.group.children.map(g => getGroupInfo(g));
                    }
                }
            }
        }
        /**
         * 지정한 그룹이 접힌 상태라면 그룹을 펼치고 true를 리턴한다.
         * 아니면 false를 리턴한다.
         * {@link isListGrouped 그룹핑 상태}가 아니거나 존재하지 않는 그룹이면 아무것도 하지 않는다.
         *
         * @param group 그룹 정보.
         * @returns 실제 expand 되면 true.
         */
        expandGroup(group) {
            this.$_c['_group'];
            return false;
        }
        /**
         * 지정한 그룹이 펼쳐진 상태라면 그룹을 접고 true를 리턴한다.
         * 아니면 false를 리턴한다.
         * {@link isListGrouped 그룹핑 상태}가 아니거나 존재하지 않는 그룹이면 아무것도 하지 않는다.
         *
         * @param group 그룹 정보.
         * @returns 실제 collapse 되면 true.
         */
        collapseGroup(group) {
            this.$_c['_group'];
            return false;
        }
        dataGroupBy(infos) {
            this.$_c.dataGroupBy(infos);
        }
        setPaging(options) {
            this.$_c.setPaging(options);
            return this;
        }
        /**
         * @noimpl
         *
         * 기존 선택 영역을 제거한다.
         */
        clearSelection() {
            this.$_c.clearSelection();
        }
        /**
         * 기존 선택 영역을 제거하고, 지정된 범위의 데이터행들을 선택한다.
         * 끝 행 번호가 시작 행 번호보다 반드시 클 필요는 없다.
         *
         * @param startRow 시작 데이터행 번호
         * @param endRow 끝 데이터행 번호
         */
        selectRows(startRow, endRow) {
            this.$_c.selectRows(startRow, endRow);
        }
        /**
         * 지정된 데이터행이 선택 영역에 포함됐으면 true 리턴.
         *
         * @param data 마스터/디테일 그룹핑일 때에는 row가 소속된 데이터를 지정해야 한다.
         * @param row 데이터행 번호
         * @returns 행이 선택에 포함되면 true.
         */
        isRowSelected(row) {
            const sel = this.$_c.getSelection();
            return sel && sel.isRowSelected(row);
        }
        /**
         * 선택 영역에 포함된 데이터행 번호들을 배열로 리턴한다.
         *
         * @returns 행 번호 목록.
         */
        getSelectedRows() {
            const sel = this.$_c.getSelection();
            return sel && sel.getSelectedRows();
        }
        /**
         * 지정된 데이터행이 체크된 상태면 true 리턴.
         *
         * @param row 데이터행 번호
         * @returns 행이 체크됐으면 true.
         */
        isRowChecked(row) {
            return this.$_c.isRowChecked(row);
        }
        /**
         * 지정한 체크 상태와 동일한 상태의 데이터행 번호들을 배열로 리턴한다.
         *
         * @param checked 체크 여부.
         * @returns 행 번호 목록. 하나도 없으면 빈 배열을 리턴한다.
         */
        getCheckedRows(checked = true) {
            return this.$_c.$_getFlags().getCheckedRows(checked);
        }
        /**
         * 지정된 데이터행의 체크 상태를 설정한다.
         * 현재 체크 상태를 뒤바꾸려면 {@link toggleChecked}를 호출한다.
         * {@link rowClickAction}이 {@link DListRowClickAction.CHECK}이면
         * 사용자가 데이터행을 탭할 때 체크 상태가 뒤바뀐다.
         *
         * @see toogleChecked
         * @see rowClickAction
         * @see DListRowClickAction
         *
         * @param {number} row 데이터행 번호
         * @param {boolean} checked 체크 상태.
         * @returns {boolean} 체크 상태가 변경됐으면 true.
         */
        checkRow(row, checked) {
            return this.$_c.checkRow(row, checked);
        }
        /**
         * 지정된 데이터행의 체크 상태를 뒤바꾼다.
         * {@link rowClickAction}이 {@link DListRowClickAction.CHECK}이면
         * 사용자가 데이터행을 탭할 때 체크 상태가 뒤바뀐다.
         *
         * @see checkRow
         * @see rowClickAction
         * @see DListRowClickAction
         *
         * @param ds 데이터소스 객체
         * @param row 데이터행 번호
         */
        toggleChecked(row) {
            this.$_c.toggleChecked(row);
        }
        /**
         * 지정한 행들의 체크 상태를 변경한다.
         *
         * @param rows 행 번호 목록.
         * @param checked 체크 여부.
         * @returns 체크 상태가 변경된 행 번호 목록.
         */
        checkRows(rows, checked) {
            return this.$_c.$_getFlags().checkRows(rows, checked);
        }
        /**
         * 지정한 범위에 포함된 행들의 checked 상태를 변경한다.
         *
         * @param row 시작 행 번호.
         * @param count 행 수.
         * @param checked 체크 여부.
         * @returns checked 상태가 변경된 행 번호 목록.
         */
        checkRowRange(row, count, checked) {
            return this.$_c.$_getFlags().checkRange(row, count, checked);
        }
        /**
         * 모든 데이터행의 체크 상태를 변경한다.
         *
         * @param checked 체크 상태.
         * @returns 변경된 행이 하나라도 존재하면 true.
         * @see {@link checkRow}
         */
        checkAllRows(checked) {
            return this.$_c.$_getFlags().checkAll(checked);
        }
        /**
         * 모든 데이터행의 체크 상태를 변경한다.
         *
         * @param checked 체크 상태.
         * @returns 변경된 행이 하나라도 존재하면 true.
         * @see {@link checkRow}
         */
        checkAll(checked) {
            if (this.$_c.isDataGrouped()) ;
            else {
                return this.checkAllRows(checked);
            }
        }
        /**
         * 사용자가 체크할 수 있는 데이터행이면 true를 리턴한다.
         *
         * @param row 데이터행 번호.
         * @returns 체크 가능 여부.
         */
        isRowCheckable(row) {
            return this.$_c.isRowCheckable(row);
        }
        setCheckable(row, checkable) {
            const flags = this.$_c.$_getFlags();
            return flags && flags.setCheckable(row, checkable);
        }
        /**
         * 지정된 데이터행이 더보기(접힘) 상태면 true 리턴.
         *
         * @param row 데이터행 번호.
         * @returns 더보기 상태 true.
         */
        isRowDetailed(row) {
            return this.$_c.isRowDetailed(row);
        }
        /**
         * 지정한 더보기(접햄) 상태와 동일한 상태의 데이터행 번호들을 배열로 리턴한다.
         *
         * @param collapsed 더보기 여부.
         * @returns 행 번호 목록.
         */
        getDetailedRows(collapsed) {
            return this.$_c.$_getFlags().getDetailedRows(collapsed);
        }
        /**
         * 지정된 데이터행의 더보기(접힘) 상태를 변경한다.
         *
         * @param row 데이터행 번호
         * @param collapsed 더보기 상태.
         */
        setRowDetailed(row, collapsed, exclusive = false) {
            this.$_c.setRowDetailed(row, collapsed, exclusive, false); // api 호출 시에는 animation 불가.
        }
        /**
         * 지정한 행들의 더보기(접힘) 상태를 변경한다.
         *
         * @param rows 행 번호 목록.
         * @param collapsed 더보기 여부.
         * @returns 더보기 상태가 변경된 행 번호 목록.
         */
        setRowsDetailed(data, rows, collapsed) {
            return this.$_c.$_getFlags().detailRows(rows, collapsed);
        }
        /**
         * 지정한 범위에 포함된 행들의 더보기(접힙) 상태를 변경한다.
         *
         * @param row 시작 행 번호.
         * @param count 행 수.
         * @param collapsed 더보기 상태.
         * @returns 더보기 상태가 변경된 행 번호 목록.
         */
        setRowRangeDetailed(data, row, count, collapsed) {
            return this.$_c.$_getFlags().detailRange(row, count, collapsed);
        }
        /**
         * 모든 데이터행의 더보기(접힘) 상태를 변경한다.
         *
         * @param collapsed 더보기 상태
         * @returns 변경된 행이 하나라도 존재하면 true.
         */
        setAllRowsDetailed(collapsed) {
            return this.$_c.$_getFlags().detailAll(collapsed);
        }
        /**
         * 지정된 데이터행에 flag 위치의 플래그가 설정됐다면 true를 리턴한다.
         * 각 데이터행별로 0에서 15 사이의 16개 다른 플래그를 설정할 수 있다.
         *
         * @param row 데이터행 번호
         * @param flag flag 위치. 0 ~ 15 사이의 값을 가질 수 있다.
         * @returns 설정됐다면 true, 아니면 false나 undefined.
         */
        isRowFlagged(row, flag) {
            return this.$_c.$_getFlags().hasUserFlag(row, flag);
        }
        /**
         * 지정된 위치에 플래그가 설정된 모든 데이터행들의 번호를 리턴한다.
         *
         * @param flag
         * @param flag flag 위치. 0 ~ 15 사이의 값을 가질 수 있다.
         * @returns 플래그가 지정된 데이터행 번호 배열. 행이 하나도 없으면 빈 배열.
         */
        getFlaggedRows(flag, set) {
            return this.$_c.$_getFlags().getUserFlaggedRows(flag, set);
        }
        /**
         * 모든 데이터행에 설정된 지정된 위치의 플래그를 해제한다.
         *
         * @param flag flag 위치. 0 ~ 15 사이의 값을 가질 수 있다.
         * @param rowEvents true로 지정하면 행 단위 이벤트가 발생한다.
         * @returns 변경된 행아 하나라도 존재하면 true, 아니면 false나 undefined.
         */
        setRowFlagAll(flag, set) {
            return this.$_c.$_getFlags().setUserFlagAll(flag, set);
        }
        /**
         * 지정된 데이터행에 flag 위치의 플래그를 설정하거나 해제한다.
         * 각 데이터행별로 0에서 15 사이의 16개 다른 플래그를 설정할 수 있다.
         *
         * @param row 데이터행 번호
         * @param flag flag 위치. 0 ~ 15 사이의 값을 가질 수 있다.
         * @param set true면 플래그 설정, 아니면 해제.
         * @returns 실제로 플래그 설정 상태가 변경되면 true, 아니면 false나 undefined.
         */
        setRowFlag(row, flag, set) {
            return this.$_c.$_getFlags().setUserFlag(row, flag, set);
        }
        /**
         * 지정된 데이터행들에 flag 위치의 플래그를 설정하거나 해제한다.
         * 각 데이터행별로 0에서 15 사이의 16개 다른 플래그를 설정할 수 있다.
         *
         * @param rows 데이터행 번호 목록.
         * @param flag flag 위치. 0 ~ 15 사이의 값을 가질 수 있다.
         * @param set true면 플래그 설정, 아니면 해제.
         * @returns 실제로 플래그 상태가 변경된 데이터행 번호 배열. 행이 하나도 없으면 빈 배열.
         */
        setRowsFlag(rows, flag, set) {
            return this.$_c.$_getFlags().setUserFlags(rows, flag, set);
        }
        /**
         * 연속적으로 지정된 범위의 데이터행들에 flag 위치의 플래그를 설정하거나 해제한다.
         * 각 데이터행별로 0에서 15 사이의 16개 다른 플래그를 설정할 수 있다.
         *
         * @param row 범위의 시작 행.
         * @param count 범위의 연속된 데이터 행 수.
         * @param flag flag 위치. 0 ~ 15 사이의 값을 가질 수 있다.
         * @param set true면 플래그 설정, 아니면 해제.
         * @returns 실제로 플래그 상태가 변경된 데이터행 번호 배열. 행이 하나도 없으면 빈 배열.
         */
        setRowRangeFlag(row, count, flag, set) {
            return this.$_c.$_getFlags().setUserFlagRange(row, count, flag, set);
        }
        /**
         * 데이터행 커맨드를 등록한다.
         * <br>
         * 라이브러리 수준에서 미리 등록된 command들이 존재하므로,
         * 이름에 고유 prefix를 붙여서 설정한다.
         *
         * @param commandName command 이름.
         * @param commandType command type. IRowCommand 속성들을 포함한 객체 혹은 IRowCommand 속성들을 갖는 클래스의 생성자.
         * @param overwrite 같은 이름의 커맨드가 이미 존재하는 경우, 이 값이 false이면 예외가 발생한다.
         *
         * @see concepts.command_box Command 상자 개요
         * @see DListCommandBox
         */
        registerRowCommand(commandName, config, overwrite = false) {
            this.$_c.rowCommands().register(commandName, config, overwrite);
        }
        /**
         * 기존에 등록된 데이터행 커맨드들을 제거한다.
         * <br>
         *
         * @param commandNames 커맨드 이름 목록
         *
         * @see concepts.command_box Command 상자 개요
         * @see DListCommandBox
         */
        unregisterRowCommands(commandNames) {
            this.$_c.rowCommands().unregister(commandNames);
        }
        getRowCommand(commandName) {
            return this.$_c.rowCommands().get(commandName);
        }
        /**
         * 기존에 등록된 행 커맨드 설정을 변경한다.
         *
         * @param commandName 커맨드 이름
         * @param config 커맨드 설정 객체
         *
         * @see concepts.command_box Command 상자 개요
         * @see DListCommandBox
         */
        updateRowCommand(commandName, config) {
            this.$_c.rowCommands().update(commandName, config);
        }
        // /**
        //  * 등록된 행 커맨드중 실행할 커맨드들을 이름으로 설정한다.
        //  * 
        //  * @param commands 커맨드 이름들. 
        //  */
        // setRowCommands(commands: string[]) {
        //     this.$_c.rowCommands().setCommands(commands);
        // }
        /**
         * Row command가 표시되는 데이터행을 지정한다.
         * 지정한 행이 현재 화면에 표시되는 위치가 아니면 스크롤해서 표시한다.
         * -1로 지정하면 기존 커맨드 표시가 감춰진다.
         * 커맨드 행으로 지정된 행이 스크롤로 사라지게 되거나, 다른 행을 터치하면 자동으로 감춘다.
         * 보통, 사용자가 데어터행을 swipe하거나 클릭해서 command를 표시하게 된다.
         *
         * @param row 데이터행 번호
         * @param animate true면 커맨드롤 표시하거나 감출 때 animation이 진행된다.
         *
         * @see concepts.command_box Command 상자 개요
         * @see DListCommandBox
         */
        setCommandRow(row, animate = true) {
            this.$_c.setCommandRow(row, animate);
        }
        /**
         * 열려 있는 패널을 닫는다.
         *
         * @see concepts.form_panel 폼 패널
         * @see concepts.filter_panel 필터 패널
         * @see concepts.search_panel 검색 패널
         * @see concepts.button_panel 버튼 패널
         *
         * @param animate true면 패널을 닫힐 때 애니메이션 효과가 적용된다.
         */
        closePanel(animate = true) {
            this.$_c.closePanel(animate);
        }
        /**
         * {@link concepts.form_panel 폼 패널}을 표시한다.
         *
         * @see closePanel
         * @see concepts.form_panel 폼 패널
         * @see concepts.filter_panel 필터 패널
         * @see concepts.search_panel 검색 패널
         * @see concepts.button_panel 버튼 패널
         *
         * @param animate true면 패널을 표시할 때 애니메이션 효과가 적용된다.
         */
        showFormPanel(animate = true) {
            this.$_c.showFormPanel(null, animate);
        }
        /**
         * {@link concepts.button_panel 버튼 패널}을 표시한다.
         *
         * @see closePanel
         * @see concepts.button_panel 버튼 패널
         * @see concepts.filter_panel 필터 패널
         * @see concepts.search_panel 검색 패널
         * @see concepts.form_panel 폼 패널
         *
         *
         * @param animate true면 패널을 표시할 때 애니메이션 효과가 적용된다.
         */
        showButtonPanel(animate = true) {
            this.$_c.showButtonPanel(animate);
        }
        /**
         * {@link concepts.search_panel 검색 패널}을 표시한다.
         *
         * @see closePanel
         * @see concepts.search_panel 검색 패널
         * @see concepts.filter_panel 필터 패널
         * @see concepts.button_panel 버튼 패널
         * @see concepts.form_panel 폼 패널
         *
         *
         * @param animate true면 패널을 표시할 때 애니메이션 효과가 적용된다.
         */
        showSearchPanel(optons, animate = true) {
            this.$_c.showSearchPanel(optons, animate);
        }
        /**
         * {@link concepts.filter_panel 검색 패널}을 표시한다.
         *
         * @see closePanel
         * @see concepts.filter_panel 필터 패널
         * @see concepts.search_panel 검색 패널
         * @see concepts.button_panel 버튼 패널
         * @see concepts.form_panel 폼 패널
         *
         * @param animate true면 패널을 표시할 때 애니메이션 효과가 적용된다.
         */
        showFilterPanel(options, animate = true) {
            this.$_c.showFilterPanel(options, animate);
        }
        /**
         * {@link concepts.menu 메뉴}룰 표시한다.
         * <br>
         *
         * @see closeMenu
         * @see concepts.filter_panel 필터 패널
         * @see concepts.search_panel 검색 패널
         * @see concepts.button_panel 버튼 패널
         * @see concepts.form_panel 폼 패널
         *
         * @param menu 메뉴 객체 혹은 컨트롤에 등록된 메뉴 이름. 지정하지 않으면 {@link DListControl.options 컨트롤 옵션}에 지정한 {@link DListOptions.menu 기본 메뉴}가 표시된다.
         * @param animate true면 메뉴를 표시할 때 애니메이션 효과가 적용된다.
         */
        showMenu(menu, animate = true) {
            this.$_c.showMenu(menu, animate);
        }
        /**
         * 표시된 메뉴를 닫는다.
         *
         * @see showMenu
         *
         * @param animate true면 메뉴를 닫을 때 애니메이션 효과가 적용된다.
         */
        closeMenu(animate = true) {
            this.$_c.closeMenu(animate);
        }
        /**
         * {@link concepts.info_page 행 정보 페이지}를 표시한다.
         * row가 타당한 값이 아니면 실행되지 않는다.
         *
         * @see closeInfoPage
         * @see showEditPage
         *
         * @param row 데이터행 번호
         * @param model info view 설정 정보 모델
         * @param animate true면 view를 열 때 애니메이션 효과가 적용된다.
         */
        showInfoPage(row, model, animate = true) {
            this.$_c.showInfoPage(row, model, animate);
        }
        /**
         * {@link concepts.info_page 행 정보 페이지}가 표시된 상태면 닫는다.
         * Info 뷰 내의 버튼 등에서 호출할 수 있다.
         * 행 Info 뷰는 {@link showInfoPage}로 표시한다.
         *
         * @see showInfoPage
         */
        closeInfoPage() {
            this.$_c.isInfoPageVisible() && this.$_c.closeRowPage(false, true);
        }
        /**
         * {@link concepts.edit_page 행 편집 페이지}를 표시한다.
         * row가 0보다 작으면 행 추가, row가 타당한 행 번호면 행 편집 view가 표시된다.
         * 아니면, 아무것도 실행하지 않는다.
         *
         * @see closeEditPage
         * @see getEditValues
         * @see showInfoPage
         *
         * @param row 데이터행 번호.
         * @param model 편집 뷰 설정 정보 모델.
         * @param animate true면 view를 표시할 때 애니메이션 효과가 적용된다.
         */
        showEditPage(row, model, animate = true) {
            this.$_c.showEditPage(row, model, animate);
        }
        /**
         * {@link concepts.edit_page 행 편집 페이지}가 표시된 상태면 닫는다.
         * 편집 뷰 내의 버튼 등에서 호출할 수 있다.
         * 편집 뷰는 {@link showEditPage}로 표시한다.
         *
         * @example
         * {
         *   renderer: {
         *     type: 'button',
         *     onClick: args => args.control.closeInfoPage(true);
         *   }
         * }
         *
         * @see showEditPage
         * @see getEditValues
         *
         * @param commit true면 편집을 완료하고 데이터에 반영하고, false면 취소한다.
         * @param animate true면 view를 닫을 때 애니메이션 효과가 적용된다.
         */
        closeEditPage(commit, animate = true) {
            this.$_c.isEditPageVisible() && this.$_c.closeRowPage(commit, animate);
        }
        /**
         * {@link concepts.edit_view 행 편집 view}가 표시된 상태일 때,
         * 현재까지의 필드 값들을 json 객체로 리턴한다.
         *
         * @see showEditPage
         * @see closeEditPage
         *
         * @returns 필드 값 json 객체.
         */
        getEditValues() {
            return this.$_c.getEditValues();
        }
        /**
         * 지정한 키값과 옵션에 따라 검색을 실행한다.
         *
         * @param key 검색 키 값.
         * @param options 검색 옵션.
         * @returns 검색 결과 목록.
         */
        search(key, options) {
            const r = this.$_c.search(options, key);
            return r ? r.fields() : void 0;
        }
        /**
         * 지정한 데이터행이 화면에 노출되도록 스크롤한다.
         * 현재 표시된 상태라면 아무일도 하지 않는다.
         *
         * @see scrollToEnd
         * @see setFocusedRow
         *
         * @param row 데이터행 번호
         */
        makeRowVisible(row) {
            this.$_c.makeRowVisible(row);
        }
        /**
         * 지정한 행을 focused 상태로 설정한다.
         * 행 하나만 focused 상태가 될 수 있다.
         * 현재 focused 상태의 데이터행은 {@link focusedRow} 속성으로 알 수 있다.
         *
         * @see focusedRow
         *
         * @param row 데이터행 번호
         */
        setFocusedRow(row) {
            this.$_c.setFocusedRow(row);
        }
        /**
         * 지정한 데이터행이 마지막 행으로 표시되게 스크롤한다.
         *
         * @see makeRowVisible
         *
         * @param row 데이터행 번호. 0보다 작거나 NaN이면 attached row가 표시되게 한다.
         */
        scrollToEnd(row) {
            this.$_c.scrollToEnd(row);
        }
        /**
         * {@link concepts.toast 토스트 메시지}를 표시한다.
         * <br>
         *
         * @param toast 메시지 문자열 혹은 메시지 뷰 설정 객체.
         */
        showToast(toast) {
            this.$_c.showToast(toast);
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * {@link DListControl DList 컨트롤}에 설정되는 데이터소스 객체들의 기반 클래스.
     * <br>
     *
     * 데이터소스는 {@link DListData}, {@link DListDataView}와 같은 단일 데이터소스와,
     * 여러개의 단일 데이터소스의 관계로 구성되는 {@link DListDataLinkView}가 있다.
     * <br>
     * {@link DListControl 컨트롤}의 {@link DListControl.data data} 속성으로 연결한다.
     *
     * @see concepts.data_model 데이터 모델
     * @see DListControl.data
     *
     * // abstract인 경우 매개변수에 기본값을 지정할 수 없어서 함수의 경우 abstract을 제거한다.
     */
    class DListDataSource extends DObject {
        /**
         * 지정된 행이 수정된 상태면 true를 리턴한다.
         *
         * @param row 데이터행 번호
         * @returns 수정된 상태면 true.
         */
        isRowUpdated(row) {
            throw NOT_IMPLEMENT;
        }
        /**
         * 지정된 행이 삭제된 상태면 true를 리턴한다.
         *
         * @param row 데이터행 번호
         * @returns 수정된 상태면 true.
         */
        isRowDeleted(row) {
            throw NOT_IMPLEMENT;
        }
        /**
         * 한 행 한 필드의 값을 가져온다.
         * row가 범위를 벗어나거나 field가 존재하지 않는 필드명이면 예외가 발생한다.
         *
         * @example
         * const v = data.getValue(3, 'address');
         * document.getElemenById('address').value = v;
         *
         * @param row 데이터행 번호.
         * @param field 필드 이름.
         * @param fieldCheck false면 필드명 존재 여부를 검사하지 않는다.
         * @returns 필드 값.
         */
        getValue(row, field, fieldCheck = true) {
            throw NOT_IMPLEMENT;
        }
        /**
         * 지정한 데이터행의 필드 값들을 json 객체로 리턴한다.
         * <br>
         * 지정한 위치에 자리만 차지한 경우({@link isEmpty}가 true) undefined를 리턴한다.
         *
         * @param row 행 위치
         * @param fields 필드 목록. 지정하지 않으면 모든 필드 값을 리턴한다.
         * @param fieldCheck true면 잘못된 필드를 지정한 경우 예외가 발생한다.
         * @returns 필드 값이 포함된 json 객체
         *
         * @error fieldCheck가 true이고, fields에 잘못된 필드명을 지정하면 발생한다.
         */
        getValues(row, fields, fieldCheck = true) {
            throw NOT_IMPLEMENT;
        }
        /**
         * 지정한 필드 값들을 포함한 첫번째 데이터행 번호를 리턴한다.
         *
         * @param where 검색 조건 값들.
         *
         * @see findRows
         */
        findRow(where, from, to) {
            throw NOT_IMPLEMENT;
        }
        /**
         * 지정한 필드 값들을 포함한 모든 데이터행 목록을 가져온다.
         * <br>
         *
         * @param where 검색 조건 값들.
         * @param from 검색 시작 행 번호
         * @param to 검색 끝 행 번호. 이 데이터행은 포함되지 않는다.
         *
         * @see findDistinctRows
         * @see findRow
         */
        findRows(where, from, to) {
            throw NOT_IMPLEMENT;
        }
        /**
         * 지정한 필드들을 기준으로 중복을 제거한 데이터행 목록을 가져온다.
         * <br>
         *
         * @param fields 필드 이름 목록.
         * @param from 검색 시작 행 번호
         * @param to 검색 끝 행 번호. 이 데이터행은 포함되지 않는다.
         *
         * @see findRows
         * @see findRow
         */
        findDistinctRows(fields, from, to) {
            throw NOT_IMPLEMENT;
        }
    }
    /**
     * 단순 데이터소스 base 모델.
     * <br>
     *
     * @see concepts.data_model 데이터 모델
     * @see DListDataLinkView
     */
    class DListSimpleData extends DListDataSource {
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        /**
         * 이 데이터를 마스터로 하는 {@link DListDataLinkView 데이터 링크}를 생성한다.
         *
         * @example
         *  const master = DList.createData('master', {...});
         *  const detail = DList.createData('detail', {...});
         *  const data = master.createLinkView('link', [{
         *      data: detail,
         *      keyFields: ['NAME']
         *  }]);
         *
         *  const dlist = DList.createList(document, 'dlist'); // 'dlist'는 div의 id.
         *  dlist.setConfig(config);    // 컨트롤 속성 및 옵션 설정
         *  dlist.data = data;          // 데이터 연결
         *
         * @see concepts.data_model 데이터 모델
         *
         * @param name 데이터 명
         * @param details 디테일 견결 정보 목록
         * @returns
         */
        createLinkView(name, details) {
            return new DListDataLinkView(name, this, details);
        }
    }
    /**
     * @desc {@link DListControl 리스트 컨트롤}의 기본 data model.
     *
     * 실제 데이터행들을 보관하고 관리하는 {@link DListSimpleData 단일} {@link DListDataSource 데이터 소스}이다.
     * <br>
     * 즉 행들의 실제 추가/수정/삭제는 이 데이터에서 실행되고,
     * {@link DListDataView}나 {@link DListDataLinkView}와 같은 data view는
     * 이 데이터의 행들을 다른 방식으로 배치해서 보여준다.
     * <br>
     * 데이터 생성 시 데이터행들의 구조를 결정하는 데이터필드들이 반드시 설정돼야 하는데,
     * 필드 목록을 직접 지정하거나 생성자 매개변수로 전달되는 원본 데이터셋의 첫 행으로 부터 필드 목록을 자동 추출한다.
     * 데이터행들을 최초 로드한 후, 데이터행(들)을 수정/삭제/추가할 수 있는데,
     * {@link restorable} 설정으로 수정된 행을 원복할 수 있다.
     * 또, {@link softDeleting} 설정으로 실제 삭제 대신 삭제 상태로 표시하고 추후에 삭제하거나 취소할 수 있다.
     * <br>
     * 리스트 데이터 내용의 변화는 즉각 리스트 컨트롤 뷰에 반영되고,
     * {@link DListControl 리스트 컨트롤}의 수정/추가/삭제 UI를 통해 데이터행을 변경하면 리스트 데이터에 바로 반영된다.
     * <br><br>
     *
     * 데이터 객체는 생성자 대신 주로 모듈 함수를 호출해서 생성한다.
     *
     * @example
     *  dlist = DList.createList(document, 'dlist'); // 'dlist'는 div의 id.
     *  dlist.setConfig(config);    // 컨트롤 속성 및 옵션 설정
     *  dlist.data = data;          // 데이터 연결
     *
     * @see concepts.data_model 데이터 모델
     * @see DListDataView
     * @see DListDataLinkView
     * @see DListControl.data
     */
    class DListData extends DListSimpleData {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        /**
         * 리스트 데이터를 생성한다.
         *
         * @param name 데이터 이름.
         * @param options 데이터 생성 정보.
         * @param source 데이터행 목록 원본.
         */
        constructor(name, options, source) {
            super();
            if (name instanceof ListData) { // for snapshot
                this.$_d = name;
            }
            else {
                this.$_d = new ListData(name, options, source, this);
            }
        }
        $_doDestory() {
            this.$_d = this.$_d.destroy();
        }
        //-------------------------------------------------------------------------
        // events
        //-------------------------------------------------------------------------
        /**
         * @event
         *
         * 필드 값이 변경된 후 발생한다.
         * <br>
         *
         * @eparam data 데이터 객체 자신
         * @eparam row 데이터행 번호
         * @eparam field 필드 이름
         * @eparam value 변경된 값
         * @eparam oldValue 변경 이전 값
         */
        get onValueUpdate() {
            return this.$_d.onValueUpdate;
        }
        set onValueUpdate(value) {
            this.$_d.onValueUpdate = value;
        }
        /**
         * @event
         *
         * 데이터행의 값이 변경된 후 발생한다.
         * <br>
         * 둘 이상의 행이 변경된 후에는 {@link onRowsUpdate} 이벤트가 발생한다.
         *
         * @eparam data 데이터 객체 자신
         * @eparam row 데이터행 번호
         * @eparam oldValues 변경 이전 필드 값들
         */
        get onRowUpdate() {
            return this.$_d.onRowUpdate;
        }
        set onRowUpdate(value) {
            this.$_d.onRowUpdate = value;
        }
        /**
         * @event
         *
         * 둘 이상의 행들이 변경된 후 발생한다.
         * <br>
         * 한 행의 필드 값들이 변경된 후에는 {@link onRowUpdate} 이벤트가 발생한다.
         *
         * @eparam data 데이터 객체 자신
         * @eparam rows 데이터행 번호 목록
         */
        get onRowsUpdate() {
            return this.$_d.onRowsUpdate;
        }
        set onRowsUpdate(value) {
            this.$_d.onRowsUpdate = value;
        }
        /**
         * @event
         *
         * 한 행이 마지막에 추가되거나 중간 위치에 삽입된 후 발생한다.
         * <br>
         * 둘 이상의 행들이 추가될 때는 {@link onRowsAdd} 이벤트가 발생한다.
         *
         * ```
         *  data.onRowAdd = args => {
         *      const values = args.data.getValues(args.row);
         *      doc.getElementbyId('name').value = values.name;
         *      doc.getElementbyId('address').value = values.address;
         *      ...
         *  };
         * ```
         *
         * @eparam data 데이터 객체 자신
         * @eparam row 신규 행이 삽입된 위치
         */
        get onRowAdd() {
            return this.$_d.onRowAdd;
        }
        set onRowAdd(value) {
            this.$_d.onRowAdd = value;
        }
        /**
         * @event
         *
         * 둘 이상의 행들이 마지막에 추가되거나 중간 위치에 삽입된 후 발생한다.
         * <br>
         * 한 행이 추가될 때는 {@link onRowAdd} 이벤트가 발생한다.
         *
         * @eparam data 데이터 객체 자신
         * @eparam row 신규 행들이 삽입된 위치
         * @eparam count 추가된 행 수
         */
        get onRowsAdd() {
            return this.$_d.onRowsAdd;
        }
        set onRowsAdd(value) {
            this.$_d.onRowsAdd = value;
        }
        /**
         * @event
         *
         * 모든 행들이 삭제된 후 발생한다.
         * <br>
         *
         * @eparam data 데이터 객체 자신
         * @eparam oldCount 삭제 이전 행 수
         */
        get onRowsClear() {
            return this.$_d.onRowsClear;
        }
        set onRowsClear(value) {
            this.$_d.onRowsClear = value;
        }
        /**
         * @event
         *
         * 한 행이 삭제될 때 발생한다.
         * <br>
         * 둘 이상의 행이 삭제될 때는 {@link onRowsDelete}나 {@link onRowRangeDelete}가 발생한다.
         *
         * @eparam data 데이터 객체 자신
         * @eparam row 삭제할 데이터행 번호
         * @eparam values 삭제된 행의 필드 값들
         */
        get onRowDelete() {
            return this.$_d.onRowDelete;
        }
        set onRowDelete(value) {
            this.$_d.onRowDelete = value;
        }
        /**
         * @event
         *
         * 연속되지 않은 여러 행들이 삭제된 후 발생한다.
         * <br>
         * 연속된 행들이 삭제될 때는 {@link onRowRangeDelete} 이벤트가 발생하고,
         * 한 행이 삭제될 때는 {@link onRowDelete} 이벤트가 발생한다.
         *
         * @eparam data 데이터 객체 자신
         * @eparam rows 데이터행 번호 목록
         */
        get onRowsDelete() {
            return this.$_d.onRowsDelete;
        }
        set onRowsDelete(value) {
            this.$_d.onRowsDelete = value;
        }
        /**
         * @event
         *
         * 연속된 여러 행들이 삭제된 후 발생한다.
         * <br>
         * 연속되지 않은 행들이 삭제될 때는 {@link onRowsDelete} 이벤트가 발생하고,
         * 한 행이 삭제될 때는 {@link onRowDelete} 이벤트가 발생한다.
         *
         * @eparam data 데이터 객체 자신
         * @eparam row 데이터행 번호
         * @eparam count 삭제할 행 수
         */
        get onRowRangeDelete() {
            return this.$_d.onRowRangeDelete;
        }
        set onRowRangeDelete(value) {
            this.$_d.onRowRangeDelete = value;
        }
        /**
         * @event
         *
         * 데이터행이 다른 위치로 이동된 후 발생한다.
         *
         * @eparam data 데이터 객체 자신
         * @eparam from 이동할 데이터행 번호
         * @eparam to 목표 데이터행 위치
         */
        get onRowMove() {
            return this.$_d.onRowMove;
        }
        set onRowMove(value) {
            this.$_d.onRowMove = value;
        }
        /**
         * @event
         *
         * 연속된 데이터행들이 다른 위치로 이동된 후 발생한다.
         *
         * @eparam data 데이터 객체 자신
         * @eparam from 이동할 시작 데이터행 번호
         * @eparam count 데이터행 수
         * @eparam to 목표 데이터행 위치
         */
        get onRowsMove() {
            return this.$_d.onRowsMove;
        }
        set onRowsMove(value) {
            this.$_d.onRowsMove = value;
        }
        /**
         * @event
         *
         * 행 상태가 변경될 때 발생한다.
         * <br>
         *
         * @eparam data 데이터 객체 자신
         * @eparam row 데이터행 번호
         */
        get onRowStateChange() {
            return this.$_d.onRowStateChange;
        }
        set onRowStateChange(value) {
            this.$_d.onRowStateChange = value;
        }
        /**
         * @event
         *
         * 행들의 상태가 변경될 때 발생한다.
         * <br>
         *
         * @eparam data 데이터 객체 자신
         * @eparam rows 데이터행 번호 목록
         */
        get onRowStatesChange() {
            return this.$_d.onRowStatesChange;
        }
        set onRowStatesChange(value) {
            this.$_d.onRowStatesChange = value;
        }
        /**
         * @event
         *
         * 행 추가/삭제 등으로 행 개수가 변경될 때 발생한다.
         * <br>
         * {@link onRowAdd} 등 기본 이벤트가 발생한 후 마지막에 발생한다.
         *
         * @eparam data 데이터 객체 자신
         * @eparam newCount 변경 후 행 수
         * @eparam oldCount 변경 전 행 수
         */
        get onRowCountChange() {
            return this.$_d.onRowCountChange;
        }
        set onRowCountChange(value) {
            this.$_d.onRowCountChange = value;
        }
        /**
         * @event
         *
         * 한 필드, 한 행, 여러 행 등 데이터에 변경이 있을 때마다 발생한다.
         * <br>
         * 데이터행 상태 등 데이터에 변경이 발생하는 모든 경우에 발생한다.
         * {@link onRowUpdate} 등 기본 이벤트들과 {@link onRowCountChange} 이벤트가 발생한 후 마지막에 발생한다.
         *
         * ```
         *  data.onDataChange = (args) => {
         *      dataChanged = true;
         *  }
         * ```
         *
         * @eparam data 데이터 객체 자신
         */
        get onDataChange() {
            return this.$_d.onDataChange;
        }
        set onDataChange(value) {
            this.$_d.onDataChange = value;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * Row info view등의 header caption 등으로 사용되는 list data 타이틀.
         * <br>
         *
         * @see name
         */
        get title() {
            return this.$_d.title();
        }
        /**
         * 데이터에 설정된 {@link IListDataField 데이터필드} 개수.
         * <br>
         *
         * @see fields
         * @see getField
         */
        get fieldCount() {
            return this.$_d.fieldCount();
        }
        /**
         * 필드 정보 목록.
         * <br>
         * 리턴되는 필드 객체는 복사본이다.
         * 필드 객체의 속성을 변경해도 데이터에 반영되지 않는다.
         * <br>
         * {@link getField} 호출로 개별 필드 정보를 가져올 수 있다.
         *
         * ```
         *  data.fields.forEach(field => {
         *      if (field.required) {
         *          if (!getElementById(field.name).value) {
         *              alert(`${field.name} 값을 반드시 지정해야 합니다.`);
         *          }
         *      }
         *  });
         * ```
         *
         * @see fieldCount
         * @see getField
         */
        get fields() {
            return this.$_d.fields().map(fld => fld.proxy());
        }
        /**
         * true로 지정하면 최초 로드 후 생성/수정/삭제할 수 없다.
         * <br>
         * 데이터 생성 시 결정된 후 변경할 수 없다.
         *
         * @see restorable
         * @see softDeleting
         */
        get readonly() {
            return this.$_d.readOnly();
        }
        /**
         * true면 데이터행 삭제 요청 시 실제로 삭제하지 않고,
         * <br>
         * 행 상태를 {@link DListDataRowState.DELETED}로 설정한다.
         *
         * @see DListDataRowState
         * @see deleteRow
         * @see deleteRows
         * @see restoreRow
         * @see restoreRows
         */
        get softDeleting() {
            return this.$_d.softDeleting();
        }
        /**
         * 행 수정 시 이전 값을 저장하고, 이 후 복원할 수 있다.
         * <br>
         *
         * @see readonly
         * @see softDeleting
         */
        get restorable() {
            return this.$_d.restorable();
        }
        /**
         * 행 수정 및 추가 완료시 실행되는 검증 콜백.
         * <br>
         * {@link updateValue 필드 하나 수정} 시에는 호출되지 않는다.
         */
        get validator() {
            return this.$_d.validator();
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        /**
         * 지정한 위치의  데이터필드 정보를  리턴한다.
         * <br>
         * 범위를 벗어난 위치를 지정하면 예외가 발생한다.
         * [주의] 리턴되는 객체는 복사본이다. 속성을 변경해도 데이터에 반영되지 않는다.
         *
         * @param index 필드 전체 목록에서 위치.
         * @returns 데이터필드 정보.
         *
         * @see fieldCount
         * @see fields
         */
        getField(index) {
            return this.$_d.getField(index).proxy();
        }
        /**
         * 이 데이터를 {@link DListDataView.source source}로 하는 {@link DListDataView}를 생성한다.
         * <br>
         *
         * @param name 생성되는 데이터뷰 이름.
         * @param options 데이터뷰 생성 옵션.
         * @returns 이 데이터를 소스로하는 데이터뷰.
         *
         * @see concepts.data_model 데이터 모델 개요
         */
        createView(name, options) {
            return new DListDataView(name, this, options);
        }
        /**
         * 추가/삭제 하지 않고 강제로 데이터행 수를 변경한다.
         * <br>
         * fillDefault가 false면 새로 추가되는 행들은 값 없이 생성되고({@link hasValues}가 true 리턴),
         * true면 각 필드의 {@link IListDataField.default 기본값}들로 채워진다.
         * 기본값이 설정되지 않은 필드 값은 undefined가 된다.
         * 이 때, 모든 필드의 기본값이 설정되지 않은 경우라도 {@link hasValues}는 true를 리턴한다.
         * <br>
         *
         * @events
         * {@link onRowCountChange}, {@link onDataChange} 이벤트들이 순서대로 발생한다.
         *
         * @param newCount 데이터행 수.
         * @param fillDefaults 추가되는 행의 값들을 기본값으로 채울 지 여부.
         */
        setRowCount(newCount, fillDefaults = false) {
            this.$_d.setRowCount(newCount);
        }
        /**
         * {@link setRowCount} 호출 등으로 데이터의 행수를 늘리면서 값은 설정되지 않은 행들이 존재할 수 있다.
         * <br>
         * 지정한 행에 값이 들어있는 지 확인.
         *
         * @param row 행 위치.
         * @returns 값들이 존재하면 true.
         *
         * @error **row**가 0 ~ {@link rowCount}-1 범위를 벗어나면 발생한다.
         */
        isEmpty(row) {
            return this.$_d.isEmpty(row);
        }
        /**
         * 지정한 데이터행의 필드 값들을 json 객체로 리턴한다.
         * <br>
         * 지정한 위치에 자리만 차지한 경우({@link hasValues}가 false 리턴) undefined를 리턴한다.
         *
         * @param row 행 위치
         * @param fields 필드 목록. 지정하지 않으면 모든 필드 값을 리턴한다.
         * @param fieldCheck true면 잘못된 필드를 지정한 경우 예외가 발생한다.
         * @returns 필드 값이 포함된 json 객체
         *
         * @error fieldCheck가 true이고, fields에 잘못된 필드명을 지정하면 발생한다.
         */
        getValues(row, fields, fieldCheck = true) {
            return this.$_d.getValues(row, fields, fieldCheck);
        }
        /**
         * 기존 행들을 모두 제거하고 source 매개변수로 전달된 데이터소스로 부터 데이터행들을 새로 구축한다.
         *
         * @events
         * (이전 행 수와 달라지면){@link onRowCountChange},
         * {@link onDataChange} 이벤트들이 순서대로 발생한다.
         *
         * @param source
         * @returns 데이터 자신.
         */
        loadData(source) {
            this.$_d.loadData(source);
            return this;
        }
        /**
         * 지정한 위치에 새로운 행을 삽입 추가한다.
         * <br>
         * **values**의 속성들 중 데이터 필드로 존재하지 않는 속성 값은 무시되고,
         * 속성으로 전달되지 않는 필드 값은 undefined가 된다.
         *
         * @events
         * {@link onRowAdd}, {@link onRowCountChange}, {@link onDataChange} 이벤트들이 순서대로 발생한다.
         *
         * ```
         *  const row = +doc.getElementById('row').value;
         *  data.insertRow(row, {
         *      name: document.getElementById('name').value,
         *      salary: +document.getElementById('salary').value,
         *      ...
         *  });
         * ```
         *
         * @see appendRows
         *
         * @param row 행 삽입 위치. {@link rowCount} 범위를 벗어나면 예외가 발생한다.
         * @param values 추가할 필드 값들을 json 객체로 넘겨야 한다.
         * @returns 실제로 추가되면 true
         *
         * @error {@link readonly}가 true면 발생한다.
         * @error **row**가 0 ~ {@link rowCount} 범위를 벗어나면 발생한다.
         */
        insertRow(row, values) {
            return this.$_d.insertRow(row, values);
        }
        /**
         * 마지막 행 다음에 새로운 행을 추가한다.
         * <br>
         * {@link insertRow}({@link rowCount}, values) 호출과 동일하다.
         * <br>
         * **values**의 속성들 중 데이터 필드로 존재하지 않는 속성 값은 무시되고,
         * 속성으로 전달되지 않는 필드 값은 undefined가 된다.
         *
         * @events
         * {@link onRowAdd}, {@link onRowCountChange}, {@link onDataChange} 이벤트들이 순서대로 발생한다.
         *
         * ```
         *  data.appendRow({
         *      name: document.getElementById('name').value,
         *      salary: +document.getElementById('salary').value,
         *      ...
         *  });
         * ```
         *
         * @see insertRow
         * @see appendRows
         * @see deleteRow
         *
         * @param values 추가할 필드 값들을 json 객체로 넘겨야 한다.
         * @returns 실제로 추가되면 true
         *
         * @error {@link readonly}가 true면 발생한다.
         */
        appendRow(values) {
            return this.$_d.appendRow(values);
        }
        /**
         * 지정한 위치에 새로운 하나 이상의 행들을 추가한다.
         * <br>
         * json 객체 배열로 신규 행들의 값을 전달한다.
         * **json**의 속성들 중 데이터 필드로 존재하지 않는 속성 값은 무시되고,
         * 속성으로 전달되지 않는 필드 값은 undefined가 된다.
         *
         * @events
         * {@link onRowsAdd}, {@link onRowCountChange}, {@link onDataChange} 이벤트들이 순서대로 발생한다.
         *
         * ```
         * const row = +doc.getElementById('row').value;
         * const values = [
         *     {name: 'name1', age: 35},
         *     {name: 'name2', age: 27}
         * ];
         * data.insertRows(row, values);
         * ```
         *
         * @see {@link insertRow}
         *
         * @param row 행 삽입 위치. {@link rowCount} 범위를 벗어나면 예외가 발생한다.
         * @param values 추가할 값들. json object 배열.
         * @returns 추가 후 총 행 수.
         *
         * @error {@link readonly}가 true면 발생한다.
         * @error **row**가 0 ~ {@link rowCount} 범위를 벗어나면 발생한다.
         */
        insertRows(row, values) {
            return this.$_d.insertRows(row, values);
        }
        /**
         * 마지막 행 다음에 새로운 하나 이상의 행들을 추가한다.
         * <br>
         * {@link insertRows}({@link rowCount}, values) 호출과 동일하다.
         * <br>
         * json 객체 배열로 신규 행들의 값을 전달한다.
         * **json**의 속성들 중 데이터 필드로 존재하지 않는 속성 값은 무시되고,
         * 속성으로 전달되지 않는 필드 값은 undefined가 된다.
         *
         * @events
         * {@link onRowsAdd}, {@link onRowCountChange}, {@link onDataChange} 이벤트들이 순서대로 발생한다.
         *
         * ```
         * const values = [
         *     {name: 'name1', age: 35},
         *     {name: 'name2', age: 27}
         * ];
         * data.appendRows(values);
         * ```
         *
         * @see {@link insertRows}
         * @see {@link appendRow}
         *
         * @param values 추가할 값들. json object 배열.
         * @returns 추가 후 총 행 수.
         *
         * @error {@link readonly}가 true면 발생한다.
         */
        appendRows(values) {
            return this.$_d.appendRows(values);
        }
        /**
         * 데이터행이 하나라도 존재하면 모두 삭제하고 true를 리턴한다.
         * <br>
         * 데이터행이 하나도 없으면 아무일도 하지 않고 바로 false를 리턴한다.
         * 또, {@link softDeleting}이 true이면 실제 삭제되지 않고,
         * 모든 행들의 상태가 {@link DListDataRowState.DELETED}로 설정된다.
         *
         * @events
         * **softDeleting**이면
         * {@link onRowStatesChange}, {@link onDataChange} 이벤트들이 순서대로 발생한다.
         * <br>
         * **softDeleting**이 아니면
         * {@link onRowsClear}, {@link onRowCountChange}, {@link onDataChange} 이벤트들이 순서대로 발생한다.
         *
         * @see deleteRow
         * @see deleteRows
         *
         * @param force true면 {@link softDeleting}이 설정돼도 실제로 삭제한다.
         * @returns 하나 이상의 행들이 존재하고 실제 모두 삭제되면 true.
         *
         * @error {@link readonly}가 true면 발생한다.
         */
        deleteAll(force = false) {
            return this.$_d.deleteAll(force);
        }
        /**
         * 지정한 행 번호에 위치한 데이터행을 삭제한다.
         * <br>
         * 행 번호가 범위를 벗어나면 예외가 발생된다.
         * 둘 이상의 행들을 동시에 삭제할 때는 {@link deleteRows}를 사용한다.
         *
         * @example
         *  const row = +doc.getElementById('row').value;
         *  data.deleteRow(row);
         *
         * @events
         * **softDeleting**이면
         * {@link onRowStateChange}, {@link onDataChange} 이벤트들이 순서대로 발생한다.
         * <br>
         * **softDeleting**이 아니면
         * {@link onRowDelete}, {@link onRowCountChange}, {@link onDataChange} 이벤트들이 순서대로 발생한다.
         *
         * @see {@link deleteRows}
         * @see {@link deleteRange}
         *
         * @param row 데이터행 번호. 범위를 벗어나면 예외가 발생한다.
         * @param force true면 {@link softDeleting}이 설정돼도 실제로 삭제한다.
         *
         * @error {@link readonly}가 true면 발생한다.
         * @error **row**가 0 ~ {@link rowCount}-1 범위를 벗어나면 발생한다.
         */
        deleteRow(row, force = false) {
            this.$_d.deleteRow(row, force);
        }
        /**
         * 지정한 번호들에 위치한 데이터행들을 삭제한다.
         * <br>
         * 범위를 벗어난 행 번호가 포함되면 예외가 발생된다.
         *
         * @see {@link deleteRow}
         * @see {@link deleteRange}
         *
         * @param rows 삭제할 데이터행 목록. 범위를 벗어나면 예외가 발생한다. Array가 아니면 아무일도 하지 않고 []를 리턴한다.
         * @param force true면 {@link softDeleting}이 설정돼도 실제로 삭제한다.
         * @returns 실제 삭제된 행 번호 목록
         *
         * @error {@link readonly}가 true면 발생한다.
         * @error **rows**에 포함된 행번호가 0 ~ {@link rowCount}-1 범위를 벗어나면 발생한다.
         */
        deleteRows(rows, force = false) {
            return this.$_d.deleteRows(rows, force);
        }
        /**
         * 지정한 행 부터 지정한 개수의 행들을 삭제한다.
         * <br>
         * 지정한 행이 범위를 벗어나면 예외가 발생된다.
         * 지정한 개수가 전체 행수를 벗어나면 나머지는 무시된다.
         *
         * @see {@link deleteRow}
         * @see {@link deleteRows}
         *
         * @param row 삭제 시작 행. 범위를 벗어나면 예외가 발생한다.
         * @param count 삭제 행 수. 전체 행수를 벗어나면 나머지는 무시된다.
         * @param force true면 {@link softDeleting}이 설정돼도 실제로 삭제한다.
         * @returns 실제 삭제된 행 수.
         *
         * @error {@link readonly}가 true면 발생한다.
         * @error **row**가 0 ~ {@link rowCount}-1 범위를 벗어나면 발생한다.
         */
        deleteRange(row, count, force = false) {
            return this.$_d.deleteRange(row, count, force);
        }
        /**
         * 지정한 행의 필드 값들을 지정한 값들로 변경한다.
         * <br>
         * 지정한 행 위치가 범위를 벗어나면 예외가 발생된다.
         * 실제로 하나 이상 필드의 값이 변경되면 true를 리턴한다.
         * forceEmpty가 false이면 values에 지정되지 않은 값들은 변경하지 않는다.
         *
         * @param row 변경할 행. 범위를 벗어나면 예외가 발생한다.
         * @param values 변경할 필드+값 목록.
         * @param forceEmpty true이면 values에 없는 필드값은 undefind로 새로 지정하고,
         *                   false이면 values에 없는 필드의 값은 손대지 않는다.
         * @returns 실제 변경되면 true.
         *
         * @error {@link readonly}가 true면 발생한다.
         * @error **row**가 0 ~ {@link rowCount}-1 범위를 벗어나면 발생한다.
         */
        updateRow(row, values, forceEmpty = false) {
            return this.$_d.updateRow(row, values, forceEmpty);
        }
        /**
         * 지정한 행의 필드 값들을 지정한 값들로 변경한다.
         * <br>
         * 지정한 행들 중 한 행의 위치리도 범위를 벗어나면 예외가 발생된다.
         * 실제로 변경된 행들의 수를 리턴한다.
         * forceEmpty가 false이면 values에 지정되지 않은 값들은 변경하지 않는다.
         *
         * @param rows 행 번호 목록. Array가 아니면 아무일도 하지 않고 []를 리턴한다.
         * @param values 수정 값들이 지정된 json 객체 목록.
         * @param forceEmpty true이면 values에 없는 필드값은 undefind로 새로 지정하고,
         *                   false이면 values에 없는 필드의 값은 손대지 않는다.
         * @returns 실제 변경된 행들의 번호 목록
         *
         * @error {@link readonly}가 true면 발생한다.
         * @error **rows**에 포함된 행번호가 0 ~ {@link rowCount}-1 범위를 벗어나면 발생한다.
         */
        updateRows(rows, values, forceEmpty = false) {
            return this.$_d.updateRows(rows, values, forceEmpty);
        }
        /**
         *
         * @param row 수정 시작 행. 범위를 벗어나면 예외가 발생한다.
         * @param count 수정 행 수. 전체 행수를 벗어나면 나머지는 무시된다.
         * @param values 수정 값들이 지정된 json 객체 목록.
         * @param forceEmpty true이면 values에 없는 필드값은 undefind로 새로 지정하고,
         *                   false이면 values에 없는 필드의 값은 손대지 않는다.
         * @returns 한 행이라도 실제 수정되면 true
         *
         * @error {@link readonly}가 true면 발생한다.
         * @error **row**가 0 ~ {@link rowCount}-1 범위를 벗어나면 발생한다.
         */
        updateRange(row, count, values, forceEmpty = false) {
            return this.$_d.updateRange(row, count, values, forceEmpty);
        }
        /**
         * 수정되거나 {@link softDeleting} 상태에서 삭제된 행을 복원한다.
         * <br>
         * 수정된 행은 이전 값들로 복원되고 {@link DListDataRowState.UPDATED 수정} 상태가 제거된다.
         * 삭제된 행은 {@link DListDataRowState.DELETED 삭제} 상태가 제거된다.
         *
         * ```
         *  // focused 행을 복원한다.
         *  data.restoreRow(list.focusedRow);
         * ```
         *
         * @events
         * {@link onRowStateChange}, {@link onDataChange} 이벤트들이 순서대로 발생한다.
         *
         * @param row 데이터행 번호. 범위를 벗어나면 예외가 발생한다.
         * @returns 실제 복원되면 true.
         *
         * @error {@link readonly}가 true면 발생한다.
         * @error **row**가 0 ~ {@link rowCount}-1 범위를 벗어나면 발생한다.
         */
        restoreRow(row) {
            return this.$_d.restoreRow(row);
        }
        /**
         * 지정한 행들을 복원한다.
         * <br>
         * 수정되거나 {@link softDeleting} 상태에서 삭제된 행들을 복원한다.
         * 수정된 행은 이전 값들로 복원되고 {@link DListDataRowState.UPDATED 수정} 상태가 제거된다.
         * 삭제된 행은 {@link DListDataRowState.DELETED 삭제} 상태가 제거된다.
         *
         * @param rows 행 번호 목록. Array가 아니면 아무일도 하지 않고 []를 리턴한다.
         * @returns 실제로 복원된 행 번호 목록
         *
         * @error {@link readonly}가 true면 발생한다.
         * @error **rows**에 포함된 행번호가 0 ~ {@link rowCount}-1 범위를 벗어나면 발생한다.
         */
        restoreRows(rows) {
            return this.$_d.restoreRows(rows);
        }
        /**
         * 행의 위치를 변경한다.
         *
         * @events
         * {@link onRowMove}, {@link onDataChange} 이벤트들이 순서대로 발생한다.
         *
         * @see moveRows
         *
         * @param from 데이터행 번호. 범위를 벗어나면 예외가 발생한다.
         * @param to 이동 위치. 범위를 벗어나면 예외가 발생한다.
         * @returns 실제 이동했으면 true
         *
         * @error **from**이 0 ~ {@link rowCount}-1 범위를 벗어나면 예외가 발생한다.
         * @error **to**가 0 ~ {@link rowCount}-1 범위를 벗어나면 예외가 발생한다.
         */
        moveRow(from, to) {
            return this.$_d.moveRow(from, to);
        }
        /**
         * 연속된 행들의 위치르 변경한다.
         * <br>
         *
         * @see moveRow
         *
         * @param from 시작 데이터행 번호. 범위를 벗어나면 예외가 발생한다.
         * @param count 연속된 행 수. 범위를 벗어나면 마지막 행까지만 이동 시킨다.
         * @param to 이동 위치. 범위를 벗어나면 예외가 발생한다.
         * @returns 실제 이동한 행 수
         *
         * @error **from**이 0 ~ {@link rowCount}-1 범위를 벗어나면 예외가 발생한다.
         * @error **to**가 0 ~ {@link rowCount}-1 범위를 벗어나면 예외가 발생한다.
         */
        moveRows(from, count, to) {
            return this.$_d.moveRows(from, count, to);
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        get name() {
            return this.$_d.name();
        }
        get source() {
            return this;
        }
        /**
         * 데이터행 수.
         * <br>
         */
        get rowCount() {
            return this.$_d.rowCount();
        }
        isRowUpdated(row) {
            return this.$_d.getRowState(row) === DListDataRowState.UPDATED;
        }
        isRowDeleted(row) {
            return this.$_d.getRowState(row) === DListDataRowState.DELETED;
        }
        getValue(row, field, fieldCheck = true) {
            if (field) {
                const p = Utils.getFieldProp(field);
                if (p) {
                    return this.$_d.getProp(row, p.field, p.props, fieldCheck);
                }
                else {
                    return this.$_d.getValue(row, field, fieldCheck);
                }
            }
        }
        findRow(where, from = 0, to = -1) {
            return this.$_d.findRow(where, from, to);
        }
        findRows(where, from = 0, to = -1) {
            return this.$_d.findRows(where, from, to);
        }
        findDistinctRows(fields, from = 0, to = -1) {
            return this.$_d.findDistinctRows(fields, from, to);
        }
    }
    /**
     * {@link DListData}를 기준으로 정렬 및 필터들을 적용해서 원본 데이터와 다르게 데이터행들을 배치하는 데이터소스.
     * <br>
     * 원본 데이터행 번호를 배열로 관리하는 것이면 실제 값들은 원본 데이터에만 존재한다.
     * 즉, 데이터행 로드/수정/추가/삭제는 원본 데이터에서만 실행된다.
     * 하지만 원본 데이터의 변경은 이 데이터의 행 배치에 즉각 반영된다.
     * <br>
     * 정렬 및 필터링은 실행 중 어느 때나 재설정 가능하다.
     *
     * @see concepts.data_model 데이터 모델
     * @see DListData
     * @see DListDataLinkView
     */
    class DListDataView extends DListSimpleData {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        /**
         *
         * @param name 데이터 이름.
         * @param source 원본 데이터.
         * @param options 데이터뷰 생성 정보.
         */
        constructor(name, source, options) {
            super();
            this.$_d = new ListDataView(name, source['$_d'], options, this);
            this._source = source;
        }
        $_doDestory() {
            this.$_d = this.$_d.destroy();
        }
        //-------------------------------------------------------------------------
        // events
        //-------------------------------------------------------------------------
        /**
         * @event
         *
         * {@link sort} 호출로 정렬 설정 상태가 변경될 때 발생한다.
         * <br>
         *
         * @eparam dv 데이터뷰 객체 자신
         */
        get onSortChange() {
            return this.$_d.onSortChange;
        }
        set onSortChange(value) {
            this.$_d.onSortChange = value;
        }
        /**
         * @event
         *
         * {@link addFilter} 등으로 필터 설정 상태가 변결될 때 발생한다.
         * <br>
         *
         * @eparam dv 데이터뷰 객체 자신
         */
        get onFilterChange() {
            return this.$_d.onFilterChange;
        }
        set onFilterChange(value) {
            this.$_d.onFilterChange = value;
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        /**
         * @readonly
         *
         * 원본 데이터 객체.
         * <br>
         */
        get source() {
            return this._source;
        }
        /**
         * @internal
         *
         * 필드 목록.
         * <br>
         * 리턴되는 필드 객체는 복사본이다.
         * 필드 객체의 속성을 변경해도 데이터에 반영되지 않는다.
         * <br>
         */
        get fields() {
            return this.$_d.fields().map(fld => fld.proxy());
        }
        /**
         * {@link source 원본 데이터} 수정/추가 시 재정렬한다.
         * <br>
         * false이면 행이 추가되거나 변경된 후 명시적으로 {@link build}(true)를 호출해야 재정렬된다.
         *
         * @default true
         */
        get autoSort() {
            return this.$_d.autoSort();
        }
        set autoSort(value) {
            this.$_d.setAutoSort(value);
        }
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        /**
         * 데이터뷰의 데이터행 목록과 동일한 데이터행으로 구성되는 {@link DListData}를 생성한다.
         * <br>
         * 데이터행들의 값들은 복사된다.
         *
         * @param options 스냅샷 생성 설정 정보.
         * @returns 데이터
         */
        snapshot(options) {
            return new DListData(this.$_d.snapshot(options));
        }
        /**
         * {@link sort}, {@link select} 등 정렬이나 필터링 상태 변경을 복수로 (build 매개변수 false) 실행한 후,
         * 호출해서 행들이 재구축되도록 한다.
         *
         * @param force true로 지정하면 필터나 정렬 설정이 변경되지 않아도 행 목록을 재구축한다.
         * @returns 데이터뷰 자신.
         */
        build(force = false) {
            this.$_d.build(force);
            return this;
        }
        /**
         * 기존 정렬 상태를 취소하고 새로 정렬한다.
         * <br>
         * 기존 정렬 설정과 동일한 경우 아무일도 하지 않는다.
         *
         * @see addSort
         * @see removeSort
         *
         * @param options 정렬 옵션. 지정하지 않거나 빈 설정이면 정렬 상태가 지워진다.
         * @param build true면 호출 후 행들을 재구축한다.
         * @returns 데이터뷰 자신.
         */
        sort(options, build = false) {
            this.$_d.sort(options, build);
            return this;
        }
        /**
         * 기존 정렬 상태에 필드 정렬을 기존 필드 정렬 앞에 추가한다.
         * <br>
         * 이미 정렬된 필드면 무시한다.
         *
         * @see appendSort
         * @see removeSort
         * @see sort
         *
         * @param field 정렬할 필드 명.
         * @param dir 정렬 방항.
         * @param before 기존 정렬 목록 사이에 추가할 때 추가할 위치가 되는 필드.
         * @param build true면 호출 후 행들을 재구축한다.
         * @returns 데이터뷰 자신.
         */
        addSort(field, dir, before, build = false) {
            this.$_d.addSort(field, dir, before, build);
            return this;
        }
        /**
         * 기존 정렬 목록의 마지막에 새 정렬 조건을 추가한다.
         * <br>
         * 이미 정렬된 필드면 무시한다.
         *
         * @param field 정렬할 필드 명.
         * @param dir 정렬 방항.
         * @param build true면 호출 후 행들을 재구축한다.
         * @returns 데이터뷰 자신.
         */
        appendSort(field, dir, build = false) {
            this.$_d.appendSort(field, dir, build);
            return this;
        }
        /**
         * 기존 정렬 상태를 제거한다.
         * <br>
         * 정렬된 상태가 아닌 필드면 무시된다.
         *
         * @param field 정렬 필드 혹은 필드 목록 배열.
         * @param build true면 호출 후 행들을 재구축한다.
         * @returns 데이터뷰 자신.
         */
        removeSort(field, build = false) {
            this.$_d.removeSort(field, build);
            return this;
        }
        /**
         * 데이터필드의 정렬 상태를 변경한다.
         * <br>
         * 1. 정렬 상태가 아니면 {@link DListDataSortDirection.ASCENDING ASCENDING} 정렬을 추가한다.<br>
         * 2. {@link DListDataSortDirection.ASCENDING ASCENDING} 정렬 상태이면 {@link DListDataSortDirection.DESCENDING DESCENDING} 정렬로 변경한다.<br>
         * 3. {@link DListDataSortDirection.ASCENDING DESCENDING} 정렬 상태이면 정렬을 제거한다.<br>
         *
         * @param field 정렬 방향을 변경할 필드 명.
         * @param build true면 호출 후 행들을 재구축한다.
         * @returns 데이터뷰 자신.
         */
        toggleSort(field, build = false) {
            this.$_d.toggleSort(field, build);
            return this;
        }
        /**
         * 정렬 이 전에 실행되는 선택 필터를 추가한다.
         * <br>
         * 정렬 이 후에 적용되는 필터는 {@link selectAfter}로 추가할 수 있다.
         *
         * @param name 필터 이름.
         * @param filter 행 선택 콜백.
         * @param build true면 필터 설정 후 바로 행들을 재구축한다.
         *
         * @see slice
         * @see dedupe
         */
        select(name, filter, enabled = true, build = false) {
            this.$_d.addFilter({ name, filter, enabled }, false, build);
            return this;
        }
        /**
         * 정렬 이 후에 실행되는 선택 필터를 추가한다.
         * <br>
         * 정렬 이 전에 적용되는 필터는 {@link select}로 추가할 수 있다.
         *
         * @param name 필터 이름.
         * @param filter 행 선택 콜백.
         * @param build true면 필터 설정 후 바로 행들을 재구축한다.
         *
         * @see slice
         * @see dedupe
         */
        selectAfter(name, filter, enabled = true, build = false) {
            this.$_d.addFilter({ name, filter, enabled }, true, build);
            return this;
        }
        /**
         * {@link DListData 원본 데이터}에서 지정한 범위 내의 행들만 가져오는 필터를 정렬 이 전에 적용한다.
         * <br>
         * ranges 매개변수에 설정하는 행 범위는 두 가지 방식으로 지정할 수 있다.
         * <br><br>
         * <ol>
         * <li>단일 숫자 - 0부터 지정한 위치 이전까지의 행들. 지정한 위치가 0 이하이면 필터가 생성되지 않는다.
         * <li>숫자 배열 - 이어지는 두 값을 쌍으로 시작/끝 범위를 생성한다. 두 번째 값이 첫번째 값보다 커야 한다.
         *              또, 각각의 범위가 겹치지 않아야 하고 이전 범위보다 먼 영역이어야 한다.
         * </ol>
         *
         * @param name 필터 이름.
         * @param ranges 행 범위(들)
         * @param build true면 필터 설정 후 바로 행들을 재구축한다.
         * @returns 데이터뷰 자신.
         *
         * @see sliceAfter
         * @see select
         * @see selectAfter
         */
        slice(name, ranges, enabled = true, build = false) {
            this.$_d.addFilter({ name, filter: ranges, enabled }, false, build);
            return this;
        }
        /**
         * {@link DListData 원본 데이터}에서 지정한 범위 내의 행들만 가져오는 필터를 정렬 이 후에 적용한다.
         * <br>
         * ranges 매개변수에 설정하는 행 범위는 두 가지 방식으로 지정할 수 있다.
         * 1. 단일 숫자 - 0부터 지정한 위치 이전까지의 행들. 지정한 위치가 0 이하이면 필터가 생성되지 않는다.
         * 2. 숫자 배열 - 이어지는 두 값을 쌍으로 시작/끝 범위를 생성한다. 두 번째 값이 첫번째 값보다 커야 한다.
         *              또, 각각의 범위가 겹치지 않아야 하고 이전 범위보다 먼 영역이어야 한다.
         *
         * @param name 필터 이름.
         * @param ranges 행 범위(들)
         * @param build true면 필터 설정 후 바로 행들을 재구축한다.
         * @returns 데이터뷰 자신.
         *
         * @see slice
         * @see select
         * @see selectAfter
         */
        sliceAfter(name, ranges, enabled = true, build = false) {
            this.$_d.addFilter({ name, filter: ranges, enabled }, true, build);
            return this;
        }
        /**
         * **keyFields** 매개변수에 지정한 필드들을 기준으로 중복된 원본 행들 중 한 행만을 가져오는 필터를 정렬 이 전에 적용한다.
         * <br>
         *
         * @param name 필터 이름.
         * @param keyFields 중복 판단 기준 필드들.
         * @param build true면 필터 설정 후 바로 행들을 재구축한다.
         * @returns 데이터뷰 자신.
         *
         * @see dedupeAfter
         * @see select
         * @see selectAfter
         * @see slice
         * @see sliceAfter
         */
        dedupe(name, keyFields, enabled = true, build = false) {
            this.$_d.addFilter({ name, filter: keyFields, enabled }, false, build);
            return this;
        }
        /**
         * **keyFields** 매개변수에 지정한 필드들을 기준으로 중복된 원본 행들 중 한 행만을 가져오는 필터를 정렬 이 후에 적용한다.
         * <br>
         *
         * @param name 필터 이름.
         * @param keyFields 중복 판단 기준 필드들.
         * @param build true면 필터 설정 후 바로 행들을 재구축한다.
         * @returns 데이터뷰 자신.
         *
         * @see dedupe
         * @see select
         * @see selectAfter
         * @see slice
         * @see sliceAfter
         */
        dedupeAfter(name, keyFields, enabled = true, build = false) {
            this.$_d.addFilter({ name, filter: keyFields, enabled }, true, build);
            return this;
        }
        addFilter(filter, build = false) {
            this.$_d.addFilter(filter, false, build);
            return this;
        }
        addPostFilter(filter, build = false) {
            this.$_d.addFilter(filter, true, build);
            return this;
        }
        addFilterSet(fs, build = false) {
            this.$_d.addFilterSet(fs, false, build);
            return this;
        }
        addPostFilterSet(fs, build = false) {
            this.$_d.addFilterSet(fs, true, build);
            return this;
        }
        /**
         * 지정한 필터를 제거한다.
         *
         * @param filter 필터 이름.
         * @param build true면 필터 제거 후 행들을 재구축한다.
         * @returns
         */
        removeFilter(filter, build = false) {
            this.$_d.removeFilter(filter, build);
            return this;
        }
        /**
         * 지정한 필터들을 제거한다.
         *
         * @param filters 필터 이름 배열.
         * @param build true면 필터 제거 후 행들을 재구축한다.
         * @returns
         */
        removeFilters(filters, build = false) {
            this.$_d.removeFilters(filters, build);
            return this;
        }
        /**
         * 모든 필터들을 제거한다.
         *
         * @param build true면 필터 제거 후 행들을 재구축한다.
         * @returns
         */
        clearFilters(build = false) {
            this.$_d.clearFilters(build);
            return this;
        }
        /**
         * 지정한 필터의 적용 여부를 변경한다.
         *
         * @param filter 필터 이름.
         * @param enabled true면 필터가 적용된다.
         * @param build true면 필터 설정 후 바로 행들을 재구축한다.
         * @returns 데이터뷰 자신.
         *
         * @see enableFilters
         * @see enableAllFilters
         */
        enableFilter(filter, enabled, build = true) {
            this.$_d.enableFilter(filter, enabled, build);
            return this;
        }
        /**
         * 지정한 필터들의 적용 여부를 변경한다.
         *
         * @param filters 필터 이름 배열.
         * @param enabled true면 필터들이 적용된다.
         * @param build true면 필터 설정 후 바로 행들을 재구축한다.
         * @returns 데이터뷰 자신.
         *
         * @see enableFilter
         * @see enableAllFilters
         */
        enableFilters(filters, enabled, build = true) {
            this.$_d.enableFilters(filters, enabled, build);
            return this;
        }
        /**
         * 모든 필터들의 적용 여부를 변경한다.
         *
         * @param enabled true면 필터들이 적용된다.
         * @param build true면 필터 설정 후 바로 행들을 재구축한다.
         * @returns 데이터뷰 자신.
         *
         * @see enableFilters
         * @see enableFilter
         */
        enableAllFilters(enabled, build = true) {
            this.$_d.enableAllFilters(enabled, true);
            return this;
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        get name() {
            return this.$_d.name();
        }
        get rowCount() {
            return this.$_d.rowCount();
        }
        getValue(row, field, fieldCheck) {
            if (field) {
                const p = Utils.getFieldProp(field);
                if (p) {
                    return this.$_d.getProp(row, p.field, p.props, fieldCheck);
                }
                else {
                    return this.$_d.getValue(row, field, fieldCheck);
                }
            }
        }
        getValues(row, fields, fieldCheck = true) {
            return this.$_d.getValues(row, fields, fieldCheck);
        }
        isRowUpdated(row) {
            return this.$_d.getRowState(row) === DListDataRowState.UPDATED;
        }
        isRowDeleted(row) {
            return this.$_d.getRowState(row) === DListDataRowState.DELETED;
        }
        findRow(where, from = 0, to = -1) {
            return this.$_d.findRow(where, from, to);
        }
        findRows(where, from = 0, to = -1) {
            return this.$_d.findRows(where, from, to);
        }
        findDistinctRows(fields, from = 0, to = -1) {
            return this.$_d.findDistinctRows(fields, from, to);
        }
        deleteRow(row, force = false) {
            this.$_d.deleteRow(row, force);
        }
        deleteRows(rows, force = false) {
            this.$_d.deleteRows(rows, force);
        }
        appendRows(values) {
            return this.source.appendRows(values);
        }
    }
    /**
     * 둘 이상의 데이터소스를 연결해서 데이터행들을 배치하는 다중 데이터 view.
     * <br>
     * 마스터나 디테일로 연결된 데이터소스는 {@link DListSimpleData 단일 데이터}이어야 한다.
     * 이 데이터소스는 마스터나 디테일이 될 수 없다.
     * <br>
     * 포함된 모든 data의 행들은 최대 한번씩만 표시된다.
     * 즉, 같은 key값들의 master행이 두 개 있으면 두 번째 마스트행에는 detail 행이 표시되지 않는다.
     * master 행은 unique해야 한다.
     * <br>
     * 마스터와 연결되지 않은 행은 표시되지 않는다.
     * <br>
     * 디테일 행은 다시 마스터행이 될 수 있다.
     * <br>
     * 적어도 한 쌍의 master/detail 관계는 존재한다고 전제한다.
     * <br>
     * 디테일이 masterFields나 keyFields 기준으로 정렬될 필요는 없다.
     * view 생성 시 master를 기준으로 detail 행들이 수집되어 배치된다.
     *
     * <br>
     * 데이터 객체는 생성자 대신 주로 모듈 함수를 호출해서 생성한다.
     *
     * @example
     *  const master = DList.createData('master', {...});
     *  const detail = DList.createData('detail', {...});
     *  const data = DList.createDataLink('link', master, [{
     *      data: detail,
     *      keyFields: ['NAME']
     *  }]);
     *
     *  const dlist = DList.createList(document, 'dlist'); // 'dlist'는 div의 id.
     *  dlist.setConfig(config);    // 컨트롤 속성 및 옵션 설정
     *  dlist.data = data;          // 데이터 연결
     *
     * @see data_model 데이터 모델
     * @see DListSimpleData.createLinkView
     * @see DListData
     */
    class DListDataLinkView extends DListDataSource {
        //-------------------------------------------------------------------------
        // constructor
        //-------------------------------------------------------------------------
        /**
         * 생성자.
         *
         * @param name
         * @param data
         * @param details
         */
        constructor(name, data, details) {
            function ds2ds(infos) {
                return Array.isArray(infos) ? infos.map(d => d2d(d)) : [d2d(infos)];
            }
            function d2d(info) {
                return info ? {
                    data: info.data['$_d'],
                    keyFields: info.keyFields,
                    masterFields: info.masterFields,
                    details: info.details ? ds2ds(info.details) : null
                } : null;
            }
            super();
            this.$_d = new ListDataLinkView(name, data['$_d'], ds2ds(details), this);
        }
        $_doDestory() {
            this.$_d = this.$_d.destroy();
        }
        //-------------------------------------------------------------------------
        // properties
        //-------------------------------------------------------------------------
        //-------------------------------------------------------------------------
        // methods
        //-------------------------------------------------------------------------
        /**
         * 지정한 행이 마스터 데이터에 포함된 행인 지 여부.
         *
         * @param row 데이터행 번호
         * @returns 마스터 데이터에 속한 행이면 true.
         */
        isMaster(row) {
            return this.$_d.isMaster(row);
        }
        /**
         * 지정한 행이 마지막 level 데이터에 포함된 행인 지 여부.
         *
         * @param row 데이터행 번호
         * @returns 마지막 level 데이터에 속한 행이면 true.
         */
        isLeaf(row) {
            return this.$_d.isLeaf(row);
        }
        //-------------------------------------------------------------------------
        // overriden members
        //-------------------------------------------------------------------------
        get name() {
            return this.$_d.name();
        }
        get source() {
            return this._data.source;
        }
        get rowCount() {
            return this.$_d.rowCount();
        }
        getValue(row, field, fieldCheck) {
            if (field) {
                const p = Utils.getFieldProp(field);
                if (p) {
                    return this.$_d.getProp(row, p.field, p.props, fieldCheck);
                }
                else {
                    return this.$_d.getValue(row, field, fieldCheck);
                }
            }
        }
        getValues(row) {
            return this.$_d.getRowValues(row);
        }
        isRowUpdated(row) {
            return this.$_d.getRowState(row) === DListDataRowState.UPDATED;
        }
        isRowDeleted(row) {
            return this.$_d.getRowState(row) === DListDataRowState.DELETED;
        }
        findRow(where, from, to) {
            return this.$_d.findRow(where, from, to);
        }
        findRows(where, from, to) {
            return this.$_d.findRows(where, from, to);
        }
        findDistinctRows(fields, from, to) {
            return this.$_d.findDistinctRows(fields, from, to);
        }
        getDataViews() {
            return this.$_d.getDataViews().map(dv => dv.wrapper());
        }
        deleteRow(row, force = false) {
            this.$_d.deleteRow(row, force);
        }
        deleteRows(rows, force = false) {
            this.$_d.deleteRows(rows, force);
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    /**
     * D·List 모듈 global.
     * <br>
     * "**DList**" namespace로 접근한다.
     *
     * ```
     *  // 데이터소스를 생성한다.
     *  const data = DList.createData('dsMain', {
     *      fields: []
     *  });
     *  // 리스트컨트롤을 생성한다.
     *  const list = DList.createList(document, 'dlist');
     *  // 컨트롤 설정 및 옵션
     *  list.setConfig({
     *      props: {},
     *      options: {}
     *  });
     *  // 컨트롤에 데이터를 연결한다.
     *  list.data = data;
     * ```
     *
     * @see concepts.about D·List 개요
     */
    class DList {
        // static DListScrollIndicator = DListScrollIndicator;
        // static DListEditBar = DListEditBar;
        // static DeleteRowCommand = DeleteRowCommand;
        // static MoveUpRowCommand = MoveUpRowCommand;
        // static MoveUpDownCommand = MoveDownRowCommand;
        static getVersion() {
            return '0.9.11';
        }
        static setLocale(lang, config) {
            if (config) {
                $_registerLocale(lang, config);
            }
            $_setLocale(lang);
        }
        static registerLocale(lang, config) {
            $_registerLocale(lang, config);
        }
        static setLogging(logging) {
            DLog.setLogging(logging);
        }
        // 최초 호출 후 실행 중에 변경할 수 없다.
        static setBounding(bounding) {
            DElement.BOUNDING = bounding;
        }
        static destroy() {
            StockTemplates.destroy();
            UserTemplates.destroy();
        }
        // NOTE: 공유하는 사용자 template에는 html template을 등록할 수 없다(?)
        /**
         * 공유 가능한 사용자 {@link concepts.templates 템플릿}을 등록한다.
         *
         * @example
         *  DList.registerTemplate('simple_row', {
         *      template: {
         *      }
         *  });
         *
         * @see unregisterTemplates
         * @see concepts.templates 템플릿 개요
         * @see concepts.layouts 레이아웃 개요
         *
         * @param name
         * @param template
         * @returns
         */
        static registerTemplate(name, template) {
            return registerUserTemplate(null, UserTemplates, name, template);
        }
        /**
         * 이 전에 등록된 공유 {@link concepts.templates 템플릿}(들)을 등록 취소한다.
         *
         * @example
         *  DList.unregisterTemplates(['simple_row', 'complex_row']);
         *
         * @see registerTemplate
         * @see concepts.templates 템플릿 개요
         * @see concepts.layouts 레이아웃 개요
         *
         * @param templates 취소할 템플릿 이름 배열 혹은 이름.
         */
        static unregisterTemplates(templates) {
            if (typeof templates === 'string') {
                UserTemplates.remove(templates);
            }
            else {
                return UserTemplates.removeAll(templates);
            }
        }
        /**
         * {@link DListData}를 생성한다.
         *
         * @param name 데이터 이름
         * @param options 데이터 생성 정보
         * @param source 원본 값 정보
         * @returns
         */
        static createData(name, options, source) {
            return new DListData(name, options, source);
        }
        /**
         * {@link DListDataView}를 생성한다.
         * <br>
         * {@link DListData.createView}와 동일한 기능이다.
         *
         * @see {@link concepts.data_model 데이터 모델 개요}
         * @see DListDataLinkView
         *
         * @param name 데이터 뷰 이름
         * @param data 원본 데이터
         * @param options 데이터 뷰 생성 정보
         * @returns
         */
        static createDataView(name, data, options) {
            if (!(data instanceof DListData)) {
                throwError(locale.dataMustSet);
            }
            return new DListDataView(name, data, options);
        }
        /**
         * {@link DListDataLinkView}를 생성한다.
         *
         * @param name
         * @param data
         * @param details
         * @returns
         */
        static createDataLink(name, data, details) {
            if (!(data instanceof DListSimpleData)) {
                throwError(locale.dataMustSet);
            }
            return new DListDataLinkView(name, data, details);
        }
        /**
         * {@link DListControl 리스트 컨트롤}을 생성한다.
         *
         * @see createData
         * @see createDataView
         * @see createDataLink
         *
         * @param doc
         * @param container 리스트컨트롤이 생성되는 div 엘리먼트나 id
         * @param renderMode
         * @returns
         */
        static createList(doc, container, renderMode = DListRenderMode.DEFAULT) {
            return new DListControl(doc, container, renderMode);
        }
    }
    DList.DListRenderMode = DListRenderMode;
    DList.DListRowBarDisplay = DListRowBarDisplay;
    DList.DListRowBorderIndent = DListRowIndent;
    DList.DListControlObjectPosition = DListControlObjectPosition;
    DList.DListScrollIndicatorMode = DListScrollIndicatorMode;
    DList.DListRowIndents = DListRowIndents;
    DList.DListDataSource = DListDataSource;
    DList.DListData = DListData;
    DList.DListDataView = DListDataView;
    DList.DListControl = DListControl;

    return DList;

}));
//# sourceMappingURL=dlist.js.map
